import {
  ACESFilmicToneMapping,
  AddEquation,
  AddOperation,
  AdditiveBlending,
  AgXToneMapping,
  AlphaFormat,
  AlwaysCompare,
  AlwaysDepth,
  AlwaysStencilFunc,
  AmbientLight,
  ArrayCamera,
  BackSide,
  BasicShadowMap,
  Box3,
  BoxGeometry,
  BufferAttribute,
  BufferGeometry,
  ByteType,
  Camera,
  CineonToneMapping,
  CircleGeometry,
  ClampToEdgeWrapping,
  Color,
  ColorManagement,
  CubeCamera,
  CubeReflectionMapping,
  CubeRefractionMapping,
  CubeTexture,
  CubeUVReflectionMapping,
  CubicBezierCurve3,
  CullFaceBack,
  CullFaceFront,
  CullFaceNone,
  Curve,
  CustomBlending,
  CylinderGeometry,
  DataArrayTexture,
  DataTexture,
  DecrementStencilOp,
  DecrementWrapStencilOp,
  DepthFormat,
  DepthStencilFormat,
  DepthTexture,
  DirectionalLight,
  DoubleSide,
  DstAlphaFactor,
  DstColorFactor,
  DynamicDrawUsage,
  EqualCompare,
  EqualDepth,
  EqualStencilFunc,
  EquirectangularReflectionMapping,
  EquirectangularRefractionMapping,
  Euler,
  EventDispatcher,
  ExtrudeGeometry,
  Float16BufferAttribute,
  Float32BufferAttribute,
  FloatType,
  FramebufferTexture,
  FrontSide,
  Frustum,
  FrustumArray,
  GreaterCompare,
  GreaterDepth,
  GreaterEqualCompare,
  GreaterEqualDepth,
  GreaterEqualStencilFunc,
  GreaterStencilFunc,
  Group,
  HalfFloatType,
  HemisphereLight,
  IncrementStencilOp,
  IncrementWrapStencilOp,
  InstancedBufferAttribute,
  InstancedBufferGeometry,
  InstancedInterleavedBuffer,
  IntType,
  InterleavedBuffer,
  InterleavedBufferAttribute,
  InvertStencilOp,
  KeepStencilOp,
  LessCompare,
  LessDepth,
  LessEqualCompare,
  LessEqualDepth,
  LessEqualStencilFunc,
  LessStencilFunc,
  LightProbe,
  Line,
  Line3,
  LineBasicMaterial,
  LineDashedMaterial,
  LineSegments,
  LinearFilter,
  LinearMipMapLinearFilter,
  LinearMipmapLinearFilter,
  LinearMipmapNearestFilter,
  LinearSRGBColorSpace,
  LinearToneMapping,
  LinearTransfer,
  Material,
  MathUtils,
  Matrix2,
  Matrix3,
  Matrix4,
  MaxEquation,
  Mesh,
  MeshBasicMaterial,
  MeshLambertMaterial,
  MeshMatcapMaterial,
  MeshNormalMaterial,
  MeshPhongMaterial,
  MeshPhysicalMaterial,
  MeshStandardMaterial,
  MeshToonMaterial,
  MinEquation,
  MirroredRepeatWrapping,
  MixOperation,
  MultiplyBlending,
  MultiplyOperation,
  NearestFilter,
  NearestMipmapLinearFilter,
  NearestMipmapNearestFilter,
  NeutralToneMapping,
  NeverCompare,
  NeverDepth,
  NeverStencilFunc,
  NoBlending,
  NoColorSpace,
  NoToneMapping,
  NormalBlending,
  NotEqualCompare,
  NotEqualDepth,
  NotEqualStencilFunc,
  Object3D,
  ObjectSpaceNormalMap,
  OneFactor,
  OneMinusDstAlphaFactor,
  OneMinusDstColorFactor,
  OneMinusSrcAlphaFactor,
  OneMinusSrcColorFactor,
  OrthographicCamera,
  PCFShadowMap,
  PerspectiveCamera,
  Plane,
  PlaneGeometry,
  PointLight,
  Points,
  PointsMaterial,
  Quaternion,
  RAD2DEG,
  RED_GREEN_RGTC2_Format,
  RED_RGTC1_Format,
  REVISION,
  RGBAFormat,
  RGBAIntegerFormat,
  RGBA_ASTC_10x10_Format,
  RGBA_ASTC_10x5_Format,
  RGBA_ASTC_10x6_Format,
  RGBA_ASTC_10x8_Format,
  RGBA_ASTC_12x10_Format,
  RGBA_ASTC_12x12_Format,
  RGBA_ASTC_4x4_Format,
  RGBA_ASTC_5x4_Format,
  RGBA_ASTC_5x5_Format,
  RGBA_ASTC_6x5_Format,
  RGBA_ASTC_6x6_Format,
  RGBA_ASTC_8x5_Format,
  RGBA_ASTC_8x6_Format,
  RGBA_ASTC_8x8_Format,
  RGBA_BPTC_Format,
  RGBA_ETC2_EAC_Format,
  RGBA_PVRTC_2BPPV1_Format,
  RGBA_PVRTC_4BPPV1_Format,
  RGBA_S3TC_DXT1_Format,
  RGBA_S3TC_DXT3_Format,
  RGBA_S3TC_DXT5_Format,
  RGBFormat,
  RGBIntegerFormat,
  RGB_ETC1_Format,
  RGB_ETC2_Format,
  RGB_PVRTC_2BPPV1_Format,
  RGB_PVRTC_4BPPV1_Format,
  RGB_S3TC_DXT1_Format,
  RGFormat,
  RGIntegerFormat,
  RectAreaLight,
  RedFormat,
  RedIntegerFormat,
  ReinhardToneMapping,
  RenderTarget,
  RepeatWrapping,
  ReplaceStencilOp,
  ReverseSubtractEquation,
  SIGNED_RED_GREEN_RGTC2_Format,
  SIGNED_RED_RGTC1_Format,
  SRGBColorSpace,
  SRGBTransfer,
  Scene,
  ShaderChunk,
  ShaderLib,
  ShaderMaterial,
  ShadowMaterial,
  ShapePath,
  ShortType,
  Sphere,
  SphereGeometry,
  SpotLight,
  SpriteMaterial,
  SrcAlphaFactor,
  SrcAlphaSaturateFactor,
  SrcColorFactor,
  StaticDrawUsage,
  SubtractEquation,
  SubtractiveBlending,
  TangentSpaceNormalMap,
  Texture,
  TextureLoader,
  TimestampQuery,
  TriangleFanDrawMode,
  TriangleStripDrawMode,
  TrianglesDrawMode,
  TubeGeometry,
  UVMapping,
  Uint16BufferAttribute,
  Uint32BufferAttribute,
  UniformsLib,
  UniformsUtils,
  UnsignedByteType,
  UnsignedInt101111Type,
  UnsignedInt248Type,
  UnsignedInt5999Type,
  UnsignedIntType,
  UnsignedShort4444Type,
  UnsignedShort5551Type,
  UnsignedShortType,
  VSMShadowMap,
  Vector2,
  Vector3,
  Vector4,
  WebGLCoordinateSystem,
  WebGLCubeRenderTarget,
  WebGPUCoordinateSystem,
  WebXRController,
  WireframeGeometry,
  ZeroFactor,
  ZeroStencilOp,
  arrayNeedsUint32,
  createCanvasElement,
  getByteLength,
  warnOnce
} from "./chunk-Z65VSUQK.js";
import {
  __commonJS,
  __export,
  __toESM
} from "./chunk-DC5AMYBS.js";

// node_modules/frame-ticker/dist/FrameTicker.js
var require_FrameTicker = __commonJS({
  "node_modules/frame-ticker/dist/FrameTicker.js"(exports, module) {
    !function(e, t) {
      "object" == typeof exports && "object" == typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define("FrameTicker", [], t) : "object" == typeof exports ? exports.FrameTicker = t() : e.FrameTicker = t();
    }(exports, function() {
      return function(e) {
        function t(n) {
          if (i[n]) return i[n].exports;
          var r = i[n] = { exports: {}, id: n, loaded: false };
          return e[n].call(r.exports, r, r.exports, t), r.loaded = true, r.exports;
        }
        var i = {};
        return t.m = e, t.c = i, t.p = "", t(0);
      }([function(e, t, i) {
        "use strict";
        var n = i(1), r = function() {
          function e3(e4, t4, i2) {
            void 0 === e4 && (e4 = NaN), void 0 === t4 && (t4 = NaN), void 0 === i2 && (i2 = false), this._minFPS = t4, this._maxFPS = e4, this._timeScale = 1, this._currentTick = 0, this._currentTime = 0, this._tickDeltaTime = 0, this._isRunning = false, this._maxInterval = isNaN(this._minFPS) ? NaN : 1e3 / this._minFPS, this._minInterval = isNaN(this._maxFPS) ? NaN : 1e3 / this._maxFPS, this._onResume = new n.default(), this._onPause = new n.default(), this._onTick = new n.default(), this._onTickOncePerFrame = new n.default(), i2 || this.resume();
          }
          return e3.prototype.updateOnce = function(e4) {
            e4(this.currentTimeSeconds, this.tickDeltaTimeSeconds, this.currentTick);
          }, e3.prototype.resume = function() {
            this._isRunning || (this._isRunning = true, this._lastTimeUpdated = this.getTimer(), this._onResume.dispatch(), this.animateOnce());
          }, e3.prototype.pause = function() {
            this._isRunning && (this._isRunning = false, this._onPause.dispatch(), window.cancelAnimationFrame(this._animationFrameHandle));
          }, e3.prototype.dispose = function() {
            this.pause(), this._onResume.removeAll(), this._onPause.removeAll(), this._onTick.removeAll();
          }, Object.defineProperty(e3.prototype, "currentTick", { get: function() {
            return this._currentTick;
          }, enumerable: true, configurable: true }), Object.defineProperty(e3.prototype, "currentTimeSeconds", { get: function() {
            return this._currentTime / 1e3;
          }, enumerable: true, configurable: true }), Object.defineProperty(e3.prototype, "tickDeltaTimeSeconds", { get: function() {
            return this._tickDeltaTime / 1e3;
          }, enumerable: true, configurable: true }), Object.defineProperty(e3.prototype, "timeScale", { get: function() {
            return this._timeScale;
          }, set: function(e4) {
            this._timeScale !== e4 && (this._timeScale = e4);
          }, enumerable: true, configurable: true }), Object.defineProperty(e3.prototype, "onResume", { get: function() {
            return this._onResume;
          }, enumerable: true, configurable: true }), Object.defineProperty(e3.prototype, "onPause", { get: function() {
            return this._onPause;
          }, enumerable: true, configurable: true }), Object.defineProperty(e3.prototype, "onTick", { get: function() {
            return this._onTick;
          }, enumerable: true, configurable: true }), Object.defineProperty(e3.prototype, "onTickOncePerFrame", { get: function() {
            return this._onTickOncePerFrame;
          }, enumerable: true, configurable: true }), Object.defineProperty(e3.prototype, "isRunning", { get: function() {
            return this._isRunning;
          }, enumerable: true, configurable: true }), e3.prototype.animateOnce = function() {
            var e4 = this;
            this._animationFrameHandle = window.requestAnimationFrame(function() {
              return e4.onFrame();
            });
          }, e3.prototype.onFrame = function() {
            if (this._now = this.getTimer(), this._frameDeltaTime = this._now - this._lastTimeUpdated, isNaN(this._minInterval) || this._frameDeltaTime >= this._minInterval) if (isNaN(this._maxInterval)) this.update(this._frameDeltaTime * this._timeScale, true), this._lastTimeUpdated = this._now;
            else for (this._interval = Math.min(this._frameDeltaTime, this._maxInterval); this._now >= this._lastTimeUpdated + this._interval; ) this.update(this._interval * this._timeScale, this._now <= this._lastTimeUpdated + 2 * this._maxInterval), this._lastTimeUpdated += this._interval;
            this._isRunning && this.animateOnce();
          }, e3.prototype.update = function(e4, t4) {
            void 0 === t4 && (t4 = true), this._currentTick++, this._currentTime += e4, this._tickDeltaTime = e4, this._onTick.dispatch(this.currentTimeSeconds, this.tickDeltaTimeSeconds, this.currentTick), t4 && this._onTickOncePerFrame.dispatch(this.currentTimeSeconds, this.tickDeltaTimeSeconds, this.currentTick);
          }, e3.prototype.getTimer = function() {
            return Date.now();
          }, e3;
        }();
        Object.defineProperty(t, "__esModule", { value: true }), t.default = r;
      }, function(e, t, i) {
        !function(t4, i2) {
          e.exports = i2();
        }(this, function() {
          return function(e3) {
            function t4(n) {
              if (i2[n]) return i2[n].exports;
              var r = i2[n] = { exports: {}, id: n, loaded: false };
              return e3[n].call(r.exports, r, r.exports, t4), r.loaded = true, r.exports;
            }
            var i2 = {};
            return t4.m = e3, t4.c = i2, t4.p = "", t4(0);
          }([function(e3, t4) {
            "use strict";
            var i2 = function() {
              function e4() {
                this.functions = [];
              }
              return e4.prototype.add = function(e6) {
                return this.functions.indexOf(e6) === -1 && (this.functions.push(e6), true);
              }, e4.prototype.remove = function(e6) {
                var t5 = this.functions.indexOf(e6);
                return t5 > -1 && (this.functions.splice(t5, 1), true);
              }, e4.prototype.removeAll = function() {
                return this.functions.length > 0 && (this.functions.length = 0, true);
              }, e4.prototype.dispatch = function() {
                for (var e6 = [], t5 = 0; t5 < arguments.length; t5++) e6[t5] = arguments[t5];
                var i3 = this.functions.concat();
                i3.forEach(function(t6) {
                  t6.apply(void 0, e6);
                });
              }, Object.defineProperty(e4.prototype, "numItems", { get: function() {
                return this.functions.length;
              }, enumerable: true, configurable: true }), e4;
            }();
            Object.defineProperty(t4, "__esModule", { value: true }), t4.default = i2;
          }]);
        });
      }]);
    });
  }
});

// node_modules/lodash-es/isObject.js
function isObject(value) {
  var type = typeof value;
  return value != null && (type == "object" || type == "function");
}
var isObject_default = isObject;

// node_modules/lodash-es/_freeGlobal.js
var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
var freeGlobal_default = freeGlobal;

// node_modules/lodash-es/_root.js
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root = freeGlobal_default || freeSelf || Function("return this")();
var root_default = root;

// node_modules/lodash-es/now.js
var now = function() {
  return root_default.Date.now();
};
var now_default = now;

// node_modules/lodash-es/_trimmedEndIndex.js
var reWhitespace = /\s/;
function trimmedEndIndex(string3) {
  var index5 = string3.length;
  while (index5-- && reWhitespace.test(string3.charAt(index5))) {
  }
  return index5;
}
var trimmedEndIndex_default = trimmedEndIndex;

// node_modules/lodash-es/_baseTrim.js
var reTrimStart = /^\s+/;
function baseTrim(string3) {
  return string3 ? string3.slice(0, trimmedEndIndex_default(string3) + 1).replace(reTrimStart, "") : string3;
}
var baseTrim_default = baseTrim;

// node_modules/lodash-es/_Symbol.js
var Symbol2 = root_default.Symbol;
var Symbol_default = Symbol2;

// node_modules/lodash-es/_getRawTag.js
var objectProto = Object.prototype;
var hasOwnProperty = objectProto.hasOwnProperty;
var nativeObjectToString = objectProto.toString;
var symToStringTag = Symbol_default ? Symbol_default.toStringTag : void 0;
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
  try {
    value[symToStringTag] = void 0;
    var unmasked = true;
  } catch (e) {
  }
  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}
var getRawTag_default = getRawTag;

// node_modules/lodash-es/_objectToString.js
var objectProto2 = Object.prototype;
var nativeObjectToString2 = objectProto2.toString;
function objectToString(value) {
  return nativeObjectToString2.call(value);
}
var objectToString_default = objectToString;

// node_modules/lodash-es/_baseGetTag.js
var nullTag = "[object Null]";
var undefinedTag = "[object Undefined]";
var symToStringTag2 = Symbol_default ? Symbol_default.toStringTag : void 0;
function baseGetTag(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag2 && symToStringTag2 in Object(value) ? getRawTag_default(value) : objectToString_default(value);
}
var baseGetTag_default = baseGetTag;

// node_modules/lodash-es/isObjectLike.js
function isObjectLike(value) {
  return value != null && typeof value == "object";
}
var isObjectLike_default = isObjectLike;

// node_modules/lodash-es/isSymbol.js
var symbolTag = "[object Symbol]";
function isSymbol(value) {
  return typeof value == "symbol" || isObjectLike_default(value) && baseGetTag_default(value) == symbolTag;
}
var isSymbol_default = isSymbol;

// node_modules/lodash-es/toNumber.js
var NAN = 0 / 0;
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
var reIsBinary = /^0b[01]+$/i;
var reIsOctal = /^0o[0-7]+$/i;
var freeParseInt = parseInt;
function toNumber(value) {
  if (typeof value == "number") {
    return value;
  }
  if (isSymbol_default(value)) {
    return NAN;
  }
  if (isObject_default(value)) {
    var other = typeof value.valueOf == "function" ? value.valueOf() : value;
    value = isObject_default(other) ? other + "" : other;
  }
  if (typeof value != "string") {
    return value === 0 ? value : +value;
  }
  value = baseTrim_default(value);
  var isBinary = reIsBinary.test(value);
  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}
var toNumber_default = toNumber;

// node_modules/lodash-es/debounce.js
var FUNC_ERROR_TEXT = "Expected a function";
var nativeMax = Math.max;
var nativeMin = Math.min;
function debounce(func, wait, options) {
  var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = toNumber_default(wait) || 0;
  if (isObject_default(options)) {
    leading = !!options.leading;
    maxing = "maxWait" in options;
    maxWait = maxing ? nativeMax(toNumber_default(options.maxWait) || 0, wait) : maxWait;
    trailing = "trailing" in options ? !!options.trailing : trailing;
  }
  function invokeFunc(time4) {
    var args = lastArgs, thisArg = lastThis;
    lastArgs = lastThis = void 0;
    lastInvokeTime = time4;
    result = func.apply(thisArg, args);
    return result;
  }
  function leadingEdge(time4) {
    lastInvokeTime = time4;
    timerId = setTimeout(timerExpired, wait);
    return leading ? invokeFunc(time4) : result;
  }
  function remainingWait(time4) {
    var timeSinceLastCall = time4 - lastCallTime, timeSinceLastInvoke = time4 - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
    return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
  }
  function shouldInvoke(time4) {
    var timeSinceLastCall = time4 - lastCallTime, timeSinceLastInvoke = time4 - lastInvokeTime;
    return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
  }
  function timerExpired() {
    var time4 = now_default();
    if (shouldInvoke(time4)) {
      return trailingEdge(time4);
    }
    timerId = setTimeout(timerExpired, remainingWait(time4));
  }
  function trailingEdge(time4) {
    timerId = void 0;
    if (trailing && lastArgs) {
      return invokeFunc(time4);
    }
    lastArgs = lastThis = void 0;
    return result;
  }
  function cancel() {
    if (timerId !== void 0) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = void 0;
  }
  function flush() {
    return timerId === void 0 ? result : trailingEdge(now_default());
  }
  function debounced() {
    var time4 = now_default(), isInvoking = shouldInvoke(time4);
    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time4;
    if (isInvoking) {
      if (timerId === void 0) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        clearTimeout(timerId);
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === void 0) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}
var debounce_default = debounce;

// node_modules/kapsule/dist/kapsule.mjs
function _arrayLikeToArray(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}
function _arrayWithHoles(r) {
  if (Array.isArray(r)) return r;
}
function _classCallCheck(a, n) {
  if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
}
function _createClass(e, r, t) {
  return Object.defineProperty(e, "prototype", {
    writable: false
  }), e;
}
function _iterableToArrayLimit(r, l) {
  var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (null != t) {
    var e, n, i, u4, a = [], f = true, o = false;
    try {
      if (i = (t = t.call(r)).next, 0 === l) ;
      else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = true) ;
    } catch (r2) {
      o = true, n = r2;
    } finally {
      try {
        if (!f && null != t.return && (u4 = t.return(), Object(u4) !== u4)) return;
      } finally {
        if (o) throw n;
      }
    }
    return a;
  }
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _slicedToArray(r, e) {
  return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest();
}
function _unsupportedIterableToArray(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
  }
}
var Prop = _createClass(function Prop2(name, _ref) {
  var _ref$default = _ref["default"], defaultVal = _ref$default === void 0 ? null : _ref$default, _ref$triggerUpdate = _ref.triggerUpdate, triggerUpdate = _ref$triggerUpdate === void 0 ? true : _ref$triggerUpdate, _ref$onChange = _ref.onChange, onChange10 = _ref$onChange === void 0 ? function(newVal, state) {
  } : _ref$onChange;
  _classCallCheck(this, Prop2);
  this.name = name;
  this.defaultVal = defaultVal;
  this.triggerUpdate = triggerUpdate;
  this.onChange = onChange10;
});
function index(_ref2) {
  var _ref2$stateInit = _ref2.stateInit, stateInit5 = _ref2$stateInit === void 0 ? function() {
    return {};
  } : _ref2$stateInit, _ref2$props = _ref2.props, rawProps = _ref2$props === void 0 ? {} : _ref2$props, _ref2$methods = _ref2.methods, methods = _ref2$methods === void 0 ? {} : _ref2$methods, _ref2$aliases = _ref2.aliases, aliases = _ref2$aliases === void 0 ? {} : _ref2$aliases, _ref2$init = _ref2.init, initFn = _ref2$init === void 0 ? function() {
  } : _ref2$init, _ref2$update = _ref2.update, updateFn = _ref2$update === void 0 ? function() {
  } : _ref2$update;
  var props = Object.keys(rawProps).map(function(propName) {
    return new Prop(propName, rawProps[propName]);
  });
  return function KapsuleComp() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    var classMode = !!(this instanceof KapsuleComp ? this.constructor : void 0);
    var nodeElement = classMode ? args.shift() : void 0;
    var _args$ = args[0], options = _args$ === void 0 ? {} : _args$;
    var state = Object.assign(
      {},
      stateInit5 instanceof Function ? stateInit5(options) : stateInit5,
      // Support plain objects for backwards compatibility
      {
        initialised: false
      }
    );
    var changedProps = {};
    function comp(nodeElement2) {
      initStatic(nodeElement2, options);
      digest();
      return comp;
    }
    var initStatic = function initStatic2(nodeElement2, options2) {
      initFn.call(comp, nodeElement2, state, options2);
      state.initialised = true;
    };
    var digest = debounce_default(function() {
      if (!state.initialised) {
        return;
      }
      updateFn.call(comp, state, changedProps);
      changedProps = {};
    }, 1);
    props.forEach(function(prop) {
      comp[prop.name] = getSetProp(prop);
      function getSetProp(_ref3) {
        var prop2 = _ref3.name, _ref3$triggerUpdate = _ref3.triggerUpdate, redigest = _ref3$triggerUpdate === void 0 ? false : _ref3$triggerUpdate, _ref3$onChange = _ref3.onChange, onChange10 = _ref3$onChange === void 0 ? function(newVal, state2) {
        } : _ref3$onChange, _ref3$defaultVal = _ref3.defaultVal, defaultVal = _ref3$defaultVal === void 0 ? null : _ref3$defaultVal;
        return function(_) {
          var curVal = state[prop2];
          if (!arguments.length) {
            return curVal;
          }
          var val = _ === void 0 ? defaultVal : _;
          state[prop2] = val;
          onChange10.call(comp, val, state, curVal);
          !changedProps.hasOwnProperty(prop2) && (changedProps[prop2] = curVal);
          if (redigest) {
            digest();
          }
          return comp;
        };
      }
    });
    Object.keys(methods).forEach(function(methodName) {
      comp[methodName] = function() {
        var _methods$methodName;
        for (var _len2 = arguments.length, args2 = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args2[_key2] = arguments[_key2];
        }
        return (_methods$methodName = methods[methodName]).call.apply(_methods$methodName, [comp, state].concat(args2));
      };
    });
    Object.entries(aliases).forEach(function(_ref4) {
      var _ref5 = _slicedToArray(_ref4, 2), alias = _ref5[0], target = _ref5[1];
      return comp[alias] = comp[target];
    });
    comp.resetProps = function() {
      props.forEach(function(prop) {
        comp[prop.name](prop.defaultVal);
      });
      return comp;
    };
    comp.resetProps();
    state._rerender = digest;
    classMode && nodeElement && comp(nodeElement);
    return comp;
  };
}

// node_modules/@tweenjs/tween.js/dist/tween.esm.js
var Easing = Object.freeze({
  Linear: Object.freeze({
    None: function(amount) {
      return amount;
    },
    In: function(amount) {
      return amount;
    },
    Out: function(amount) {
      return amount;
    },
    InOut: function(amount) {
      return amount;
    }
  }),
  Quadratic: Object.freeze({
    In: function(amount) {
      return amount * amount;
    },
    Out: function(amount) {
      return amount * (2 - amount);
    },
    InOut: function(amount) {
      if ((amount *= 2) < 1) {
        return 0.5 * amount * amount;
      }
      return -0.5 * (--amount * (amount - 2) - 1);
    }
  }),
  Cubic: Object.freeze({
    In: function(amount) {
      return amount * amount * amount;
    },
    Out: function(amount) {
      return --amount * amount * amount + 1;
    },
    InOut: function(amount) {
      if ((amount *= 2) < 1) {
        return 0.5 * amount * amount * amount;
      }
      return 0.5 * ((amount -= 2) * amount * amount + 2);
    }
  }),
  Quartic: Object.freeze({
    In: function(amount) {
      return amount * amount * amount * amount;
    },
    Out: function(amount) {
      return 1 - --amount * amount * amount * amount;
    },
    InOut: function(amount) {
      if ((amount *= 2) < 1) {
        return 0.5 * amount * amount * amount * amount;
      }
      return -0.5 * ((amount -= 2) * amount * amount * amount - 2);
    }
  }),
  Quintic: Object.freeze({
    In: function(amount) {
      return amount * amount * amount * amount * amount;
    },
    Out: function(amount) {
      return --amount * amount * amount * amount * amount + 1;
    },
    InOut: function(amount) {
      if ((amount *= 2) < 1) {
        return 0.5 * amount * amount * amount * amount * amount;
      }
      return 0.5 * ((amount -= 2) * amount * amount * amount * amount + 2);
    }
  }),
  Sinusoidal: Object.freeze({
    In: function(amount) {
      return 1 - Math.sin((1 - amount) * Math.PI / 2);
    },
    Out: function(amount) {
      return Math.sin(amount * Math.PI / 2);
    },
    InOut: function(amount) {
      return 0.5 * (1 - Math.sin(Math.PI * (0.5 - amount)));
    }
  }),
  Exponential: Object.freeze({
    In: function(amount) {
      return amount === 0 ? 0 : Math.pow(1024, amount - 1);
    },
    Out: function(amount) {
      return amount === 1 ? 1 : 1 - Math.pow(2, -10 * amount);
    },
    InOut: function(amount) {
      if (amount === 0) {
        return 0;
      }
      if (amount === 1) {
        return 1;
      }
      if ((amount *= 2) < 1) {
        return 0.5 * Math.pow(1024, amount - 1);
      }
      return 0.5 * (-Math.pow(2, -10 * (amount - 1)) + 2);
    }
  }),
  Circular: Object.freeze({
    In: function(amount) {
      return 1 - Math.sqrt(1 - amount * amount);
    },
    Out: function(amount) {
      return Math.sqrt(1 - --amount * amount);
    },
    InOut: function(amount) {
      if ((amount *= 2) < 1) {
        return -0.5 * (Math.sqrt(1 - amount * amount) - 1);
      }
      return 0.5 * (Math.sqrt(1 - (amount -= 2) * amount) + 1);
    }
  }),
  Elastic: Object.freeze({
    In: function(amount) {
      if (amount === 0) {
        return 0;
      }
      if (amount === 1) {
        return 1;
      }
      return -Math.pow(2, 10 * (amount - 1)) * Math.sin((amount - 1.1) * 5 * Math.PI);
    },
    Out: function(amount) {
      if (amount === 0) {
        return 0;
      }
      if (amount === 1) {
        return 1;
      }
      return Math.pow(2, -10 * amount) * Math.sin((amount - 0.1) * 5 * Math.PI) + 1;
    },
    InOut: function(amount) {
      if (amount === 0) {
        return 0;
      }
      if (amount === 1) {
        return 1;
      }
      amount *= 2;
      if (amount < 1) {
        return -0.5 * Math.pow(2, 10 * (amount - 1)) * Math.sin((amount - 1.1) * 5 * Math.PI);
      }
      return 0.5 * Math.pow(2, -10 * (amount - 1)) * Math.sin((amount - 1.1) * 5 * Math.PI) + 1;
    }
  }),
  Back: Object.freeze({
    In: function(amount) {
      var s = 1.70158;
      return amount === 1 ? 1 : amount * amount * ((s + 1) * amount - s);
    },
    Out: function(amount) {
      var s = 1.70158;
      return amount === 0 ? 0 : --amount * amount * ((s + 1) * amount + s) + 1;
    },
    InOut: function(amount) {
      var s = 1.70158 * 1.525;
      if ((amount *= 2) < 1) {
        return 0.5 * (amount * amount * ((s + 1) * amount - s));
      }
      return 0.5 * ((amount -= 2) * amount * ((s + 1) * amount + s) + 2);
    }
  }),
  Bounce: Object.freeze({
    In: function(amount) {
      return 1 - Easing.Bounce.Out(1 - amount);
    },
    Out: function(amount) {
      if (amount < 1 / 2.75) {
        return 7.5625 * amount * amount;
      } else if (amount < 2 / 2.75) {
        return 7.5625 * (amount -= 1.5 / 2.75) * amount + 0.75;
      } else if (amount < 2.5 / 2.75) {
        return 7.5625 * (amount -= 2.25 / 2.75) * amount + 0.9375;
      } else {
        return 7.5625 * (amount -= 2.625 / 2.75) * amount + 0.984375;
      }
    },
    InOut: function(amount) {
      if (amount < 0.5) {
        return Easing.Bounce.In(amount * 2) * 0.5;
      }
      return Easing.Bounce.Out(amount * 2 - 1) * 0.5 + 0.5;
    }
  }),
  generatePow: function(power) {
    if (power === void 0) {
      power = 4;
    }
    power = power < Number.EPSILON ? Number.EPSILON : power;
    power = power > 1e4 ? 1e4 : power;
    return {
      In: function(amount) {
        return Math.pow(amount, power);
      },
      Out: function(amount) {
        return 1 - Math.pow(1 - amount, power);
      },
      InOut: function(amount) {
        if (amount < 0.5) {
          return Math.pow(amount * 2, power) / 2;
        }
        return (1 - Math.pow(2 - amount * 2, power)) / 2 + 0.5;
      }
    };
  }
});
var now2 = function() {
  return performance.now();
};
var Group2 = (
  /** @class */
  function() {
    function Group3() {
      this._tweens = {};
      this._tweensAddedDuringUpdate = {};
    }
    Group3.prototype.getAll = function() {
      var _this = this;
      return Object.keys(this._tweens).map(function(tweenId) {
        return _this._tweens[tweenId];
      });
    };
    Group3.prototype.removeAll = function() {
      this._tweens = {};
    };
    Group3.prototype.add = function(tween) {
      this._tweens[tween.getId()] = tween;
      this._tweensAddedDuringUpdate[tween.getId()] = tween;
    };
    Group3.prototype.remove = function(tween) {
      delete this._tweens[tween.getId()];
      delete this._tweensAddedDuringUpdate[tween.getId()];
    };
    Group3.prototype.update = function(time4, preserve) {
      if (time4 === void 0) {
        time4 = now2();
      }
      if (preserve === void 0) {
        preserve = false;
      }
      var tweenIds = Object.keys(this._tweens);
      if (tweenIds.length === 0) {
        return false;
      }
      while (tweenIds.length > 0) {
        this._tweensAddedDuringUpdate = {};
        for (var i = 0; i < tweenIds.length; i++) {
          var tween = this._tweens[tweenIds[i]];
          var autoStart = !preserve;
          if (tween && tween.update(time4, autoStart) === false && !preserve) {
            delete this._tweens[tweenIds[i]];
          }
        }
        tweenIds = Object.keys(this._tweensAddedDuringUpdate);
      }
      return true;
    };
    return Group3;
  }()
);
var Interpolation = {
  Linear: function(v2, k) {
    var m = v2.length - 1;
    var f = m * k;
    var i = Math.floor(f);
    var fn = Interpolation.Utils.Linear;
    if (k < 0) {
      return fn(v2[0], v2[1], f);
    }
    if (k > 1) {
      return fn(v2[m], v2[m - 1], m - f);
    }
    return fn(v2[i], v2[i + 1 > m ? m : i + 1], f - i);
  },
  Bezier: function(v2, k) {
    var b = 0;
    var n = v2.length - 1;
    var pw = Math.pow;
    var bn = Interpolation.Utils.Bernstein;
    for (var i = 0; i <= n; i++) {
      b += pw(1 - k, n - i) * pw(k, i) * v2[i] * bn(n, i);
    }
    return b;
  },
  CatmullRom: function(v2, k) {
    var m = v2.length - 1;
    var f = m * k;
    var i = Math.floor(f);
    var fn = Interpolation.Utils.CatmullRom;
    if (v2[0] === v2[m]) {
      if (k < 0) {
        i = Math.floor(f = m * (1 + k));
      }
      return fn(v2[(i - 1 + m) % m], v2[i], v2[(i + 1) % m], v2[(i + 2) % m], f - i);
    } else {
      if (k < 0) {
        return v2[0] - (fn(v2[0], v2[0], v2[1], v2[1], -f) - v2[0]);
      }
      if (k > 1) {
        return v2[m] - (fn(v2[m], v2[m], v2[m - 1], v2[m - 1], f - m) - v2[m]);
      }
      return fn(v2[i ? i - 1 : 0], v2[i], v2[m < i + 1 ? m : i + 1], v2[m < i + 2 ? m : i + 2], f - i);
    }
  },
  Utils: {
    Linear: function(p02, p1, t) {
      return (p1 - p02) * t + p02;
    },
    Bernstein: function(n, i) {
      var fc = Interpolation.Utils.Factorial;
      return fc(n) / fc(i) / fc(n - i);
    },
    Factorial: /* @__PURE__ */ function() {
      var a = [1];
      return function(n) {
        var s = 1;
        if (a[n]) {
          return a[n];
        }
        for (var i = n; i > 1; i--) {
          s *= i;
        }
        a[n] = s;
        return s;
      };
    }(),
    CatmullRom: function(p02, p1, p2, p3, t) {
      var v0 = (p2 - p02) * 0.5;
      var v1 = (p3 - p1) * 0.5;
      var t22 = t * t;
      var t32 = t * t22;
      return (2 * p1 - 2 * p2 + v0 + v1) * t32 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t22 + v0 * t + p1;
    }
  }
};
var Sequence = (
  /** @class */
  function() {
    function Sequence2() {
    }
    Sequence2.nextId = function() {
      return Sequence2._nextId++;
    };
    Sequence2._nextId = 0;
    return Sequence2;
  }()
);
var mainGroup = new Group2();
var Tween = (
  /** @class */
  function() {
    function Tween2(_object, _group) {
      if (_group === void 0) {
        _group = mainGroup;
      }
      this._object = _object;
      this._group = _group;
      this._isPaused = false;
      this._pauseStart = 0;
      this._valuesStart = {};
      this._valuesEnd = {};
      this._valuesStartRepeat = {};
      this._duration = 1e3;
      this._isDynamic = false;
      this._initialRepeat = 0;
      this._repeat = 0;
      this._yoyo = false;
      this._isPlaying = false;
      this._reversed = false;
      this._delayTime = 0;
      this._startTime = 0;
      this._easingFunction = Easing.Linear.None;
      this._interpolationFunction = Interpolation.Linear;
      this._chainedTweens = [];
      this._onStartCallbackFired = false;
      this._onEveryStartCallbackFired = false;
      this._id = Sequence.nextId();
      this._isChainStopped = false;
      this._propertiesAreSetUp = false;
      this._goToEnd = false;
    }
    Tween2.prototype.getId = function() {
      return this._id;
    };
    Tween2.prototype.isPlaying = function() {
      return this._isPlaying;
    };
    Tween2.prototype.isPaused = function() {
      return this._isPaused;
    };
    Tween2.prototype.getDuration = function() {
      return this._duration;
    };
    Tween2.prototype.to = function(target, duration) {
      if (duration === void 0) {
        duration = 1e3;
      }
      if (this._isPlaying)
        throw new Error("Can not call Tween.to() while Tween is already started or paused. Stop the Tween first.");
      this._valuesEnd = target;
      this._propertiesAreSetUp = false;
      this._duration = duration < 0 ? 0 : duration;
      return this;
    };
    Tween2.prototype.duration = function(duration) {
      if (duration === void 0) {
        duration = 1e3;
      }
      this._duration = duration < 0 ? 0 : duration;
      return this;
    };
    Tween2.prototype.dynamic = function(dynamic) {
      if (dynamic === void 0) {
        dynamic = false;
      }
      this._isDynamic = dynamic;
      return this;
    };
    Tween2.prototype.start = function(time4, overrideStartingValues) {
      if (time4 === void 0) {
        time4 = now2();
      }
      if (overrideStartingValues === void 0) {
        overrideStartingValues = false;
      }
      if (this._isPlaying) {
        return this;
      }
      this._group && this._group.add(this);
      this._repeat = this._initialRepeat;
      if (this._reversed) {
        this._reversed = false;
        for (var property3 in this._valuesStartRepeat) {
          this._swapEndStartRepeatValues(property3);
          this._valuesStart[property3] = this._valuesStartRepeat[property3];
        }
      }
      this._isPlaying = true;
      this._isPaused = false;
      this._onStartCallbackFired = false;
      this._onEveryStartCallbackFired = false;
      this._isChainStopped = false;
      this._startTime = time4;
      this._startTime += this._delayTime;
      if (!this._propertiesAreSetUp || overrideStartingValues) {
        this._propertiesAreSetUp = true;
        if (!this._isDynamic) {
          var tmp = {};
          for (var prop in this._valuesEnd)
            tmp[prop] = this._valuesEnd[prop];
          this._valuesEnd = tmp;
        }
        this._setupProperties(this._object, this._valuesStart, this._valuesEnd, this._valuesStartRepeat, overrideStartingValues);
      }
      return this;
    };
    Tween2.prototype.startFromCurrentValues = function(time4) {
      return this.start(time4, true);
    };
    Tween2.prototype._setupProperties = function(_object, _valuesStart, _valuesEnd, _valuesStartRepeat, overrideStartingValues) {
      for (var property3 in _valuesEnd) {
        var startValue = _object[property3];
        var startValueIsArray = Array.isArray(startValue);
        var propType = startValueIsArray ? "array" : typeof startValue;
        var isInterpolationList = !startValueIsArray && Array.isArray(_valuesEnd[property3]);
        if (propType === "undefined" || propType === "function") {
          continue;
        }
        if (isInterpolationList) {
          var endValues = _valuesEnd[property3];
          if (endValues.length === 0) {
            continue;
          }
          var temp = [startValue];
          for (var i = 0, l = endValues.length; i < l; i += 1) {
            var value = this._handleRelativeValue(startValue, endValues[i]);
            if (isNaN(value)) {
              isInterpolationList = false;
              console.warn("Found invalid interpolation list. Skipping.");
              break;
            }
            temp.push(value);
          }
          if (isInterpolationList) {
            _valuesEnd[property3] = temp;
          }
        }
        if ((propType === "object" || startValueIsArray) && startValue && !isInterpolationList) {
          _valuesStart[property3] = startValueIsArray ? [] : {};
          var nestedObject = startValue;
          for (var prop in nestedObject) {
            _valuesStart[property3][prop] = nestedObject[prop];
          }
          _valuesStartRepeat[property3] = startValueIsArray ? [] : {};
          var endValues = _valuesEnd[property3];
          if (!this._isDynamic) {
            var tmp = {};
            for (var prop in endValues)
              tmp[prop] = endValues[prop];
            _valuesEnd[property3] = endValues = tmp;
          }
          this._setupProperties(nestedObject, _valuesStart[property3], endValues, _valuesStartRepeat[property3], overrideStartingValues);
        } else {
          if (typeof _valuesStart[property3] === "undefined" || overrideStartingValues) {
            _valuesStart[property3] = startValue;
          }
          if (!startValueIsArray) {
            _valuesStart[property3] *= 1;
          }
          if (isInterpolationList) {
            _valuesStartRepeat[property3] = _valuesEnd[property3].slice().reverse();
          } else {
            _valuesStartRepeat[property3] = _valuesStart[property3] || 0;
          }
        }
      }
    };
    Tween2.prototype.stop = function() {
      if (!this._isChainStopped) {
        this._isChainStopped = true;
        this.stopChainedTweens();
      }
      if (!this._isPlaying) {
        return this;
      }
      this._group && this._group.remove(this);
      this._isPlaying = false;
      this._isPaused = false;
      if (this._onStopCallback) {
        this._onStopCallback(this._object);
      }
      return this;
    };
    Tween2.prototype.end = function() {
      this._goToEnd = true;
      this.update(Infinity);
      return this;
    };
    Tween2.prototype.pause = function(time4) {
      if (time4 === void 0) {
        time4 = now2();
      }
      if (this._isPaused || !this._isPlaying) {
        return this;
      }
      this._isPaused = true;
      this._pauseStart = time4;
      this._group && this._group.remove(this);
      return this;
    };
    Tween2.prototype.resume = function(time4) {
      if (time4 === void 0) {
        time4 = now2();
      }
      if (!this._isPaused || !this._isPlaying) {
        return this;
      }
      this._isPaused = false;
      this._startTime += time4 - this._pauseStart;
      this._pauseStart = 0;
      this._group && this._group.add(this);
      return this;
    };
    Tween2.prototype.stopChainedTweens = function() {
      for (var i = 0, numChainedTweens = this._chainedTweens.length; i < numChainedTweens; i++) {
        this._chainedTweens[i].stop();
      }
      return this;
    };
    Tween2.prototype.group = function(group2) {
      if (group2 === void 0) {
        group2 = mainGroup;
      }
      this._group = group2;
      return this;
    };
    Tween2.prototype.delay = function(amount) {
      if (amount === void 0) {
        amount = 0;
      }
      this._delayTime = amount;
      return this;
    };
    Tween2.prototype.repeat = function(times) {
      if (times === void 0) {
        times = 0;
      }
      this._initialRepeat = times;
      this._repeat = times;
      return this;
    };
    Tween2.prototype.repeatDelay = function(amount) {
      this._repeatDelayTime = amount;
      return this;
    };
    Tween2.prototype.yoyo = function(yoyo) {
      if (yoyo === void 0) {
        yoyo = false;
      }
      this._yoyo = yoyo;
      return this;
    };
    Tween2.prototype.easing = function(easingFunction) {
      if (easingFunction === void 0) {
        easingFunction = Easing.Linear.None;
      }
      this._easingFunction = easingFunction;
      return this;
    };
    Tween2.prototype.interpolation = function(interpolationFunction) {
      if (interpolationFunction === void 0) {
        interpolationFunction = Interpolation.Linear;
      }
      this._interpolationFunction = interpolationFunction;
      return this;
    };
    Tween2.prototype.chain = function() {
      var tweens = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        tweens[_i] = arguments[_i];
      }
      this._chainedTweens = tweens;
      return this;
    };
    Tween2.prototype.onStart = function(callback) {
      this._onStartCallback = callback;
      return this;
    };
    Tween2.prototype.onEveryStart = function(callback) {
      this._onEveryStartCallback = callback;
      return this;
    };
    Tween2.prototype.onUpdate = function(callback) {
      this._onUpdateCallback = callback;
      return this;
    };
    Tween2.prototype.onRepeat = function(callback) {
      this._onRepeatCallback = callback;
      return this;
    };
    Tween2.prototype.onComplete = function(callback) {
      this._onCompleteCallback = callback;
      return this;
    };
    Tween2.prototype.onStop = function(callback) {
      this._onStopCallback = callback;
      return this;
    };
    Tween2.prototype.update = function(time4, autoStart) {
      var _this = this;
      var _a2;
      if (time4 === void 0) {
        time4 = now2();
      }
      if (autoStart === void 0) {
        autoStart = true;
      }
      if (this._isPaused)
        return true;
      var property3;
      var endTime = this._startTime + this._duration;
      if (!this._goToEnd && !this._isPlaying) {
        if (time4 > endTime)
          return false;
        if (autoStart)
          this.start(time4, true);
      }
      this._goToEnd = false;
      if (time4 < this._startTime) {
        return true;
      }
      if (this._onStartCallbackFired === false) {
        if (this._onStartCallback) {
          this._onStartCallback(this._object);
        }
        this._onStartCallbackFired = true;
      }
      if (this._onEveryStartCallbackFired === false) {
        if (this._onEveryStartCallback) {
          this._onEveryStartCallback(this._object);
        }
        this._onEveryStartCallbackFired = true;
      }
      var elapsedTime = time4 - this._startTime;
      var durationAndDelay = this._duration + ((_a2 = this._repeatDelayTime) !== null && _a2 !== void 0 ? _a2 : this._delayTime);
      var totalTime = this._duration + this._repeat * durationAndDelay;
      var calculateElapsedPortion = function() {
        if (_this._duration === 0)
          return 1;
        if (elapsedTime > totalTime) {
          return 1;
        }
        var timesRepeated = Math.trunc(elapsedTime / durationAndDelay);
        var timeIntoCurrentRepeat = elapsedTime - timesRepeated * durationAndDelay;
        var portion = Math.min(timeIntoCurrentRepeat / _this._duration, 1);
        if (portion === 0 && elapsedTime === _this._duration) {
          return 1;
        }
        return portion;
      };
      var elapsed = calculateElapsedPortion();
      var value = this._easingFunction(elapsed);
      this._updateProperties(this._object, this._valuesStart, this._valuesEnd, value);
      if (this._onUpdateCallback) {
        this._onUpdateCallback(this._object, elapsed);
      }
      if (this._duration === 0 || elapsedTime >= this._duration) {
        if (this._repeat > 0) {
          var completeCount = Math.min(Math.trunc((elapsedTime - this._duration) / durationAndDelay) + 1, this._repeat);
          if (isFinite(this._repeat)) {
            this._repeat -= completeCount;
          }
          for (property3 in this._valuesStartRepeat) {
            if (!this._yoyo && typeof this._valuesEnd[property3] === "string") {
              this._valuesStartRepeat[property3] = // eslint-disable-next-line
              // @ts-ignore FIXME?
              this._valuesStartRepeat[property3] + parseFloat(this._valuesEnd[property3]);
            }
            if (this._yoyo) {
              this._swapEndStartRepeatValues(property3);
            }
            this._valuesStart[property3] = this._valuesStartRepeat[property3];
          }
          if (this._yoyo) {
            this._reversed = !this._reversed;
          }
          this._startTime += durationAndDelay * completeCount;
          if (this._onRepeatCallback) {
            this._onRepeatCallback(this._object);
          }
          this._onEveryStartCallbackFired = false;
          return true;
        } else {
          if (this._onCompleteCallback) {
            this._onCompleteCallback(this._object);
          }
          for (var i = 0, numChainedTweens = this._chainedTweens.length; i < numChainedTweens; i++) {
            this._chainedTweens[i].start(this._startTime + this._duration, false);
          }
          this._isPlaying = false;
          return false;
        }
      }
      return true;
    };
    Tween2.prototype._updateProperties = function(_object, _valuesStart, _valuesEnd, value) {
      for (var property3 in _valuesEnd) {
        if (_valuesStart[property3] === void 0) {
          continue;
        }
        var start = _valuesStart[property3] || 0;
        var end = _valuesEnd[property3];
        var startIsArray = Array.isArray(_object[property3]);
        var endIsArray = Array.isArray(end);
        var isInterpolationList = !startIsArray && endIsArray;
        if (isInterpolationList) {
          _object[property3] = this._interpolationFunction(end, value);
        } else if (typeof end === "object" && end) {
          this._updateProperties(_object[property3], start, end, value);
        } else {
          end = this._handleRelativeValue(start, end);
          if (typeof end === "number") {
            _object[property3] = start + (end - start) * value;
          }
        }
      }
    };
    Tween2.prototype._handleRelativeValue = function(start, end) {
      if (typeof end !== "string") {
        return end;
      }
      if (end.charAt(0) === "+" || end.charAt(0) === "-") {
        return start + parseFloat(end);
      }
      return parseFloat(end);
    };
    Tween2.prototype._swapEndStartRepeatValues = function(property3) {
      var tmp = this._valuesStartRepeat[property3];
      var endValue = this._valuesEnd[property3];
      if (typeof endValue === "string") {
        this._valuesStartRepeat[property3] = this._valuesStartRepeat[property3] + parseFloat(endValue);
      } else {
        this._valuesStartRepeat[property3] = this._valuesEnd[property3];
      }
      this._valuesEnd[property3] = tmp;
    };
    return Tween2;
  }()
);
var nextId = Sequence.nextId;
var TWEEN = mainGroup;
var getAll = TWEEN.getAll.bind(TWEEN);
var removeAll = TWEEN.removeAll.bind(TWEEN);
var add = TWEEN.add.bind(TWEEN);
var remove = TWEEN.remove.bind(TWEEN);
var update = TWEEN.update.bind(TWEEN);

// node_modules/d3-octree/src/add.js
function add_default(d) {
  const x = +this._x.call(null, d), y = +this._y.call(null, d), z = +this._z.call(null, d);
  return add2(this.cover(x, y, z), x, y, z, d);
}
function add2(tree, x, y, z, d) {
  if (isNaN(x) || isNaN(y) || isNaN(z)) return tree;
  var parent, node = tree._root, leaf = { data: d }, x03 = tree._x0, y03 = tree._y0, z02 = tree._z0, x12 = tree._x1, y12 = tree._y1, z1 = tree._z1, xm, ym, zm, xp, yp, zp, right, bottom, deep, i, j;
  if (!node) return tree._root = leaf, tree;
  while (node.length) {
    if (right = x >= (xm = (x03 + x12) / 2)) x03 = xm;
    else x12 = xm;
    if (bottom = y >= (ym = (y03 + y12) / 2)) y03 = ym;
    else y12 = ym;
    if (deep = z >= (zm = (z02 + z1) / 2)) z02 = zm;
    else z1 = zm;
    if (parent = node, !(node = node[i = deep << 2 | bottom << 1 | right])) return parent[i] = leaf, tree;
  }
  xp = +tree._x.call(null, node.data);
  yp = +tree._y.call(null, node.data);
  zp = +tree._z.call(null, node.data);
  if (x === xp && y === yp && z === zp) return leaf.next = node, parent ? parent[i] = leaf : tree._root = leaf, tree;
  do {
    parent = parent ? parent[i] = new Array(8) : tree._root = new Array(8);
    if (right = x >= (xm = (x03 + x12) / 2)) x03 = xm;
    else x12 = xm;
    if (bottom = y >= (ym = (y03 + y12) / 2)) y03 = ym;
    else y12 = ym;
    if (deep = z >= (zm = (z02 + z1) / 2)) z02 = zm;
    else z1 = zm;
  } while ((i = deep << 2 | bottom << 1 | right) === (j = (zp >= zm) << 2 | (yp >= ym) << 1 | xp >= xm));
  return parent[j] = node, parent[i] = leaf, tree;
}
function addAll(data) {
  if (!Array.isArray(data)) data = Array.from(data);
  const n = data.length;
  const xz = new Float64Array(n);
  const yz = new Float64Array(n);
  const zz = new Float64Array(n);
  let x03 = Infinity, y03 = Infinity, z02 = Infinity, x12 = -Infinity, y12 = -Infinity, z1 = -Infinity;
  for (let i = 0, d, x, y, z; i < n; ++i) {
    if (isNaN(x = +this._x.call(null, d = data[i])) || isNaN(y = +this._y.call(null, d)) || isNaN(z = +this._z.call(null, d))) continue;
    xz[i] = x;
    yz[i] = y;
    zz[i] = z;
    if (x < x03) x03 = x;
    if (x > x12) x12 = x;
    if (y < y03) y03 = y;
    if (y > y12) y12 = y;
    if (z < z02) z02 = z;
    if (z > z1) z1 = z;
  }
  if (x03 > x12 || y03 > y12 || z02 > z1) return this;
  this.cover(x03, y03, z02).cover(x12, y12, z1);
  for (let i = 0; i < n; ++i) {
    add2(this, xz[i], yz[i], zz[i], data[i]);
  }
  return this;
}

// node_modules/d3-octree/src/cover.js
function cover_default(x, y, z) {
  if (isNaN(x = +x) || isNaN(y = +y) || isNaN(z = +z)) return this;
  var x03 = this._x0, y03 = this._y0, z02 = this._z0, x12 = this._x1, y12 = this._y1, z1 = this._z1;
  if (isNaN(x03)) {
    x12 = (x03 = Math.floor(x)) + 1;
    y12 = (y03 = Math.floor(y)) + 1;
    z1 = (z02 = Math.floor(z)) + 1;
  } else {
    var t = x12 - x03 || 1, node = this._root, parent, i;
    while (x03 > x || x >= x12 || y03 > y || y >= y12 || z02 > z || z >= z1) {
      i = (z < z02) << 2 | (y < y03) << 1 | x < x03;
      parent = new Array(8), parent[i] = node, node = parent, t *= 2;
      switch (i) {
        case 0:
          x12 = x03 + t, y12 = y03 + t, z1 = z02 + t;
          break;
        case 1:
          x03 = x12 - t, y12 = y03 + t, z1 = z02 + t;
          break;
        case 2:
          x12 = x03 + t, y03 = y12 - t, z1 = z02 + t;
          break;
        case 3:
          x03 = x12 - t, y03 = y12 - t, z1 = z02 + t;
          break;
        case 4:
          x12 = x03 + t, y12 = y03 + t, z02 = z1 - t;
          break;
        case 5:
          x03 = x12 - t, y12 = y03 + t, z02 = z1 - t;
          break;
        case 6:
          x12 = x03 + t, y03 = y12 - t, z02 = z1 - t;
          break;
        case 7:
          x03 = x12 - t, y03 = y12 - t, z02 = z1 - t;
          break;
      }
    }
    if (this._root && this._root.length) this._root = node;
  }
  this._x0 = x03;
  this._y0 = y03;
  this._z0 = z02;
  this._x1 = x12;
  this._y1 = y12;
  this._z1 = z1;
  return this;
}

// node_modules/d3-octree/src/data.js
function data_default() {
  var data = [];
  this.visit(function(node) {
    if (!node.length) do
      data.push(node.data);
    while (node = node.next);
  });
  return data;
}

// node_modules/d3-octree/src/extent.js
function extent_default(_) {
  return arguments.length ? this.cover(+_[0][0], +_[0][1], +_[0][2]).cover(+_[1][0], +_[1][1], +_[1][2]) : isNaN(this._x0) ? void 0 : [[this._x0, this._y0, this._z0], [this._x1, this._y1, this._z1]];
}

// node_modules/d3-octree/src/octant.js
function octant_default(node, x03, y03, z02, x12, y12, z1) {
  this.node = node;
  this.x0 = x03;
  this.y0 = y03;
  this.z0 = z02;
  this.x1 = x12;
  this.y1 = y12;
  this.z1 = z1;
}

// node_modules/d3-octree/src/find.js
function find_default(x, y, z, radius) {
  var data, x03 = this._x0, y03 = this._y0, z02 = this._z0, x12, y12, z1, x2, y2, z2, x3 = this._x1, y3 = this._y1, z3 = this._z1, octs = [], node = this._root, q, i;
  if (node) octs.push(new octant_default(node, x03, y03, z02, x3, y3, z3));
  if (radius == null) radius = Infinity;
  else {
    x03 = x - radius, y03 = y - radius, z02 = z - radius;
    x3 = x + radius, y3 = y + radius, z3 = z + radius;
    radius *= radius;
  }
  while (q = octs.pop()) {
    if (!(node = q.node) || (x12 = q.x0) > x3 || (y12 = q.y0) > y3 || (z1 = q.z0) > z3 || (x2 = q.x1) < x03 || (y2 = q.y1) < y03 || (z2 = q.z1) < z02) continue;
    if (node.length) {
      var xm = (x12 + x2) / 2, ym = (y12 + y2) / 2, zm = (z1 + z2) / 2;
      octs.push(
        new octant_default(node[7], xm, ym, zm, x2, y2, z2),
        new octant_default(node[6], x12, ym, zm, xm, y2, z2),
        new octant_default(node[5], xm, y12, zm, x2, ym, z2),
        new octant_default(node[4], x12, y12, zm, xm, ym, z2),
        new octant_default(node[3], xm, ym, z1, x2, y2, zm),
        new octant_default(node[2], x12, ym, z1, xm, y2, zm),
        new octant_default(node[1], xm, y12, z1, x2, ym, zm),
        new octant_default(node[0], x12, y12, z1, xm, ym, zm)
      );
      if (i = (z >= zm) << 2 | (y >= ym) << 1 | x >= xm) {
        q = octs[octs.length - 1];
        octs[octs.length - 1] = octs[octs.length - 1 - i];
        octs[octs.length - 1 - i] = q;
      }
    } else {
      var dx = x - +this._x.call(null, node.data), dy = y - +this._y.call(null, node.data), dz = z - +this._z.call(null, node.data), d2 = dx * dx + dy * dy + dz * dz;
      if (d2 < radius) {
        var d = Math.sqrt(radius = d2);
        x03 = x - d, y03 = y - d, z02 = z - d;
        x3 = x + d, y3 = y + d, z3 = z + d;
        data = node.data;
      }
    }
  }
  return data;
}

// node_modules/d3-octree/src/findAll.js
var distance = (x12, y12, z1, x2, y2, z2) => Math.sqrt((x12 - x2) ** 2 + (y12 - y2) ** 2 + (z1 - z2) ** 2);
function findAllWithinRadius(x, y, z, radius) {
  const result = [];
  const xMin = x - radius;
  const yMin = y - radius;
  const zMin = z - radius;
  const xMax = x + radius;
  const yMax = y + radius;
  const zMax = z + radius;
  this.visit((node, x12, y12, z1, x2, y2, z2) => {
    if (!node.length) {
      do {
        const d = node.data;
        if (distance(x, y, z, this._x(d), this._y(d), this._z(d)) <= radius) {
          result.push(d);
        }
      } while (node = node.next);
    }
    return x12 > xMax || y12 > yMax || z1 > zMax || x2 < xMin || y2 < yMin || z2 < zMin;
  });
  return result;
}

// node_modules/d3-octree/src/remove.js
function remove_default(d) {
  if (isNaN(x = +this._x.call(null, d)) || isNaN(y = +this._y.call(null, d)) || isNaN(z = +this._z.call(null, d))) return this;
  var parent, node = this._root, retainer, previous, next, x03 = this._x0, y03 = this._y0, z02 = this._z0, x12 = this._x1, y12 = this._y1, z1 = this._z1, x, y, z, xm, ym, zm, right, bottom, deep, i, j;
  if (!node) return this;
  if (node.length) while (true) {
    if (right = x >= (xm = (x03 + x12) / 2)) x03 = xm;
    else x12 = xm;
    if (bottom = y >= (ym = (y03 + y12) / 2)) y03 = ym;
    else y12 = ym;
    if (deep = z >= (zm = (z02 + z1) / 2)) z02 = zm;
    else z1 = zm;
    if (!(parent = node, node = node[i = deep << 2 | bottom << 1 | right])) return this;
    if (!node.length) break;
    if (parent[i + 1 & 7] || parent[i + 2 & 7] || parent[i + 3 & 7] || parent[i + 4 & 7] || parent[i + 5 & 7] || parent[i + 6 & 7] || parent[i + 7 & 7]) retainer = parent, j = i;
  }
  while (node.data !== d) if (!(previous = node, node = node.next)) return this;
  if (next = node.next) delete node.next;
  if (previous) return next ? previous.next = next : delete previous.next, this;
  if (!parent) return this._root = next, this;
  next ? parent[i] = next : delete parent[i];
  if ((node = parent[0] || parent[1] || parent[2] || parent[3] || parent[4] || parent[5] || parent[6] || parent[7]) && node === (parent[7] || parent[6] || parent[5] || parent[4] || parent[3] || parent[2] || parent[1] || parent[0]) && !node.length) {
    if (retainer) retainer[j] = node;
    else this._root = node;
  }
  return this;
}
function removeAll2(data) {
  for (var i = 0, n = data.length; i < n; ++i) this.remove(data[i]);
  return this;
}

// node_modules/d3-octree/src/root.js
function root_default2() {
  return this._root;
}

// node_modules/d3-octree/src/size.js
function size_default() {
  var size = 0;
  this.visit(function(node) {
    if (!node.length) do
      ++size;
    while (node = node.next);
  });
  return size;
}

// node_modules/d3-octree/src/visit.js
function visit_default(callback) {
  var octs = [], q, node = this._root, child, x03, y03, z02, x12, y12, z1;
  if (node) octs.push(new octant_default(node, this._x0, this._y0, this._z0, this._x1, this._y1, this._z1));
  while (q = octs.pop()) {
    if (!callback(node = q.node, x03 = q.x0, y03 = q.y0, z02 = q.z0, x12 = q.x1, y12 = q.y1, z1 = q.z1) && node.length) {
      var xm = (x03 + x12) / 2, ym = (y03 + y12) / 2, zm = (z02 + z1) / 2;
      if (child = node[7]) octs.push(new octant_default(child, xm, ym, zm, x12, y12, z1));
      if (child = node[6]) octs.push(new octant_default(child, x03, ym, zm, xm, y12, z1));
      if (child = node[5]) octs.push(new octant_default(child, xm, y03, zm, x12, ym, z1));
      if (child = node[4]) octs.push(new octant_default(child, x03, y03, zm, xm, ym, z1));
      if (child = node[3]) octs.push(new octant_default(child, xm, ym, z02, x12, y12, zm));
      if (child = node[2]) octs.push(new octant_default(child, x03, ym, z02, xm, y12, zm));
      if (child = node[1]) octs.push(new octant_default(child, xm, y03, z02, x12, ym, zm));
      if (child = node[0]) octs.push(new octant_default(child, x03, y03, z02, xm, ym, zm));
    }
  }
  return this;
}

// node_modules/d3-octree/src/visitAfter.js
function visitAfter_default(callback) {
  var octs = [], next = [], q;
  if (this._root) octs.push(new octant_default(this._root, this._x0, this._y0, this._z0, this._x1, this._y1, this._z1));
  while (q = octs.pop()) {
    var node = q.node;
    if (node.length) {
      var child, x03 = q.x0, y03 = q.y0, z02 = q.z0, x12 = q.x1, y12 = q.y1, z1 = q.z1, xm = (x03 + x12) / 2, ym = (y03 + y12) / 2, zm = (z02 + z1) / 2;
      if (child = node[0]) octs.push(new octant_default(child, x03, y03, z02, xm, ym, zm));
      if (child = node[1]) octs.push(new octant_default(child, xm, y03, z02, x12, ym, zm));
      if (child = node[2]) octs.push(new octant_default(child, x03, ym, z02, xm, y12, zm));
      if (child = node[3]) octs.push(new octant_default(child, xm, ym, z02, x12, y12, zm));
      if (child = node[4]) octs.push(new octant_default(child, x03, y03, zm, xm, ym, z1));
      if (child = node[5]) octs.push(new octant_default(child, xm, y03, zm, x12, ym, z1));
      if (child = node[6]) octs.push(new octant_default(child, x03, ym, zm, xm, y12, z1));
      if (child = node[7]) octs.push(new octant_default(child, xm, ym, zm, x12, y12, z1));
    }
    next.push(q);
  }
  while (q = next.pop()) {
    callback(q.node, q.x0, q.y0, q.z0, q.x1, q.y1, q.z1);
  }
  return this;
}

// node_modules/d3-octree/src/x.js
function defaultX(d) {
  return d[0];
}
function x_default(_) {
  return arguments.length ? (this._x = _, this) : this._x;
}

// node_modules/d3-octree/src/y.js
function defaultY(d) {
  return d[1];
}
function y_default(_) {
  return arguments.length ? (this._y = _, this) : this._y;
}

// node_modules/d3-octree/src/z.js
function defaultZ(d) {
  return d[2];
}
function z_default(_) {
  return arguments.length ? (this._z = _, this) : this._z;
}

// node_modules/d3-octree/src/octree.js
function octree(nodes, x, y, z) {
  var tree = new Octree(x == null ? defaultX : x, y == null ? defaultY : y, z == null ? defaultZ : z, NaN, NaN, NaN, NaN, NaN, NaN);
  return nodes == null ? tree : tree.addAll(nodes);
}
function Octree(x, y, z, x03, y03, z02, x12, y12, z1) {
  this._x = x;
  this._y = y;
  this._z = z;
  this._x0 = x03;
  this._y0 = y03;
  this._z0 = z02;
  this._x1 = x12;
  this._y1 = y12;
  this._z1 = z1;
  this._root = void 0;
}
function leaf_copy(leaf) {
  var copy3 = { data: leaf.data }, next = copy3;
  while (leaf = leaf.next) next = next.next = { data: leaf.data };
  return copy3;
}
var treeProto = octree.prototype = Octree.prototype;
treeProto.copy = function() {
  var copy3 = new Octree(this._x, this._y, this._z, this._x0, this._y0, this._z0, this._x1, this._y1, this._z1), node = this._root, nodes, child;
  if (!node) return copy3;
  if (!node.length) return copy3._root = leaf_copy(node), copy3;
  nodes = [{ source: node, target: copy3._root = new Array(8) }];
  while (node = nodes.pop()) {
    for (var i = 0; i < 8; ++i) {
      if (child = node.source[i]) {
        if (child.length) nodes.push({ source: child, target: node.target[i] = new Array(8) });
        else node.target[i] = leaf_copy(child);
      }
    }
  }
  return copy3;
};
treeProto.add = add_default;
treeProto.addAll = addAll;
treeProto.cover = cover_default;
treeProto.data = data_default;
treeProto.extent = extent_default;
treeProto.find = find_default;
treeProto.findAllWithinRadius = findAllWithinRadius;
treeProto.remove = remove_default;
treeProto.removeAll = removeAll2;
treeProto.root = root_default2;
treeProto.size = size_default;
treeProto.visit = visit_default;
treeProto.visitAfter = visitAfter_default;
treeProto.x = x_default;
treeProto.y = y_default;
treeProto.z = z_default;

// node_modules/d3-array/src/ascending.js
function ascending(a, b) {
  return a == null || b == null ? NaN : a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}

// node_modules/d3-array/src/descending.js
function descending(a, b) {
  return a == null || b == null ? NaN : b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
}

// node_modules/d3-array/src/bisector.js
function bisector(f) {
  let compare1, compare2, delta;
  if (f.length !== 2) {
    compare1 = ascending;
    compare2 = (d, x) => ascending(f(d), x);
    delta = (d, x) => f(d) - x;
  } else {
    compare1 = f === ascending || f === descending ? f : zero;
    compare2 = f;
    delta = f;
  }
  function left(a, x, lo = 0, hi = a.length) {
    if (lo < hi) {
      if (compare1(x, x) !== 0) return hi;
      do {
        const mid = lo + hi >>> 1;
        if (compare2(a[mid], x) < 0) lo = mid + 1;
        else hi = mid;
      } while (lo < hi);
    }
    return lo;
  }
  function right(a, x, lo = 0, hi = a.length) {
    if (lo < hi) {
      if (compare1(x, x) !== 0) return hi;
      do {
        const mid = lo + hi >>> 1;
        if (compare2(a[mid], x) <= 0) lo = mid + 1;
        else hi = mid;
      } while (lo < hi);
    }
    return lo;
  }
  function center(a, x, lo = 0, hi = a.length) {
    const i = left(a, x, lo, hi - 1);
    return i > lo && delta(a[i - 1], x) > -delta(a[i], x) ? i - 1 : i;
  }
  return { left, center, right };
}
function zero() {
  return 0;
}

// node_modules/d3-array/src/number.js
function number(x) {
  return x === null ? NaN : +x;
}

// node_modules/d3-array/src/bisect.js
var ascendingBisect = bisector(ascending);
var bisectRight = ascendingBisect.right;
var bisectLeft = ascendingBisect.left;
var bisectCenter = bisector(number).center;
var bisect_default = bisectRight;

// node_modules/d3-array/src/blur.js
var blur2 = Blur2(blurf);
var blurImage = Blur2(blurfImage);
function Blur2(blur5) {
  return function(data, rx, ry = rx) {
    if (!((rx = +rx) >= 0)) throw new RangeError("invalid rx");
    if (!((ry = +ry) >= 0)) throw new RangeError("invalid ry");
    let { data: values, width, height } = data;
    if (!((width = Math.floor(width)) >= 0)) throw new RangeError("invalid width");
    if (!((height = Math.floor(height !== void 0 ? height : values.length / width)) >= 0)) throw new RangeError("invalid height");
    if (!width || !height || !rx && !ry) return data;
    const blurx = rx && blur5(rx);
    const blury = ry && blur5(ry);
    const temp = values.slice();
    if (blurx && blury) {
      blurh(blurx, temp, values, width, height);
      blurh(blurx, values, temp, width, height);
      blurh(blurx, temp, values, width, height);
      blurv(blury, values, temp, width, height);
      blurv(blury, temp, values, width, height);
      blurv(blury, values, temp, width, height);
    } else if (blurx) {
      blurh(blurx, values, temp, width, height);
      blurh(blurx, temp, values, width, height);
      blurh(blurx, values, temp, width, height);
    } else if (blury) {
      blurv(blury, values, temp, width, height);
      blurv(blury, temp, values, width, height);
      blurv(blury, values, temp, width, height);
    }
    return data;
  };
}
function blurh(blur5, T2, S, w, h) {
  for (let y = 0, n = w * h; y < n; ) {
    blur5(T2, S, y, y += w, 1);
  }
}
function blurv(blur5, T2, S, w, h) {
  for (let x = 0, n = w * h; x < w; ++x) {
    blur5(T2, S, x, x + n, w);
  }
}
function blurfImage(radius) {
  const blur5 = blurf(radius);
  return (T2, S, start, stop, step3) => {
    start <<= 2, stop <<= 2, step3 <<= 2;
    blur5(T2, S, start + 0, stop + 0, step3);
    blur5(T2, S, start + 1, stop + 1, step3);
    blur5(T2, S, start + 2, stop + 2, step3);
    blur5(T2, S, start + 3, stop + 3, step3);
  };
}
function blurf(radius) {
  const radius0 = Math.floor(radius);
  if (radius0 === radius) return bluri(radius);
  const t = radius - radius0;
  const w = 2 * radius + 1;
  return (T2, S, start, stop, step3) => {
    if (!((stop -= step3) >= start)) return;
    let sum3 = radius0 * S[start];
    const s0 = step3 * radius0;
    const s1 = s0 + step3;
    for (let i = start, j = start + s0; i < j; i += step3) {
      sum3 += S[Math.min(stop, i)];
    }
    for (let i = start, j = stop; i <= j; i += step3) {
      sum3 += S[Math.min(stop, i + s0)];
      T2[i] = (sum3 + t * (S[Math.max(start, i - s1)] + S[Math.min(stop, i + s1)])) / w;
      sum3 -= S[Math.max(start, i - s0)];
    }
  };
}
function bluri(radius) {
  const w = 2 * radius + 1;
  return (T2, S, start, stop, step3) => {
    if (!((stop -= step3) >= start)) return;
    let sum3 = radius * S[start];
    const s = step3 * radius;
    for (let i = start, j = start + s; i < j; i += step3) {
      sum3 += S[Math.min(stop, i)];
    }
    for (let i = start, j = stop; i <= j; i += step3) {
      sum3 += S[Math.min(stop, i + s)];
      T2[i] = sum3 / w;
      sum3 -= S[Math.max(start, i - s)];
    }
  };
}

// node_modules/d3-array/src/extent.js
function extent(values, valueof) {
  let min5;
  let max5;
  if (valueof === void 0) {
    for (const value of values) {
      if (value != null) {
        if (min5 === void 0) {
          if (value >= value) min5 = max5 = value;
        } else {
          if (min5 > value) min5 = value;
          if (max5 < value) max5 = value;
        }
      }
    }
  } else {
    let index5 = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index5, values)) != null) {
        if (min5 === void 0) {
          if (value >= value) min5 = max5 = value;
        } else {
          if (min5 > value) min5 = value;
          if (max5 < value) max5 = value;
        }
      }
    }
  }
  return [min5, max5];
}

// node_modules/d3-array/src/fsum.js
var Adder = class {
  constructor() {
    this._partials = new Float64Array(32);
    this._n = 0;
  }
  add(x) {
    const p = this._partials;
    let i = 0;
    for (let j = 0; j < this._n && j < 32; j++) {
      const y = p[j], hi = x + y, lo = Math.abs(x) < Math.abs(y) ? x - (hi - y) : y - (hi - x);
      if (lo) p[i++] = lo;
      x = hi;
    }
    p[i] = x;
    this._n = i + 1;
    return this;
  }
  valueOf() {
    const p = this._partials;
    let n = this._n, x, y, lo, hi = 0;
    if (n > 0) {
      hi = p[--n];
      while (n > 0) {
        x = hi;
        y = p[--n];
        hi = x + y;
        lo = y - (hi - x);
        if (lo) break;
      }
      if (n > 0 && (lo < 0 && p[n - 1] < 0 || lo > 0 && p[n - 1] > 0)) {
        y = lo * 2;
        x = hi + y;
        if (y == x - hi) hi = x;
      }
    }
    return hi;
  }
};

// node_modules/d3-array/src/array.js
var array = Array.prototype;
var slice = array.slice;
var map = array.map;

// node_modules/d3-array/src/ticks.js
var e10 = Math.sqrt(50);
var e5 = Math.sqrt(10);
var e2 = Math.sqrt(2);
function tickSpec(start, stop, count2) {
  const step3 = (stop - start) / Math.max(0, count2), power = Math.floor(Math.log10(step3)), error = step3 / Math.pow(10, power), factor = error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1;
  let i1, i2, inc;
  if (power < 0) {
    inc = Math.pow(10, -power) / factor;
    i1 = Math.round(start * inc);
    i2 = Math.round(stop * inc);
    if (i1 / inc < start) ++i1;
    if (i2 / inc > stop) --i2;
    inc = -inc;
  } else {
    inc = Math.pow(10, power) * factor;
    i1 = Math.round(start / inc);
    i2 = Math.round(stop / inc);
    if (i1 * inc < start) ++i1;
    if (i2 * inc > stop) --i2;
  }
  if (i2 < i1 && 0.5 <= count2 && count2 < 2) return tickSpec(start, stop, count2 * 2);
  return [i1, i2, inc];
}
function ticks(start, stop, count2) {
  stop = +stop, start = +start, count2 = +count2;
  if (!(count2 > 0)) return [];
  if (start === stop) return [start];
  const reverse2 = stop < start, [i1, i2, inc] = reverse2 ? tickSpec(stop, start, count2) : tickSpec(start, stop, count2);
  if (!(i2 >= i1)) return [];
  const n = i2 - i1 + 1, ticks2 = new Array(n);
  if (reverse2) {
    if (inc < 0) for (let i = 0; i < n; ++i) ticks2[i] = (i2 - i) / -inc;
    else for (let i = 0; i < n; ++i) ticks2[i] = (i2 - i) * inc;
  } else {
    if (inc < 0) for (let i = 0; i < n; ++i) ticks2[i] = (i1 + i) / -inc;
    else for (let i = 0; i < n; ++i) ticks2[i] = (i1 + i) * inc;
  }
  return ticks2;
}
function tickIncrement(start, stop, count2) {
  stop = +stop, start = +start, count2 = +count2;
  return tickSpec(start, stop, count2)[2];
}
function tickStep(start, stop, count2) {
  stop = +stop, start = +start, count2 = +count2;
  const reverse2 = stop < start, inc = reverse2 ? tickIncrement(stop, start, count2) : tickIncrement(start, stop, count2);
  return (reverse2 ? -1 : 1) * (inc < 0 ? 1 / -inc : inc);
}

// node_modules/d3-array/src/max.js
function max(values, valueof) {
  let max5;
  if (valueof === void 0) {
    for (const value of values) {
      if (value != null && (max5 < value || max5 === void 0 && value >= value)) {
        max5 = value;
      }
    }
  } else {
    let index5 = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index5, values)) != null && (max5 < value || max5 === void 0 && value >= value)) {
        max5 = value;
      }
    }
  }
  return max5;
}

// node_modules/d3-array/src/mean.js
function mean(values, valueof) {
  let count2 = 0;
  let sum3 = 0;
  if (valueof === void 0) {
    for (let value of values) {
      if (value != null && (value = +value) >= value) {
        ++count2, sum3 += value;
      }
    }
  } else {
    let index5 = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index5, values)) != null && (value = +value) >= value) {
        ++count2, sum3 += value;
      }
    }
  }
  if (count2) return sum3 / count2;
}

// node_modules/d3-array/src/merge.js
function* flatten(arrays) {
  for (const array4 of arrays) {
    yield* array4;
  }
}
function merge(arrays) {
  return Array.from(flatten(arrays));
}

// node_modules/d3-array/src/range.js
function range(start, stop, step3) {
  start = +start, stop = +stop, step3 = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step3;
  var i = -1, n = Math.max(0, Math.ceil((stop - start) / step3)) | 0, range5 = new Array(n);
  while (++i < n) {
    range5[i] = start + i * step3;
  }
  return range5;
}

// node_modules/d3-array/src/shuffle.js
var shuffle_default = shuffler(Math.random);
function shuffler(random) {
  return function shuffle(array4, i0 = 0, i1 = array4.length) {
    let m = i1 - (i0 = +i0);
    while (m) {
      const i = random() * m-- | 0, t = array4[m + i0];
      array4[m + i0] = array4[i + i0];
      array4[i + i0] = t;
    }
    return array4;
  };
}

// node_modules/d3-array/src/sum.js
function sum(values, valueof) {
  let sum3 = 0;
  if (valueof === void 0) {
    for (let value of values) {
      if (value = +value) {
        sum3 += value;
      }
    }
  } else {
    let index5 = -1;
    for (let value of values) {
      if (value = +valueof(value, ++index5, values)) {
        sum3 += value;
      }
    }
  }
  return sum3;
}

// node_modules/d3-scale/src/init.js
function initRange(domain, range5) {
  switch (arguments.length) {
    case 0:
      break;
    case 1:
      this.range(domain);
      break;
    default:
      this.range(range5).domain(domain);
      break;
  }
  return this;
}

// node_modules/d3-scale/src/ordinal.js
var implicit = Symbol("implicit");

// node_modules/d3-color/src/define.js
function define_default(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
}
function extend(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key in definition) prototype[key] = definition[key];
  return prototype;
}

// node_modules/d3-color/src/color.js
function Color2() {
}
var darker = 0.7;
var brighter = 1 / darker;
var reI = "\\s*([+-]?\\d+)\\s*";
var reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*";
var reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*";
var reHex = /^#([0-9a-f]{3,8})$/;
var reRgbInteger = new RegExp(`^rgb\\(${reI},${reI},${reI}\\)$`);
var reRgbPercent = new RegExp(`^rgb\\(${reP},${reP},${reP}\\)$`);
var reRgbaInteger = new RegExp(`^rgba\\(${reI},${reI},${reI},${reN}\\)$`);
var reRgbaPercent = new RegExp(`^rgba\\(${reP},${reP},${reP},${reN}\\)$`);
var reHslPercent = new RegExp(`^hsl\\(${reN},${reP},${reP}\\)$`);
var reHslaPercent = new RegExp(`^hsla\\(${reN},${reP},${reP},${reN}\\)$`);
var named = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
define_default(Color2, color, {
  copy(channels) {
    return Object.assign(new this.constructor(), this, channels);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: color_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: color_formatHex,
  formatHex8: color_formatHex8,
  formatHsl: color_formatHsl,
  formatRgb: color_formatRgb,
  toString: color_formatRgb
});
function color_formatHex() {
  return this.rgb().formatHex();
}
function color_formatHex8() {
  return this.rgb().formatHex8();
}
function color_formatHsl() {
  return hslConvert(this).formatHsl();
}
function color_formatRgb() {
  return this.rgb().formatRgb();
}
function color(format2) {
  var m, l;
  format2 = (format2 + "").trim().toLowerCase();
  return (m = reHex.exec(format2)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) : l === 3 ? new Rgb(m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, (m & 15) << 4 | m & 15, 1) : l === 8 ? rgba(m >> 24 & 255, m >> 16 & 255, m >> 8 & 255, (m & 255) / 255) : l === 4 ? rgba(m >> 12 & 15 | m >> 8 & 240, m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, ((m & 15) << 4 | m & 15) / 255) : null) : (m = reRgbInteger.exec(format2)) ? new Rgb(m[1], m[2], m[3], 1) : (m = reRgbPercent.exec(format2)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) : (m = reRgbaInteger.exec(format2)) ? rgba(m[1], m[2], m[3], m[4]) : (m = reRgbaPercent.exec(format2)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) : (m = reHslPercent.exec(format2)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) : (m = reHslaPercent.exec(format2)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) : named.hasOwnProperty(format2) ? rgbn(named[format2]) : format2 === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
}
function rgbn(n) {
  return new Rgb(n >> 16 & 255, n >> 8 & 255, n & 255, 1);
}
function rgba(r, g, b, a) {
  if (a <= 0) r = g = b = NaN;
  return new Rgb(r, g, b, a);
}
function rgbConvert(o) {
  if (!(o instanceof Color2)) o = color(o);
  if (!o) return new Rgb();
  o = o.rgb();
  return new Rgb(o.r, o.g, o.b, o.opacity);
}
function rgb(r, g, b, opacity) {
  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
}
function Rgb(r, g, b, opacity) {
  this.r = +r;
  this.g = +g;
  this.b = +b;
  this.opacity = +opacity;
}
define_default(Rgb, rgb, extend(Color2, {
  brighter(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  darker(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: rgb_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: rgb_formatHex,
  formatHex8: rgb_formatHex8,
  formatRgb: rgb_formatRgb,
  toString: rgb_formatRgb
}));
function rgb_formatHex() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}`;
}
function rgb_formatHex8() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}${hex((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function rgb_formatRgb() {
  const a = clampa(this.opacity);
  return `${a === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a === 1 ? ")" : `, ${a})`}`;
}
function clampa(opacity) {
  return isNaN(opacity) ? 1 : Math.max(0, Math.min(1, opacity));
}
function clampi(value) {
  return Math.max(0, Math.min(255, Math.round(value) || 0));
}
function hex(value) {
  value = clampi(value);
  return (value < 16 ? "0" : "") + value.toString(16);
}
function hsla(h, s, l, a) {
  if (a <= 0) h = s = l = NaN;
  else if (l <= 0 || l >= 1) h = s = NaN;
  else if (s <= 0) h = NaN;
  return new Hsl(h, s, l, a);
}
function hslConvert(o) {
  if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color2)) o = color(o);
  if (!o) return new Hsl();
  if (o instanceof Hsl) return o;
  o = o.rgb();
  var r = o.r / 255, g = o.g / 255, b = o.b / 255, min5 = Math.min(r, g, b), max5 = Math.max(r, g, b), h = NaN, s = max5 - min5, l = (max5 + min5) / 2;
  if (s) {
    if (r === max5) h = (g - b) / s + (g < b) * 6;
    else if (g === max5) h = (b - r) / s + 2;
    else h = (r - g) / s + 4;
    s /= l < 0.5 ? max5 + min5 : 2 - max5 - min5;
    h *= 60;
  } else {
    s = l > 0 && l < 1 ? 0 : h;
  }
  return new Hsl(h, s, l, o.opacity);
}
function hsl(h, s, l, opacity) {
  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
}
function Hsl(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}
define_default(Hsl, hsl, extend(Color2, {
  brighter(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  darker(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  rgb() {
    var h = this.h % 360 + (this.h < 0) * 360, s = isNaN(h) || isNaN(this.s) ? 0 : this.s, l = this.l, m2 = l + (l < 0.5 ? l : 1 - l) * s, m1 = 2 * l - m2;
    return new Rgb(
      hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
      hsl2rgb(h, m1, m2),
      hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
      this.opacity
    );
  },
  clamp() {
    return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
  },
  formatHsl() {
    const a = clampa(this.opacity);
    return `${a === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a === 1 ? ")" : `, ${a})`}`;
  }
}));
function clamph(value) {
  value = (value || 0) % 360;
  return value < 0 ? value + 360 : value;
}
function clampt(value) {
  return Math.max(0, Math.min(1, value || 0));
}
function hsl2rgb(h, m1, m2) {
  return (h < 60 ? m1 + (m2 - m1) * h / 60 : h < 180 ? m2 : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60 : m1) * 255;
}

// node_modules/d3-color/src/math.js
var radians = Math.PI / 180;
var degrees = 180 / Math.PI;

// node_modules/d3-color/src/lab.js
var K = 18;
var Xn = 0.96422;
var Yn = 1;
var Zn = 0.82521;
var t0 = 4 / 29;
var t1 = 6 / 29;
var t2 = 3 * t1 * t1;
var t3 = t1 * t1 * t1;
function labConvert(o) {
  if (o instanceof Lab) return new Lab(o.l, o.a, o.b, o.opacity);
  if (o instanceof Hcl) return hcl2lab(o);
  if (!(o instanceof Rgb)) o = rgbConvert(o);
  var r = rgb2lrgb(o.r), g = rgb2lrgb(o.g), b = rgb2lrgb(o.b), y = xyz2lab((0.2225045 * r + 0.7168786 * g + 0.0606169 * b) / Yn), x, z;
  if (r === g && g === b) x = z = y;
  else {
    x = xyz2lab((0.4360747 * r + 0.3850649 * g + 0.1430804 * b) / Xn);
    z = xyz2lab((0.0139322 * r + 0.0971045 * g + 0.7141733 * b) / Zn);
  }
  return new Lab(116 * y - 16, 500 * (x - y), 200 * (y - z), o.opacity);
}
function lab(l, a, b, opacity) {
  return arguments.length === 1 ? labConvert(l) : new Lab(l, a, b, opacity == null ? 1 : opacity);
}
function Lab(l, a, b, opacity) {
  this.l = +l;
  this.a = +a;
  this.b = +b;
  this.opacity = +opacity;
}
define_default(Lab, lab, extend(Color2, {
  brighter(k) {
    return new Lab(this.l + K * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  darker(k) {
    return new Lab(this.l - K * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  rgb() {
    var y = (this.l + 16) / 116, x = isNaN(this.a) ? y : y + this.a / 500, z = isNaN(this.b) ? y : y - this.b / 200;
    x = Xn * lab2xyz(x);
    y = Yn * lab2xyz(y);
    z = Zn * lab2xyz(z);
    return new Rgb(
      lrgb2rgb(3.1338561 * x - 1.6168667 * y - 0.4906146 * z),
      lrgb2rgb(-0.9787684 * x + 1.9161415 * y + 0.033454 * z),
      lrgb2rgb(0.0719453 * x - 0.2289914 * y + 1.4052427 * z),
      this.opacity
    );
  }
}));
function xyz2lab(t) {
  return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;
}
function lab2xyz(t) {
  return t > t1 ? t * t * t : t2 * (t - t0);
}
function lrgb2rgb(x) {
  return 255 * (x <= 31308e-7 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);
}
function rgb2lrgb(x) {
  return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
}
function hclConvert(o) {
  if (o instanceof Hcl) return new Hcl(o.h, o.c, o.l, o.opacity);
  if (!(o instanceof Lab)) o = labConvert(o);
  if (o.a === 0 && o.b === 0) return new Hcl(NaN, 0 < o.l && o.l < 100 ? 0 : NaN, o.l, o.opacity);
  var h = Math.atan2(o.b, o.a) * degrees;
  return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
}
function hcl(h, c3, l, opacity) {
  return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c3, l, opacity == null ? 1 : opacity);
}
function Hcl(h, c3, l, opacity) {
  this.h = +h;
  this.c = +c3;
  this.l = +l;
  this.opacity = +opacity;
}
function hcl2lab(o) {
  if (isNaN(o.h)) return new Lab(o.l, 0, 0, o.opacity);
  var h = o.h * radians;
  return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
}
define_default(Hcl, hcl, extend(Color2, {
  brighter(k) {
    return new Hcl(this.h, this.c, this.l + K * (k == null ? 1 : k), this.opacity);
  },
  darker(k) {
    return new Hcl(this.h, this.c, this.l - K * (k == null ? 1 : k), this.opacity);
  },
  rgb() {
    return hcl2lab(this).rgb();
  }
}));

// node_modules/d3-color/src/cubehelix.js
var A = -0.14861;
var B = 1.78277;
var C = -0.29227;
var D = -0.90649;
var E = 1.97294;
var ED = E * D;
var EB = E * B;
var BC_DA = B * C - D * A;
function cubehelixConvert(o) {
  if (o instanceof Cubehelix) return new Cubehelix(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Rgb)) o = rgbConvert(o);
  var r = o.r / 255, g = o.g / 255, b = o.b / 255, l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB), bl = b - l, k = (E * (g - l) - C * bl) / D, s = Math.sqrt(k * k + bl * bl) / (E * l * (1 - l)), h = s ? Math.atan2(k, bl) * degrees - 120 : NaN;
  return new Cubehelix(h < 0 ? h + 360 : h, s, l, o.opacity);
}
function cubehelix(h, s, l, opacity) {
  return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s, l, opacity == null ? 1 : opacity);
}
function Cubehelix(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}
define_default(Cubehelix, cubehelix, extend(Color2, {
  brighter(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  darker(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  rgb() {
    var h = isNaN(this.h) ? 0 : (this.h + 120) * radians, l = +this.l, a = isNaN(this.s) ? 0 : this.s * l * (1 - l), cosh2 = Math.cos(h), sinh2 = Math.sin(h);
    return new Rgb(
      255 * (l + a * (A * cosh2 + B * sinh2)),
      255 * (l + a * (C * cosh2 + D * sinh2)),
      255 * (l + a * (E * cosh2)),
      this.opacity
    );
  }
}));

// node_modules/d3-interpolate/src/basis.js
function basis(t13, v0, v1, v2, v3) {
  var t22 = t13 * t13, t32 = t22 * t13;
  return ((1 - 3 * t13 + 3 * t22 - t32) * v0 + (4 - 6 * t22 + 3 * t32) * v1 + (1 + 3 * t13 + 3 * t22 - 3 * t32) * v2 + t32 * v3) / 6;
}
function basis_default(values) {
  var n = values.length - 1;
  return function(t) {
    var i = t <= 0 ? t = 0 : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n), v1 = values[i], v2 = values[i + 1], v0 = i > 0 ? values[i - 1] : 2 * v1 - v2, v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
}

// node_modules/d3-interpolate/src/basisClosed.js
function basisClosed_default(values) {
  var n = values.length;
  return function(t) {
    var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n), v0 = values[(i + n - 1) % n], v1 = values[i % n], v2 = values[(i + 1) % n], v3 = values[(i + 2) % n];
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
}

// node_modules/d3-interpolate/src/constant.js
var constant_default = (x) => () => x;

// node_modules/d3-interpolate/src/color.js
function linear(a, d) {
  return function(t) {
    return a + t * d;
  };
}
function exponential(a, b, y) {
  return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
    return Math.pow(a + t * b, y);
  };
}
function hue(a, b) {
  var d = b - a;
  return d ? linear(a, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : constant_default(isNaN(a) ? b : a);
}
function gamma(y) {
  return (y = +y) === 1 ? nogamma : function(a, b) {
    return b - a ? exponential(a, b, y) : constant_default(isNaN(a) ? b : a);
  };
}
function nogamma(a, b) {
  var d = b - a;
  return d ? linear(a, d) : constant_default(isNaN(a) ? b : a);
}

// node_modules/d3-interpolate/src/rgb.js
var rgb_default = function rgbGamma(y) {
  var color4 = gamma(y);
  function rgb2(start, end) {
    var r = color4((start = rgb(start)).r, (end = rgb(end)).r), g = color4(start.g, end.g), b = color4(start.b, end.b), opacity = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.r = r(t);
      start.g = g(t);
      start.b = b(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }
  rgb2.gamma = rgbGamma;
  return rgb2;
}(1);
function rgbSpline(spline) {
  return function(colors) {
    var n = colors.length, r = new Array(n), g = new Array(n), b = new Array(n), i, color4;
    for (i = 0; i < n; ++i) {
      color4 = rgb(colors[i]);
      r[i] = color4.r || 0;
      g[i] = color4.g || 0;
      b[i] = color4.b || 0;
    }
    r = spline(r);
    g = spline(g);
    b = spline(b);
    color4.opacity = 1;
    return function(t) {
      color4.r = r(t);
      color4.g = g(t);
      color4.b = b(t);
      return color4 + "";
    };
  };
}
var rgbBasis = rgbSpline(basis_default);
var rgbBasisClosed = rgbSpline(basisClosed_default);

// node_modules/d3-interpolate/src/numberArray.js
function numberArray_default(a, b) {
  if (!b) b = [];
  var n = a ? Math.min(b.length, a.length) : 0, c3 = b.slice(), i;
  return function(t) {
    for (i = 0; i < n; ++i) c3[i] = a[i] * (1 - t) + b[i] * t;
    return c3;
  };
}
function isNumberArray(x) {
  return ArrayBuffer.isView(x) && !(x instanceof DataView);
}

// node_modules/d3-interpolate/src/array.js
function array_default(a, b) {
  return (isNumberArray(b) ? numberArray_default : genericArray)(a, b);
}
function genericArray(a, b) {
  var nb = b ? b.length : 0, na = a ? Math.min(nb, a.length) : 0, x = new Array(na), c3 = new Array(nb), i;
  for (i = 0; i < na; ++i) x[i] = value_default(a[i], b[i]);
  for (; i < nb; ++i) c3[i] = b[i];
  return function(t) {
    for (i = 0; i < na; ++i) c3[i] = x[i](t);
    return c3;
  };
}

// node_modules/d3-interpolate/src/date.js
function date_default(a, b) {
  var d = /* @__PURE__ */ new Date();
  return a = +a, b = +b, function(t) {
    return d.setTime(a * (1 - t) + b * t), d;
  };
}

// node_modules/d3-interpolate/src/number.js
function number_default(a, b) {
  return a = +a, b = +b, function(t) {
    return a * (1 - t) + b * t;
  };
}

// node_modules/d3-interpolate/src/object.js
function object_default(a, b) {
  var i = {}, c3 = {}, k;
  if (a === null || typeof a !== "object") a = {};
  if (b === null || typeof b !== "object") b = {};
  for (k in b) {
    if (k in a) {
      i[k] = value_default(a[k], b[k]);
    } else {
      c3[k] = b[k];
    }
  }
  return function(t) {
    for (k in i) c3[k] = i[k](t);
    return c3;
  };
}

// node_modules/d3-interpolate/src/string.js
var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g;
var reB = new RegExp(reA.source, "g");
function zero2(b) {
  return function() {
    return b;
  };
}
function one(b) {
  return function(t) {
    return b(t) + "";
  };
}
function string_default(a, b) {
  var bi = reA.lastIndex = reB.lastIndex = 0, am, bm, bs, i = -1, s = [], q = [];
  a = a + "", b = b + "";
  while ((am = reA.exec(a)) && (bm = reB.exec(b))) {
    if ((bs = bm.index) > bi) {
      bs = b.slice(bi, bs);
      if (s[i]) s[i] += bs;
      else s[++i] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) {
      if (s[i]) s[i] += bm;
      else s[++i] = bm;
    } else {
      s[++i] = null;
      q.push({ i, x: number_default(am, bm) });
    }
    bi = reB.lastIndex;
  }
  if (bi < b.length) {
    bs = b.slice(bi);
    if (s[i]) s[i] += bs;
    else s[++i] = bs;
  }
  return s.length < 2 ? q[0] ? one(q[0].x) : zero2(b) : (b = q.length, function(t) {
    for (var i2 = 0, o; i2 < b; ++i2) s[(o = q[i2]).i] = o.x(t);
    return s.join("");
  });
}

// node_modules/d3-interpolate/src/value.js
function value_default(a, b) {
  var t = typeof b, c3;
  return b == null || t === "boolean" ? constant_default(b) : (t === "number" ? number_default : t === "string" ? (c3 = color(b)) ? (b = c3, rgb_default) : string_default : b instanceof color ? rgb_default : b instanceof Date ? date_default : isNumberArray(b) ? numberArray_default : Array.isArray(b) ? genericArray : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object_default : number_default)(a, b);
}

// node_modules/d3-interpolate/src/round.js
function round_default(a, b) {
  return a = +a, b = +b, function(t) {
    return Math.round(a * (1 - t) + b * t);
  };
}

// node_modules/d3-interpolate/src/transform/decompose.js
var degrees2 = 180 / Math.PI;
var identity2 = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};
function decompose_default(a, b, c3, d, e, f) {
  var scaleX, scaleY, skewX;
  if (scaleX = Math.sqrt(a * a + b * b)) a /= scaleX, b /= scaleX;
  if (skewX = a * c3 + b * d) c3 -= a * skewX, d -= b * skewX;
  if (scaleY = Math.sqrt(c3 * c3 + d * d)) c3 /= scaleY, d /= scaleY, skewX /= scaleY;
  if (a * d < b * c3) a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
  return {
    translateX: e,
    translateY: f,
    rotate: Math.atan2(b, a) * degrees2,
    skewX: Math.atan(skewX) * degrees2,
    scaleX,
    scaleY
  };
}

// node_modules/d3-interpolate/src/transform/parse.js
var svgNode;
function parseCss(value) {
  const m = new (typeof DOMMatrix === "function" ? DOMMatrix : WebKitCSSMatrix)(value + "");
  return m.isIdentity ? identity2 : decompose_default(m.a, m.b, m.c, m.d, m.e, m.f);
}
function parseSvg(value) {
  if (value == null) return identity2;
  if (!svgNode) svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
  svgNode.setAttribute("transform", value);
  if (!(value = svgNode.transform.baseVal.consolidate())) return identity2;
  value = value.matrix;
  return decompose_default(value.a, value.b, value.c, value.d, value.e, value.f);
}

// node_modules/d3-interpolate/src/transform/index.js
function interpolateTransform(parse2, pxComma, pxParen, degParen) {
  function pop(s) {
    return s.length ? s.pop() + " " : "";
  }
  function translate(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push("translate(", null, pxComma, null, pxParen);
      q.push({ i: i - 4, x: number_default(xa, xb) }, { i: i - 2, x: number_default(ya, yb) });
    } else if (xb || yb) {
      s.push("translate(" + xb + pxComma + yb + pxParen);
    }
  }
  function rotate3(a, b, s, q) {
    if (a !== b) {
      if (a - b > 180) b += 360;
      else if (b - a > 180) a += 360;
      q.push({ i: s.push(pop(s) + "rotate(", null, degParen) - 2, x: number_default(a, b) });
    } else if (b) {
      s.push(pop(s) + "rotate(" + b + degParen);
    }
  }
  function skewX(a, b, s, q) {
    if (a !== b) {
      q.push({ i: s.push(pop(s) + "skewX(", null, degParen) - 2, x: number_default(a, b) });
    } else if (b) {
      s.push(pop(s) + "skewX(" + b + degParen);
    }
  }
  function scale3(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push(pop(s) + "scale(", null, ",", null, ")");
      q.push({ i: i - 4, x: number_default(xa, xb) }, { i: i - 2, x: number_default(ya, yb) });
    } else if (xb !== 1 || yb !== 1) {
      s.push(pop(s) + "scale(" + xb + "," + yb + ")");
    }
  }
  return function(a, b) {
    var s = [], q = [];
    a = parse2(a), b = parse2(b);
    translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
    rotate3(a.rotate, b.rotate, s, q);
    skewX(a.skewX, b.skewX, s, q);
    scale3(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
    a = b = null;
    return function(t) {
      var i = -1, n = q.length, o;
      while (++i < n) s[(o = q[i]).i] = o.x(t);
      return s.join("");
    };
  };
}
var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");

// node_modules/d3-interpolate/src/zoom.js
var epsilon2 = 1e-12;
function cosh(x) {
  return ((x = Math.exp(x)) + 1 / x) / 2;
}
function sinh(x) {
  return ((x = Math.exp(x)) - 1 / x) / 2;
}
function tanh(x) {
  return ((x = Math.exp(2 * x)) - 1) / (x + 1);
}
var zoom_default = function zoomRho(rho, rho2, rho4) {
  function zoom(p02, p1) {
    var ux0 = p02[0], uy0 = p02[1], w02 = p02[2], ux1 = p1[0], uy1 = p1[1], w12 = p1[2], dx = ux1 - ux0, dy = uy1 - uy0, d2 = dx * dx + dy * dy, i, S;
    if (d2 < epsilon2) {
      S = Math.log(w12 / w02) / rho;
      i = function(t) {
        return [
          ux0 + t * dx,
          uy0 + t * dy,
          w02 * Math.exp(rho * t * S)
        ];
      };
    } else {
      var d1 = Math.sqrt(d2), b0 = (w12 * w12 - w02 * w02 + rho4 * d2) / (2 * w02 * rho2 * d1), b1 = (w12 * w12 - w02 * w02 - rho4 * d2) / (2 * w12 * rho2 * d1), r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0), r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
      S = (r1 - r0) / rho;
      i = function(t) {
        var s = t * S, coshr0 = cosh(r0), u4 = w02 / (rho2 * d1) * (coshr0 * tanh(rho * s + r0) - sinh(r0));
        return [
          ux0 + u4 * dx,
          uy0 + u4 * dy,
          w02 * coshr0 / cosh(rho * s + r0)
        ];
      };
    }
    i.duration = S * 1e3 * rho / Math.SQRT2;
    return i;
  }
  zoom.rho = function(_) {
    var _1 = Math.max(1e-3, +_), _2 = _1 * _1, _4 = _2 * _2;
    return zoomRho(_1, _2, _4);
  };
  return zoom;
}(Math.SQRT2, 2, 4);

// node_modules/d3-interpolate/src/hsl.js
function hsl2(hue4) {
  return function(start, end) {
    var h = hue4((start = hsl(start)).h, (end = hsl(end)).h), s = nogamma(start.s, end.s), l = nogamma(start.l, end.l), opacity = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.h = h(t);
      start.s = s(t);
      start.l = l(t);
      start.opacity = opacity(t);
      return start + "";
    };
  };
}
var hsl_default = hsl2(hue);
var hslLong = hsl2(nogamma);

// node_modules/d3-interpolate/src/hcl.js
function hcl2(hue4) {
  return function(start, end) {
    var h = hue4((start = hcl(start)).h, (end = hcl(end)).h), c3 = nogamma(start.c, end.c), l = nogamma(start.l, end.l), opacity = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.h = h(t);
      start.c = c3(t);
      start.l = l(t);
      start.opacity = opacity(t);
      return start + "";
    };
  };
}
var hcl_default = hcl2(hue);
var hclLong = hcl2(nogamma);

// node_modules/d3-interpolate/src/cubehelix.js
function cubehelix2(hue4) {
  return function cubehelixGamma(y) {
    y = +y;
    function cubehelix3(start, end) {
      var h = hue4((start = cubehelix(start)).h, (end = cubehelix(end)).h), s = nogamma(start.s, end.s), l = nogamma(start.l, end.l), opacity = nogamma(start.opacity, end.opacity);
      return function(t) {
        start.h = h(t);
        start.s = s(t);
        start.l = l(Math.pow(t, y));
        start.opacity = opacity(t);
        return start + "";
      };
    }
    cubehelix3.gamma = cubehelixGamma;
    return cubehelix3;
  }(1);
}
var cubehelix_default = cubehelix2(hue);
var cubehelixLong = cubehelix2(nogamma);

// node_modules/d3-scale/src/constant.js
function constants(x) {
  return function() {
    return x;
  };
}

// node_modules/d3-scale/src/number.js
function number2(x) {
  return +x;
}

// node_modules/d3-scale/src/continuous.js
var unit = [0, 1];
function identity3(x) {
  return x;
}
function normalize(a, b) {
  return (b -= a = +a) ? function(x) {
    return (x - a) / b;
  } : constants(isNaN(b) ? NaN : 0.5);
}
function clamper(a, b) {
  var t;
  if (a > b) t = a, a = b, b = t;
  return function(x) {
    return Math.max(a, Math.min(b, x));
  };
}
function bimap(domain, range5, interpolate) {
  var d0 = domain[0], d1 = domain[1], r0 = range5[0], r1 = range5[1];
  if (d1 < d0) d0 = normalize(d1, d0), r0 = interpolate(r1, r0);
  else d0 = normalize(d0, d1), r0 = interpolate(r0, r1);
  return function(x) {
    return r0(d0(x));
  };
}
function polymap(domain, range5, interpolate) {
  var j = Math.min(domain.length, range5.length) - 1, d = new Array(j), r = new Array(j), i = -1;
  if (domain[j] < domain[0]) {
    domain = domain.slice().reverse();
    range5 = range5.slice().reverse();
  }
  while (++i < j) {
    d[i] = normalize(domain[i], domain[i + 1]);
    r[i] = interpolate(range5[i], range5[i + 1]);
  }
  return function(x) {
    var i2 = bisect_default(domain, x, 1, j) - 1;
    return r[i2](d[i2](x));
  };
}
function copy(source, target) {
  return target.domain(source.domain()).range(source.range()).interpolate(source.interpolate()).clamp(source.clamp()).unknown(source.unknown());
}
function transformer() {
  var domain = unit, range5 = unit, interpolate = value_default, transform, untransform, unknown, clamp3 = identity3, piecewise2, output3, input;
  function rescale() {
    var n = Math.min(domain.length, range5.length);
    if (clamp3 !== identity3) clamp3 = clamper(domain[0], domain[n - 1]);
    piecewise2 = n > 2 ? polymap : bimap;
    output3 = input = null;
    return scale3;
  }
  function scale3(x) {
    return x == null || isNaN(x = +x) ? unknown : (output3 || (output3 = piecewise2(domain.map(transform), range5, interpolate)))(transform(clamp3(x)));
  }
  scale3.invert = function(y) {
    return clamp3(untransform((input || (input = piecewise2(range5, domain.map(transform), number_default)))(y)));
  };
  scale3.domain = function(_) {
    return arguments.length ? (domain = Array.from(_, number2), rescale()) : domain.slice();
  };
  scale3.range = function(_) {
    return arguments.length ? (range5 = Array.from(_), rescale()) : range5.slice();
  };
  scale3.rangeRound = function(_) {
    return range5 = Array.from(_), interpolate = round_default, rescale();
  };
  scale3.clamp = function(_) {
    return arguments.length ? (clamp3 = _ ? true : identity3, rescale()) : clamp3 !== identity3;
  };
  scale3.interpolate = function(_) {
    return arguments.length ? (interpolate = _, rescale()) : interpolate;
  };
  scale3.unknown = function(_) {
    return arguments.length ? (unknown = _, scale3) : unknown;
  };
  return function(t, u4) {
    transform = t, untransform = u4;
    return rescale();
  };
}
function continuous() {
  return transformer()(identity3, identity3);
}

// node_modules/d3-format/src/formatDecimal.js
function formatDecimal_default(x) {
  return Math.abs(x = Math.round(x)) >= 1e21 ? x.toLocaleString("en").replace(/,/g, "") : x.toString(10);
}
function formatDecimalParts(x, p) {
  if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0) return null;
  var i, coefficient = x.slice(0, i);
  return [
    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
    +x.slice(i + 1)
  ];
}

// node_modules/d3-format/src/exponent.js
function exponent_default(x) {
  return x = formatDecimalParts(Math.abs(x)), x ? x[1] : NaN;
}

// node_modules/d3-format/src/formatGroup.js
function formatGroup_default(grouping, thousands) {
  return function(value, width) {
    var i = value.length, t = [], j = 0, g = grouping[0], length3 = 0;
    while (i > 0 && g > 0) {
      if (length3 + g + 1 > width) g = Math.max(1, width - length3);
      t.push(value.substring(i -= g, i + g));
      if ((length3 += g + 1) > width) break;
      g = grouping[j = (j + 1) % grouping.length];
    }
    return t.reverse().join(thousands);
  };
}

// node_modules/d3-format/src/formatNumerals.js
function formatNumerals_default(numerals) {
  return function(value) {
    return value.replace(/[0-9]/g, function(i) {
      return numerals[+i];
    });
  };
}

// node_modules/d3-format/src/formatSpecifier.js
var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
function formatSpecifier(specifier) {
  if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);
  var match;
  return new FormatSpecifier({
    fill: match[1],
    align: match[2],
    sign: match[3],
    symbol: match[4],
    zero: match[5],
    width: match[6],
    comma: match[7],
    precision: match[8] && match[8].slice(1),
    trim: match[9],
    type: match[10]
  });
}
formatSpecifier.prototype = FormatSpecifier.prototype;
function FormatSpecifier(specifier) {
  this.fill = specifier.fill === void 0 ? " " : specifier.fill + "";
  this.align = specifier.align === void 0 ? ">" : specifier.align + "";
  this.sign = specifier.sign === void 0 ? "-" : specifier.sign + "";
  this.symbol = specifier.symbol === void 0 ? "" : specifier.symbol + "";
  this.zero = !!specifier.zero;
  this.width = specifier.width === void 0 ? void 0 : +specifier.width;
  this.comma = !!specifier.comma;
  this.precision = specifier.precision === void 0 ? void 0 : +specifier.precision;
  this.trim = !!specifier.trim;
  this.type = specifier.type === void 0 ? "" : specifier.type + "";
}
FormatSpecifier.prototype.toString = function() {
  return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
};

// node_modules/d3-format/src/formatTrim.js
function formatTrim_default(s) {
  out: for (var n = s.length, i = 1, i0 = -1, i1; i < n; ++i) {
    switch (s[i]) {
      case ".":
        i0 = i1 = i;
        break;
      case "0":
        if (i0 === 0) i0 = i;
        i1 = i;
        break;
      default:
        if (!+s[i]) break out;
        if (i0 > 0) i0 = 0;
        break;
    }
  }
  return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
}

// node_modules/d3-format/src/formatPrefixAuto.js
var prefixExponent;
function formatPrefixAuto_default(x, p) {
  var d = formatDecimalParts(x, p);
  if (!d) return x + "";
  var coefficient = d[0], exponent = d[1], i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1, n = coefficient.length;
  return i === n ? coefficient : i > n ? coefficient + new Array(i - n + 1).join("0") : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i) : "0." + new Array(1 - i).join("0") + formatDecimalParts(x, Math.max(0, p + i - 1))[0];
}

// node_modules/d3-format/src/formatRounded.js
function formatRounded_default(x, p) {
  var d = formatDecimalParts(x, p);
  if (!d) return x + "";
  var coefficient = d[0], exponent = d[1];
  return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1) : coefficient + new Array(exponent - coefficient.length + 2).join("0");
}

// node_modules/d3-format/src/formatTypes.js
var formatTypes_default = {
  "%": (x, p) => (x * 100).toFixed(p),
  "b": (x) => Math.round(x).toString(2),
  "c": (x) => x + "",
  "d": formatDecimal_default,
  "e": (x, p) => x.toExponential(p),
  "f": (x, p) => x.toFixed(p),
  "g": (x, p) => x.toPrecision(p),
  "o": (x) => Math.round(x).toString(8),
  "p": (x, p) => formatRounded_default(x * 100, p),
  "r": formatRounded_default,
  "s": formatPrefixAuto_default,
  "X": (x) => Math.round(x).toString(16).toUpperCase(),
  "x": (x) => Math.round(x).toString(16)
};

// node_modules/d3-format/src/identity.js
function identity_default(x) {
  return x;
}

// node_modules/d3-format/src/locale.js
var map3 = Array.prototype.map;
var prefixes = ["y", "z", "a", "f", "p", "n", "", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
function locale_default(locale3) {
  var group2 = locale3.grouping === void 0 || locale3.thousands === void 0 ? identity_default : formatGroup_default(map3.call(locale3.grouping, Number), locale3.thousands + ""), currencyPrefix = locale3.currency === void 0 ? "" : locale3.currency[0] + "", currencySuffix = locale3.currency === void 0 ? "" : locale3.currency[1] + "", decimal = locale3.decimal === void 0 ? "." : locale3.decimal + "", numerals = locale3.numerals === void 0 ? identity_default : formatNumerals_default(map3.call(locale3.numerals, String)), percent = locale3.percent === void 0 ? "%" : locale3.percent + "", minus = locale3.minus === void 0 ? "" : locale3.minus + "", nan = locale3.nan === void 0 ? "NaN" : locale3.nan + "";
  function newFormat(specifier) {
    specifier = formatSpecifier(specifier);
    var fill = specifier.fill, align = specifier.align, sign6 = specifier.sign, symbol = specifier.symbol, zero3 = specifier.zero, width = specifier.width, comma = specifier.comma, precision = specifier.precision, trim = specifier.trim, type = specifier.type;
    if (type === "n") comma = true, type = "g";
    else if (!formatTypes_default[type]) precision === void 0 && (precision = 12), trim = true, type = "g";
    if (zero3 || fill === "0" && align === "=") zero3 = true, fill = "0", align = "=";
    var prefix = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "", suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type) ? percent : "";
    var formatType = formatTypes_default[type], maybeSuffix = /[defgprs%]/.test(type);
    precision = precision === void 0 ? 6 : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision)) : Math.max(0, Math.min(20, precision));
    function format2(value) {
      var valuePrefix = prefix, valueSuffix = suffix, i, n, c3;
      if (type === "c") {
        valueSuffix = formatType(value) + valueSuffix;
        value = "";
      } else {
        value = +value;
        var valueNegative = value < 0 || 1 / value < 0;
        value = isNaN(value) ? nan : formatType(Math.abs(value), precision);
        if (trim) value = formatTrim_default(value);
        if (valueNegative && +value === 0 && sign6 !== "+") valueNegative = false;
        valuePrefix = (valueNegative ? sign6 === "(" ? sign6 : minus : sign6 === "-" || sign6 === "(" ? "" : sign6) + valuePrefix;
        valueSuffix = (type === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign6 === "(" ? ")" : "");
        if (maybeSuffix) {
          i = -1, n = value.length;
          while (++i < n) {
            if (c3 = value.charCodeAt(i), 48 > c3 || c3 > 57) {
              valueSuffix = (c3 === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
              value = value.slice(0, i);
              break;
            }
          }
        }
      }
      if (comma && !zero3) value = group2(value, Infinity);
      var length3 = valuePrefix.length + value.length + valueSuffix.length, padding = length3 < width ? new Array(width - length3 + 1).join(fill) : "";
      if (comma && zero3) value = group2(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";
      switch (align) {
        case "<":
          value = valuePrefix + value + valueSuffix + padding;
          break;
        case "=":
          value = valuePrefix + padding + value + valueSuffix;
          break;
        case "^":
          value = padding.slice(0, length3 = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length3);
          break;
        default:
          value = padding + valuePrefix + value + valueSuffix;
          break;
      }
      return numerals(value);
    }
    format2.toString = function() {
      return specifier + "";
    };
    return format2;
  }
  function formatPrefix2(specifier, value) {
    var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)), e = Math.max(-8, Math.min(8, Math.floor(exponent_default(value) / 3))) * 3, k = Math.pow(10, -e), prefix = prefixes[8 + e / 3];
    return function(value2) {
      return f(k * value2) + prefix;
    };
  }
  return {
    format: newFormat,
    formatPrefix: formatPrefix2
  };
}

// node_modules/d3-format/src/defaultLocale.js
var locale;
var format;
var formatPrefix;
defaultLocale({
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});
function defaultLocale(definition) {
  locale = locale_default(definition);
  format = locale.format;
  formatPrefix = locale.formatPrefix;
  return locale;
}

// node_modules/d3-format/src/precisionFixed.js
function precisionFixed_default(step3) {
  return Math.max(0, -exponent_default(Math.abs(step3)));
}

// node_modules/d3-format/src/precisionPrefix.js
function precisionPrefix_default(step3, value) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent_default(value) / 3))) * 3 - exponent_default(Math.abs(step3)));
}

// node_modules/d3-format/src/precisionRound.js
function precisionRound_default(step3, max5) {
  step3 = Math.abs(step3), max5 = Math.abs(max5) - step3;
  return Math.max(0, exponent_default(max5) - exponent_default(step3)) + 1;
}

// node_modules/d3-scale/src/tickFormat.js
function tickFormat(start, stop, count2, specifier) {
  var step3 = tickStep(start, stop, count2), precision;
  specifier = formatSpecifier(specifier == null ? ",f" : specifier);
  switch (specifier.type) {
    case "s": {
      var value = Math.max(Math.abs(start), Math.abs(stop));
      if (specifier.precision == null && !isNaN(precision = precisionPrefix_default(step3, value))) specifier.precision = precision;
      return formatPrefix(specifier, value);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      if (specifier.precision == null && !isNaN(precision = precisionRound_default(step3, Math.max(Math.abs(start), Math.abs(stop))))) specifier.precision = precision - (specifier.type === "e");
      break;
    }
    case "f":
    case "%": {
      if (specifier.precision == null && !isNaN(precision = precisionFixed_default(step3))) specifier.precision = precision - (specifier.type === "%") * 2;
      break;
    }
  }
  return format(specifier);
}

// node_modules/d3-scale/src/linear.js
function linearish(scale3) {
  var domain = scale3.domain;
  scale3.ticks = function(count2) {
    var d = domain();
    return ticks(d[0], d[d.length - 1], count2 == null ? 10 : count2);
  };
  scale3.tickFormat = function(count2, specifier) {
    var d = domain();
    return tickFormat(d[0], d[d.length - 1], count2 == null ? 10 : count2, specifier);
  };
  scale3.nice = function(count2) {
    if (count2 == null) count2 = 10;
    var d = domain();
    var i0 = 0;
    var i1 = d.length - 1;
    var start = d[i0];
    var stop = d[i1];
    var prestep;
    var step3;
    var maxIter = 10;
    if (stop < start) {
      step3 = start, start = stop, stop = step3;
      step3 = i0, i0 = i1, i1 = step3;
    }
    while (maxIter-- > 0) {
      step3 = tickIncrement(start, stop, count2);
      if (step3 === prestep) {
        d[i0] = start;
        d[i1] = stop;
        return domain(d);
      } else if (step3 > 0) {
        start = Math.floor(start / step3) * step3;
        stop = Math.ceil(stop / step3) * step3;
      } else if (step3 < 0) {
        start = Math.ceil(start * step3) / step3;
        stop = Math.floor(stop * step3) / step3;
      } else {
        break;
      }
      prestep = step3;
    }
    return scale3;
  };
  return scale3;
}
function linear2() {
  var scale3 = continuous();
  scale3.copy = function() {
    return copy(scale3, linear2());
  };
  initRange.apply(scale3, arguments);
  return linearish(scale3);
}

// node_modules/d3-scale/src/quantize.js
function quantize() {
  var x03 = 0, x12 = 1, n = 1, domain = [0.5], range5 = [0, 1], unknown;
  function scale3(x) {
    return x != null && x <= x ? range5[bisect_default(domain, x, 0, n)] : unknown;
  }
  function rescale() {
    var i = -1;
    domain = new Array(n);
    while (++i < n) domain[i] = ((i + 1) * x12 - (i - n) * x03) / (n + 1);
    return scale3;
  }
  scale3.domain = function(_) {
    return arguments.length ? ([x03, x12] = _, x03 = +x03, x12 = +x12, rescale()) : [x03, x12];
  };
  scale3.range = function(_) {
    return arguments.length ? (n = (range5 = Array.from(_)).length - 1, rescale()) : range5.slice();
  };
  scale3.invertExtent = function(y) {
    var i = range5.indexOf(y);
    return i < 0 ? [NaN, NaN] : i < 1 ? [x03, domain[0]] : i >= n ? [domain[n - 1], x12] : [domain[i - 1], domain[i]];
  };
  scale3.unknown = function(_) {
    return arguments.length ? (unknown = _, scale3) : scale3;
  };
  scale3.thresholds = function() {
    return domain.slice();
  };
  scale3.copy = function() {
    return quantize().domain([x03, x12]).range(range5).unknown(unknown);
  };
  return initRange.apply(linearish(scale3), arguments);
}

// node_modules/d3-time/src/interval.js
var t02 = /* @__PURE__ */ new Date();
var t12 = /* @__PURE__ */ new Date();
function timeInterval(floori, offseti, count2, field) {
  function interval(date) {
    return floori(date = arguments.length === 0 ? /* @__PURE__ */ new Date() : /* @__PURE__ */ new Date(+date)), date;
  }
  interval.floor = (date) => {
    return floori(date = /* @__PURE__ */ new Date(+date)), date;
  };
  interval.ceil = (date) => {
    return floori(date = new Date(date - 1)), offseti(date, 1), floori(date), date;
  };
  interval.round = (date) => {
    const d0 = interval(date), d1 = interval.ceil(date);
    return date - d0 < d1 - date ? d0 : d1;
  };
  interval.offset = (date, step3) => {
    return offseti(date = /* @__PURE__ */ new Date(+date), step3 == null ? 1 : Math.floor(step3)), date;
  };
  interval.range = (start, stop, step3) => {
    const range5 = [];
    start = interval.ceil(start);
    step3 = step3 == null ? 1 : Math.floor(step3);
    if (!(start < stop) || !(step3 > 0)) return range5;
    let previous;
    do
      range5.push(previous = /* @__PURE__ */ new Date(+start)), offseti(start, step3), floori(start);
    while (previous < start && start < stop);
    return range5;
  };
  interval.filter = (test) => {
    return timeInterval((date) => {
      if (date >= date) while (floori(date), !test(date)) date.setTime(date - 1);
    }, (date, step3) => {
      if (date >= date) {
        if (step3 < 0) while (++step3 <= 0) {
          while (offseti(date, -1), !test(date)) {
          }
        }
        else while (--step3 >= 0) {
          while (offseti(date, 1), !test(date)) {
          }
        }
      }
    });
  };
  if (count2) {
    interval.count = (start, end) => {
      t02.setTime(+start), t12.setTime(+end);
      floori(t02), floori(t12);
      return Math.floor(count2(t02, t12));
    };
    interval.every = (step3) => {
      step3 = Math.floor(step3);
      return !isFinite(step3) || !(step3 > 0) ? null : !(step3 > 1) ? interval : interval.filter(field ? (d) => field(d) % step3 === 0 : (d) => interval.count(0, d) % step3 === 0);
    };
  }
  return interval;
}

// node_modules/d3-time/src/millisecond.js
var millisecond = timeInterval(() => {
}, (date, step3) => {
  date.setTime(+date + step3);
}, (start, end) => {
  return end - start;
});
millisecond.every = (k) => {
  k = Math.floor(k);
  if (!isFinite(k) || !(k > 0)) return null;
  if (!(k > 1)) return millisecond;
  return timeInterval((date) => {
    date.setTime(Math.floor(date / k) * k);
  }, (date, step3) => {
    date.setTime(+date + step3 * k);
  }, (start, end) => {
    return (end - start) / k;
  });
};
var milliseconds = millisecond.range;

// node_modules/d3-time/src/duration.js
var durationSecond = 1e3;
var durationMinute = durationSecond * 60;
var durationHour = durationMinute * 60;
var durationDay = durationHour * 24;
var durationWeek = durationDay * 7;
var durationMonth = durationDay * 30;
var durationYear = durationDay * 365;

// node_modules/d3-time/src/second.js
var second = timeInterval((date) => {
  date.setTime(date - date.getMilliseconds());
}, (date, step3) => {
  date.setTime(+date + step3 * durationSecond);
}, (start, end) => {
  return (end - start) / durationSecond;
}, (date) => {
  return date.getUTCSeconds();
});
var seconds = second.range;

// node_modules/d3-time/src/minute.js
var timeMinute = timeInterval((date) => {
  date.setTime(date - date.getMilliseconds() - date.getSeconds() * durationSecond);
}, (date, step3) => {
  date.setTime(+date + step3 * durationMinute);
}, (start, end) => {
  return (end - start) / durationMinute;
}, (date) => {
  return date.getMinutes();
});
var timeMinutes = timeMinute.range;
var utcMinute = timeInterval((date) => {
  date.setUTCSeconds(0, 0);
}, (date, step3) => {
  date.setTime(+date + step3 * durationMinute);
}, (start, end) => {
  return (end - start) / durationMinute;
}, (date) => {
  return date.getUTCMinutes();
});
var utcMinutes = utcMinute.range;

// node_modules/d3-time/src/hour.js
var timeHour = timeInterval((date) => {
  date.setTime(date - date.getMilliseconds() - date.getSeconds() * durationSecond - date.getMinutes() * durationMinute);
}, (date, step3) => {
  date.setTime(+date + step3 * durationHour);
}, (start, end) => {
  return (end - start) / durationHour;
}, (date) => {
  return date.getHours();
});
var timeHours = timeHour.range;
var utcHour = timeInterval((date) => {
  date.setUTCMinutes(0, 0, 0);
}, (date, step3) => {
  date.setTime(+date + step3 * durationHour);
}, (start, end) => {
  return (end - start) / durationHour;
}, (date) => {
  return date.getUTCHours();
});
var utcHours = utcHour.range;

// node_modules/d3-time/src/day.js
var timeDay = timeInterval(
  (date) => date.setHours(0, 0, 0, 0),
  (date, step3) => date.setDate(date.getDate() + step3),
  (start, end) => (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationDay,
  (date) => date.getDate() - 1
);
var timeDays = timeDay.range;
var utcDay = timeInterval((date) => {
  date.setUTCHours(0, 0, 0, 0);
}, (date, step3) => {
  date.setUTCDate(date.getUTCDate() + step3);
}, (start, end) => {
  return (end - start) / durationDay;
}, (date) => {
  return date.getUTCDate() - 1;
});
var utcDays = utcDay.range;
var unixDay = timeInterval((date) => {
  date.setUTCHours(0, 0, 0, 0);
}, (date, step3) => {
  date.setUTCDate(date.getUTCDate() + step3);
}, (start, end) => {
  return (end - start) / durationDay;
}, (date) => {
  return Math.floor(date / durationDay);
});
var unixDays = unixDay.range;

// node_modules/d3-time/src/week.js
function timeWeekday(i) {
  return timeInterval((date) => {
    date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);
    date.setHours(0, 0, 0, 0);
  }, (date, step3) => {
    date.setDate(date.getDate() + step3 * 7);
  }, (start, end) => {
    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationWeek;
  });
}
var timeSunday = timeWeekday(0);
var timeMonday = timeWeekday(1);
var timeTuesday = timeWeekday(2);
var timeWednesday = timeWeekday(3);
var timeThursday = timeWeekday(4);
var timeFriday = timeWeekday(5);
var timeSaturday = timeWeekday(6);
var timeSundays = timeSunday.range;
var timeMondays = timeMonday.range;
var timeTuesdays = timeTuesday.range;
var timeWednesdays = timeWednesday.range;
var timeThursdays = timeThursday.range;
var timeFridays = timeFriday.range;
var timeSaturdays = timeSaturday.range;
function utcWeekday(i) {
  return timeInterval((date) => {
    date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);
    date.setUTCHours(0, 0, 0, 0);
  }, (date, step3) => {
    date.setUTCDate(date.getUTCDate() + step3 * 7);
  }, (start, end) => {
    return (end - start) / durationWeek;
  });
}
var utcSunday = utcWeekday(0);
var utcMonday = utcWeekday(1);
var utcTuesday = utcWeekday(2);
var utcWednesday = utcWeekday(3);
var utcThursday = utcWeekday(4);
var utcFriday = utcWeekday(5);
var utcSaturday = utcWeekday(6);
var utcSundays = utcSunday.range;
var utcMondays = utcMonday.range;
var utcTuesdays = utcTuesday.range;
var utcWednesdays = utcWednesday.range;
var utcThursdays = utcThursday.range;
var utcFridays = utcFriday.range;
var utcSaturdays = utcSaturday.range;

// node_modules/d3-time/src/month.js
var timeMonth = timeInterval((date) => {
  date.setDate(1);
  date.setHours(0, 0, 0, 0);
}, (date, step3) => {
  date.setMonth(date.getMonth() + step3);
}, (start, end) => {
  return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;
}, (date) => {
  return date.getMonth();
});
var timeMonths = timeMonth.range;
var utcMonth = timeInterval((date) => {
  date.setUTCDate(1);
  date.setUTCHours(0, 0, 0, 0);
}, (date, step3) => {
  date.setUTCMonth(date.getUTCMonth() + step3);
}, (start, end) => {
  return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;
}, (date) => {
  return date.getUTCMonth();
});
var utcMonths = utcMonth.range;

// node_modules/d3-time/src/year.js
var timeYear = timeInterval((date) => {
  date.setMonth(0, 1);
  date.setHours(0, 0, 0, 0);
}, (date, step3) => {
  date.setFullYear(date.getFullYear() + step3);
}, (start, end) => {
  return end.getFullYear() - start.getFullYear();
}, (date) => {
  return date.getFullYear();
});
timeYear.every = (k) => {
  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : timeInterval((date) => {
    date.setFullYear(Math.floor(date.getFullYear() / k) * k);
    date.setMonth(0, 1);
    date.setHours(0, 0, 0, 0);
  }, (date, step3) => {
    date.setFullYear(date.getFullYear() + step3 * k);
  });
};
var timeYears = timeYear.range;
var utcYear = timeInterval((date) => {
  date.setUTCMonth(0, 1);
  date.setUTCHours(0, 0, 0, 0);
}, (date, step3) => {
  date.setUTCFullYear(date.getUTCFullYear() + step3);
}, (start, end) => {
  return end.getUTCFullYear() - start.getUTCFullYear();
}, (date) => {
  return date.getUTCFullYear();
});
utcYear.every = (k) => {
  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : timeInterval((date) => {
    date.setUTCFullYear(Math.floor(date.getUTCFullYear() / k) * k);
    date.setUTCMonth(0, 1);
    date.setUTCHours(0, 0, 0, 0);
  }, (date, step3) => {
    date.setUTCFullYear(date.getUTCFullYear() + step3 * k);
  });
};
var utcYears = utcYear.range;

// node_modules/d3-time/src/ticks.js
function ticker(year, month, week, day, hour, minute) {
  const tickIntervals = [
    [second, 1, durationSecond],
    [second, 5, 5 * durationSecond],
    [second, 15, 15 * durationSecond],
    [second, 30, 30 * durationSecond],
    [minute, 1, durationMinute],
    [minute, 5, 5 * durationMinute],
    [minute, 15, 15 * durationMinute],
    [minute, 30, 30 * durationMinute],
    [hour, 1, durationHour],
    [hour, 3, 3 * durationHour],
    [hour, 6, 6 * durationHour],
    [hour, 12, 12 * durationHour],
    [day, 1, durationDay],
    [day, 2, 2 * durationDay],
    [week, 1, durationWeek],
    [month, 1, durationMonth],
    [month, 3, 3 * durationMonth],
    [year, 1, durationYear]
  ];
  function ticks2(start, stop, count2) {
    const reverse2 = stop < start;
    if (reverse2) [start, stop] = [stop, start];
    const interval = count2 && typeof count2.range === "function" ? count2 : tickInterval(start, stop, count2);
    const ticks3 = interval ? interval.range(start, +stop + 1) : [];
    return reverse2 ? ticks3.reverse() : ticks3;
  }
  function tickInterval(start, stop, count2) {
    const target = Math.abs(stop - start) / count2;
    const i = bisector(([, , step4]) => step4).right(tickIntervals, target);
    if (i === tickIntervals.length) return year.every(tickStep(start / durationYear, stop / durationYear, count2));
    if (i === 0) return millisecond.every(Math.max(tickStep(start, stop, count2), 1));
    const [t, step3] = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i];
    return t.every(step3);
  }
  return [ticks2, tickInterval];
}
var [utcTicks, utcTickInterval] = ticker(utcYear, utcMonth, utcSunday, unixDay, utcHour, utcMinute);
var [timeTicks, timeTickInterval] = ticker(timeYear, timeMonth, timeSunday, timeDay, timeHour, timeMinute);

// node_modules/d3-time-format/src/locale.js
function localDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
    date.setFullYear(d.y);
    return date;
  }
  return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
}
function utcDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
    date.setUTCFullYear(d.y);
    return date;
  }
  return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
}
function newDate(y, m, d) {
  return { y, m, d, H: 0, M: 0, S: 0, L: 0 };
}
function formatLocale(locale3) {
  var locale_dateTime = locale3.dateTime, locale_date = locale3.date, locale_time = locale3.time, locale_periods = locale3.periods, locale_weekdays = locale3.days, locale_shortWeekdays = locale3.shortDays, locale_months = locale3.months, locale_shortMonths = locale3.shortMonths;
  var periodRe = formatRe(locale_periods), periodLookup = formatLookup(locale_periods), weekdayRe = formatRe(locale_weekdays), weekdayLookup = formatLookup(locale_weekdays), shortWeekdayRe = formatRe(locale_shortWeekdays), shortWeekdayLookup = formatLookup(locale_shortWeekdays), monthRe = formatRe(locale_months), monthLookup = formatLookup(locale_months), shortMonthRe = formatRe(locale_shortMonths), shortMonthLookup = formatLookup(locale_shortMonths);
  var formats = {
    "a": formatShortWeekday,
    "A": formatWeekday,
    "b": formatShortMonth,
    "B": formatMonth,
    "c": null,
    "d": formatDayOfMonth,
    "e": formatDayOfMonth,
    "f": formatMicroseconds,
    "g": formatYearISO,
    "G": formatFullYearISO,
    "H": formatHour24,
    "I": formatHour12,
    "j": formatDayOfYear,
    "L": formatMilliseconds,
    "m": formatMonthNumber,
    "M": formatMinutes,
    "p": formatPeriod,
    "q": formatQuarter,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatSeconds,
    "u": formatWeekdayNumberMonday,
    "U": formatWeekNumberSunday,
    "V": formatWeekNumberISO,
    "w": formatWeekdayNumberSunday,
    "W": formatWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatYear,
    "Y": formatFullYear,
    "Z": formatZone,
    "%": formatLiteralPercent
  };
  var utcFormats = {
    "a": formatUTCShortWeekday,
    "A": formatUTCWeekday,
    "b": formatUTCShortMonth,
    "B": formatUTCMonth,
    "c": null,
    "d": formatUTCDayOfMonth,
    "e": formatUTCDayOfMonth,
    "f": formatUTCMicroseconds,
    "g": formatUTCYearISO,
    "G": formatUTCFullYearISO,
    "H": formatUTCHour24,
    "I": formatUTCHour12,
    "j": formatUTCDayOfYear,
    "L": formatUTCMilliseconds,
    "m": formatUTCMonthNumber,
    "M": formatUTCMinutes,
    "p": formatUTCPeriod,
    "q": formatUTCQuarter,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatUTCSeconds,
    "u": formatUTCWeekdayNumberMonday,
    "U": formatUTCWeekNumberSunday,
    "V": formatUTCWeekNumberISO,
    "w": formatUTCWeekdayNumberSunday,
    "W": formatUTCWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatUTCYear,
    "Y": formatUTCFullYear,
    "Z": formatUTCZone,
    "%": formatLiteralPercent
  };
  var parses = {
    "a": parseShortWeekday,
    "A": parseWeekday,
    "b": parseShortMonth,
    "B": parseMonth,
    "c": parseLocaleDateTime,
    "d": parseDayOfMonth,
    "e": parseDayOfMonth,
    "f": parseMicroseconds,
    "g": parseYear,
    "G": parseFullYear,
    "H": parseHour24,
    "I": parseHour24,
    "j": parseDayOfYear,
    "L": parseMilliseconds,
    "m": parseMonthNumber,
    "M": parseMinutes,
    "p": parsePeriod,
    "q": parseQuarter,
    "Q": parseUnixTimestamp,
    "s": parseUnixTimestampSeconds,
    "S": parseSeconds,
    "u": parseWeekdayNumberMonday,
    "U": parseWeekNumberSunday,
    "V": parseWeekNumberISO,
    "w": parseWeekdayNumberSunday,
    "W": parseWeekNumberMonday,
    "x": parseLocaleDate,
    "X": parseLocaleTime,
    "y": parseYear,
    "Y": parseFullYear,
    "Z": parseZone,
    "%": parseLiteralPercent
  };
  formats.x = newFormat(locale_date, formats);
  formats.X = newFormat(locale_time, formats);
  formats.c = newFormat(locale_dateTime, formats);
  utcFormats.x = newFormat(locale_date, utcFormats);
  utcFormats.X = newFormat(locale_time, utcFormats);
  utcFormats.c = newFormat(locale_dateTime, utcFormats);
  function newFormat(specifier, formats2) {
    return function(date) {
      var string3 = [], i = -1, j = 0, n = specifier.length, c3, pad3, format2;
      if (!(date instanceof Date)) date = /* @__PURE__ */ new Date(+date);
      while (++i < n) {
        if (specifier.charCodeAt(i) === 37) {
          string3.push(specifier.slice(j, i));
          if ((pad3 = pads[c3 = specifier.charAt(++i)]) != null) c3 = specifier.charAt(++i);
          else pad3 = c3 === "e" ? " " : "0";
          if (format2 = formats2[c3]) c3 = format2(date, pad3);
          string3.push(c3);
          j = i + 1;
        }
      }
      string3.push(specifier.slice(j, i));
      return string3.join("");
    };
  }
  function newParse(specifier, Z) {
    return function(string3) {
      var d = newDate(1900, void 0, 1), i = parseSpecifier(d, specifier, string3 += "", 0), week, day;
      if (i != string3.length) return null;
      if ("Q" in d) return new Date(d.Q);
      if ("s" in d) return new Date(d.s * 1e3 + ("L" in d ? d.L : 0));
      if (Z && !("Z" in d)) d.Z = 0;
      if ("p" in d) d.H = d.H % 12 + d.p * 12;
      if (d.m === void 0) d.m = "q" in d ? d.q : 0;
      if ("V" in d) {
        if (d.V < 1 || d.V > 53) return null;
        if (!("w" in d)) d.w = 1;
        if ("Z" in d) {
          week = utcDate(newDate(d.y, 0, 1)), day = week.getUTCDay();
          week = day > 4 || day === 0 ? utcMonday.ceil(week) : utcMonday(week);
          week = utcDay.offset(week, (d.V - 1) * 7);
          d.y = week.getUTCFullYear();
          d.m = week.getUTCMonth();
          d.d = week.getUTCDate() + (d.w + 6) % 7;
        } else {
          week = localDate(newDate(d.y, 0, 1)), day = week.getDay();
          week = day > 4 || day === 0 ? timeMonday.ceil(week) : timeMonday(week);
          week = timeDay.offset(week, (d.V - 1) * 7);
          d.y = week.getFullYear();
          d.m = week.getMonth();
          d.d = week.getDate() + (d.w + 6) % 7;
        }
      } else if ("W" in d || "U" in d) {
        if (!("w" in d)) d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0;
        day = "Z" in d ? utcDate(newDate(d.y, 0, 1)).getUTCDay() : localDate(newDate(d.y, 0, 1)).getDay();
        d.m = 0;
        d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day + 5) % 7 : d.w + d.U * 7 - (day + 6) % 7;
      }
      if ("Z" in d) {
        d.H += d.Z / 100 | 0;
        d.M += d.Z % 100;
        return utcDate(d);
      }
      return localDate(d);
    };
  }
  function parseSpecifier(d, specifier, string3, j) {
    var i = 0, n = specifier.length, m = string3.length, c3, parse2;
    while (i < n) {
      if (j >= m) return -1;
      c3 = specifier.charCodeAt(i++);
      if (c3 === 37) {
        c3 = specifier.charAt(i++);
        parse2 = parses[c3 in pads ? specifier.charAt(i++) : c3];
        if (!parse2 || (j = parse2(d, string3, j)) < 0) return -1;
      } else if (c3 != string3.charCodeAt(j++)) {
        return -1;
      }
    }
    return j;
  }
  function parsePeriod(d, string3, i) {
    var n = periodRe.exec(string3.slice(i));
    return n ? (d.p = periodLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseShortWeekday(d, string3, i) {
    var n = shortWeekdayRe.exec(string3.slice(i));
    return n ? (d.w = shortWeekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseWeekday(d, string3, i) {
    var n = weekdayRe.exec(string3.slice(i));
    return n ? (d.w = weekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseShortMonth(d, string3, i) {
    var n = shortMonthRe.exec(string3.slice(i));
    return n ? (d.m = shortMonthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseMonth(d, string3, i) {
    var n = monthRe.exec(string3.slice(i));
    return n ? (d.m = monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseLocaleDateTime(d, string3, i) {
    return parseSpecifier(d, locale_dateTime, string3, i);
  }
  function parseLocaleDate(d, string3, i) {
    return parseSpecifier(d, locale_date, string3, i);
  }
  function parseLocaleTime(d, string3, i) {
    return parseSpecifier(d, locale_time, string3, i);
  }
  function formatShortWeekday(d) {
    return locale_shortWeekdays[d.getDay()];
  }
  function formatWeekday(d) {
    return locale_weekdays[d.getDay()];
  }
  function formatShortMonth(d) {
    return locale_shortMonths[d.getMonth()];
  }
  function formatMonth(d) {
    return locale_months[d.getMonth()];
  }
  function formatPeriod(d) {
    return locale_periods[+(d.getHours() >= 12)];
  }
  function formatQuarter(d) {
    return 1 + ~~(d.getMonth() / 3);
  }
  function formatUTCShortWeekday(d) {
    return locale_shortWeekdays[d.getUTCDay()];
  }
  function formatUTCWeekday(d) {
    return locale_weekdays[d.getUTCDay()];
  }
  function formatUTCShortMonth(d) {
    return locale_shortMonths[d.getUTCMonth()];
  }
  function formatUTCMonth(d) {
    return locale_months[d.getUTCMonth()];
  }
  function formatUTCPeriod(d) {
    return locale_periods[+(d.getUTCHours() >= 12)];
  }
  function formatUTCQuarter(d) {
    return 1 + ~~(d.getUTCMonth() / 3);
  }
  return {
    format: function(specifier) {
      var f = newFormat(specifier += "", formats);
      f.toString = function() {
        return specifier;
      };
      return f;
    },
    parse: function(specifier) {
      var p = newParse(specifier += "", false);
      p.toString = function() {
        return specifier;
      };
      return p;
    },
    utcFormat: function(specifier) {
      var f = newFormat(specifier += "", utcFormats);
      f.toString = function() {
        return specifier;
      };
      return f;
    },
    utcParse: function(specifier) {
      var p = newParse(specifier += "", true);
      p.toString = function() {
        return specifier;
      };
      return p;
    }
  };
}
var pads = { "-": "", "_": " ", "0": "0" };
var numberRe = /^\s*\d+/;
var percentRe = /^%/;
var requoteRe = /[\\^$*+?|[\]().{}]/g;
function pad(value, fill, width) {
  var sign6 = value < 0 ? "-" : "", string3 = (sign6 ? -value : value) + "", length3 = string3.length;
  return sign6 + (length3 < width ? new Array(width - length3 + 1).join(fill) + string3 : string3);
}
function requote(s) {
  return s.replace(requoteRe, "\\$&");
}
function formatRe(names2) {
  return new RegExp("^(?:" + names2.map(requote).join("|") + ")", "i");
}
function formatLookup(names2) {
  return new Map(names2.map((name, i) => [name.toLowerCase(), i]));
}
function parseWeekdayNumberSunday(d, string3, i) {
  var n = numberRe.exec(string3.slice(i, i + 1));
  return n ? (d.w = +n[0], i + n[0].length) : -1;
}
function parseWeekdayNumberMonday(d, string3, i) {
  var n = numberRe.exec(string3.slice(i, i + 1));
  return n ? (d.u = +n[0], i + n[0].length) : -1;
}
function parseWeekNumberSunday(d, string3, i) {
  var n = numberRe.exec(string3.slice(i, i + 2));
  return n ? (d.U = +n[0], i + n[0].length) : -1;
}
function parseWeekNumberISO(d, string3, i) {
  var n = numberRe.exec(string3.slice(i, i + 2));
  return n ? (d.V = +n[0], i + n[0].length) : -1;
}
function parseWeekNumberMonday(d, string3, i) {
  var n = numberRe.exec(string3.slice(i, i + 2));
  return n ? (d.W = +n[0], i + n[0].length) : -1;
}
function parseFullYear(d, string3, i) {
  var n = numberRe.exec(string3.slice(i, i + 4));
  return n ? (d.y = +n[0], i + n[0].length) : -1;
}
function parseYear(d, string3, i) {
  var n = numberRe.exec(string3.slice(i, i + 2));
  return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2e3), i + n[0].length) : -1;
}
function parseZone(d, string3, i) {
  var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string3.slice(i, i + 6));
  return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
}
function parseQuarter(d, string3, i) {
  var n = numberRe.exec(string3.slice(i, i + 1));
  return n ? (d.q = n[0] * 3 - 3, i + n[0].length) : -1;
}
function parseMonthNumber(d, string3, i) {
  var n = numberRe.exec(string3.slice(i, i + 2));
  return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
}
function parseDayOfMonth(d, string3, i) {
  var n = numberRe.exec(string3.slice(i, i + 2));
  return n ? (d.d = +n[0], i + n[0].length) : -1;
}
function parseDayOfYear(d, string3, i) {
  var n = numberRe.exec(string3.slice(i, i + 3));
  return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
}
function parseHour24(d, string3, i) {
  var n = numberRe.exec(string3.slice(i, i + 2));
  return n ? (d.H = +n[0], i + n[0].length) : -1;
}
function parseMinutes(d, string3, i) {
  var n = numberRe.exec(string3.slice(i, i + 2));
  return n ? (d.M = +n[0], i + n[0].length) : -1;
}
function parseSeconds(d, string3, i) {
  var n = numberRe.exec(string3.slice(i, i + 2));
  return n ? (d.S = +n[0], i + n[0].length) : -1;
}
function parseMilliseconds(d, string3, i) {
  var n = numberRe.exec(string3.slice(i, i + 3));
  return n ? (d.L = +n[0], i + n[0].length) : -1;
}
function parseMicroseconds(d, string3, i) {
  var n = numberRe.exec(string3.slice(i, i + 6));
  return n ? (d.L = Math.floor(n[0] / 1e3), i + n[0].length) : -1;
}
function parseLiteralPercent(d, string3, i) {
  var n = percentRe.exec(string3.slice(i, i + 1));
  return n ? i + n[0].length : -1;
}
function parseUnixTimestamp(d, string3, i) {
  var n = numberRe.exec(string3.slice(i));
  return n ? (d.Q = +n[0], i + n[0].length) : -1;
}
function parseUnixTimestampSeconds(d, string3, i) {
  var n = numberRe.exec(string3.slice(i));
  return n ? (d.s = +n[0], i + n[0].length) : -1;
}
function formatDayOfMonth(d, p) {
  return pad(d.getDate(), p, 2);
}
function formatHour24(d, p) {
  return pad(d.getHours(), p, 2);
}
function formatHour12(d, p) {
  return pad(d.getHours() % 12 || 12, p, 2);
}
function formatDayOfYear(d, p) {
  return pad(1 + timeDay.count(timeYear(d), d), p, 3);
}
function formatMilliseconds(d, p) {
  return pad(d.getMilliseconds(), p, 3);
}
function formatMicroseconds(d, p) {
  return formatMilliseconds(d, p) + "000";
}
function formatMonthNumber(d, p) {
  return pad(d.getMonth() + 1, p, 2);
}
function formatMinutes(d, p) {
  return pad(d.getMinutes(), p, 2);
}
function formatSeconds(d, p) {
  return pad(d.getSeconds(), p, 2);
}
function formatWeekdayNumberMonday(d) {
  var day = d.getDay();
  return day === 0 ? 7 : day;
}
function formatWeekNumberSunday(d, p) {
  return pad(timeSunday.count(timeYear(d) - 1, d), p, 2);
}
function dISO(d) {
  var day = d.getDay();
  return day >= 4 || day === 0 ? timeThursday(d) : timeThursday.ceil(d);
}
function formatWeekNumberISO(d, p) {
  d = dISO(d);
  return pad(timeThursday.count(timeYear(d), d) + (timeYear(d).getDay() === 4), p, 2);
}
function formatWeekdayNumberSunday(d) {
  return d.getDay();
}
function formatWeekNumberMonday(d, p) {
  return pad(timeMonday.count(timeYear(d) - 1, d), p, 2);
}
function formatYear(d, p) {
  return pad(d.getFullYear() % 100, p, 2);
}
function formatYearISO(d, p) {
  d = dISO(d);
  return pad(d.getFullYear() % 100, p, 2);
}
function formatFullYear(d, p) {
  return pad(d.getFullYear() % 1e4, p, 4);
}
function formatFullYearISO(d, p) {
  var day = d.getDay();
  d = day >= 4 || day === 0 ? timeThursday(d) : timeThursday.ceil(d);
  return pad(d.getFullYear() % 1e4, p, 4);
}
function formatZone(d) {
  var z = d.getTimezoneOffset();
  return (z > 0 ? "-" : (z *= -1, "+")) + pad(z / 60 | 0, "0", 2) + pad(z % 60, "0", 2);
}
function formatUTCDayOfMonth(d, p) {
  return pad(d.getUTCDate(), p, 2);
}
function formatUTCHour24(d, p) {
  return pad(d.getUTCHours(), p, 2);
}
function formatUTCHour12(d, p) {
  return pad(d.getUTCHours() % 12 || 12, p, 2);
}
function formatUTCDayOfYear(d, p) {
  return pad(1 + utcDay.count(utcYear(d), d), p, 3);
}
function formatUTCMilliseconds(d, p) {
  return pad(d.getUTCMilliseconds(), p, 3);
}
function formatUTCMicroseconds(d, p) {
  return formatUTCMilliseconds(d, p) + "000";
}
function formatUTCMonthNumber(d, p) {
  return pad(d.getUTCMonth() + 1, p, 2);
}
function formatUTCMinutes(d, p) {
  return pad(d.getUTCMinutes(), p, 2);
}
function formatUTCSeconds(d, p) {
  return pad(d.getUTCSeconds(), p, 2);
}
function formatUTCWeekdayNumberMonday(d) {
  var dow = d.getUTCDay();
  return dow === 0 ? 7 : dow;
}
function formatUTCWeekNumberSunday(d, p) {
  return pad(utcSunday.count(utcYear(d) - 1, d), p, 2);
}
function UTCdISO(d) {
  var day = d.getUTCDay();
  return day >= 4 || day === 0 ? utcThursday(d) : utcThursday.ceil(d);
}
function formatUTCWeekNumberISO(d, p) {
  d = UTCdISO(d);
  return pad(utcThursday.count(utcYear(d), d) + (utcYear(d).getUTCDay() === 4), p, 2);
}
function formatUTCWeekdayNumberSunday(d) {
  return d.getUTCDay();
}
function formatUTCWeekNumberMonday(d, p) {
  return pad(utcMonday.count(utcYear(d) - 1, d), p, 2);
}
function formatUTCYear(d, p) {
  return pad(d.getUTCFullYear() % 100, p, 2);
}
function formatUTCYearISO(d, p) {
  d = UTCdISO(d);
  return pad(d.getUTCFullYear() % 100, p, 2);
}
function formatUTCFullYear(d, p) {
  return pad(d.getUTCFullYear() % 1e4, p, 4);
}
function formatUTCFullYearISO(d, p) {
  var day = d.getUTCDay();
  d = day >= 4 || day === 0 ? utcThursday(d) : utcThursday.ceil(d);
  return pad(d.getUTCFullYear() % 1e4, p, 4);
}
function formatUTCZone() {
  return "+0000";
}
function formatLiteralPercent() {
  return "%";
}
function formatUnixTimestamp(d) {
  return +d;
}
function formatUnixTimestampSeconds(d) {
  return Math.floor(+d / 1e3);
}

// node_modules/d3-time-format/src/defaultLocale.js
var locale2;
var timeFormat;
var timeParse;
var utcFormat;
var utcParse;
defaultLocale2({
  dateTime: "%x, %X",
  date: "%-m/%-d/%Y",
  time: "%-I:%M:%S %p",
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});
function defaultLocale2(definition) {
  locale2 = formatLocale(definition);
  timeFormat = locale2.format;
  timeParse = locale2.parse;
  utcFormat = locale2.utcFormat;
  utcParse = locale2.utcParse;
  return locale2;
}

// node_modules/d3-time-format/src/isoFormat.js
var isoSpecifier = "%Y-%m-%dT%H:%M:%S.%LZ";
function formatIsoNative(date) {
  return date.toISOString();
}
var formatIso = Date.prototype.toISOString ? formatIsoNative : utcFormat(isoSpecifier);

// node_modules/d3-time-format/src/isoParse.js
function parseIsoNative(string3) {
  var date = new Date(string3);
  return isNaN(date) ? null : date;
}
var parseIso = +/* @__PURE__ */ new Date("2000-01-01T00:00:00.000Z") ? parseIsoNative : utcParse(isoSpecifier);

// node_modules/d3-geo/src/math.js
var epsilon = 1e-6;
var epsilon22 = 1e-12;
var pi = Math.PI;
var halfPi = pi / 2;
var quarterPi = pi / 4;
var tau = pi * 2;
var degrees3 = 180 / pi;
var radians2 = pi / 180;
var abs = Math.abs;
var atan = Math.atan;
var atan2 = Math.atan2;
var cos = Math.cos;
var ceil = Math.ceil;
var exp = Math.exp;
var hypot = Math.hypot;
var log2 = Math.log;
var sin = Math.sin;
var sign = Math.sign || function(x) {
  return x > 0 ? 1 : x < 0 ? -1 : 0;
};
var sqrt2 = Math.sqrt;
var tan = Math.tan;
function acos(x) {
  return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);
}
function asin(x) {
  return x > 1 ? halfPi : x < -1 ? -halfPi : Math.asin(x);
}
function haversin(x) {
  return (x = sin(x / 2)) * x;
}

// node_modules/d3-geo/src/noop.js
function noop() {
}

// node_modules/d3-geo/src/stream.js
function streamGeometry(geometry, stream) {
  if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {
    streamGeometryType[geometry.type](geometry, stream);
  }
}
var streamObjectType = {
  Feature: function(object2, stream) {
    streamGeometry(object2.geometry, stream);
  },
  FeatureCollection: function(object2, stream) {
    var features = object2.features, i = -1, n = features.length;
    while (++i < n) streamGeometry(features[i].geometry, stream);
  }
};
var streamGeometryType = {
  Sphere: function(object2, stream) {
    stream.sphere();
  },
  Point: function(object2, stream) {
    object2 = object2.coordinates;
    stream.point(object2[0], object2[1], object2[2]);
  },
  MultiPoint: function(object2, stream) {
    var coordinates2 = object2.coordinates, i = -1, n = coordinates2.length;
    while (++i < n) object2 = coordinates2[i], stream.point(object2[0], object2[1], object2[2]);
  },
  LineString: function(object2, stream) {
    streamLine(object2.coordinates, stream, 0);
  },
  MultiLineString: function(object2, stream) {
    var coordinates2 = object2.coordinates, i = -1, n = coordinates2.length;
    while (++i < n) streamLine(coordinates2[i], stream, 0);
  },
  Polygon: function(object2, stream) {
    streamPolygon(object2.coordinates, stream);
  },
  MultiPolygon: function(object2, stream) {
    var coordinates2 = object2.coordinates, i = -1, n = coordinates2.length;
    while (++i < n) streamPolygon(coordinates2[i], stream);
  },
  GeometryCollection: function(object2, stream) {
    var geometries = object2.geometries, i = -1, n = geometries.length;
    while (++i < n) streamGeometry(geometries[i], stream);
  }
};
function streamLine(coordinates2, stream, closed) {
  var i = -1, n = coordinates2.length - closed, coordinate;
  stream.lineStart();
  while (++i < n) coordinate = coordinates2[i], stream.point(coordinate[0], coordinate[1], coordinate[2]);
  stream.lineEnd();
}
function streamPolygon(coordinates2, stream) {
  var i = -1, n = coordinates2.length;
  stream.polygonStart();
  while (++i < n) streamLine(coordinates2[i], stream, 1);
  stream.polygonEnd();
}
function stream_default(object2, stream) {
  if (object2 && streamObjectType.hasOwnProperty(object2.type)) {
    streamObjectType[object2.type](object2, stream);
  } else {
    streamGeometry(object2, stream);
  }
}

// node_modules/d3-geo/src/area.js
var areaRingSum = new Adder();
var areaSum = new Adder();
var lambda00;
var phi00;
var lambda0;
var cosPhi0;
var sinPhi0;
var areaStream = {
  point: noop,
  lineStart: noop,
  lineEnd: noop,
  polygonStart: function() {
    areaRingSum = new Adder();
    areaStream.lineStart = areaRingStart;
    areaStream.lineEnd = areaRingEnd;
  },
  polygonEnd: function() {
    var areaRing = +areaRingSum;
    areaSum.add(areaRing < 0 ? tau + areaRing : areaRing);
    this.lineStart = this.lineEnd = this.point = noop;
  },
  sphere: function() {
    areaSum.add(tau);
  }
};
function areaRingStart() {
  areaStream.point = areaPointFirst;
}
function areaRingEnd() {
  areaPoint(lambda00, phi00);
}
function areaPointFirst(lambda, phi) {
  areaStream.point = areaPoint;
  lambda00 = lambda, phi00 = phi;
  lambda *= radians2, phi *= radians2;
  lambda0 = lambda, cosPhi0 = cos(phi = phi / 2 + quarterPi), sinPhi0 = sin(phi);
}
function areaPoint(lambda, phi) {
  lambda *= radians2, phi *= radians2;
  phi = phi / 2 + quarterPi;
  var dLambda = lambda - lambda0, sdLambda = dLambda >= 0 ? 1 : -1, adLambda = sdLambda * dLambda, cosPhi = cos(phi), sinPhi = sin(phi), k = sinPhi0 * sinPhi, u4 = cosPhi0 * cosPhi + k * cos(adLambda), v2 = k * sdLambda * sin(adLambda);
  areaRingSum.add(atan2(v2, u4));
  lambda0 = lambda, cosPhi0 = cosPhi, sinPhi0 = sinPhi;
}

// node_modules/d3-geo/src/cartesian.js
function spherical(cartesian3) {
  return [atan2(cartesian3[1], cartesian3[0]), asin(cartesian3[2])];
}
function cartesian(spherical3) {
  var lambda = spherical3[0], phi = spherical3[1], cosPhi = cos(phi);
  return [cosPhi * cos(lambda), cosPhi * sin(lambda), sin(phi)];
}
function cartesianDot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}
function cartesianCross(a, b) {
  return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];
}
function cartesianAddInPlace(a, b) {
  a[0] += b[0], a[1] += b[1], a[2] += b[2];
}
function cartesianScale(vector, k) {
  return [vector[0] * k, vector[1] * k, vector[2] * k];
}
function cartesianNormalizeInPlace(d) {
  var l = sqrt2(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
  d[0] /= l, d[1] /= l, d[2] /= l;
}

// node_modules/d3-geo/src/bounds.js
var lambda02;
var phi0;
var lambda1;
var phi1;
var lambda2;
var lambda002;
var phi002;
var p0;
var deltaSum;
var ranges;
var range2;
var boundsStream = {
  point: boundsPoint,
  lineStart: boundsLineStart,
  lineEnd: boundsLineEnd,
  polygonStart: function() {
    boundsStream.point = boundsRingPoint;
    boundsStream.lineStart = boundsRingStart;
    boundsStream.lineEnd = boundsRingEnd;
    deltaSum = new Adder();
    areaStream.polygonStart();
  },
  polygonEnd: function() {
    areaStream.polygonEnd();
    boundsStream.point = boundsPoint;
    boundsStream.lineStart = boundsLineStart;
    boundsStream.lineEnd = boundsLineEnd;
    if (areaRingSum < 0) lambda02 = -(lambda1 = 180), phi0 = -(phi1 = 90);
    else if (deltaSum > epsilon) phi1 = 90;
    else if (deltaSum < -epsilon) phi0 = -90;
    range2[0] = lambda02, range2[1] = lambda1;
  },
  sphere: function() {
    lambda02 = -(lambda1 = 180), phi0 = -(phi1 = 90);
  }
};
function boundsPoint(lambda, phi) {
  ranges.push(range2 = [lambda02 = lambda, lambda1 = lambda]);
  if (phi < phi0) phi0 = phi;
  if (phi > phi1) phi1 = phi;
}
function linePoint(lambda, phi) {
  var p = cartesian([lambda * radians2, phi * radians2]);
  if (p0) {
    var normal2 = cartesianCross(p0, p), equatorial = [normal2[1], -normal2[0], 0], inflection = cartesianCross(equatorial, normal2);
    cartesianNormalizeInPlace(inflection);
    inflection = spherical(inflection);
    var delta = lambda - lambda2, sign6 = delta > 0 ? 1 : -1, lambdai = inflection[0] * degrees3 * sign6, phii, antimeridian = abs(delta) > 180;
    if (antimeridian ^ (sign6 * lambda2 < lambdai && lambdai < sign6 * lambda)) {
      phii = inflection[1] * degrees3;
      if (phii > phi1) phi1 = phii;
    } else if (lambdai = (lambdai + 360) % 360 - 180, antimeridian ^ (sign6 * lambda2 < lambdai && lambdai < sign6 * lambda)) {
      phii = -inflection[1] * degrees3;
      if (phii < phi0) phi0 = phii;
    } else {
      if (phi < phi0) phi0 = phi;
      if (phi > phi1) phi1 = phi;
    }
    if (antimeridian) {
      if (lambda < lambda2) {
        if (angle(lambda02, lambda) > angle(lambda02, lambda1)) lambda1 = lambda;
      } else {
        if (angle(lambda, lambda1) > angle(lambda02, lambda1)) lambda02 = lambda;
      }
    } else {
      if (lambda1 >= lambda02) {
        if (lambda < lambda02) lambda02 = lambda;
        if (lambda > lambda1) lambda1 = lambda;
      } else {
        if (lambda > lambda2) {
          if (angle(lambda02, lambda) > angle(lambda02, lambda1)) lambda1 = lambda;
        } else {
          if (angle(lambda, lambda1) > angle(lambda02, lambda1)) lambda02 = lambda;
        }
      }
    }
  } else {
    ranges.push(range2 = [lambda02 = lambda, lambda1 = lambda]);
  }
  if (phi < phi0) phi0 = phi;
  if (phi > phi1) phi1 = phi;
  p0 = p, lambda2 = lambda;
}
function boundsLineStart() {
  boundsStream.point = linePoint;
}
function boundsLineEnd() {
  range2[0] = lambda02, range2[1] = lambda1;
  boundsStream.point = boundsPoint;
  p0 = null;
}
function boundsRingPoint(lambda, phi) {
  if (p0) {
    var delta = lambda - lambda2;
    deltaSum.add(abs(delta) > 180 ? delta + (delta > 0 ? 360 : -360) : delta);
  } else {
    lambda002 = lambda, phi002 = phi;
  }
  areaStream.point(lambda, phi);
  linePoint(lambda, phi);
}
function boundsRingStart() {
  areaStream.lineStart();
}
function boundsRingEnd() {
  boundsRingPoint(lambda002, phi002);
  areaStream.lineEnd();
  if (abs(deltaSum) > epsilon) lambda02 = -(lambda1 = 180);
  range2[0] = lambda02, range2[1] = lambda1;
  p0 = null;
}
function angle(lambda04, lambda12) {
  return (lambda12 -= lambda04) < 0 ? lambda12 + 360 : lambda12;
}
function rangeCompare(a, b) {
  return a[0] - b[0];
}
function rangeContains(range5, x) {
  return range5[0] <= range5[1] ? range5[0] <= x && x <= range5[1] : x < range5[0] || range5[1] < x;
}
function bounds_default(feature) {
  var i, n, a, b, merged, deltaMax, delta;
  phi1 = lambda1 = -(lambda02 = phi0 = Infinity);
  ranges = [];
  stream_default(feature, boundsStream);
  if (n = ranges.length) {
    ranges.sort(rangeCompare);
    for (i = 1, a = ranges[0], merged = [a]; i < n; ++i) {
      b = ranges[i];
      if (rangeContains(a, b[0]) || rangeContains(a, b[1])) {
        if (angle(a[0], b[1]) > angle(a[0], a[1])) a[1] = b[1];
        if (angle(b[0], a[1]) > angle(a[0], a[1])) a[0] = b[0];
      } else {
        merged.push(a = b);
      }
    }
    for (deltaMax = -Infinity, n = merged.length - 1, i = 0, a = merged[n]; i <= n; a = b, ++i) {
      b = merged[i];
      if ((delta = angle(a[1], b[0])) > deltaMax) deltaMax = delta, lambda02 = b[0], lambda1 = a[1];
    }
  }
  ranges = range2 = null;
  return lambda02 === Infinity || phi0 === Infinity ? [[NaN, NaN], [NaN, NaN]] : [[lambda02, phi0], [lambda1, phi1]];
}

// node_modules/d3-geo/src/centroid.js
var W0;
var W1;
var X0;
var Y0;
var Z0;
var X1;
var Y1;
var Z1;
var X2;
var Y2;
var Z2;
var lambda003;
var phi003;
var x0;
var y0;
var z0;
var centroidStream = {
  sphere: noop,
  point: centroidPoint,
  lineStart: centroidLineStart,
  lineEnd: centroidLineEnd,
  polygonStart: function() {
    centroidStream.lineStart = centroidRingStart;
    centroidStream.lineEnd = centroidRingEnd;
  },
  polygonEnd: function() {
    centroidStream.lineStart = centroidLineStart;
    centroidStream.lineEnd = centroidLineEnd;
  }
};
function centroidPoint(lambda, phi) {
  lambda *= radians2, phi *= radians2;
  var cosPhi = cos(phi);
  centroidPointCartesian(cosPhi * cos(lambda), cosPhi * sin(lambda), sin(phi));
}
function centroidPointCartesian(x, y, z) {
  ++W0;
  X0 += (x - X0) / W0;
  Y0 += (y - Y0) / W0;
  Z0 += (z - Z0) / W0;
}
function centroidLineStart() {
  centroidStream.point = centroidLinePointFirst;
}
function centroidLinePointFirst(lambda, phi) {
  lambda *= radians2, phi *= radians2;
  var cosPhi = cos(phi);
  x0 = cosPhi * cos(lambda);
  y0 = cosPhi * sin(lambda);
  z0 = sin(phi);
  centroidStream.point = centroidLinePoint;
  centroidPointCartesian(x0, y0, z0);
}
function centroidLinePoint(lambda, phi) {
  lambda *= radians2, phi *= radians2;
  var cosPhi = cos(phi), x = cosPhi * cos(lambda), y = cosPhi * sin(lambda), z = sin(phi), w = atan2(sqrt2((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);
  W1 += w;
  X1 += w * (x0 + (x0 = x));
  Y1 += w * (y0 + (y0 = y));
  Z1 += w * (z0 + (z0 = z));
  centroidPointCartesian(x0, y0, z0);
}
function centroidLineEnd() {
  centroidStream.point = centroidPoint;
}
function centroidRingStart() {
  centroidStream.point = centroidRingPointFirst;
}
function centroidRingEnd() {
  centroidRingPoint(lambda003, phi003);
  centroidStream.point = centroidPoint;
}
function centroidRingPointFirst(lambda, phi) {
  lambda003 = lambda, phi003 = phi;
  lambda *= radians2, phi *= radians2;
  centroidStream.point = centroidRingPoint;
  var cosPhi = cos(phi);
  x0 = cosPhi * cos(lambda);
  y0 = cosPhi * sin(lambda);
  z0 = sin(phi);
  centroidPointCartesian(x0, y0, z0);
}
function centroidRingPoint(lambda, phi) {
  lambda *= radians2, phi *= radians2;
  var cosPhi = cos(phi), x = cosPhi * cos(lambda), y = cosPhi * sin(lambda), z = sin(phi), cx = y0 * z - z0 * y, cy = z0 * x - x0 * z, cz = x0 * y - y0 * x, m = hypot(cx, cy, cz), w = asin(m), v2 = m && -w / m;
  X2.add(v2 * cx);
  Y2.add(v2 * cy);
  Z2.add(v2 * cz);
  W1 += w;
  X1 += w * (x0 + (x0 = x));
  Y1 += w * (y0 + (y0 = y));
  Z1 += w * (z0 + (z0 = z));
  centroidPointCartesian(x0, y0, z0);
}
function centroid_default(object2) {
  W0 = W1 = X0 = Y0 = Z0 = X1 = Y1 = Z1 = 0;
  X2 = new Adder();
  Y2 = new Adder();
  Z2 = new Adder();
  stream_default(object2, centroidStream);
  var x = +X2, y = +Y2, z = +Z2, m = hypot(x, y, z);
  if (m < epsilon22) {
    x = X1, y = Y1, z = Z1;
    if (W1 < epsilon) x = X0, y = Y0, z = Z0;
    m = hypot(x, y, z);
    if (m < epsilon22) return [NaN, NaN];
  }
  return [atan2(y, x) * degrees3, asin(z / m) * degrees3];
}

// node_modules/d3-geo/src/compose.js
function compose_default(a, b) {
  function compose(x, y) {
    return x = a(x, y), b(x[0], x[1]);
  }
  if (a.invert && b.invert) compose.invert = function(x, y) {
    return x = b.invert(x, y), x && a.invert(x[0], x[1]);
  };
  return compose;
}

// node_modules/d3-geo/src/rotation.js
function rotationIdentity(lambda, phi) {
  if (abs(lambda) > pi) lambda -= Math.round(lambda / tau) * tau;
  return [lambda, phi];
}
rotationIdentity.invert = rotationIdentity;
function rotateRadians(deltaLambda, deltaPhi, deltaGamma) {
  return (deltaLambda %= tau) ? deltaPhi || deltaGamma ? compose_default(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma)) : rotationLambda(deltaLambda) : deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma) : rotationIdentity;
}
function forwardRotationLambda(deltaLambda) {
  return function(lambda, phi) {
    lambda += deltaLambda;
    if (abs(lambda) > pi) lambda -= Math.round(lambda / tau) * tau;
    return [lambda, phi];
  };
}
function rotationLambda(deltaLambda) {
  var rotation = forwardRotationLambda(deltaLambda);
  rotation.invert = forwardRotationLambda(-deltaLambda);
  return rotation;
}
function rotationPhiGamma(deltaPhi, deltaGamma) {
  var cosDeltaPhi = cos(deltaPhi), sinDeltaPhi = sin(deltaPhi), cosDeltaGamma = cos(deltaGamma), sinDeltaGamma = sin(deltaGamma);
  function rotation(lambda, phi) {
    var cosPhi = cos(phi), x = cos(lambda) * cosPhi, y = sin(lambda) * cosPhi, z = sin(phi), k = z * cosDeltaPhi + x * sinDeltaPhi;
    return [
      atan2(y * cosDeltaGamma - k * sinDeltaGamma, x * cosDeltaPhi - z * sinDeltaPhi),
      asin(k * cosDeltaGamma + y * sinDeltaGamma)
    ];
  }
  rotation.invert = function(lambda, phi) {
    var cosPhi = cos(phi), x = cos(lambda) * cosPhi, y = sin(lambda) * cosPhi, z = sin(phi), k = z * cosDeltaGamma - y * sinDeltaGamma;
    return [
      atan2(y * cosDeltaGamma + z * sinDeltaGamma, x * cosDeltaPhi + k * sinDeltaPhi),
      asin(k * cosDeltaPhi - x * sinDeltaPhi)
    ];
  };
  return rotation;
}
function rotation_default(rotate3) {
  rotate3 = rotateRadians(rotate3[0] * radians2, rotate3[1] * radians2, rotate3.length > 2 ? rotate3[2] * radians2 : 0);
  function forward(coordinates2) {
    coordinates2 = rotate3(coordinates2[0] * radians2, coordinates2[1] * radians2);
    return coordinates2[0] *= degrees3, coordinates2[1] *= degrees3, coordinates2;
  }
  forward.invert = function(coordinates2) {
    coordinates2 = rotate3.invert(coordinates2[0] * radians2, coordinates2[1] * radians2);
    return coordinates2[0] *= degrees3, coordinates2[1] *= degrees3, coordinates2;
  };
  return forward;
}

// node_modules/d3-geo/src/circle.js
function circleStream(stream, radius, delta, direction, t03, t13) {
  if (!delta) return;
  var cosRadius = cos(radius), sinRadius = sin(radius), step3 = direction * delta;
  if (t03 == null) {
    t03 = radius + direction * tau;
    t13 = radius - step3 / 2;
  } else {
    t03 = circleRadius(cosRadius, t03);
    t13 = circleRadius(cosRadius, t13);
    if (direction > 0 ? t03 < t13 : t03 > t13) t03 += direction * tau;
  }
  for (var point2, t = t03; direction > 0 ? t > t13 : t < t13; t -= step3) {
    point2 = spherical([cosRadius, -sinRadius * cos(t), -sinRadius * sin(t)]);
    stream.point(point2[0], point2[1]);
  }
}
function circleRadius(cosRadius, point2) {
  point2 = cartesian(point2), point2[0] -= cosRadius;
  cartesianNormalizeInPlace(point2);
  var radius = acos(-point2[1]);
  return ((-point2[2] < 0 ? -radius : radius) + tau - epsilon) % tau;
}

// node_modules/d3-geo/src/clip/buffer.js
function buffer_default() {
  var lines = [], line;
  return {
    point: function(x, y, m) {
      line.push([x, y, m]);
    },
    lineStart: function() {
      lines.push(line = []);
    },
    lineEnd: noop,
    rejoin: function() {
      if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));
    },
    result: function() {
      var result = lines;
      lines = [];
      line = null;
      return result;
    }
  };
}

// node_modules/d3-geo/src/pointEqual.js
function pointEqual_default(a, b) {
  return abs(a[0] - b[0]) < epsilon && abs(a[1] - b[1]) < epsilon;
}

// node_modules/d3-geo/src/clip/rejoin.js
function Intersection(point2, points, other, entry) {
  this.x = point2;
  this.z = points;
  this.o = other;
  this.e = entry;
  this.v = false;
  this.n = this.p = null;
}
function rejoin_default(segments, compareIntersection2, startInside, interpolate, stream) {
  var subject = [], clip = [], i, n;
  segments.forEach(function(segment) {
    if ((n2 = segment.length - 1) <= 0) return;
    var n2, p02 = segment[0], p1 = segment[n2], x;
    if (pointEqual_default(p02, p1)) {
      if (!p02[2] && !p1[2]) {
        stream.lineStart();
        for (i = 0; i < n2; ++i) stream.point((p02 = segment[i])[0], p02[1]);
        stream.lineEnd();
        return;
      }
      p1[0] += 2 * epsilon;
    }
    subject.push(x = new Intersection(p02, segment, null, true));
    clip.push(x.o = new Intersection(p02, null, x, false));
    subject.push(x = new Intersection(p1, segment, null, false));
    clip.push(x.o = new Intersection(p1, null, x, true));
  });
  if (!subject.length) return;
  clip.sort(compareIntersection2);
  link(subject);
  link(clip);
  for (i = 0, n = clip.length; i < n; ++i) {
    clip[i].e = startInside = !startInside;
  }
  var start = subject[0], points, point2;
  while (1) {
    var current = start, isSubject = true;
    while (current.v) if ((current = current.n) === start) return;
    points = current.z;
    stream.lineStart();
    do {
      current.v = current.o.v = true;
      if (current.e) {
        if (isSubject) {
          for (i = 0, n = points.length; i < n; ++i) stream.point((point2 = points[i])[0], point2[1]);
        } else {
          interpolate(current.x, current.n.x, 1, stream);
        }
        current = current.n;
      } else {
        if (isSubject) {
          points = current.p.z;
          for (i = points.length - 1; i >= 0; --i) stream.point((point2 = points[i])[0], point2[1]);
        } else {
          interpolate(current.x, current.p.x, -1, stream);
        }
        current = current.p;
      }
      current = current.o;
      points = current.z;
      isSubject = !isSubject;
    } while (!current.v);
    stream.lineEnd();
  }
}
function link(array4) {
  if (!(n = array4.length)) return;
  var n, i = 0, a = array4[0], b;
  while (++i < n) {
    a.n = b = array4[i];
    b.p = a;
    a = b;
  }
  a.n = b = array4[0];
  b.p = a;
}

// node_modules/d3-geo/src/polygonContains.js
function longitude(point2) {
  return abs(point2[0]) <= pi ? point2[0] : sign(point2[0]) * ((abs(point2[0]) + pi) % tau - pi);
}
function polygonContains_default(polygon, point2) {
  var lambda = longitude(point2), phi = point2[1], sinPhi = sin(phi), normal2 = [sin(lambda), -cos(lambda), 0], angle2 = 0, winding = 0;
  var sum3 = new Adder();
  if (sinPhi === 1) phi = halfPi + epsilon;
  else if (sinPhi === -1) phi = -halfPi - epsilon;
  for (var i = 0, n = polygon.length; i < n; ++i) {
    if (!(m = (ring = polygon[i]).length)) continue;
    var ring, m, point0 = ring[m - 1], lambda04 = longitude(point0), phi02 = point0[1] / 2 + quarterPi, sinPhi03 = sin(phi02), cosPhi03 = cos(phi02);
    for (var j = 0; j < m; ++j, lambda04 = lambda12, sinPhi03 = sinPhi1, cosPhi03 = cosPhi1, point0 = point1) {
      var point1 = ring[j], lambda12 = longitude(point1), phi12 = point1[1] / 2 + quarterPi, sinPhi1 = sin(phi12), cosPhi1 = cos(phi12), delta = lambda12 - lambda04, sign6 = delta >= 0 ? 1 : -1, absDelta = sign6 * delta, antimeridian = absDelta > pi, k = sinPhi03 * sinPhi1;
      sum3.add(atan2(k * sign6 * sin(absDelta), cosPhi03 * cosPhi1 + k * cos(absDelta)));
      angle2 += antimeridian ? delta + sign6 * tau : delta;
      if (antimeridian ^ lambda04 >= lambda ^ lambda12 >= lambda) {
        var arc = cartesianCross(cartesian(point0), cartesian(point1));
        cartesianNormalizeInPlace(arc);
        var intersection2 = cartesianCross(normal2, arc);
        cartesianNormalizeInPlace(intersection2);
        var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * asin(intersection2[2]);
        if (phi > phiArc || phi === phiArc && (arc[0] || arc[1])) {
          winding += antimeridian ^ delta >= 0 ? 1 : -1;
        }
      }
    }
  }
  return (angle2 < -epsilon || angle2 < epsilon && sum3 < -epsilon22) ^ winding & 1;
}

// node_modules/d3-geo/src/clip/index.js
function clip_default(pointVisible, clipLine, interpolate, start) {
  return function(sink) {
    var line = clipLine(sink), ringBuffer = buffer_default(), ringSink = clipLine(ringBuffer), polygonStarted = false, polygon, segments, ring;
    var clip = {
      point: point2,
      lineStart,
      lineEnd,
      polygonStart: function() {
        clip.point = pointRing;
        clip.lineStart = ringStart;
        clip.lineEnd = ringEnd;
        segments = [];
        polygon = [];
      },
      polygonEnd: function() {
        clip.point = point2;
        clip.lineStart = lineStart;
        clip.lineEnd = lineEnd;
        segments = merge(segments);
        var startInside = polygonContains_default(polygon, start);
        if (segments.length) {
          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
          rejoin_default(segments, compareIntersection, startInside, interpolate, sink);
        } else if (startInside) {
          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
          sink.lineStart();
          interpolate(null, null, 1, sink);
          sink.lineEnd();
        }
        if (polygonStarted) sink.polygonEnd(), polygonStarted = false;
        segments = polygon = null;
      },
      sphere: function() {
        sink.polygonStart();
        sink.lineStart();
        interpolate(null, null, 1, sink);
        sink.lineEnd();
        sink.polygonEnd();
      }
    };
    function point2(lambda, phi) {
      if (pointVisible(lambda, phi)) sink.point(lambda, phi);
    }
    function pointLine(lambda, phi) {
      line.point(lambda, phi);
    }
    function lineStart() {
      clip.point = pointLine;
      line.lineStart();
    }
    function lineEnd() {
      clip.point = point2;
      line.lineEnd();
    }
    function pointRing(lambda, phi) {
      ring.push([lambda, phi]);
      ringSink.point(lambda, phi);
    }
    function ringStart() {
      ringSink.lineStart();
      ring = [];
    }
    function ringEnd() {
      pointRing(ring[0][0], ring[0][1]);
      ringSink.lineEnd();
      var clean = ringSink.clean(), ringSegments = ringBuffer.result(), i, n = ringSegments.length, m, segment, point3;
      ring.pop();
      polygon.push(ring);
      ring = null;
      if (!n) return;
      if (clean & 1) {
        segment = ringSegments[0];
        if ((m = segment.length - 1) > 0) {
          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
          sink.lineStart();
          for (i = 0; i < m; ++i) sink.point((point3 = segment[i])[0], point3[1]);
          sink.lineEnd();
        }
        return;
      }
      if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));
      segments.push(ringSegments.filter(validSegment));
    }
    return clip;
  };
}
function validSegment(segment) {
  return segment.length > 1;
}
function compareIntersection(a, b) {
  return ((a = a.x)[0] < 0 ? a[1] - halfPi - epsilon : halfPi - a[1]) - ((b = b.x)[0] < 0 ? b[1] - halfPi - epsilon : halfPi - b[1]);
}

// node_modules/d3-geo/src/clip/antimeridian.js
var antimeridian_default = clip_default(
  function() {
    return true;
  },
  clipAntimeridianLine,
  clipAntimeridianInterpolate,
  [-pi, -halfPi]
);
function clipAntimeridianLine(stream) {
  var lambda04 = NaN, phi02 = NaN, sign0 = NaN, clean;
  return {
    lineStart: function() {
      stream.lineStart();
      clean = 1;
    },
    point: function(lambda12, phi12) {
      var sign1 = lambda12 > 0 ? pi : -pi, delta = abs(lambda12 - lambda04);
      if (abs(delta - pi) < epsilon) {
        stream.point(lambda04, phi02 = (phi02 + phi12) / 2 > 0 ? halfPi : -halfPi);
        stream.point(sign0, phi02);
        stream.lineEnd();
        stream.lineStart();
        stream.point(sign1, phi02);
        stream.point(lambda12, phi02);
        clean = 0;
      } else if (sign0 !== sign1 && delta >= pi) {
        if (abs(lambda04 - sign0) < epsilon) lambda04 -= sign0 * epsilon;
        if (abs(lambda12 - sign1) < epsilon) lambda12 -= sign1 * epsilon;
        phi02 = clipAntimeridianIntersect(lambda04, phi02, lambda12, phi12);
        stream.point(sign0, phi02);
        stream.lineEnd();
        stream.lineStart();
        stream.point(sign1, phi02);
        clean = 0;
      }
      stream.point(lambda04 = lambda12, phi02 = phi12);
      sign0 = sign1;
    },
    lineEnd: function() {
      stream.lineEnd();
      lambda04 = phi02 = NaN;
    },
    clean: function() {
      return 2 - clean;
    }
  };
}
function clipAntimeridianIntersect(lambda04, phi02, lambda12, phi12) {
  var cosPhi03, cosPhi1, sinLambda0Lambda1 = sin(lambda04 - lambda12);
  return abs(sinLambda0Lambda1) > epsilon ? atan((sin(phi02) * (cosPhi1 = cos(phi12)) * sin(lambda12) - sin(phi12) * (cosPhi03 = cos(phi02)) * sin(lambda04)) / (cosPhi03 * cosPhi1 * sinLambda0Lambda1)) : (phi02 + phi12) / 2;
}
function clipAntimeridianInterpolate(from, to, direction, stream) {
  var phi;
  if (from == null) {
    phi = direction * halfPi;
    stream.point(-pi, phi);
    stream.point(0, phi);
    stream.point(pi, phi);
    stream.point(pi, 0);
    stream.point(pi, -phi);
    stream.point(0, -phi);
    stream.point(-pi, -phi);
    stream.point(-pi, 0);
    stream.point(-pi, phi);
  } else if (abs(from[0] - to[0]) > epsilon) {
    var lambda = from[0] < to[0] ? pi : -pi;
    phi = direction * lambda / 2;
    stream.point(-lambda, phi);
    stream.point(0, phi);
    stream.point(lambda, phi);
  } else {
    stream.point(to[0], to[1]);
  }
}

// node_modules/d3-geo/src/clip/circle.js
function circle_default(radius) {
  var cr = cos(radius), delta = 2 * radians2, smallRadius = cr > 0, notHemisphere = abs(cr) > epsilon;
  function interpolate(from, to, direction, stream) {
    circleStream(stream, radius, delta, direction, from, to);
  }
  function visible(lambda, phi) {
    return cos(lambda) * cos(phi) > cr;
  }
  function clipLine(stream) {
    var point0, c0, v0, v00, clean;
    return {
      lineStart: function() {
        v00 = v0 = false;
        clean = 1;
      },
      point: function(lambda, phi) {
        var point1 = [lambda, phi], point2, v2 = visible(lambda, phi), c3 = smallRadius ? v2 ? 0 : code3(lambda, phi) : v2 ? code3(lambda + (lambda < 0 ? pi : -pi), phi) : 0;
        if (!point0 && (v00 = v0 = v2)) stream.lineStart();
        if (v2 !== v0) {
          point2 = intersect(point0, point1);
          if (!point2 || pointEqual_default(point0, point2) || pointEqual_default(point1, point2))
            point1[2] = 1;
        }
        if (v2 !== v0) {
          clean = 0;
          if (v2) {
            stream.lineStart();
            point2 = intersect(point1, point0);
            stream.point(point2[0], point2[1]);
          } else {
            point2 = intersect(point0, point1);
            stream.point(point2[0], point2[1], 2);
            stream.lineEnd();
          }
          point0 = point2;
        } else if (notHemisphere && point0 && smallRadius ^ v2) {
          var t;
          if (!(c3 & c0) && (t = intersect(point1, point0, true))) {
            clean = 0;
            if (smallRadius) {
              stream.lineStart();
              stream.point(t[0][0], t[0][1]);
              stream.point(t[1][0], t[1][1]);
              stream.lineEnd();
            } else {
              stream.point(t[1][0], t[1][1]);
              stream.lineEnd();
              stream.lineStart();
              stream.point(t[0][0], t[0][1], 3);
            }
          }
        }
        if (v2 && (!point0 || !pointEqual_default(point0, point1))) {
          stream.point(point1[0], point1[1]);
        }
        point0 = point1, v0 = v2, c0 = c3;
      },
      lineEnd: function() {
        if (v0) stream.lineEnd();
        point0 = null;
      },
      // Rejoin first and last segments if there were intersections and the first
      // and last points were visible.
      clean: function() {
        return clean | (v00 && v0) << 1;
      }
    };
  }
  function intersect(a, b, two) {
    var pa = cartesian(a), pb = cartesian(b);
    var n1 = [1, 0, 0], n2 = cartesianCross(pa, pb), n2n2 = cartesianDot(n2, n2), n1n2 = n2[0], determinant3 = n2n2 - n1n2 * n1n2;
    if (!determinant3) return !two && a;
    var c1 = cr * n2n2 / determinant3, c22 = -cr * n1n2 / determinant3, n1xn2 = cartesianCross(n1, n2), A5 = cartesianScale(n1, c1), B4 = cartesianScale(n2, c22);
    cartesianAddInPlace(A5, B4);
    var u4 = n1xn2, w = cartesianDot(A5, u4), uu = cartesianDot(u4, u4), t22 = w * w - uu * (cartesianDot(A5, A5) - 1);
    if (t22 < 0) return;
    var t = sqrt2(t22), q = cartesianScale(u4, (-w - t) / uu);
    cartesianAddInPlace(q, A5);
    q = spherical(q);
    if (!two) return q;
    var lambda04 = a[0], lambda12 = b[0], phi02 = a[1], phi12 = b[1], z;
    if (lambda12 < lambda04) z = lambda04, lambda04 = lambda12, lambda12 = z;
    var delta2 = lambda12 - lambda04, polar = abs(delta2 - pi) < epsilon, meridian = polar || delta2 < epsilon;
    if (!polar && phi12 < phi02) z = phi02, phi02 = phi12, phi12 = z;
    if (meridian ? polar ? phi02 + phi12 > 0 ^ q[1] < (abs(q[0] - lambda04) < epsilon ? phi02 : phi12) : phi02 <= q[1] && q[1] <= phi12 : delta2 > pi ^ (lambda04 <= q[0] && q[0] <= lambda12)) {
      var q12 = cartesianScale(u4, (-w + t) / uu);
      cartesianAddInPlace(q12, A5);
      return [q, spherical(q12)];
    }
  }
  function code3(lambda, phi) {
    var r = smallRadius ? radius : pi - radius, code4 = 0;
    if (lambda < -r) code4 |= 1;
    else if (lambda > r) code4 |= 2;
    if (phi < -r) code4 |= 4;
    else if (phi > r) code4 |= 8;
    return code4;
  }
  return clip_default(visible, clipLine, interpolate, smallRadius ? [0, -radius] : [-pi, radius - pi]);
}

// node_modules/d3-geo/src/clip/line.js
function line_default(a, b, x03, y03, x12, y12) {
  var ax = a[0], ay = a[1], bx = b[0], by = b[1], t03 = 0, t13 = 1, dx = bx - ax, dy = by - ay, r;
  r = x03 - ax;
  if (!dx && r > 0) return;
  r /= dx;
  if (dx < 0) {
    if (r < t03) return;
    if (r < t13) t13 = r;
  } else if (dx > 0) {
    if (r > t13) return;
    if (r > t03) t03 = r;
  }
  r = x12 - ax;
  if (!dx && r < 0) return;
  r /= dx;
  if (dx < 0) {
    if (r > t13) return;
    if (r > t03) t03 = r;
  } else if (dx > 0) {
    if (r < t03) return;
    if (r < t13) t13 = r;
  }
  r = y03 - ay;
  if (!dy && r > 0) return;
  r /= dy;
  if (dy < 0) {
    if (r < t03) return;
    if (r < t13) t13 = r;
  } else if (dy > 0) {
    if (r > t13) return;
    if (r > t03) t03 = r;
  }
  r = y12 - ay;
  if (!dy && r < 0) return;
  r /= dy;
  if (dy < 0) {
    if (r > t13) return;
    if (r > t03) t03 = r;
  } else if (dy > 0) {
    if (r < t03) return;
    if (r < t13) t13 = r;
  }
  if (t03 > 0) a[0] = ax + t03 * dx, a[1] = ay + t03 * dy;
  if (t13 < 1) b[0] = ax + t13 * dx, b[1] = ay + t13 * dy;
  return true;
}

// node_modules/d3-geo/src/clip/rectangle.js
var clipMax = 1e9;
var clipMin = -clipMax;
function clipRectangle(x03, y03, x12, y12) {
  function visible(x, y) {
    return x03 <= x && x <= x12 && y03 <= y && y <= y12;
  }
  function interpolate(from, to, direction, stream) {
    var a = 0, a1 = 0;
    if (from == null || (a = corner(from, direction)) !== (a1 = corner(to, direction)) || comparePoint(from, to) < 0 ^ direction > 0) {
      do
        stream.point(a === 0 || a === 3 ? x03 : x12, a > 1 ? y12 : y03);
      while ((a = (a + direction + 4) % 4) !== a1);
    } else {
      stream.point(to[0], to[1]);
    }
  }
  function corner(p, direction) {
    return abs(p[0] - x03) < epsilon ? direction > 0 ? 0 : 3 : abs(p[0] - x12) < epsilon ? direction > 0 ? 2 : 1 : abs(p[1] - y03) < epsilon ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2;
  }
  function compareIntersection2(a, b) {
    return comparePoint(a.x, b.x);
  }
  function comparePoint(a, b) {
    var ca3 = corner(a, 1), cb = corner(b, 1);
    return ca3 !== cb ? ca3 - cb : ca3 === 0 ? b[1] - a[1] : ca3 === 1 ? a[0] - b[0] : ca3 === 2 ? a[1] - b[1] : b[0] - a[0];
  }
  return function(stream) {
    var activeStream = stream, bufferStream = buffer_default(), segments, polygon, ring, x__, y__, v__, x_, y_, v_, first, clean;
    var clipStream = {
      point: point2,
      lineStart,
      lineEnd,
      polygonStart,
      polygonEnd
    };
    function point2(x, y) {
      if (visible(x, y)) activeStream.point(x, y);
    }
    function polygonInside() {
      var winding = 0;
      for (var i = 0, n = polygon.length; i < n; ++i) {
        for (var ring2 = polygon[i], j = 1, m = ring2.length, point3 = ring2[0], a0, a1, b0 = point3[0], b1 = point3[1]; j < m; ++j) {
          a0 = b0, a1 = b1, point3 = ring2[j], b0 = point3[0], b1 = point3[1];
          if (a1 <= y12) {
            if (b1 > y12 && (b0 - a0) * (y12 - a1) > (b1 - a1) * (x03 - a0)) ++winding;
          } else {
            if (b1 <= y12 && (b0 - a0) * (y12 - a1) < (b1 - a1) * (x03 - a0)) --winding;
          }
        }
      }
      return winding;
    }
    function polygonStart() {
      activeStream = bufferStream, segments = [], polygon = [], clean = true;
    }
    function polygonEnd() {
      var startInside = polygonInside(), cleanInside = clean && startInside, visible2 = (segments = merge(segments)).length;
      if (cleanInside || visible2) {
        stream.polygonStart();
        if (cleanInside) {
          stream.lineStart();
          interpolate(null, null, 1, stream);
          stream.lineEnd();
        }
        if (visible2) {
          rejoin_default(segments, compareIntersection2, startInside, interpolate, stream);
        }
        stream.polygonEnd();
      }
      activeStream = stream, segments = polygon = ring = null;
    }
    function lineStart() {
      clipStream.point = linePoint2;
      if (polygon) polygon.push(ring = []);
      first = true;
      v_ = false;
      x_ = y_ = NaN;
    }
    function lineEnd() {
      if (segments) {
        linePoint2(x__, y__);
        if (v__ && v_) bufferStream.rejoin();
        segments.push(bufferStream.result());
      }
      clipStream.point = point2;
      if (v_) activeStream.lineEnd();
    }
    function linePoint2(x, y) {
      var v2 = visible(x, y);
      if (polygon) ring.push([x, y]);
      if (first) {
        x__ = x, y__ = y, v__ = v2;
        first = false;
        if (v2) {
          activeStream.lineStart();
          activeStream.point(x, y);
        }
      } else {
        if (v2 && v_) activeStream.point(x, y);
        else {
          var a = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))], b = [x = Math.max(clipMin, Math.min(clipMax, x)), y = Math.max(clipMin, Math.min(clipMax, y))];
          if (line_default(a, b, x03, y03, x12, y12)) {
            if (!v_) {
              activeStream.lineStart();
              activeStream.point(a[0], a[1]);
            }
            activeStream.point(b[0], b[1]);
            if (!v2) activeStream.lineEnd();
            clean = false;
          } else if (v2) {
            activeStream.lineStart();
            activeStream.point(x, y);
            clean = false;
          }
        }
      }
      x_ = x, y_ = y, v_ = v2;
    }
    return clipStream;
  };
}

// node_modules/d3-geo/src/length.js
var lengthSum;
var lambda03;
var sinPhi02;
var cosPhi02;
var lengthStream = {
  sphere: noop,
  point: noop,
  lineStart: lengthLineStart,
  lineEnd: noop,
  polygonStart: noop,
  polygonEnd: noop
};
function lengthLineStart() {
  lengthStream.point = lengthPointFirst;
  lengthStream.lineEnd = lengthLineEnd;
}
function lengthLineEnd() {
  lengthStream.point = lengthStream.lineEnd = noop;
}
function lengthPointFirst(lambda, phi) {
  lambda *= radians2, phi *= radians2;
  lambda03 = lambda, sinPhi02 = sin(phi), cosPhi02 = cos(phi);
  lengthStream.point = lengthPoint;
}
function lengthPoint(lambda, phi) {
  lambda *= radians2, phi *= radians2;
  var sinPhi = sin(phi), cosPhi = cos(phi), delta = abs(lambda - lambda03), cosDelta = cos(delta), sinDelta = sin(delta), x = cosPhi * sinDelta, y = cosPhi02 * sinPhi - sinPhi02 * cosPhi * cosDelta, z = sinPhi02 * sinPhi + cosPhi02 * cosPhi * cosDelta;
  lengthSum.add(atan2(sqrt2(x * x + y * y), z));
  lambda03 = lambda, sinPhi02 = sinPhi, cosPhi02 = cosPhi;
}
function length_default(object2) {
  lengthSum = new Adder();
  stream_default(object2, lengthStream);
  return +lengthSum;
}

// node_modules/d3-geo/src/distance.js
var coordinates = [null, null];
var object = { type: "LineString", coordinates };
function distance_default(a, b) {
  coordinates[0] = a;
  coordinates[1] = b;
  return length_default(object);
}

// node_modules/d3-geo/src/contains.js
var containsObjectType = {
  Feature: function(object2, point2) {
    return containsGeometry(object2.geometry, point2);
  },
  FeatureCollection: function(object2, point2) {
    var features = object2.features, i = -1, n = features.length;
    while (++i < n) if (containsGeometry(features[i].geometry, point2)) return true;
    return false;
  }
};
var containsGeometryType = {
  Sphere: function() {
    return true;
  },
  Point: function(object2, point2) {
    return containsPoint(object2.coordinates, point2);
  },
  MultiPoint: function(object2, point2) {
    var coordinates2 = object2.coordinates, i = -1, n = coordinates2.length;
    while (++i < n) if (containsPoint(coordinates2[i], point2)) return true;
    return false;
  },
  LineString: function(object2, point2) {
    return containsLine(object2.coordinates, point2);
  },
  MultiLineString: function(object2, point2) {
    var coordinates2 = object2.coordinates, i = -1, n = coordinates2.length;
    while (++i < n) if (containsLine(coordinates2[i], point2)) return true;
    return false;
  },
  Polygon: function(object2, point2) {
    return containsPolygon(object2.coordinates, point2);
  },
  MultiPolygon: function(object2, point2) {
    var coordinates2 = object2.coordinates, i = -1, n = coordinates2.length;
    while (++i < n) if (containsPolygon(coordinates2[i], point2)) return true;
    return false;
  },
  GeometryCollection: function(object2, point2) {
    var geometries = object2.geometries, i = -1, n = geometries.length;
    while (++i < n) if (containsGeometry(geometries[i], point2)) return true;
    return false;
  }
};
function containsGeometry(geometry, point2) {
  return geometry && containsGeometryType.hasOwnProperty(geometry.type) ? containsGeometryType[geometry.type](geometry, point2) : false;
}
function containsPoint(coordinates2, point2) {
  return distance_default(coordinates2, point2) === 0;
}
function containsLine(coordinates2, point2) {
  var ao, bo, ab4;
  for (var i = 0, n = coordinates2.length; i < n; i++) {
    bo = distance_default(coordinates2[i], point2);
    if (bo === 0) return true;
    if (i > 0) {
      ab4 = distance_default(coordinates2[i], coordinates2[i - 1]);
      if (ab4 > 0 && ao <= ab4 && bo <= ab4 && (ao + bo - ab4) * (1 - Math.pow((ao - bo) / ab4, 2)) < epsilon22 * ab4)
        return true;
    }
    ao = bo;
  }
  return false;
}
function containsPolygon(coordinates2, point2) {
  return !!polygonContains_default(coordinates2.map(ringRadians), pointRadians(point2));
}
function ringRadians(ring) {
  return ring = ring.map(pointRadians), ring.pop(), ring;
}
function pointRadians(point2) {
  return [point2[0] * radians2, point2[1] * radians2];
}
function contains_default(object2, point2) {
  return (object2 && containsObjectType.hasOwnProperty(object2.type) ? containsObjectType[object2.type] : containsGeometry)(object2, point2);
}

// node_modules/d3-geo/src/graticule.js
function graticuleX(y03, y12, dy) {
  var y = range(y03, y12 - epsilon, dy).concat(y12);
  return function(x) {
    return y.map(function(y2) {
      return [x, y2];
    });
  };
}
function graticuleY(x03, x12, dx) {
  var x = range(x03, x12 - epsilon, dx).concat(x12);
  return function(y) {
    return x.map(function(x2) {
      return [x2, y];
    });
  };
}
function graticule() {
  var x12, x03, X12, X02, y12, y03, Y12, Y02, dx = 10, dy = dx, DX = 90, DY = 360, x, y, X, Y, precision = 2.5;
  function graticule2() {
    return { type: "MultiLineString", coordinates: lines() };
  }
  function lines() {
    return range(ceil(X02 / DX) * DX, X12, DX).map(X).concat(range(ceil(Y02 / DY) * DY, Y12, DY).map(Y)).concat(range(ceil(x03 / dx) * dx, x12, dx).filter(function(x2) {
      return abs(x2 % DX) > epsilon;
    }).map(x)).concat(range(ceil(y03 / dy) * dy, y12, dy).filter(function(y2) {
      return abs(y2 % DY) > epsilon;
    }).map(y));
  }
  graticule2.lines = function() {
    return lines().map(function(coordinates2) {
      return { type: "LineString", coordinates: coordinates2 };
    });
  };
  graticule2.outline = function() {
    return {
      type: "Polygon",
      coordinates: [
        X(X02).concat(
          Y(Y12).slice(1),
          X(X12).reverse().slice(1),
          Y(Y02).reverse().slice(1)
        )
      ]
    };
  };
  graticule2.extent = function(_) {
    if (!arguments.length) return graticule2.extentMinor();
    return graticule2.extentMajor(_).extentMinor(_);
  };
  graticule2.extentMajor = function(_) {
    if (!arguments.length) return [[X02, Y02], [X12, Y12]];
    X02 = +_[0][0], X12 = +_[1][0];
    Y02 = +_[0][1], Y12 = +_[1][1];
    if (X02 > X12) _ = X02, X02 = X12, X12 = _;
    if (Y02 > Y12) _ = Y02, Y02 = Y12, Y12 = _;
    return graticule2.precision(precision);
  };
  graticule2.extentMinor = function(_) {
    if (!arguments.length) return [[x03, y03], [x12, y12]];
    x03 = +_[0][0], x12 = +_[1][0];
    y03 = +_[0][1], y12 = +_[1][1];
    if (x03 > x12) _ = x03, x03 = x12, x12 = _;
    if (y03 > y12) _ = y03, y03 = y12, y12 = _;
    return graticule2.precision(precision);
  };
  graticule2.step = function(_) {
    if (!arguments.length) return graticule2.stepMinor();
    return graticule2.stepMajor(_).stepMinor(_);
  };
  graticule2.stepMajor = function(_) {
    if (!arguments.length) return [DX, DY];
    DX = +_[0], DY = +_[1];
    return graticule2;
  };
  graticule2.stepMinor = function(_) {
    if (!arguments.length) return [dx, dy];
    dx = +_[0], dy = +_[1];
    return graticule2;
  };
  graticule2.precision = function(_) {
    if (!arguments.length) return precision;
    precision = +_;
    x = graticuleX(y03, y12, 90);
    y = graticuleY(x03, x12, precision);
    X = graticuleX(Y02, Y12, 90);
    Y = graticuleY(X02, X12, precision);
    return graticule2;
  };
  return graticule2.extentMajor([[-180, -90 + epsilon], [180, 90 - epsilon]]).extentMinor([[-180, -80 - epsilon], [180, 80 + epsilon]]);
}
function graticule10() {
  return graticule()();
}

// node_modules/d3-geo/src/interpolate.js
function interpolate_default(a, b) {
  var x03 = a[0] * radians2, y03 = a[1] * radians2, x12 = b[0] * radians2, y12 = b[1] * radians2, cy0 = cos(y03), sy0 = sin(y03), cy1 = cos(y12), sy1 = sin(y12), kx0 = cy0 * cos(x03), ky0 = cy0 * sin(x03), kx1 = cy1 * cos(x12), ky1 = cy1 * sin(x12), d = 2 * asin(sqrt2(haversin(y12 - y03) + cy0 * cy1 * haversin(x12 - x03))), k = sin(d);
  var interpolate = d ? function(t) {
    var B4 = sin(t *= d) / k, A5 = sin(d - t) / k, x = A5 * kx0 + B4 * kx1, y = A5 * ky0 + B4 * ky1, z = A5 * sy0 + B4 * sy1;
    return [
      atan2(y, x) * degrees3,
      atan2(z, sqrt2(x * x + y * y)) * degrees3
    ];
  } : function() {
    return [x03 * degrees3, y03 * degrees3];
  };
  interpolate.distance = d;
  return interpolate;
}

// node_modules/d3-geo/src/identity.js
var identity_default2 = (x) => x;

// node_modules/d3-geo/src/path/area.js
var areaSum2 = new Adder();
var areaRingSum2 = new Adder();

// node_modules/d3-geo/src/path/bounds.js
var x02 = Infinity;
var y02 = x02;
var x1 = -x02;
var y1 = x1;
var boundsStream2 = {
  point: boundsPoint2,
  lineStart: noop,
  lineEnd: noop,
  polygonStart: noop,
  polygonEnd: noop,
  result: function() {
    var bounds = [[x02, y02], [x1, y1]];
    x1 = y1 = -(y02 = x02 = Infinity);
    return bounds;
  }
};
function boundsPoint2(x, y) {
  if (x < x02) x02 = x;
  if (x > x1) x1 = x;
  if (y < y02) y02 = y;
  if (y > y1) y1 = y;
}
var bounds_default2 = boundsStream2;

// node_modules/d3-geo/src/path/context.js
function PathContext(context3) {
  this._context = context3;
}
PathContext.prototype = {
  _radius: 4.5,
  pointRadius: function(_) {
    return this._radius = _, this;
  },
  polygonStart: function() {
    this._line = 0;
  },
  polygonEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line === 0) this._context.closePath();
    this._point = NaN;
  },
  point: function(x, y) {
    switch (this._point) {
      case 0: {
        this._context.moveTo(x, y);
        this._point = 1;
        break;
      }
      case 1: {
        this._context.lineTo(x, y);
        break;
      }
      default: {
        this._context.moveTo(x + this._radius, y);
        this._context.arc(x, y, this._radius, 0, tau);
        break;
      }
    }
  },
  result: noop
};

// node_modules/d3-geo/src/path/measure.js
var lengthSum2 = new Adder();

// node_modules/d3-geo/src/transform.js
function transformer2(methods) {
  return function(stream) {
    var s = new TransformStream();
    for (var key in methods) s[key] = methods[key];
    s.stream = stream;
    return s;
  };
}
function TransformStream() {
}
TransformStream.prototype = {
  constructor: TransformStream,
  point: function(x, y) {
    this.stream.point(x, y);
  },
  sphere: function() {
    this.stream.sphere();
  },
  lineStart: function() {
    this.stream.lineStart();
  },
  lineEnd: function() {
    this.stream.lineEnd();
  },
  polygonStart: function() {
    this.stream.polygonStart();
  },
  polygonEnd: function() {
    this.stream.polygonEnd();
  }
};

// node_modules/d3-geo/src/projection/fit.js
function fit(projection2, fitBounds, object2) {
  var clip = projection2.clipExtent && projection2.clipExtent();
  projection2.scale(150).translate([0, 0]);
  if (clip != null) projection2.clipExtent(null);
  stream_default(object2, projection2.stream(bounds_default2));
  fitBounds(bounds_default2.result());
  if (clip != null) projection2.clipExtent(clip);
  return projection2;
}
function fitExtent(projection2, extent2, object2) {
  return fit(projection2, function(b) {
    var w = extent2[1][0] - extent2[0][0], h = extent2[1][1] - extent2[0][1], k = Math.min(w / (b[1][0] - b[0][0]), h / (b[1][1] - b[0][1])), x = +extent2[0][0] + (w - k * (b[1][0] + b[0][0])) / 2, y = +extent2[0][1] + (h - k * (b[1][1] + b[0][1])) / 2;
    projection2.scale(150 * k).translate([x, y]);
  }, object2);
}
function fitSize(projection2, size, object2) {
  return fitExtent(projection2, [[0, 0], size], object2);
}
function fitWidth(projection2, width, object2) {
  return fit(projection2, function(b) {
    var w = +width, k = w / (b[1][0] - b[0][0]), x = (w - k * (b[1][0] + b[0][0])) / 2, y = -k * b[0][1];
    projection2.scale(150 * k).translate([x, y]);
  }, object2);
}
function fitHeight(projection2, height, object2) {
  return fit(projection2, function(b) {
    var h = +height, k = h / (b[1][1] - b[0][1]), x = -k * b[0][0], y = (h - k * (b[1][1] + b[0][1])) / 2;
    projection2.scale(150 * k).translate([x, y]);
  }, object2);
}

// node_modules/d3-geo/src/projection/resample.js
var maxDepth = 16;
var cosMinDistance = cos(30 * radians2);
function resample_default(project, delta2) {
  return +delta2 ? resample(project, delta2) : resampleNone(project);
}
function resampleNone(project) {
  return transformer2({
    point: function(x, y) {
      x = project(x, y);
      this.stream.point(x[0], x[1]);
    }
  });
}
function resample(project, delta2) {
  function resampleLineTo(x03, y03, lambda04, a0, b0, c0, x12, y12, lambda12, a1, b1, c1, depth3, stream) {
    var dx = x12 - x03, dy = y12 - y03, d2 = dx * dx + dy * dy;
    if (d2 > 4 * delta2 && depth3--) {
      var a = a0 + a1, b = b0 + b1, c3 = c0 + c1, m = sqrt2(a * a + b * b + c3 * c3), phi2 = asin(c3 /= m), lambda22 = abs(abs(c3) - 1) < epsilon || abs(lambda04 - lambda12) < epsilon ? (lambda04 + lambda12) / 2 : atan2(b, a), p = project(lambda22, phi2), x2 = p[0], y2 = p[1], dx2 = x2 - x03, dy2 = y2 - y03, dz = dy * dx2 - dx * dy2;
      if (dz * dz / d2 > delta2 || abs((dx * dx2 + dy * dy2) / d2 - 0.5) > 0.3 || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) {
        resampleLineTo(x03, y03, lambda04, a0, b0, c0, x2, y2, lambda22, a /= m, b /= m, c3, depth3, stream);
        stream.point(x2, y2);
        resampleLineTo(x2, y2, lambda22, a, b, c3, x12, y12, lambda12, a1, b1, c1, depth3, stream);
      }
    }
  }
  return function(stream) {
    var lambda004, x00, y00, a00, b00, c00, lambda04, x03, y03, a0, b0, c0;
    var resampleStream = {
      point: point2,
      lineStart,
      lineEnd,
      polygonStart: function() {
        stream.polygonStart();
        resampleStream.lineStart = ringStart;
      },
      polygonEnd: function() {
        stream.polygonEnd();
        resampleStream.lineStart = lineStart;
      }
    };
    function point2(x, y) {
      x = project(x, y);
      stream.point(x[0], x[1]);
    }
    function lineStart() {
      x03 = NaN;
      resampleStream.point = linePoint2;
      stream.lineStart();
    }
    function linePoint2(lambda, phi) {
      var c3 = cartesian([lambda, phi]), p = project(lambda, phi);
      resampleLineTo(x03, y03, lambda04, a0, b0, c0, x03 = p[0], y03 = p[1], lambda04 = lambda, a0 = c3[0], b0 = c3[1], c0 = c3[2], maxDepth, stream);
      stream.point(x03, y03);
    }
    function lineEnd() {
      resampleStream.point = point2;
      stream.lineEnd();
    }
    function ringStart() {
      lineStart();
      resampleStream.point = ringPoint;
      resampleStream.lineEnd = ringEnd;
    }
    function ringPoint(lambda, phi) {
      linePoint2(lambda004 = lambda, phi), x00 = x03, y00 = y03, a00 = a0, b00 = b0, c00 = c0;
      resampleStream.point = linePoint2;
    }
    function ringEnd() {
      resampleLineTo(x03, y03, lambda04, a0, b0, c0, x00, y00, lambda004, a00, b00, c00, maxDepth, stream);
      resampleStream.lineEnd = lineEnd;
      lineEnd();
    }
    return resampleStream;
  };
}

// node_modules/d3-geo/src/projection/index.js
var transformRadians = transformer2({
  point: function(x, y) {
    this.stream.point(x * radians2, y * radians2);
  }
});
function transformRotate(rotate3) {
  return transformer2({
    point: function(x, y) {
      var r = rotate3(x, y);
      return this.stream.point(r[0], r[1]);
    }
  });
}
function scaleTranslate(k, dx, dy, sx, sy) {
  function transform(x, y) {
    x *= sx;
    y *= sy;
    return [dx + k * x, dy - k * y];
  }
  transform.invert = function(x, y) {
    return [(x - dx) / k * sx, (dy - y) / k * sy];
  };
  return transform;
}
function scaleTranslateRotate(k, dx, dy, sx, sy, alpha) {
  if (!alpha) return scaleTranslate(k, dx, dy, sx, sy);
  var cosAlpha = cos(alpha), sinAlpha = sin(alpha), a = cosAlpha * k, b = sinAlpha * k, ai = cosAlpha / k, bi = sinAlpha / k, ci = (sinAlpha * dy - cosAlpha * dx) / k, fi = (sinAlpha * dx + cosAlpha * dy) / k;
  function transform(x, y) {
    x *= sx;
    y *= sy;
    return [a * x - b * y + dx, dy - b * x - a * y];
  }
  transform.invert = function(x, y) {
    return [sx * (ai * x - bi * y + ci), sy * (fi - bi * x - ai * y)];
  };
  return transform;
}
function projection(project) {
  return projectionMutator(function() {
    return project;
  })();
}
function projectionMutator(projectAt) {
  var project, k = 150, x = 480, y = 250, lambda = 0, phi = 0, deltaLambda = 0, deltaPhi = 0, deltaGamma = 0, rotate3, alpha = 0, sx = 1, sy = 1, theta = null, preclip = antimeridian_default, x03 = null, y03, x12, y12, postclip = identity_default2, delta2 = 0.5, projectResample, projectTransform, projectRotateTransform, cache3, cacheStream;
  function projection2(point2) {
    return projectRotateTransform(point2[0] * radians2, point2[1] * radians2);
  }
  function invert(point2) {
    point2 = projectRotateTransform.invert(point2[0], point2[1]);
    return point2 && [point2[0] * degrees3, point2[1] * degrees3];
  }
  projection2.stream = function(stream) {
    return cache3 && cacheStream === stream ? cache3 : cache3 = transformRadians(transformRotate(rotate3)(preclip(projectResample(postclip(cacheStream = stream)))));
  };
  projection2.preclip = function(_) {
    return arguments.length ? (preclip = _, theta = void 0, reset()) : preclip;
  };
  projection2.postclip = function(_) {
    return arguments.length ? (postclip = _, x03 = y03 = x12 = y12 = null, reset()) : postclip;
  };
  projection2.clipAngle = function(_) {
    return arguments.length ? (preclip = +_ ? circle_default(theta = _ * radians2) : (theta = null, antimeridian_default), reset()) : theta * degrees3;
  };
  projection2.clipExtent = function(_) {
    return arguments.length ? (postclip = _ == null ? (x03 = y03 = x12 = y12 = null, identity_default2) : clipRectangle(x03 = +_[0][0], y03 = +_[0][1], x12 = +_[1][0], y12 = +_[1][1]), reset()) : x03 == null ? null : [[x03, y03], [x12, y12]];
  };
  projection2.scale = function(_) {
    return arguments.length ? (k = +_, recenter()) : k;
  };
  projection2.translate = function(_) {
    return arguments.length ? (x = +_[0], y = +_[1], recenter()) : [x, y];
  };
  projection2.center = function(_) {
    return arguments.length ? (lambda = _[0] % 360 * radians2, phi = _[1] % 360 * radians2, recenter()) : [lambda * degrees3, phi * degrees3];
  };
  projection2.rotate = function(_) {
    return arguments.length ? (deltaLambda = _[0] % 360 * radians2, deltaPhi = _[1] % 360 * radians2, deltaGamma = _.length > 2 ? _[2] % 360 * radians2 : 0, recenter()) : [deltaLambda * degrees3, deltaPhi * degrees3, deltaGamma * degrees3];
  };
  projection2.angle = function(_) {
    return arguments.length ? (alpha = _ % 360 * radians2, recenter()) : alpha * degrees3;
  };
  projection2.reflectX = function(_) {
    return arguments.length ? (sx = _ ? -1 : 1, recenter()) : sx < 0;
  };
  projection2.reflectY = function(_) {
    return arguments.length ? (sy = _ ? -1 : 1, recenter()) : sy < 0;
  };
  projection2.precision = function(_) {
    return arguments.length ? (projectResample = resample_default(projectTransform, delta2 = _ * _), reset()) : sqrt2(delta2);
  };
  projection2.fitExtent = function(extent2, object2) {
    return fitExtent(projection2, extent2, object2);
  };
  projection2.fitSize = function(size, object2) {
    return fitSize(projection2, size, object2);
  };
  projection2.fitWidth = function(width, object2) {
    return fitWidth(projection2, width, object2);
  };
  projection2.fitHeight = function(height, object2) {
    return fitHeight(projection2, height, object2);
  };
  function recenter() {
    var center = scaleTranslateRotate(k, 0, 0, sx, sy, alpha).apply(null, project(lambda, phi)), transform = scaleTranslateRotate(k, x - center[0], y - center[1], sx, sy, alpha);
    rotate3 = rotateRadians(deltaLambda, deltaPhi, deltaGamma);
    projectTransform = compose_default(project, transform);
    projectRotateTransform = compose_default(rotate3, projectTransform);
    projectResample = resample_default(projectTransform, delta2);
    return reset();
  }
  function reset() {
    cache3 = cacheStream = null;
    return projection2;
  }
  return function() {
    project = projectAt.apply(this, arguments);
    projection2.invert = project.invert && invert;
    return recenter();
  };
}

// node_modules/d3-geo/src/projection/azimuthal.js
function azimuthalRaw(scale3) {
  return function(x, y) {
    var cx = cos(x), cy = cos(y), k = scale3(cx * cy);
    if (k === Infinity) return [2, 0];
    return [
      k * cy * sin(x),
      k * sin(y)
    ];
  };
}
function azimuthalInvert(angle2) {
  return function(x, y) {
    var z = sqrt2(x * x + y * y), c3 = angle2(z), sc = sin(c3), cc2 = cos(c3);
    return [
      atan2(x * sc, z * cc2),
      asin(z && y * sc / z)
    ];
  };
}

// node_modules/d3-geo/src/projection/azimuthalEqualArea.js
var azimuthalEqualAreaRaw = azimuthalRaw(function(cxcy) {
  return sqrt2(2 / (1 + cxcy));
});
azimuthalEqualAreaRaw.invert = azimuthalInvert(function(z) {
  return 2 * asin(z / 2);
});

// node_modules/d3-geo/src/projection/azimuthalEquidistant.js
var azimuthalEquidistantRaw = azimuthalRaw(function(c3) {
  return (c3 = acos(c3)) && c3 / sin(c3);
});
azimuthalEquidistantRaw.invert = azimuthalInvert(function(z) {
  return z;
});

// node_modules/d3-geo/src/projection/mercator.js
function mercatorRaw(lambda, phi) {
  return [lambda, log2(tan((halfPi + phi) / 2))];
}
mercatorRaw.invert = function(x, y) {
  return [x, 2 * atan(exp(y)) - halfPi];
};

// node_modules/d3-geo/src/projection/equirectangular.js
function equirectangularRaw(lambda, phi) {
  return [lambda, phi];
}
equirectangularRaw.invert = equirectangularRaw;

// node_modules/d3-geo/src/projection/equalEarth.js
var A1 = 1.340264;
var A2 = -0.081106;
var A3 = 893e-6;
var A4 = 3796e-6;
var M = sqrt2(3) / 2;
var iterations = 12;
function equalEarthRaw(lambda, phi) {
  var l = asin(M * sin(phi)), l2 = l * l, l6 = l2 * l2 * l2;
  return [
    lambda * cos(l) / (M * (A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2))),
    l * (A1 + A2 * l2 + l6 * (A3 + A4 * l2))
  ];
}
equalEarthRaw.invert = function(x, y) {
  var l = y, l2 = l * l, l6 = l2 * l2 * l2;
  for (var i = 0, delta, fy, fpy; i < iterations; ++i) {
    fy = l * (A1 + A2 * l2 + l6 * (A3 + A4 * l2)) - y;
    fpy = A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2);
    l -= delta = fy / fpy, l2 = l * l, l6 = l2 * l2 * l2;
    if (abs(delta) < epsilon22) break;
  }
  return [
    M * x * (A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2)) / cos(l),
    asin(sin(l) / M)
  ];
};

// node_modules/d3-geo/src/projection/gnomonic.js
function gnomonicRaw(x, y) {
  var cy = cos(y), k = cos(x) * cy;
  return [cy * sin(x) / k, sin(y) / k];
}
gnomonicRaw.invert = azimuthalInvert(atan);

// node_modules/d3-geo/src/projection/naturalEarth1.js
function naturalEarth1Raw(lambda, phi) {
  var phi2 = phi * phi, phi4 = phi2 * phi2;
  return [
    lambda * (0.8707 - 0.131979 * phi2 + phi4 * (-0.013791 + phi4 * (3971e-6 * phi2 - 1529e-6 * phi4))),
    phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 5916e-6 * phi4)))
  ];
}
naturalEarth1Raw.invert = function(x, y) {
  var phi = y, i = 25, delta;
  do {
    var phi2 = phi * phi, phi4 = phi2 * phi2;
    phi -= delta = (phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 5916e-6 * phi4))) - y) / (1.007226 + phi2 * (0.015085 * 3 + phi4 * (-0.044475 * 7 + 0.028874 * 9 * phi2 - 5916e-6 * 11 * phi4)));
  } while (abs(delta) > epsilon && --i > 0);
  return [
    x / (0.8707 + (phi2 = phi * phi) * (-0.131979 + phi2 * (-0.013791 + phi2 * phi2 * phi2 * (3971e-6 - 1529e-6 * phi2)))),
    phi
  ];
};

// node_modules/d3-geo/src/projection/orthographic.js
function orthographicRaw(x, y) {
  return [cos(y) * sin(x), sin(y)];
}
orthographicRaw.invert = azimuthalInvert(asin);

// node_modules/d3-geo/src/projection/stereographic.js
function stereographicRaw(x, y) {
  var cy = cos(y), k = 1 + cos(x) * cy;
  return [cy * sin(x) / k, sin(y) / k];
}
stereographicRaw.invert = azimuthalInvert(function(z) {
  return 2 * atan(z);
});
function stereographic_default() {
  return projection(stereographicRaw).scale(250).clipAngle(142);
}

// node_modules/d3-geo/src/projection/transverseMercator.js
function transverseMercatorRaw(lambda, phi) {
  return [log2(tan((halfPi + phi) / 2)), -lambda];
}
transverseMercatorRaw.invert = function(x, y) {
  return [-y, 2 * atan(exp(x)) - halfPi];
};

// node_modules/three-slippy-map-globe/dist/three-slippy-map-globe.mjs
function _arrayLikeToArray2(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}
function _arrayWithHoles2(r) {
  if (Array.isArray(r)) return r;
}
function _arrayWithoutHoles(r) {
  if (Array.isArray(r)) return _arrayLikeToArray2(r);
}
function _assertClassBrand(e, t, n) {
  if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n;
  throw new TypeError("Private element is not present on this object");
}
function _assertThisInitialized(e) {
  if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function _callSuper(t, o, e) {
  return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, [], _getPrototypeOf(t).constructor) : o.apply(t, e));
}
function _checkPrivateRedeclaration(e, t) {
  if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object");
}
function _classCallCheck2(a, n) {
  if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
}
function _classPrivateFieldGet2(s, a) {
  return s.get(_assertClassBrand(s, a));
}
function _classPrivateFieldInitSpec(e, t, a) {
  _checkPrivateRedeclaration(e, t), t.set(e, a);
}
function _classPrivateFieldSet2(s, a, r) {
  return s.set(_assertClassBrand(s, a), r), r;
}
function _classPrivateMethodInitSpec(e, a) {
  _checkPrivateRedeclaration(e, a), a.add(e);
}
function _defineProperties(e, r) {
  for (var t = 0; t < r.length; t++) {
    var o = r[t];
    o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
  }
}
function _createClass2(e, r, t) {
  return r && _defineProperties(e.prototype, r), Object.defineProperty(e, "prototype", {
    writable: false
  }), e;
}
function _defineProperty(e, r, t) {
  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
    value: t,
    enumerable: true,
    configurable: true,
    writable: true
  }) : e[r] = t, e;
}
function _getPrototypeOf(t) {
  return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t4) {
    return t4.__proto__ || Object.getPrototypeOf(t4);
  }, _getPrototypeOf(t);
}
function _inherits(t, e) {
  if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
  t.prototype = Object.create(e && e.prototype, {
    constructor: {
      value: t,
      writable: true,
      configurable: true
    }
  }), Object.defineProperty(t, "prototype", {
    writable: false
  }), e && _setPrototypeOf(t, e);
}
function _isNativeReflectConstruct() {
  try {
    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (t4) {
  }
  return (_isNativeReflectConstruct = function() {
    return !!t;
  })();
}
function _iterableToArray(r) {
  if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
}
function _iterableToArrayLimit2(r, l) {
  var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (null != t) {
    var e, n, i, u4, a = [], f = true, o = false;
    try {
      if (i = (t = t.call(r)).next, 0 === l) ;
      else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = true) ;
    } catch (r2) {
      o = true, n = r2;
    } finally {
      try {
        if (!f && null != t.return && (u4 = t.return(), Object(u4) !== u4)) return;
      } finally {
        if (o) throw n;
      }
    }
    return a;
  }
}
function _nonIterableRest2() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _possibleConstructorReturn(t, e) {
  if (e && ("object" == typeof e || "function" == typeof e)) return e;
  if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
  return _assertThisInitialized(t);
}
function _setPrototypeOf(t, e) {
  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t4, e3) {
    return t4.__proto__ = e3, t4;
  }, _setPrototypeOf(t, e);
}
function _slicedToArray2(r, e) {
  return _arrayWithHoles2(r) || _iterableToArrayLimit2(r, e) || _unsupportedIterableToArray2(r, e) || _nonIterableRest2();
}
function _toConsumableArray(r) {
  return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray2(r) || _nonIterableSpread();
}
function _toPrimitive(t, r) {
  if ("object" != typeof t || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r);
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(t);
}
function _toPropertyKey(t) {
  var i = _toPrimitive(t, "string");
  return "symbol" == typeof i ? i : i + "";
}
function _unsupportedIterableToArray2(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray2(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray2(r, a) : void 0;
  }
}
var _materialDispose = function materialDispose(material) {
  if (material instanceof Array) {
    material.forEach(_materialDispose);
  } else {
    if (material.map) {
      material.map.dispose();
    }
    material.dispose();
  }
};
var _deallocate = function deallocate(obj) {
  if (obj.geometry) {
    obj.geometry.dispose();
  }
  if (obj.material) {
    _materialDispose(obj.material);
  }
  if (obj.texture) {
    obj.texture.dispose();
  }
  if (obj.children) {
    obj.children.forEach(_deallocate);
  }
};
var emptyObject = function emptyObject2(obj) {
  if (obj && obj.children) while (obj.children.length) {
    var childObj = obj.children[0];
    obj.remove(childObj);
    _deallocate(childObj);
  }
};
function polar2Cartesian(lat, lng, r) {
  var phi = (90 - lat) * Math.PI / 180;
  var theta = (90 - lng) * Math.PI / 180;
  return {
    x: r * Math.sin(phi) * Math.cos(theta),
    y: r * Math.cos(phi),
    z: r * Math.sin(phi) * Math.sin(theta)
  };
}
function cartesian2Polar(_ref) {
  var x = _ref.x, y = _ref.y, z = _ref.z;
  var r = Math.sqrt(x * x + y * y + z * z);
  var phi = Math.acos(y / r);
  var theta = Math.atan2(z, x);
  return {
    lat: 90 - phi * 180 / Math.PI,
    lng: 90 - theta * 180 / Math.PI - (theta < -Math.PI / 2 ? 360 : 0),
    // keep within [-180, 180] boundaries
    r
  };
}
function deg2Rad(deg) {
  return deg * Math.PI / 180;
}
var yMercatorScale = function yMercatorScale2(y) {
  return 1 - (mercatorRaw(0, (0.5 - y) * Math.PI)[1] / Math.PI + 1) / 2;
};
var yMercatorScaleClamped = function yMercatorScaleClamped2(y) {
  return Math.max(0, Math.min(1, yMercatorScale(y)));
};
var yMercatorScaleInvert = function yMercatorScaleInvert2(y) {
  return 0.5 - mercatorRaw.invert(0, (2 * (1 - y) - 1) * Math.PI)[1] / Math.PI;
};
var convertMercatorUV = function convertMercatorUV2(uvs) {
  var y03 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  var y12 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
  var offsetScale = linear2().domain([1, 0]).range([y03, y12]).clamp(true);
  var revOffsetScale = linear2().domain([yMercatorScaleClamped(y03), yMercatorScaleClamped(y12)]).range([1, 0]).clamp(true);
  var scale3 = function scale4(v2) {
    return revOffsetScale(yMercatorScaleClamped(offsetScale(v2)));
  };
  var arr = uvs.array;
  for (var i = 0, len = arr.length; i < len; i += 2) {
    arr[i + 1] = scale3(arr[i + 1]);
  }
  uvs.needsUpdate = true;
};
var findTileXY = function findTileXY2(level, isMercator, lng, lat) {
  var gridSize = Math.pow(2, level);
  var x = Math.max(0, Math.min(gridSize - 1, Math.floor((lng + 180) * gridSize / 360)));
  var relY = (90 - lat) / 180;
  isMercator && (relY = Math.max(0, Math.min(1, yMercatorScale(relY))));
  var y = Math.floor(relY * gridSize);
  return [x, y];
};
var genTilesCoords = function genTilesCoords2(level, isMercator) {
  var x03 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
  var y03 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
  var _x1 = arguments.length > 4 ? arguments[4] : void 0;
  var _y1 = arguments.length > 5 ? arguments[5] : void 0;
  var tiles = [];
  var gridSize = Math.pow(2, level);
  var tileLngLen = 360 / gridSize;
  var regTileLatLen = 180 / gridSize;
  var x12 = _x1 === void 0 ? gridSize - 1 : _x1;
  var y12 = _y1 === void 0 ? gridSize - 1 : _y1;
  for (var x = x03, maxX = Math.min(gridSize - 1, x12); x <= maxX; x++) {
    for (var y = y03, maxY = Math.min(gridSize - 1, y12); y <= maxY; y++) {
      var reproY = y, tileLatLen = regTileLatLen;
      if (isMercator) {
        reproY = y === 0 ? y : yMercatorScaleInvert(y / gridSize) * gridSize;
        var reproYEnd = y + 1 === gridSize ? y + 1 : yMercatorScaleInvert((y + 1) / gridSize) * gridSize;
        tileLatLen = (reproYEnd - reproY) * 180 / gridSize;
      }
      var lng = -180 + (x + 0.5) * tileLngLen;
      var lat = 90 - (reproY * 180 / gridSize + tileLatLen / 2);
      var latLen = tileLatLen;
      tiles.push({
        x,
        y,
        lng,
        lat,
        latLen
      });
    }
  }
  return tiles;
};
var MAX_LEVEL_TO_RENDER_ALL_TILES = 6;
var MAX_LEVEL_TO_BUILD_LOOKUP_OCTREE = 7;
var TILE_SEARCH_RADIUS_CAMERA_DISTANCE = 3;
var TILE_SEARCH_RADIUS_SURFACE_DISTANCE = 90;
var _radius = /* @__PURE__ */ new WeakMap();
var _isMercator = /* @__PURE__ */ new WeakMap();
var _tileUrl = /* @__PURE__ */ new WeakMap();
var _level = /* @__PURE__ */ new WeakMap();
var _tilesMeta = /* @__PURE__ */ new WeakMap();
var _isInView = /* @__PURE__ */ new WeakMap();
var _camera = /* @__PURE__ */ new WeakMap();
var _innerBackLayer = /* @__PURE__ */ new WeakMap();
var _ThreeSlippyMapGlobe_brand = /* @__PURE__ */ new WeakSet();
var ThreeSlippyMapGlobe = function(_Group) {
  function ThreeSlippyMapGlobe2(radius) {
    var _this;
    var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, tileUrl = _ref.tileUrl, _ref$minLevel = _ref.minLevel, minLevel = _ref$minLevel === void 0 ? 0 : _ref$minLevel, _ref$maxLevel = _ref.maxLevel, maxLevel = _ref$maxLevel === void 0 ? 17 : _ref$maxLevel, _ref$mercatorProjecti = _ref.mercatorProjection, mercatorProjection2 = _ref$mercatorProjecti === void 0 ? true : _ref$mercatorProjecti;
    _classCallCheck2(this, ThreeSlippyMapGlobe2);
    _this = _callSuper(this, ThreeSlippyMapGlobe2);
    _classPrivateMethodInitSpec(_this, _ThreeSlippyMapGlobe_brand);
    _classPrivateFieldInitSpec(_this, _radius, void 0);
    _classPrivateFieldInitSpec(_this, _isMercator, void 0);
    _classPrivateFieldInitSpec(_this, _tileUrl, void 0);
    _classPrivateFieldInitSpec(_this, _level, void 0);
    _classPrivateFieldInitSpec(_this, _tilesMeta, {});
    _classPrivateFieldInitSpec(_this, _isInView, void 0);
    _classPrivateFieldInitSpec(_this, _camera, void 0);
    _classPrivateFieldInitSpec(_this, _innerBackLayer, void 0);
    _defineProperty(_this, "minLevel", void 0);
    _defineProperty(_this, "maxLevel", void 0);
    _defineProperty(_this, "thresholds", _toConsumableArray(new Array(30)).map(function(_, idx) {
      return 8 / Math.pow(2, idx);
    }));
    _defineProperty(_this, "curvatureResolution", 5);
    _defineProperty(_this, "tileMargin", 0);
    _defineProperty(_this, "clearTiles", function() {
      Object.values(_classPrivateFieldGet2(_tilesMeta, _this)).forEach(function(l) {
        l.forEach(function(d) {
          if (d.obj) {
            _this.remove(d.obj);
            emptyObject(d.obj);
            delete d.obj;
          }
        });
      });
      _classPrivateFieldSet2(_tilesMeta, _this, {});
    });
    _classPrivateFieldSet2(_radius, _this, radius);
    _this.tileUrl = tileUrl;
    _classPrivateFieldSet2(_isMercator, _this, mercatorProjection2);
    _this.minLevel = minLevel;
    _this.maxLevel = maxLevel;
    _this.level = 0;
    _this.add(_classPrivateFieldSet2(_innerBackLayer, _this, new Mesh(new SphereGeometry(_classPrivateFieldGet2(_radius, _this) * 0.99, 180, 90), new MeshBasicMaterial({
      color: 0
    }))));
    _classPrivateFieldGet2(_innerBackLayer, _this).visible = false;
    _classPrivateFieldGet2(_innerBackLayer, _this).material.polygonOffset = true;
    _classPrivateFieldGet2(_innerBackLayer, _this).material.polygonOffsetUnits = 3;
    _classPrivateFieldGet2(_innerBackLayer, _this).material.polygonOffsetFactor = 1;
    return _this;
  }
  _inherits(ThreeSlippyMapGlobe2, _Group);
  return _createClass2(ThreeSlippyMapGlobe2, [{
    key: "tileUrl",
    get: (
      // Public attributes
      function get() {
        return _classPrivateFieldGet2(_tileUrl, this);
      }
    ),
    set: function set(tileUrl) {
      _classPrivateFieldSet2(_tileUrl, this, tileUrl);
      this.updatePov(_classPrivateFieldGet2(_camera, this));
    }
  }, {
    key: "level",
    get: function get() {
      return _classPrivateFieldGet2(_level, this);
    },
    set: function set(level) {
      var _classPrivateFieldGet2$1, _this2 = this;
      if (!_classPrivateFieldGet2(_tilesMeta, this)[level]) _assertClassBrand(_ThreeSlippyMapGlobe_brand, this, _buildMetaLevel).call(this, level);
      var prevLevel = _classPrivateFieldGet2(_level, this);
      _classPrivateFieldSet2(_level, this, level);
      if (level === prevLevel || prevLevel === void 0) return;
      _classPrivateFieldGet2(_innerBackLayer, this).visible = level > 0;
      _classPrivateFieldGet2(_tilesMeta, this)[level].forEach(function(d) {
        return d.obj && (d.obj.material.depthWrite = true);
      });
      prevLevel < level && ((_classPrivateFieldGet2$1 = _classPrivateFieldGet2(_tilesMeta, this)[prevLevel]) === null || _classPrivateFieldGet2$1 === void 0 ? void 0 : _classPrivateFieldGet2$1.forEach(function(d) {
        return d.obj && (d.obj.material.depthWrite = false);
      }));
      if (prevLevel > level) {
        for (var l = level + 1; l <= prevLevel; l++) {
          _classPrivateFieldGet2(_tilesMeta, this)[l] && _classPrivateFieldGet2(_tilesMeta, this)[l].forEach(function(d) {
            if (d.obj) {
              _this2.remove(d.obj);
              emptyObject(d.obj);
              delete d.obj;
            }
          });
        }
      }
      _assertClassBrand(_ThreeSlippyMapGlobe_brand, this, _fetchNeededTiles).call(this);
    }
    // Public methods
  }, {
    key: "updatePov",
    value: function updatePov(camera) {
      var _this3 = this;
      if (!camera || !(camera instanceof Camera)) return;
      _classPrivateFieldSet2(_camera, this, camera);
      var frustum;
      _classPrivateFieldSet2(_isInView, this, function(d) {
        if (!d.hullPnts) {
          var lngLen = 360 / Math.pow(2, _this3.level);
          var lng = d.lng, lat = d.lat, latLen = d.latLen;
          var lng0 = lng - lngLen / 2;
          var lng1 = lng + lngLen / 2;
          var lat0 = lat - latLen / 2;
          var lat1 = lat + latLen / 2;
          d.hullPnts = [[lat, lng], [lat0, lng0], [lat1, lng0], [lat0, lng1], [lat1, lng1]].map(function(_ref2) {
            var _ref3 = _slicedToArray2(_ref2, 2), lat2 = _ref3[0], lng2 = _ref3[1];
            return polar2Cartesian(lat2, lng2, _classPrivateFieldGet2(_radius, _this3));
          }).map(function(_ref4) {
            var x = _ref4.x, y = _ref4.y, z = _ref4.z;
            return new Vector3(x, y, z);
          });
        }
        if (!frustum) {
          frustum = new Frustum();
          camera.updateMatrix();
          camera.updateMatrixWorld();
          frustum.setFromProjectionMatrix(new Matrix4().multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse));
        }
        return d.hullPnts.some(function(pos) {
          return frustum.containsPoint(pos.clone().applyMatrix4(_this3.matrixWorld));
        });
      });
      if (this.tileUrl) {
        var pov = camera.position.clone();
        var distToGlobeCenter = pov.distanceTo(this.getWorldPosition(new Vector3()));
        var cameraDistance = (distToGlobeCenter - _classPrivateFieldGet2(_radius, this)) / _classPrivateFieldGet2(_radius, this);
        var idx = this.thresholds.findIndex(function(t) {
          return t && t <= cameraDistance;
        });
        this.level = Math.min(this.maxLevel, Math.max(this.minLevel, idx < 0 ? this.thresholds.length : idx));
        _assertClassBrand(_ThreeSlippyMapGlobe_brand, this, _fetchNeededTiles).call(this);
      }
    }
  }]);
}(Group);
function _buildMetaLevel(level) {
  var _this4 = this;
  if (level > MAX_LEVEL_TO_BUILD_LOOKUP_OCTREE) {
    _classPrivateFieldGet2(_tilesMeta, this)[level] = [];
    return;
  }
  var levelMeta = _classPrivateFieldGet2(_tilesMeta, this)[level] = genTilesCoords(level, _classPrivateFieldGet2(_isMercator, this));
  levelMeta.forEach(function(d) {
    return d.centroid = polar2Cartesian(d.lat, d.lng, _classPrivateFieldGet2(_radius, _this4));
  });
  levelMeta.octree = octree().x(function(d) {
    return d.centroid.x;
  }).y(function(d) {
    return d.centroid.y;
  }).z(function(d) {
    return d.centroid.z;
  }).addAll(levelMeta);
}
function _fetchNeededTiles() {
  var _this5 = this;
  if (!this.tileUrl || this.level === void 0 || !_classPrivateFieldGet2(_tilesMeta, this).hasOwnProperty(this.level)) return;
  if (!_classPrivateFieldGet2(_isInView, this) && this.level > MAX_LEVEL_TO_RENDER_ALL_TILES) return;
  var tiles = _classPrivateFieldGet2(_tilesMeta, this)[this.level];
  if (_classPrivateFieldGet2(_camera, this)) {
    var povPos = this.worldToLocal(_classPrivateFieldGet2(_camera, this).position.clone());
    if (tiles.octree) {
      var _tiles$octree;
      var _povPos = this.worldToLocal(_classPrivateFieldGet2(_camera, this).position.clone());
      var searchRadius = (_povPos.length() - _classPrivateFieldGet2(_radius, this)) * TILE_SEARCH_RADIUS_CAMERA_DISTANCE;
      tiles = (_tiles$octree = tiles.octree).findAllWithinRadius.apply(_tiles$octree, _toConsumableArray(_povPos).concat([searchRadius]));
    } else {
      var povCoords = cartesian2Polar(povPos);
      var searchRadiusLat = (povCoords.r / _classPrivateFieldGet2(_radius, this) - 1) * TILE_SEARCH_RADIUS_SURFACE_DISTANCE;
      var searchRadiusLng = searchRadiusLat / Math.cos(deg2Rad(povCoords.lat));
      var lngRange = [povCoords.lng - searchRadiusLng, povCoords.lng + searchRadiusLng];
      var latRange = [povCoords.lat + searchRadiusLat, povCoords.lat - searchRadiusLat];
      var _findTileXY = findTileXY(this.level, _classPrivateFieldGet2(_isMercator, this), lngRange[0], latRange[0]), _findTileXY2 = _slicedToArray2(_findTileXY, 2), x03 = _findTileXY2[0], y03 = _findTileXY2[1];
      var _findTileXY3 = findTileXY(this.level, _classPrivateFieldGet2(_isMercator, this), lngRange[1], latRange[1]), _findTileXY4 = _slicedToArray2(_findTileXY3, 2), x12 = _findTileXY4[0], y12 = _findTileXY4[1];
      !tiles.record && (tiles.record = {});
      var r = tiles.record;
      if (!r.hasOwnProperty("".concat(Math.round((x03 + x12) / 2), "_").concat(Math.round((y03 + y12) / 2)))) {
        tiles = genTilesCoords(this.level, _classPrivateFieldGet2(_isMercator, this), x03, y03, x12, y12).map(function(d) {
          var k2 = "".concat(d.x, "_").concat(d.y);
          if (r.hasOwnProperty(k2)) return r[k2];
          r[k2] = d;
          tiles.push(d);
          return d;
        });
      } else {
        var selTiles = [];
        for (var x = x03; x <= x12; x++) {
          for (var y = y03; y <= y12; y++) {
            var k = "".concat(x, "_").concat(y);
            if (!r.hasOwnProperty(k)) {
              r[k] = genTilesCoords(this.level, _classPrivateFieldGet2(_isMercator, this), x, y, x, y)[0];
              tiles.push(r[k]);
            }
            selTiles.push(r[k]);
          }
        }
        tiles = selTiles;
      }
    }
  }
  tiles.filter(function(d) {
    return !d.obj;
  }).filter(_classPrivateFieldGet2(_isInView, this) || function() {
    return true;
  }).forEach(function(d) {
    var x2 = d.x, y2 = d.y, lng = d.lng, lat = d.lat, latLen = d.latLen;
    var lngLen = 360 / Math.pow(2, _this5.level);
    if (!d.obj) {
      var width = lngLen * (1 - _this5.tileMargin);
      var height = latLen * (1 - _this5.tileMargin);
      var rotLng = deg2Rad(lng);
      var rotLat = deg2Rad(-lat);
      var tile = new Mesh(new SphereGeometry(_classPrivateFieldGet2(_radius, _this5), Math.ceil(width / _this5.curvatureResolution), Math.ceil(height / _this5.curvatureResolution), deg2Rad(90 - width / 2) + rotLng, deg2Rad(width), deg2Rad(90 - height / 2) + rotLat, deg2Rad(height)), new MeshLambertMaterial());
      if (_classPrivateFieldGet2(_isMercator, _this5)) {
        var _map = [lat + latLen / 2, lat - latLen / 2].map(function(lat2) {
          return 0.5 - lat2 / 180;
        }), _map2 = _slicedToArray2(_map, 2), _y = _map2[0], _y2 = _map2[1];
        convertMercatorUV(tile.geometry.attributes.uv, _y, _y2);
      }
      d.obj = tile;
    }
    if (!d.loading) {
      d.loading = true;
      new TextureLoader().load(_this5.tileUrl(x2, y2, _this5.level), function(texture3) {
        var tile2 = d.obj;
        if (tile2) {
          texture3.colorSpace = SRGBColorSpace;
          tile2.material.map = texture3;
          tile2.material.color = null;
          tile2.material.needsUpdate = true;
          _this5.add(tile2);
        }
        d.loading = false;
      });
    }
  });
}

// node_modules/earcut/src/earcut.js
function earcut(data, holeIndices, dim = 2) {
  const hasHoles = holeIndices && holeIndices.length;
  const outerLen = hasHoles ? holeIndices[0] * dim : data.length;
  let outerNode = linkedList(data, 0, outerLen, dim, true);
  const triangles = [];
  if (!outerNode || outerNode.next === outerNode.prev) return triangles;
  let minX, minY, invSize;
  if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
  if (data.length > 80 * dim) {
    minX = data[0];
    minY = data[1];
    let maxX = minX;
    let maxY = minY;
    for (let i = dim; i < outerLen; i += dim) {
      const x = data[i];
      const y = data[i + 1];
      if (x < minX) minX = x;
      if (y < minY) minY = y;
      if (x > maxX) maxX = x;
      if (y > maxY) maxY = y;
    }
    invSize = Math.max(maxX - minX, maxY - minY);
    invSize = invSize !== 0 ? 32767 / invSize : 0;
  }
  earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);
  return triangles;
}
function linkedList(data, start, end, dim, clockwise) {
  let last;
  if (clockwise === signedArea(data, start, end, dim) > 0) {
    for (let i = start; i < end; i += dim) last = insertNode(i / dim | 0, data[i], data[i + 1], last);
  } else {
    for (let i = end - dim; i >= start; i -= dim) last = insertNode(i / dim | 0, data[i], data[i + 1], last);
  }
  if (last && equals(last, last.next)) {
    removeNode(last);
    last = last.next;
  }
  return last;
}
function filterPoints(start, end) {
  if (!start) return start;
  if (!end) end = start;
  let p = start, again;
  do {
    again = false;
    if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
      removeNode(p);
      p = end = p.prev;
      if (p === p.next) break;
      again = true;
    } else {
      p = p.next;
    }
  } while (again || p !== end);
  return end;
}
function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass3) {
  if (!ear) return;
  if (!pass3 && invSize) indexCurve(ear, minX, minY, invSize);
  let stop = ear;
  while (ear.prev !== ear.next) {
    const prev = ear.prev;
    const next = ear.next;
    if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
      triangles.push(prev.i, ear.i, next.i);
      removeNode(ear);
      ear = next.next;
      stop = next.next;
      continue;
    }
    ear = next;
    if (ear === stop) {
      if (!pass3) {
        earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
      } else if (pass3 === 1) {
        ear = cureLocalIntersections(filterPoints(ear), triangles);
        earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
      } else if (pass3 === 2) {
        splitEarcut(ear, triangles, dim, minX, minY, invSize);
      }
      break;
    }
  }
}
function isEar(ear) {
  const a = ear.prev, b = ear, c3 = ear.next;
  if (area(a, b, c3) >= 0) return false;
  const ax = a.x, bx = b.x, cx = c3.x, ay = a.y, by = b.y, cy = c3.y;
  const x03 = Math.min(ax, bx, cx), y03 = Math.min(ay, by, cy), x12 = Math.max(ax, bx, cx), y12 = Math.max(ay, by, cy);
  let p = c3.next;
  while (p !== a) {
    if (p.x >= x03 && p.x <= x12 && p.y >= y03 && p.y <= y12 && pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
    p = p.next;
  }
  return true;
}
function isEarHashed(ear, minX, minY, invSize) {
  const a = ear.prev, b = ear, c3 = ear.next;
  if (area(a, b, c3) >= 0) return false;
  const ax = a.x, bx = b.x, cx = c3.x, ay = a.y, by = b.y, cy = c3.y;
  const x03 = Math.min(ax, bx, cx), y03 = Math.min(ay, by, cy), x12 = Math.max(ax, bx, cx), y12 = Math.max(ay, by, cy);
  const minZ = zOrder(x03, y03, minX, minY, invSize), maxZ = zOrder(x12, y12, minX, minY, invSize);
  let p = ear.prevZ, n = ear.nextZ;
  while (p && p.z >= minZ && n && n.z <= maxZ) {
    if (p.x >= x03 && p.x <= x12 && p.y >= y03 && p.y <= y12 && p !== a && p !== c3 && pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
    p = p.prevZ;
    if (n.x >= x03 && n.x <= x12 && n.y >= y03 && n.y <= y12 && n !== a && n !== c3 && pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
    n = n.nextZ;
  }
  while (p && p.z >= minZ) {
    if (p.x >= x03 && p.x <= x12 && p.y >= y03 && p.y <= y12 && p !== a && p !== c3 && pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
    p = p.prevZ;
  }
  while (n && n.z <= maxZ) {
    if (n.x >= x03 && n.x <= x12 && n.y >= y03 && n.y <= y12 && n !== a && n !== c3 && pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
    n = n.nextZ;
  }
  return true;
}
function cureLocalIntersections(start, triangles) {
  let p = start;
  do {
    const a = p.prev, b = p.next.next;
    if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
      triangles.push(a.i, p.i, b.i);
      removeNode(p);
      removeNode(p.next);
      p = start = b;
    }
    p = p.next;
  } while (p !== start);
  return filterPoints(p);
}
function splitEarcut(start, triangles, dim, minX, minY, invSize) {
  let a = start;
  do {
    let b = a.next.next;
    while (b !== a.prev) {
      if (a.i !== b.i && isValidDiagonal(a, b)) {
        let c3 = splitPolygon(a, b);
        a = filterPoints(a, a.next);
        c3 = filterPoints(c3, c3.next);
        earcutLinked(a, triangles, dim, minX, minY, invSize, 0);
        earcutLinked(c3, triangles, dim, minX, minY, invSize, 0);
        return;
      }
      b = b.next;
    }
    a = a.next;
  } while (a !== start);
}
function eliminateHoles(data, holeIndices, outerNode, dim) {
  const queue = [];
  for (let i = 0, len = holeIndices.length; i < len; i++) {
    const start = holeIndices[i] * dim;
    const end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
    const list = linkedList(data, start, end, dim, false);
    if (list === list.next) list.steiner = true;
    queue.push(getLeftmost(list));
  }
  queue.sort(compareXYSlope);
  for (let i = 0; i < queue.length; i++) {
    outerNode = eliminateHole(queue[i], outerNode);
  }
  return outerNode;
}
function compareXYSlope(a, b) {
  let result = a.x - b.x;
  if (result === 0) {
    result = a.y - b.y;
    if (result === 0) {
      const aSlope = (a.next.y - a.y) / (a.next.x - a.x);
      const bSlope = (b.next.y - b.y) / (b.next.x - b.x);
      result = aSlope - bSlope;
    }
  }
  return result;
}
function eliminateHole(hole, outerNode) {
  const bridge = findHoleBridge(hole, outerNode);
  if (!bridge) {
    return outerNode;
  }
  const bridgeReverse = splitPolygon(bridge, hole);
  filterPoints(bridgeReverse, bridgeReverse.next);
  return filterPoints(bridge, bridge.next);
}
function findHoleBridge(hole, outerNode) {
  let p = outerNode;
  const hx = hole.x;
  const hy = hole.y;
  let qx = -Infinity;
  let m;
  if (equals(hole, p)) return p;
  do {
    if (equals(hole, p.next)) return p.next;
    else if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
      const x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
      if (x <= hx && x > qx) {
        qx = x;
        m = p.x < p.next.x ? p : p.next;
        if (x === hx) return m;
      }
    }
    p = p.next;
  } while (p !== outerNode);
  if (!m) return null;
  const stop = m;
  const mx = m.x;
  const my = m.y;
  let tanMin = Infinity;
  p = m;
  do {
    if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
      const tan4 = Math.abs(hy - p.y) / (hx - p.x);
      if (locallyInside(p, hole) && (tan4 < tanMin || tan4 === tanMin && (p.x > m.x || p.x === m.x && sectorContainsSector(m, p)))) {
        m = p;
        tanMin = tan4;
      }
    }
    p = p.next;
  } while (p !== stop);
  return m;
}
function sectorContainsSector(m, p) {
  return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
}
function indexCurve(start, minX, minY, invSize) {
  let p = start;
  do {
    if (p.z === 0) p.z = zOrder(p.x, p.y, minX, minY, invSize);
    p.prevZ = p.prev;
    p.nextZ = p.next;
    p = p.next;
  } while (p !== start);
  p.prevZ.nextZ = null;
  p.prevZ = null;
  sortLinked(p);
}
function sortLinked(list) {
  let numMerges;
  let inSize = 1;
  do {
    let p = list;
    let e;
    list = null;
    let tail = null;
    numMerges = 0;
    while (p) {
      numMerges++;
      let q = p;
      let pSize = 0;
      for (let i = 0; i < inSize; i++) {
        pSize++;
        q = q.nextZ;
        if (!q) break;
      }
      let qSize = inSize;
      while (pSize > 0 || qSize > 0 && q) {
        if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
          e = p;
          p = p.nextZ;
          pSize--;
        } else {
          e = q;
          q = q.nextZ;
          qSize--;
        }
        if (tail) tail.nextZ = e;
        else list = e;
        e.prevZ = tail;
        tail = e;
      }
      p = q;
    }
    tail.nextZ = null;
    inSize *= 2;
  } while (numMerges > 1);
  return list;
}
function zOrder(x, y, minX, minY, invSize) {
  x = (x - minX) * invSize | 0;
  y = (y - minY) * invSize | 0;
  x = (x | x << 8) & 16711935;
  x = (x | x << 4) & 252645135;
  x = (x | x << 2) & 858993459;
  x = (x | x << 1) & 1431655765;
  y = (y | y << 8) & 16711935;
  y = (y | y << 4) & 252645135;
  y = (y | y << 2) & 858993459;
  y = (y | y << 1) & 1431655765;
  return x | y << 1;
}
function getLeftmost(start) {
  let p = start, leftmost = start;
  do {
    if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y) leftmost = p;
    p = p.next;
  } while (p !== start);
  return leftmost;
}
function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
  return (cx - px) * (ay - py) >= (ax - px) * (cy - py) && (ax - px) * (by - py) >= (bx - px) * (ay - py) && (bx - px) * (cy - py) >= (cx - px) * (by - py);
}
function pointInTriangleExceptFirst(ax, ay, bx, by, cx, cy, px, py) {
  return !(ax === px && ay === py) && pointInTriangle(ax, ay, bx, by, cx, cy, px, py);
}
function isValidDiagonal(a, b) {
  return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // doesn't intersect other edges
  (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible
  (area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors
  equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0);
}
function area(p, q, r) {
  return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
}
function equals(p1, p2) {
  return p1.x === p2.x && p1.y === p2.y;
}
function intersects(p1, q12, p2, q2) {
  const o1 = sign2(area(p1, q12, p2));
  const o2 = sign2(area(p1, q12, q2));
  const o3 = sign2(area(p2, q2, p1));
  const o4 = sign2(area(p2, q2, q12));
  if (o1 !== o2 && o3 !== o4) return true;
  if (o1 === 0 && onSegment(p1, p2, q12)) return true;
  if (o2 === 0 && onSegment(p1, q2, q12)) return true;
  if (o3 === 0 && onSegment(p2, p1, q2)) return true;
  if (o4 === 0 && onSegment(p2, q12, q2)) return true;
  return false;
}
function onSegment(p, q, r) {
  return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
}
function sign2(num) {
  return num > 0 ? 1 : num < 0 ? -1 : 0;
}
function intersectsPolygon(a, b) {
  let p = a;
  do {
    if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b)) return true;
    p = p.next;
  } while (p !== a);
  return false;
}
function locallyInside(a, b) {
  return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
}
function middleInside(a, b) {
  let p = a;
  let inside = false;
  const px = (a.x + b.x) / 2;
  const py = (a.y + b.y) / 2;
  do {
    if (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x)
      inside = !inside;
    p = p.next;
  } while (p !== a);
  return inside;
}
function splitPolygon(a, b) {
  const a2 = createNode(a.i, a.x, a.y), b2 = createNode(b.i, b.x, b.y), an = a.next, bp = b.prev;
  a.next = b;
  b.prev = a;
  a2.next = an;
  an.prev = a2;
  b2.next = a2;
  a2.prev = b2;
  bp.next = b2;
  b2.prev = bp;
  return b2;
}
function insertNode(i, x, y, last) {
  const p = createNode(i, x, y);
  if (!last) {
    p.prev = p;
    p.next = p;
  } else {
    p.next = last.next;
    p.prev = last;
    last.next.prev = p;
    last.next = p;
  }
  return p;
}
function removeNode(p) {
  p.next.prev = p.prev;
  p.prev.next = p.next;
  if (p.prevZ) p.prevZ.nextZ = p.nextZ;
  if (p.nextZ) p.nextZ.prevZ = p.prevZ;
}
function createNode(i, x, y) {
  return {
    i,
    // vertex index in coordinates array
    x,
    y,
    // vertex coordinates
    prev: null,
    // previous and next vertex nodes in a polygon ring
    next: null,
    z: 0,
    // z-order curve value
    prevZ: null,
    // previous and next nodes in z-order
    nextZ: null,
    steiner: false
    // indicates whether this is a steiner point
  };
}
function signedArea(data, start, end, dim) {
  let sum3 = 0;
  for (let i = start, j = end - dim; i < end; i += dim) {
    sum3 += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
    j = i;
  }
  return sum3;
}
function flatten2(data) {
  const vertices = [];
  const holes = [];
  const dimensions = data[0][0].length;
  let holeIndex = 0;
  let prevLen = 0;
  for (const ring of data) {
    for (const p of ring) {
      for (let d = 0; d < dimensions; d++) vertices.push(p[d]);
    }
    if (prevLen) {
      holeIndex += prevLen;
      holes.push(holeIndex);
    }
    prevLen = ring.length;
  }
  return { vertices, holes, dimensions };
}

// node_modules/three-geojson-geometry/dist/three-geojson-geometry.mjs
function _arrayLikeToArray3(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}
function _arrayWithHoles3(r) {
  if (Array.isArray(r)) return r;
}
function _arrayWithoutHoles2(r) {
  if (Array.isArray(r)) return _arrayLikeToArray3(r);
}
function _assertThisInitialized2(e) {
  if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function _callSuper2(t, o, e) {
  return o = _getPrototypeOf2(o), _possibleConstructorReturn2(t, _isNativeReflectConstruct2() ? Reflect.construct(o, [], _getPrototypeOf2(t).constructor) : o.apply(t, e));
}
function _classCallCheck3(a, n) {
  if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
}
function _createClass3(e, r, t) {
  return Object.defineProperty(e, "prototype", {
    writable: false
  }), e;
}
function _createForOfIteratorHelper(r, e) {
  var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (!t) {
    if (Array.isArray(r) || (t = _unsupportedIterableToArray3(r)) || e) {
      t && (r = t);
      var n = 0, F = function() {
      };
      return {
        s: F,
        n: function() {
          return n >= r.length ? {
            done: true
          } : {
            done: false,
            value: r[n++]
          };
        },
        e: function(r2) {
          throw r2;
        },
        f: F
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var o, a = true, u4 = false;
  return {
    s: function() {
      t = t.call(r);
    },
    n: function() {
      var r2 = t.next();
      return a = r2.done, r2;
    },
    e: function(r2) {
      u4 = true, o = r2;
    },
    f: function() {
      try {
        a || null == t.return || t.return();
      } finally {
        if (u4) throw o;
      }
    }
  };
}
function _getPrototypeOf2(t) {
  return _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t4) {
    return t4.__proto__ || Object.getPrototypeOf(t4);
  }, _getPrototypeOf2(t);
}
function _inherits2(t, e) {
  if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
  t.prototype = Object.create(e && e.prototype, {
    constructor: {
      value: t,
      writable: true,
      configurable: true
    }
  }), Object.defineProperty(t, "prototype", {
    writable: false
  }), e && _setPrototypeOf2(t, e);
}
function _isNativeReflectConstruct2() {
  try {
    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (t4) {
  }
  return (_isNativeReflectConstruct2 = function() {
    return !!t;
  })();
}
function _iterableToArray2(r) {
  if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
}
function _iterableToArrayLimit3(r, l) {
  var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (null != t) {
    var e, n, i, u4, a = [], f = true, o = false;
    try {
      if (i = (t = t.call(r)).next, 0 === l) {
        if (Object(t) !== t) return;
        f = false;
      } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = true) ;
    } catch (r2) {
      o = true, n = r2;
    } finally {
      try {
        if (!f && null != t.return && (u4 = t.return(), Object(u4) !== u4)) return;
      } finally {
        if (o) throw n;
      }
    }
    return a;
  }
}
function _nonIterableRest3() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _nonIterableSpread2() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _possibleConstructorReturn2(t, e) {
  if (e && ("object" == typeof e || "function" == typeof e)) return e;
  if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
  return _assertThisInitialized2(t);
}
function _setPrototypeOf2(t, e) {
  return _setPrototypeOf2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t4, e3) {
    return t4.__proto__ = e3, t4;
  }, _setPrototypeOf2(t, e);
}
function _slicedToArray3(r, e) {
  return _arrayWithHoles3(r) || _iterableToArrayLimit3(r, e) || _unsupportedIterableToArray3(r, e) || _nonIterableRest3();
}
function _toConsumableArray2(r) {
  return _arrayWithoutHoles2(r) || _iterableToArray2(r) || _unsupportedIterableToArray3(r) || _nonIterableSpread2();
}
function _unsupportedIterableToArray3(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray3(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray3(r, a) : void 0;
  }
}
var interpolateLine = function interpolateLine2() {
  var lineCoords = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  var maxDegDistance = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
  var result = [];
  var prevPnt = null;
  lineCoords.forEach(function(pnt) {
    if (prevPnt) {
      var dist2 = distance_default(pnt, prevPnt) * 180 / Math.PI;
      if (dist2 > maxDegDistance) {
        var geoInterpol = interpolate_default(prevPnt, pnt);
        var altInterpol = prevPnt.length > 2 || pnt.length > 2 ? number_default(prevPnt[2] || 0, pnt[2] || 0) : null;
        var interpol = altInterpol ? function(t4) {
          return [].concat(_toConsumableArray2(geoInterpol(t4)), [altInterpol(t4)]);
        } : geoInterpol;
        var tStep = 1 / Math.ceil(dist2 / maxDegDistance);
        var t = tStep;
        while (t < 1) {
          result.push(interpol(t));
          t += tStep;
        }
      }
    }
    result.push(prevPnt = pnt);
  });
  return result;
};
var THREE = typeof window !== "undefined" && window.THREE ? window.THREE : {
  BufferGeometry,
  Float32BufferAttribute
};
var setAttributeFn = new THREE.BufferGeometry().setAttribute ? "setAttribute" : "addAttribute";
var GeoJsonGeometry = function(_THREE$BufferGeometry) {
  function GeoJsonGeometry2(geoJson) {
    var _this;
    var radius = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
    var resolution2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 5;
    _classCallCheck3(this, GeoJsonGeometry2);
    _this = _callSuper2(this, GeoJsonGeometry2);
    _this.type = "GeoJsonGeometry";
    _this.parameters = {
      geoJson,
      radius,
      resolution: resolution2
    };
    var groups2 = ({
      Point: genPoint,
      MultiPoint: genMultiPoint,
      LineString: genLineString,
      MultiLineString: genMultiLineString,
      Polygon: genPolygon,
      MultiPolygon: genMultiPolygon
    }[geoJson.type] || function() {
      return [];
    })(geoJson.coordinates, radius);
    var indices = [], vertices = [];
    var groupCnt = 0;
    groups2.forEach(function(newG) {
      var prevIndCnt = indices.length;
      concatGroup({
        indices,
        vertices
      }, newG);
      _this.addGroup(prevIndCnt, indices.length - prevIndCnt, groupCnt++);
    });
    indices.length && _this.setIndex(indices);
    vertices.length && _this[setAttributeFn]("position", new THREE.Float32BufferAttribute(vertices, 3));
    function genPoint(coords, r) {
      var vertices2 = polar2Cartesian2(coords[1], coords[0], r + (coords[2] || 0));
      var indices2 = [];
      return [{
        vertices: vertices2,
        indices: indices2
      }];
    }
    function genMultiPoint(coords, r) {
      var result = {
        vertices: [],
        indices: []
      };
      coords.map(function(c3) {
        return genPoint(c3, r);
      }).forEach(function(_ref) {
        var _ref2 = _slicedToArray3(_ref, 1), newPnt = _ref2[0];
        concatGroup(result, newPnt);
      });
      return [result];
    }
    function genLineString(coords, r) {
      var coords3d = interpolateLine(coords, resolution2).map(function(_ref3) {
        var _ref4 = _slicedToArray3(_ref3, 3), lng = _ref4[0], lat = _ref4[1], _ref4$ = _ref4[2], alt = _ref4$ === void 0 ? 0 : _ref4$;
        return polar2Cartesian2(lat, lng, r + alt);
      });
      var _earcutFlatten = flatten2([coords3d]), vertices2 = _earcutFlatten.vertices;
      var numPoints = Math.round(vertices2.length / 3);
      var indices2 = [];
      for (var vIdx = 1; vIdx < numPoints; vIdx++) {
        indices2.push(vIdx - 1, vIdx);
      }
      return [{
        vertices: vertices2,
        indices: indices2
      }];
    }
    function genMultiLineString(coords, r) {
      var result = {
        vertices: [],
        indices: []
      };
      coords.map(function(c3) {
        return genLineString(c3, r);
      }).forEach(function(_ref5) {
        var _ref6 = _slicedToArray3(_ref5, 1), newLine = _ref6[0];
        concatGroup(result, newLine);
      });
      return [result];
    }
    function genPolygon(coords, r) {
      var coords3d = coords.map(function(coordsSegment) {
        return interpolateLine(coordsSegment, resolution2).map(function(_ref7) {
          var _ref8 = _slicedToArray3(_ref7, 3), lng = _ref8[0], lat = _ref8[1], _ref8$ = _ref8[2], alt = _ref8$ === void 0 ? 0 : _ref8$;
          return polar2Cartesian2(lat, lng, r + alt);
        });
      });
      var _earcutFlatten2 = flatten2(coords3d), vertices2 = _earcutFlatten2.vertices, holes = _earcutFlatten2.holes;
      var firstHoleIdx = holes[0] || Infinity;
      var outerVertices = vertices2.slice(0, firstHoleIdx * 3);
      var holeVertices = vertices2.slice(firstHoleIdx * 3);
      var holesIdx = new Set(holes);
      var numPoints = Math.round(vertices2.length / 3);
      var outerIndices = [], holeIndices = [];
      for (var vIdx = 1; vIdx < numPoints; vIdx++) {
        if (!holesIdx.has(vIdx)) {
          if (vIdx < firstHoleIdx) {
            outerIndices.push(vIdx - 1, vIdx);
          } else {
            holeIndices.push(vIdx - 1 - firstHoleIdx, vIdx - firstHoleIdx);
          }
        }
      }
      var groups3 = [{
        indices: outerIndices,
        vertices: outerVertices
      }];
      if (holes.length) {
        groups3.push({
          indices: holeIndices,
          vertices: holeVertices
        });
      }
      return groups3;
    }
    function genMultiPolygon(coords, r) {
      var outer = {
        vertices: [],
        indices: []
      };
      var holes = {
        vertices: [],
        indices: []
      };
      coords.map(function(c3) {
        return genPolygon(c3, r);
      }).forEach(function(_ref9) {
        var _ref10 = _slicedToArray3(_ref9, 2), newOuter = _ref10[0], newHoles = _ref10[1];
        concatGroup(outer, newOuter);
        newHoles && concatGroup(holes, newHoles);
      });
      var groups3 = [outer];
      holes.vertices.length && groups3.push(holes);
      return groups3;
    }
    return _this;
  }
  _inherits2(GeoJsonGeometry2, _THREE$BufferGeometry);
  return _createClass3(GeoJsonGeometry2);
}(THREE.BufferGeometry);
function concatGroup(main, extra) {
  var prevVertCnt = Math.round(main.vertices.length / 3);
  concatArr(main.vertices, extra.vertices);
  concatArr(main.indices, extra.indices.map(function(ind) {
    return ind + prevVertCnt;
  }));
}
function concatArr(target, src) {
  var _iterator = _createForOfIteratorHelper(src), _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
      var e = _step.value;
      target.push(e);
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
}
function polar2Cartesian2(lat, lng) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
  var phi = (90 - lat) * Math.PI / 180;
  var theta = (90 - lng) * Math.PI / 180;
  return [
    r * Math.sin(phi) * Math.cos(theta),
    // x
    r * Math.cos(phi),
    // y
    r * Math.sin(phi) * Math.sin(theta)
    // z
  ];
}

// node_modules/three/examples/jsm/utils/BufferGeometryUtils.js
var BufferGeometryUtils_exports = {};
__export(BufferGeometryUtils_exports, {
  computeMikkTSpaceTangents: () => computeMikkTSpaceTangents,
  computeMorphedAttributes: () => computeMorphedAttributes,
  deepCloneAttribute: () => deepCloneAttribute,
  deinterleaveAttribute: () => deinterleaveAttribute,
  deinterleaveGeometry: () => deinterleaveGeometry,
  estimateBytesUsed: () => estimateBytesUsed,
  interleaveAttributes: () => interleaveAttributes,
  mergeAttributes: () => mergeAttributes,
  mergeGeometries: () => mergeGeometries,
  mergeGroups: () => mergeGroups,
  mergeVertices: () => mergeVertices,
  toCreasedNormals: () => toCreasedNormals,
  toTrianglesDrawMode: () => toTrianglesDrawMode
});
function computeMikkTSpaceTangents(geometry, MikkTSpace, negateSign = true) {
  if (!MikkTSpace || !MikkTSpace.isReady) {
    throw new Error("BufferGeometryUtils: Initialized MikkTSpace library required.");
  }
  if (!geometry.hasAttribute("position") || !geometry.hasAttribute("normal") || !geometry.hasAttribute("uv")) {
    throw new Error('BufferGeometryUtils: Tangents require "position", "normal", and "uv" attributes.');
  }
  function getAttributeArray(attribute3) {
    if (attribute3.normalized || attribute3.isInterleavedBufferAttribute) {
      const dstArray = new Float32Array(attribute3.count * attribute3.itemSize);
      for (let i = 0, j = 0; i < attribute3.count; i++) {
        dstArray[j++] = attribute3.getX(i);
        dstArray[j++] = attribute3.getY(i);
        if (attribute3.itemSize > 2) {
          dstArray[j++] = attribute3.getZ(i);
        }
      }
      return dstArray;
    }
    if (attribute3.array instanceof Float32Array) {
      return attribute3.array;
    }
    return new Float32Array(attribute3.array);
  }
  const _geometry2 = geometry.index ? geometry.toNonIndexed() : geometry;
  const tangents = MikkTSpace.generateTangents(
    getAttributeArray(_geometry2.attributes.position),
    getAttributeArray(_geometry2.attributes.normal),
    getAttributeArray(_geometry2.attributes.uv)
  );
  if (negateSign) {
    for (let i = 3; i < tangents.length; i += 4) {
      tangents[i] *= -1;
    }
  }
  _geometry2.setAttribute("tangent", new BufferAttribute(tangents, 4));
  if (geometry !== _geometry2) {
    geometry.copy(_geometry2);
  }
  return geometry;
}
function mergeGeometries(geometries, useGroups = false) {
  const isIndexed = geometries[0].index !== null;
  const attributesUsed = new Set(Object.keys(geometries[0].attributes));
  const morphAttributesUsed = new Set(Object.keys(geometries[0].morphAttributes));
  const attributes = {};
  const morphAttributes = {};
  const morphTargetsRelative = geometries[0].morphTargetsRelative;
  const mergedGeometry = new BufferGeometry();
  let offset = 0;
  for (let i = 0; i < geometries.length; ++i) {
    const geometry = geometries[i];
    let attributesCount = 0;
    if (isIndexed !== (geometry.index !== null)) {
      console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + i + ". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.");
      return null;
    }
    for (const name in geometry.attributes) {
      if (!attributesUsed.has(name)) {
        console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + i + '. All geometries must have compatible attributes; make sure "' + name + '" attribute exists among all geometries, or in none of them.');
        return null;
      }
      if (attributes[name] === void 0) attributes[name] = [];
      attributes[name].push(geometry.attributes[name]);
      attributesCount++;
    }
    if (attributesCount !== attributesUsed.size) {
      console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + i + ". Make sure all geometries have the same number of attributes.");
      return null;
    }
    if (morphTargetsRelative !== geometry.morphTargetsRelative) {
      console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + i + ". .morphTargetsRelative must be consistent throughout all geometries.");
      return null;
    }
    for (const name in geometry.morphAttributes) {
      if (!morphAttributesUsed.has(name)) {
        console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + i + ".  .morphAttributes must be consistent throughout all geometries.");
        return null;
      }
      if (morphAttributes[name] === void 0) morphAttributes[name] = [];
      morphAttributes[name].push(geometry.morphAttributes[name]);
    }
    if (useGroups) {
      let count2;
      if (isIndexed) {
        count2 = geometry.index.count;
      } else if (geometry.attributes.position !== void 0) {
        count2 = geometry.attributes.position.count;
      } else {
        console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + i + ". The geometry must have either an index or a position attribute");
        return null;
      }
      mergedGeometry.addGroup(offset, count2, i);
      offset += count2;
    }
  }
  if (isIndexed) {
    let indexOffset = 0;
    const mergedIndex = [];
    for (let i = 0; i < geometries.length; ++i) {
      const index5 = geometries[i].index;
      for (let j = 0; j < index5.count; ++j) {
        mergedIndex.push(index5.getX(j) + indexOffset);
      }
      indexOffset += geometries[i].attributes.position.count;
    }
    mergedGeometry.setIndex(mergedIndex);
  }
  for (const name in attributes) {
    const mergedAttribute = mergeAttributes(attributes[name]);
    if (!mergedAttribute) {
      console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the " + name + " attribute.");
      return null;
    }
    mergedGeometry.setAttribute(name, mergedAttribute);
  }
  for (const name in morphAttributes) {
    const numMorphTargets = morphAttributes[name][0].length;
    if (numMorphTargets === 0) break;
    mergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};
    mergedGeometry.morphAttributes[name] = [];
    for (let i = 0; i < numMorphTargets; ++i) {
      const morphAttributesToMerge = [];
      for (let j = 0; j < morphAttributes[name].length; ++j) {
        morphAttributesToMerge.push(morphAttributes[name][j][i]);
      }
      const mergedMorphAttribute = mergeAttributes(morphAttributesToMerge);
      if (!mergedMorphAttribute) {
        console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the " + name + " morphAttribute.");
        return null;
      }
      mergedGeometry.morphAttributes[name].push(mergedMorphAttribute);
    }
  }
  return mergedGeometry;
}
function mergeAttributes(attributes) {
  let TypedArray;
  let itemSize;
  let normalized;
  let gpuType = -1;
  let arrayLength = 0;
  for (let i = 0; i < attributes.length; ++i) {
    const attribute3 = attributes[i];
    if (TypedArray === void 0) TypedArray = attribute3.array.constructor;
    if (TypedArray !== attribute3.array.constructor) {
      console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.");
      return null;
    }
    if (itemSize === void 0) itemSize = attribute3.itemSize;
    if (itemSize !== attribute3.itemSize) {
      console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.");
      return null;
    }
    if (normalized === void 0) normalized = attribute3.normalized;
    if (normalized !== attribute3.normalized) {
      console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.");
      return null;
    }
    if (gpuType === -1) gpuType = attribute3.gpuType;
    if (gpuType !== attribute3.gpuType) {
      console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.gpuType must be consistent across matching attributes.");
      return null;
    }
    arrayLength += attribute3.count * itemSize;
  }
  const array4 = new TypedArray(arrayLength);
  const result = new BufferAttribute(array4, itemSize, normalized);
  let offset = 0;
  for (let i = 0; i < attributes.length; ++i) {
    const attribute3 = attributes[i];
    if (attribute3.isInterleavedBufferAttribute) {
      const tupleOffset = offset / itemSize;
      for (let j = 0, l = attribute3.count; j < l; j++) {
        for (let c3 = 0; c3 < itemSize; c3++) {
          const value = attribute3.getComponent(j, c3);
          result.setComponent(j + tupleOffset, c3, value);
        }
      }
    } else {
      array4.set(attribute3.array, offset);
    }
    offset += attribute3.count * itemSize;
  }
  if (gpuType !== void 0) {
    result.gpuType = gpuType;
  }
  return result;
}
function deepCloneAttribute(attribute3) {
  if (attribute3.isInstancedInterleavedBufferAttribute || attribute3.isInterleavedBufferAttribute) {
    return deinterleaveAttribute(attribute3);
  }
  if (attribute3.isInstancedBufferAttribute) {
    return new InstancedBufferAttribute().copy(attribute3);
  }
  return new BufferAttribute().copy(attribute3);
}
function interleaveAttributes(attributes) {
  let TypedArray;
  let arrayLength = 0;
  let stride = 0;
  for (let i = 0, l = attributes.length; i < l; ++i) {
    const attribute3 = attributes[i];
    if (TypedArray === void 0) TypedArray = attribute3.array.constructor;
    if (TypedArray !== attribute3.array.constructor) {
      console.error("AttributeBuffers of different types cannot be interleaved");
      return null;
    }
    arrayLength += attribute3.array.length;
    stride += attribute3.itemSize;
  }
  const interleavedBuffer = new InterleavedBuffer(new TypedArray(arrayLength), stride);
  let offset = 0;
  const res = [];
  const getters = ["getX", "getY", "getZ", "getW"];
  const setters = ["setX", "setY", "setZ", "setW"];
  for (let j = 0, l = attributes.length; j < l; j++) {
    const attribute3 = attributes[j];
    const itemSize = attribute3.itemSize;
    const count2 = attribute3.count;
    const iba = new InterleavedBufferAttribute(interleavedBuffer, itemSize, offset, attribute3.normalized);
    res.push(iba);
    offset += itemSize;
    for (let c3 = 0; c3 < count2; c3++) {
      for (let k = 0; k < itemSize; k++) {
        iba[setters[k]](c3, attribute3[getters[k]](c3));
      }
    }
  }
  return res;
}
function deinterleaveAttribute(attribute3) {
  const cons = attribute3.data.array.constructor;
  const count2 = attribute3.count;
  const itemSize = attribute3.itemSize;
  const normalized = attribute3.normalized;
  const array4 = new cons(count2 * itemSize);
  let newAttribute;
  if (attribute3.isInstancedInterleavedBufferAttribute) {
    newAttribute = new InstancedBufferAttribute(array4, itemSize, normalized, attribute3.meshPerAttribute);
  } else {
    newAttribute = new BufferAttribute(array4, itemSize, normalized);
  }
  for (let i = 0; i < count2; i++) {
    newAttribute.setX(i, attribute3.getX(i));
    if (itemSize >= 2) {
      newAttribute.setY(i, attribute3.getY(i));
    }
    if (itemSize >= 3) {
      newAttribute.setZ(i, attribute3.getZ(i));
    }
    if (itemSize >= 4) {
      newAttribute.setW(i, attribute3.getW(i));
    }
  }
  return newAttribute;
}
function deinterleaveGeometry(geometry) {
  const attributes = geometry.attributes;
  const morphTargets = geometry.morphTargets;
  const attrMap = /* @__PURE__ */ new Map();
  for (const key in attributes) {
    const attr = attributes[key];
    if (attr.isInterleavedBufferAttribute) {
      if (!attrMap.has(attr)) {
        attrMap.set(attr, deinterleaveAttribute(attr));
      }
      attributes[key] = attrMap.get(attr);
    }
  }
  for (const key in morphTargets) {
    const attr = morphTargets[key];
    if (attr.isInterleavedBufferAttribute) {
      if (!attrMap.has(attr)) {
        attrMap.set(attr, deinterleaveAttribute(attr));
      }
      morphTargets[key] = attrMap.get(attr);
    }
  }
}
function estimateBytesUsed(geometry) {
  let mem = 0;
  for (const name in geometry.attributes) {
    const attr = geometry.getAttribute(name);
    mem += attr.count * attr.itemSize * attr.array.BYTES_PER_ELEMENT;
  }
  const indices = geometry.getIndex();
  mem += indices ? indices.count * indices.itemSize * indices.array.BYTES_PER_ELEMENT : 0;
  return mem;
}
function mergeVertices(geometry, tolerance = 1e-4) {
  tolerance = Math.max(tolerance, Number.EPSILON);
  const hashToIndex = {};
  const indices = geometry.getIndex();
  const positions = geometry.getAttribute("position");
  const vertexCount = indices ? indices.count : positions.count;
  let nextIndex = 0;
  const attributeNames = Object.keys(geometry.attributes);
  const tmpAttributes = {};
  const tmpMorphAttributes = {};
  const newIndices = [];
  const getters = ["getX", "getY", "getZ", "getW"];
  const setters = ["setX", "setY", "setZ", "setW"];
  for (let i = 0, l = attributeNames.length; i < l; i++) {
    const name = attributeNames[i];
    const attr = geometry.attributes[name];
    tmpAttributes[name] = new attr.constructor(
      new attr.array.constructor(attr.count * attr.itemSize),
      attr.itemSize,
      attr.normalized
    );
    const morphAttributes = geometry.morphAttributes[name];
    if (morphAttributes) {
      if (!tmpMorphAttributes[name]) tmpMorphAttributes[name] = [];
      morphAttributes.forEach((morphAttr, i2) => {
        const array4 = new morphAttr.array.constructor(morphAttr.count * morphAttr.itemSize);
        tmpMorphAttributes[name][i2] = new morphAttr.constructor(array4, morphAttr.itemSize, morphAttr.normalized);
      });
    }
  }
  const halfTolerance = tolerance * 0.5;
  const exponent = Math.log10(1 / tolerance);
  const hashMultiplier = Math.pow(10, exponent);
  const hashAdditive = halfTolerance * hashMultiplier;
  for (let i = 0; i < vertexCount; i++) {
    const index5 = indices ? indices.getX(i) : i;
    let hash3 = "";
    for (let j = 0, l = attributeNames.length; j < l; j++) {
      const name = attributeNames[j];
      const attribute3 = geometry.getAttribute(name);
      const itemSize = attribute3.itemSize;
      for (let k = 0; k < itemSize; k++) {
        hash3 += `${~~(attribute3[getters[k]](index5) * hashMultiplier + hashAdditive)},`;
      }
    }
    if (hash3 in hashToIndex) {
      newIndices.push(hashToIndex[hash3]);
    } else {
      for (let j = 0, l = attributeNames.length; j < l; j++) {
        const name = attributeNames[j];
        const attribute3 = geometry.getAttribute(name);
        const morphAttributes = geometry.morphAttributes[name];
        const itemSize = attribute3.itemSize;
        const newArray = tmpAttributes[name];
        const newMorphArrays = tmpMorphAttributes[name];
        for (let k = 0; k < itemSize; k++) {
          const getterFunc = getters[k];
          const setterFunc = setters[k];
          newArray[setterFunc](nextIndex, attribute3[getterFunc](index5));
          if (morphAttributes) {
            for (let m = 0, ml = morphAttributes.length; m < ml; m++) {
              newMorphArrays[m][setterFunc](nextIndex, morphAttributes[m][getterFunc](index5));
            }
          }
        }
      }
      hashToIndex[hash3] = nextIndex;
      newIndices.push(nextIndex);
      nextIndex++;
    }
  }
  const result = geometry.clone();
  for (const name in geometry.attributes) {
    const tmpAttribute = tmpAttributes[name];
    result.setAttribute(name, new tmpAttribute.constructor(
      tmpAttribute.array.slice(0, nextIndex * tmpAttribute.itemSize),
      tmpAttribute.itemSize,
      tmpAttribute.normalized
    ));
    if (!(name in tmpMorphAttributes)) continue;
    for (let j = 0; j < tmpMorphAttributes[name].length; j++) {
      const tmpMorphAttribute = tmpMorphAttributes[name][j];
      result.morphAttributes[name][j] = new tmpMorphAttribute.constructor(
        tmpMorphAttribute.array.slice(0, nextIndex * tmpMorphAttribute.itemSize),
        tmpMorphAttribute.itemSize,
        tmpMorphAttribute.normalized
      );
    }
  }
  result.setIndex(newIndices);
  return result;
}
function toTrianglesDrawMode(geometry, drawMode) {
  if (drawMode === TrianglesDrawMode) {
    console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.");
    return geometry;
  }
  if (drawMode === TriangleFanDrawMode || drawMode === TriangleStripDrawMode) {
    let index5 = geometry.getIndex();
    if (index5 === null) {
      const indices = [];
      const position = geometry.getAttribute("position");
      if (position !== void 0) {
        for (let i = 0; i < position.count; i++) {
          indices.push(i);
        }
        geometry.setIndex(indices);
        index5 = geometry.getIndex();
      } else {
        console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.");
        return geometry;
      }
    }
    const numberOfTriangles = index5.count - 2;
    const newIndices = [];
    if (drawMode === TriangleFanDrawMode) {
      for (let i = 1; i <= numberOfTriangles; i++) {
        newIndices.push(index5.getX(0));
        newIndices.push(index5.getX(i));
        newIndices.push(index5.getX(i + 1));
      }
    } else {
      for (let i = 0; i < numberOfTriangles; i++) {
        if (i % 2 === 0) {
          newIndices.push(index5.getX(i));
          newIndices.push(index5.getX(i + 1));
          newIndices.push(index5.getX(i + 2));
        } else {
          newIndices.push(index5.getX(i + 2));
          newIndices.push(index5.getX(i + 1));
          newIndices.push(index5.getX(i));
        }
      }
    }
    if (newIndices.length / 3 !== numberOfTriangles) {
      console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
    }
    const newGeometry = geometry.clone();
    newGeometry.setIndex(newIndices);
    newGeometry.clearGroups();
    return newGeometry;
  } else {
    console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:", drawMode);
    return geometry;
  }
}
function computeMorphedAttributes(object2) {
  const _vA = new Vector3();
  const _vB = new Vector3();
  const _vC = new Vector3();
  const _tempA = new Vector3();
  const _tempB = new Vector3();
  const _tempC = new Vector3();
  const _morphA = new Vector3();
  const _morphB = new Vector3();
  const _morphC = new Vector3();
  function _calculateMorphedAttributeData(object3, attribute3, morphAttribute, morphTargetsRelative2, a2, b2, c4, modifiedAttributeArray) {
    _vA.fromBufferAttribute(attribute3, a2);
    _vB.fromBufferAttribute(attribute3, b2);
    _vC.fromBufferAttribute(attribute3, c4);
    const morphInfluences = object3.morphTargetInfluences;
    if (morphAttribute && morphInfluences) {
      _morphA.set(0, 0, 0);
      _morphB.set(0, 0, 0);
      _morphC.set(0, 0, 0);
      for (let i2 = 0, il2 = morphAttribute.length; i2 < il2; i2++) {
        const influence = morphInfluences[i2];
        const morph = morphAttribute[i2];
        if (influence === 0) continue;
        _tempA.fromBufferAttribute(morph, a2);
        _tempB.fromBufferAttribute(morph, b2);
        _tempC.fromBufferAttribute(morph, c4);
        if (morphTargetsRelative2) {
          _morphA.addScaledVector(_tempA, influence);
          _morphB.addScaledVector(_tempB, influence);
          _morphC.addScaledVector(_tempC, influence);
        } else {
          _morphA.addScaledVector(_tempA.sub(_vA), influence);
          _morphB.addScaledVector(_tempB.sub(_vB), influence);
          _morphC.addScaledVector(_tempC.sub(_vC), influence);
        }
      }
      _vA.add(_morphA);
      _vB.add(_morphB);
      _vC.add(_morphC);
    }
    if (object3.isSkinnedMesh) {
      object3.applyBoneTransform(a2, _vA);
      object3.applyBoneTransform(b2, _vB);
      object3.applyBoneTransform(c4, _vC);
    }
    modifiedAttributeArray[a2 * 3 + 0] = _vA.x;
    modifiedAttributeArray[a2 * 3 + 1] = _vA.y;
    modifiedAttributeArray[a2 * 3 + 2] = _vA.z;
    modifiedAttributeArray[b2 * 3 + 0] = _vB.x;
    modifiedAttributeArray[b2 * 3 + 1] = _vB.y;
    modifiedAttributeArray[b2 * 3 + 2] = _vB.z;
    modifiedAttributeArray[c4 * 3 + 0] = _vC.x;
    modifiedAttributeArray[c4 * 3 + 1] = _vC.y;
    modifiedAttributeArray[c4 * 3 + 2] = _vC.z;
  }
  const geometry = object2.geometry;
  const material = object2.material;
  let a, b, c3;
  const index5 = geometry.index;
  const positionAttribute = geometry.attributes.position;
  const morphPosition = geometry.morphAttributes.position;
  const morphTargetsRelative = geometry.morphTargetsRelative;
  const normalAttribute = geometry.attributes.normal;
  const morphNormal = geometry.morphAttributes.position;
  const groups2 = geometry.groups;
  const drawRange = geometry.drawRange;
  let i, j, il, jl;
  let group2;
  let start, end;
  const modifiedPosition = new Float32Array(positionAttribute.count * positionAttribute.itemSize);
  const modifiedNormal = new Float32Array(normalAttribute.count * normalAttribute.itemSize);
  if (index5 !== null) {
    if (Array.isArray(material)) {
      for (i = 0, il = groups2.length; i < il; i++) {
        group2 = groups2[i];
        start = Math.max(group2.start, drawRange.start);
        end = Math.min(group2.start + group2.count, drawRange.start + drawRange.count);
        for (j = start, jl = end; j < jl; j += 3) {
          a = index5.getX(j);
          b = index5.getX(j + 1);
          c3 = index5.getX(j + 2);
          _calculateMorphedAttributeData(
            object2,
            positionAttribute,
            morphPosition,
            morphTargetsRelative,
            a,
            b,
            c3,
            modifiedPosition
          );
          _calculateMorphedAttributeData(
            object2,
            normalAttribute,
            morphNormal,
            morphTargetsRelative,
            a,
            b,
            c3,
            modifiedNormal
          );
        }
      }
    } else {
      start = Math.max(0, drawRange.start);
      end = Math.min(index5.count, drawRange.start + drawRange.count);
      for (i = start, il = end; i < il; i += 3) {
        a = index5.getX(i);
        b = index5.getX(i + 1);
        c3 = index5.getX(i + 2);
        _calculateMorphedAttributeData(
          object2,
          positionAttribute,
          morphPosition,
          morphTargetsRelative,
          a,
          b,
          c3,
          modifiedPosition
        );
        _calculateMorphedAttributeData(
          object2,
          normalAttribute,
          morphNormal,
          morphTargetsRelative,
          a,
          b,
          c3,
          modifiedNormal
        );
      }
    }
  } else {
    if (Array.isArray(material)) {
      for (i = 0, il = groups2.length; i < il; i++) {
        group2 = groups2[i];
        start = Math.max(group2.start, drawRange.start);
        end = Math.min(group2.start + group2.count, drawRange.start + drawRange.count);
        for (j = start, jl = end; j < jl; j += 3) {
          a = j;
          b = j + 1;
          c3 = j + 2;
          _calculateMorphedAttributeData(
            object2,
            positionAttribute,
            morphPosition,
            morphTargetsRelative,
            a,
            b,
            c3,
            modifiedPosition
          );
          _calculateMorphedAttributeData(
            object2,
            normalAttribute,
            morphNormal,
            morphTargetsRelative,
            a,
            b,
            c3,
            modifiedNormal
          );
        }
      }
    } else {
      start = Math.max(0, drawRange.start);
      end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);
      for (i = start, il = end; i < il; i += 3) {
        a = i;
        b = i + 1;
        c3 = i + 2;
        _calculateMorphedAttributeData(
          object2,
          positionAttribute,
          morphPosition,
          morphTargetsRelative,
          a,
          b,
          c3,
          modifiedPosition
        );
        _calculateMorphedAttributeData(
          object2,
          normalAttribute,
          morphNormal,
          morphTargetsRelative,
          a,
          b,
          c3,
          modifiedNormal
        );
      }
    }
  }
  const morphedPositionAttribute = new Float32BufferAttribute(modifiedPosition, 3);
  const morphedNormalAttribute = new Float32BufferAttribute(modifiedNormal, 3);
  return {
    positionAttribute,
    normalAttribute,
    morphedPositionAttribute,
    morphedNormalAttribute
  };
}
function mergeGroups(geometry) {
  if (geometry.groups.length === 0) {
    console.warn("THREE.BufferGeometryUtils.mergeGroups(): No groups are defined. Nothing to merge.");
    return geometry;
  }
  let groups2 = geometry.groups;
  groups2 = groups2.sort((a, b) => {
    if (a.materialIndex !== b.materialIndex) return a.materialIndex - b.materialIndex;
    return a.start - b.start;
  });
  if (geometry.getIndex() === null) {
    const positionAttribute = geometry.getAttribute("position");
    const indices = [];
    for (let i = 0; i < positionAttribute.count; i += 3) {
      indices.push(i, i + 1, i + 2);
    }
    geometry.setIndex(indices);
  }
  const index5 = geometry.getIndex();
  const newIndices = [];
  for (let i = 0; i < groups2.length; i++) {
    const group2 = groups2[i];
    const groupStart = group2.start;
    const groupLength = groupStart + group2.count;
    for (let j = groupStart; j < groupLength; j++) {
      newIndices.push(index5.getX(j));
    }
  }
  geometry.dispose();
  geometry.setIndex(newIndices);
  let start = 0;
  for (let i = 0; i < groups2.length; i++) {
    const group2 = groups2[i];
    group2.start = start;
    start += group2.count;
  }
  let currentGroup = groups2[0];
  geometry.groups = [currentGroup];
  for (let i = 1; i < groups2.length; i++) {
    const group2 = groups2[i];
    if (currentGroup.materialIndex === group2.materialIndex) {
      currentGroup.count += group2.count;
    } else {
      currentGroup = group2;
      geometry.groups.push(currentGroup);
    }
  }
  return geometry;
}
function toCreasedNormals(geometry, creaseAngle = Math.PI / 3) {
  const creaseDot = Math.cos(creaseAngle);
  const hashMultiplier = (1 + 1e-10) * 100;
  const verts = [new Vector3(), new Vector3(), new Vector3()];
  const tempVec1 = new Vector3();
  const tempVec2 = new Vector3();
  const tempNorm = new Vector3();
  const tempNorm2 = new Vector3();
  function hashVertex(v2) {
    const x = ~~(v2.x * hashMultiplier);
    const y = ~~(v2.y * hashMultiplier);
    const z = ~~(v2.z * hashMultiplier);
    return `${x},${y},${z}`;
  }
  const resultGeometry = geometry.index ? geometry.toNonIndexed() : geometry;
  const posAttr = resultGeometry.attributes.position;
  const vertexMap = {};
  for (let i = 0, l = posAttr.count / 3; i < l; i++) {
    const i3 = 3 * i;
    const a = verts[0].fromBufferAttribute(posAttr, i3 + 0);
    const b = verts[1].fromBufferAttribute(posAttr, i3 + 1);
    const c3 = verts[2].fromBufferAttribute(posAttr, i3 + 2);
    tempVec1.subVectors(c3, b);
    tempVec2.subVectors(a, b);
    const normal2 = new Vector3().crossVectors(tempVec1, tempVec2).normalize();
    for (let n = 0; n < 3; n++) {
      const vert = verts[n];
      const hash3 = hashVertex(vert);
      if (!(hash3 in vertexMap)) {
        vertexMap[hash3] = [];
      }
      vertexMap[hash3].push(normal2);
    }
  }
  const normalArray = new Float32Array(posAttr.count * 3);
  const normAttr = new BufferAttribute(normalArray, 3, false);
  for (let i = 0, l = posAttr.count / 3; i < l; i++) {
    const i3 = 3 * i;
    const a = verts[0].fromBufferAttribute(posAttr, i3 + 0);
    const b = verts[1].fromBufferAttribute(posAttr, i3 + 1);
    const c3 = verts[2].fromBufferAttribute(posAttr, i3 + 2);
    tempVec1.subVectors(c3, b);
    tempVec2.subVectors(a, b);
    tempNorm.crossVectors(tempVec1, tempVec2).normalize();
    for (let n = 0; n < 3; n++) {
      const vert = verts[n];
      const hash3 = hashVertex(vert);
      const otherNormals = vertexMap[hash3];
      tempNorm2.set(0, 0, 0);
      for (let k = 0, lk = otherNormals.length; k < lk; k++) {
        const otherNorm = otherNormals[k];
        if (tempNorm.dot(otherNorm) > creaseDot) {
          tempNorm2.add(otherNorm);
        }
      }
      tempNorm2.normalize();
      normAttr.setXYZ(i3 + n, tempNorm2.x, tempNorm2.y, tempNorm2.z);
    }
  }
  resultGeometry.setAttribute("normal", normAttr);
  return resultGeometry;
}

// node_modules/accessor-fn/dist/accessor-fn.mjs
var index3 = function(p) {
  return typeof p === "function" ? p : typeof p === "string" ? function(obj) {
    return obj[p];
  } : function(obj) {
    return p;
  };
};

// node_modules/tinycolor2/esm/tinycolor.js
function _typeof(obj) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof(obj);
}
var trimLeft = /^\s+/;
var trimRight = /\s+$/;
function tinycolor(color4, opts) {
  color4 = color4 ? color4 : "";
  opts = opts || {};
  if (color4 instanceof tinycolor) {
    return color4;
  }
  if (!(this instanceof tinycolor)) {
    return new tinycolor(color4, opts);
  }
  var rgb2 = inputToRGB(color4);
  this._originalInput = color4, this._r = rgb2.r, this._g = rgb2.g, this._b = rgb2.b, this._a = rgb2.a, this._roundA = Math.round(100 * this._a) / 100, this._format = opts.format || rgb2.format;
  this._gradientType = opts.gradientType;
  if (this._r < 1) this._r = Math.round(this._r);
  if (this._g < 1) this._g = Math.round(this._g);
  if (this._b < 1) this._b = Math.round(this._b);
  this._ok = rgb2.ok;
}
tinycolor.prototype = {
  isDark: function isDark() {
    return this.getBrightness() < 128;
  },
  isLight: function isLight() {
    return !this.isDark();
  },
  isValid: function isValid() {
    return this._ok;
  },
  getOriginalInput: function getOriginalInput() {
    return this._originalInput;
  },
  getFormat: function getFormat() {
    return this._format;
  },
  getAlpha: function getAlpha() {
    return this._a;
  },
  getBrightness: function getBrightness() {
    var rgb2 = this.toRgb();
    return (rgb2.r * 299 + rgb2.g * 587 + rgb2.b * 114) / 1e3;
  },
  getLuminance: function getLuminance() {
    var rgb2 = this.toRgb();
    var RsRGB, GsRGB, BsRGB, R, G, B4;
    RsRGB = rgb2.r / 255;
    GsRGB = rgb2.g / 255;
    BsRGB = rgb2.b / 255;
    if (RsRGB <= 0.03928) R = RsRGB / 12.92;
    else R = Math.pow((RsRGB + 0.055) / 1.055, 2.4);
    if (GsRGB <= 0.03928) G = GsRGB / 12.92;
    else G = Math.pow((GsRGB + 0.055) / 1.055, 2.4);
    if (BsRGB <= 0.03928) B4 = BsRGB / 12.92;
    else B4 = Math.pow((BsRGB + 0.055) / 1.055, 2.4);
    return 0.2126 * R + 0.7152 * G + 0.0722 * B4;
  },
  setAlpha: function setAlpha(value) {
    this._a = boundAlpha(value);
    this._roundA = Math.round(100 * this._a) / 100;
    return this;
  },
  toHsv: function toHsv() {
    var hsv = rgbToHsv(this._r, this._g, this._b);
    return {
      h: hsv.h * 360,
      s: hsv.s,
      v: hsv.v,
      a: this._a
    };
  },
  toHsvString: function toHsvString() {
    var hsv = rgbToHsv(this._r, this._g, this._b);
    var h = Math.round(hsv.h * 360), s = Math.round(hsv.s * 100), v2 = Math.round(hsv.v * 100);
    return this._a == 1 ? "hsv(" + h + ", " + s + "%, " + v2 + "%)" : "hsva(" + h + ", " + s + "%, " + v2 + "%, " + this._roundA + ")";
  },
  toHsl: function toHsl() {
    var hsl3 = rgbToHsl(this._r, this._g, this._b);
    return {
      h: hsl3.h * 360,
      s: hsl3.s,
      l: hsl3.l,
      a: this._a
    };
  },
  toHslString: function toHslString() {
    var hsl3 = rgbToHsl(this._r, this._g, this._b);
    var h = Math.round(hsl3.h * 360), s = Math.round(hsl3.s * 100), l = Math.round(hsl3.l * 100);
    return this._a == 1 ? "hsl(" + h + ", " + s + "%, " + l + "%)" : "hsla(" + h + ", " + s + "%, " + l + "%, " + this._roundA + ")";
  },
  toHex: function toHex(allow3Char) {
    return rgbToHex(this._r, this._g, this._b, allow3Char);
  },
  toHexString: function toHexString(allow3Char) {
    return "#" + this.toHex(allow3Char);
  },
  toHex8: function toHex8(allow4Char) {
    return rgbaToHex(this._r, this._g, this._b, this._a, allow4Char);
  },
  toHex8String: function toHex8String(allow4Char) {
    return "#" + this.toHex8(allow4Char);
  },
  toRgb: function toRgb() {
    return {
      r: Math.round(this._r),
      g: Math.round(this._g),
      b: Math.round(this._b),
      a: this._a
    };
  },
  toRgbString: function toRgbString() {
    return this._a == 1 ? "rgb(" + Math.round(this._r) + ", " + Math.round(this._g) + ", " + Math.round(this._b) + ")" : "rgba(" + Math.round(this._r) + ", " + Math.round(this._g) + ", " + Math.round(this._b) + ", " + this._roundA + ")";
  },
  toPercentageRgb: function toPercentageRgb() {
    return {
      r: Math.round(bound01(this._r, 255) * 100) + "%",
      g: Math.round(bound01(this._g, 255) * 100) + "%",
      b: Math.round(bound01(this._b, 255) * 100) + "%",
      a: this._a
    };
  },
  toPercentageRgbString: function toPercentageRgbString() {
    return this._a == 1 ? "rgb(" + Math.round(bound01(this._r, 255) * 100) + "%, " + Math.round(bound01(this._g, 255) * 100) + "%, " + Math.round(bound01(this._b, 255) * 100) + "%)" : "rgba(" + Math.round(bound01(this._r, 255) * 100) + "%, " + Math.round(bound01(this._g, 255) * 100) + "%, " + Math.round(bound01(this._b, 255) * 100) + "%, " + this._roundA + ")";
  },
  toName: function toName() {
    if (this._a === 0) {
      return "transparent";
    }
    if (this._a < 1) {
      return false;
    }
    return hexNames[rgbToHex(this._r, this._g, this._b, true)] || false;
  },
  toFilter: function toFilter(secondColor) {
    var hex8String = "#" + rgbaToArgbHex(this._r, this._g, this._b, this._a);
    var secondHex8String = hex8String;
    var gradientType = this._gradientType ? "GradientType = 1, " : "";
    if (secondColor) {
      var s = tinycolor(secondColor);
      secondHex8String = "#" + rgbaToArgbHex(s._r, s._g, s._b, s._a);
    }
    return "progid:DXImageTransform.Microsoft.gradient(" + gradientType + "startColorstr=" + hex8String + ",endColorstr=" + secondHex8String + ")";
  },
  toString: function toString(format2) {
    var formatSet = !!format2;
    format2 = format2 || this._format;
    var formattedString = false;
    var hasAlpha = this._a < 1 && this._a >= 0;
    var needsAlphaFormat = !formatSet && hasAlpha && (format2 === "hex" || format2 === "hex6" || format2 === "hex3" || format2 === "hex4" || format2 === "hex8" || format2 === "name");
    if (needsAlphaFormat) {
      if (format2 === "name" && this._a === 0) {
        return this.toName();
      }
      return this.toRgbString();
    }
    if (format2 === "rgb") {
      formattedString = this.toRgbString();
    }
    if (format2 === "prgb") {
      formattedString = this.toPercentageRgbString();
    }
    if (format2 === "hex" || format2 === "hex6") {
      formattedString = this.toHexString();
    }
    if (format2 === "hex3") {
      formattedString = this.toHexString(true);
    }
    if (format2 === "hex4") {
      formattedString = this.toHex8String(true);
    }
    if (format2 === "hex8") {
      formattedString = this.toHex8String();
    }
    if (format2 === "name") {
      formattedString = this.toName();
    }
    if (format2 === "hsl") {
      formattedString = this.toHslString();
    }
    if (format2 === "hsv") {
      formattedString = this.toHsvString();
    }
    return formattedString || this.toHexString();
  },
  clone: function clone() {
    return tinycolor(this.toString());
  },
  _applyModification: function _applyModification(fn, args) {
    var color4 = fn.apply(null, [this].concat([].slice.call(args)));
    this._r = color4._r;
    this._g = color4._g;
    this._b = color4._b;
    this.setAlpha(color4._a);
    return this;
  },
  lighten: function lighten() {
    return this._applyModification(_lighten, arguments);
  },
  brighten: function brighten() {
    return this._applyModification(_brighten, arguments);
  },
  darken: function darken() {
    return this._applyModification(_darken, arguments);
  },
  desaturate: function desaturate() {
    return this._applyModification(_desaturate, arguments);
  },
  saturate: function saturate() {
    return this._applyModification(_saturate, arguments);
  },
  greyscale: function greyscale() {
    return this._applyModification(_greyscale, arguments);
  },
  spin: function spin() {
    return this._applyModification(_spin, arguments);
  },
  _applyCombination: function _applyCombination(fn, args) {
    return fn.apply(null, [this].concat([].slice.call(args)));
  },
  analogous: function analogous() {
    return this._applyCombination(_analogous, arguments);
  },
  complement: function complement() {
    return this._applyCombination(_complement, arguments);
  },
  monochromatic: function monochromatic() {
    return this._applyCombination(_monochromatic, arguments);
  },
  splitcomplement: function splitcomplement() {
    return this._applyCombination(_splitcomplement, arguments);
  },
  // Disabled until https://github.com/bgrins/TinyColor/issues/254
  // polyad: function (number) {
  //   return this._applyCombination(polyad, [number]);
  // },
  triad: function triad() {
    return this._applyCombination(polyad, [3]);
  },
  tetrad: function tetrad() {
    return this._applyCombination(polyad, [4]);
  }
};
tinycolor.fromRatio = function(color4, opts) {
  if (_typeof(color4) == "object") {
    var newColor = {};
    for (var i in color4) {
      if (color4.hasOwnProperty(i)) {
        if (i === "a") {
          newColor[i] = color4[i];
        } else {
          newColor[i] = convertToPercentage(color4[i]);
        }
      }
    }
    color4 = newColor;
  }
  return tinycolor(color4, opts);
};
function inputToRGB(color4) {
  var rgb2 = {
    r: 0,
    g: 0,
    b: 0
  };
  var a = 1;
  var s = null;
  var v2 = null;
  var l = null;
  var ok = false;
  var format2 = false;
  if (typeof color4 == "string") {
    color4 = stringInputToObject(color4);
  }
  if (_typeof(color4) == "object") {
    if (isValidCSSUnit(color4.r) && isValidCSSUnit(color4.g) && isValidCSSUnit(color4.b)) {
      rgb2 = rgbToRgb(color4.r, color4.g, color4.b);
      ok = true;
      format2 = String(color4.r).substr(-1) === "%" ? "prgb" : "rgb";
    } else if (isValidCSSUnit(color4.h) && isValidCSSUnit(color4.s) && isValidCSSUnit(color4.v)) {
      s = convertToPercentage(color4.s);
      v2 = convertToPercentage(color4.v);
      rgb2 = hsvToRgb(color4.h, s, v2);
      ok = true;
      format2 = "hsv";
    } else if (isValidCSSUnit(color4.h) && isValidCSSUnit(color4.s) && isValidCSSUnit(color4.l)) {
      s = convertToPercentage(color4.s);
      l = convertToPercentage(color4.l);
      rgb2 = hslToRgb(color4.h, s, l);
      ok = true;
      format2 = "hsl";
    }
    if (color4.hasOwnProperty("a")) {
      a = color4.a;
    }
  }
  a = boundAlpha(a);
  return {
    ok,
    format: color4.format || format2,
    r: Math.min(255, Math.max(rgb2.r, 0)),
    g: Math.min(255, Math.max(rgb2.g, 0)),
    b: Math.min(255, Math.max(rgb2.b, 0)),
    a
  };
}
function rgbToRgb(r, g, b) {
  return {
    r: bound01(r, 255) * 255,
    g: bound01(g, 255) * 255,
    b: bound01(b, 255) * 255
  };
}
function rgbToHsl(r, g, b) {
  r = bound01(r, 255);
  g = bound01(g, 255);
  b = bound01(b, 255);
  var max5 = Math.max(r, g, b), min5 = Math.min(r, g, b);
  var h, s, l = (max5 + min5) / 2;
  if (max5 == min5) {
    h = s = 0;
  } else {
    var d = max5 - min5;
    s = l > 0.5 ? d / (2 - max5 - min5) : d / (max5 + min5);
    switch (max5) {
      case r:
        h = (g - b) / d + (g < b ? 6 : 0);
        break;
      case g:
        h = (b - r) / d + 2;
        break;
      case b:
        h = (r - g) / d + 4;
        break;
    }
    h /= 6;
  }
  return {
    h,
    s,
    l
  };
}
function hslToRgb(h, s, l) {
  var r, g, b;
  h = bound01(h, 360);
  s = bound01(s, 100);
  l = bound01(l, 100);
  function hue2rgb(p2, q2, t) {
    if (t < 0) t += 1;
    if (t > 1) t -= 1;
    if (t < 1 / 6) return p2 + (q2 - p2) * 6 * t;
    if (t < 1 / 2) return q2;
    if (t < 2 / 3) return p2 + (q2 - p2) * (2 / 3 - t) * 6;
    return p2;
  }
  if (s === 0) {
    r = g = b = l;
  } else {
    var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    var p = 2 * l - q;
    r = hue2rgb(p, q, h + 1 / 3);
    g = hue2rgb(p, q, h);
    b = hue2rgb(p, q, h - 1 / 3);
  }
  return {
    r: r * 255,
    g: g * 255,
    b: b * 255
  };
}
function rgbToHsv(r, g, b) {
  r = bound01(r, 255);
  g = bound01(g, 255);
  b = bound01(b, 255);
  var max5 = Math.max(r, g, b), min5 = Math.min(r, g, b);
  var h, s, v2 = max5;
  var d = max5 - min5;
  s = max5 === 0 ? 0 : d / max5;
  if (max5 == min5) {
    h = 0;
  } else {
    switch (max5) {
      case r:
        h = (g - b) / d + (g < b ? 6 : 0);
        break;
      case g:
        h = (b - r) / d + 2;
        break;
      case b:
        h = (r - g) / d + 4;
        break;
    }
    h /= 6;
  }
  return {
    h,
    s,
    v: v2
  };
}
function hsvToRgb(h, s, v2) {
  h = bound01(h, 360) * 6;
  s = bound01(s, 100);
  v2 = bound01(v2, 100);
  var i = Math.floor(h), f = h - i, p = v2 * (1 - s), q = v2 * (1 - f * s), t = v2 * (1 - (1 - f) * s), mod3 = i % 6, r = [v2, q, p, p, t, v2][mod3], g = [t, v2, v2, q, p, p][mod3], b = [p, p, t, v2, v2, q][mod3];
  return {
    r: r * 255,
    g: g * 255,
    b: b * 255
  };
}
function rgbToHex(r, g, b, allow3Char) {
  var hex2 = [pad2(Math.round(r).toString(16)), pad2(Math.round(g).toString(16)), pad2(Math.round(b).toString(16))];
  if (allow3Char && hex2[0].charAt(0) == hex2[0].charAt(1) && hex2[1].charAt(0) == hex2[1].charAt(1) && hex2[2].charAt(0) == hex2[2].charAt(1)) {
    return hex2[0].charAt(0) + hex2[1].charAt(0) + hex2[2].charAt(0);
  }
  return hex2.join("");
}
function rgbaToHex(r, g, b, a, allow4Char) {
  var hex2 = [pad2(Math.round(r).toString(16)), pad2(Math.round(g).toString(16)), pad2(Math.round(b).toString(16)), pad2(convertDecimalToHex(a))];
  if (allow4Char && hex2[0].charAt(0) == hex2[0].charAt(1) && hex2[1].charAt(0) == hex2[1].charAt(1) && hex2[2].charAt(0) == hex2[2].charAt(1) && hex2[3].charAt(0) == hex2[3].charAt(1)) {
    return hex2[0].charAt(0) + hex2[1].charAt(0) + hex2[2].charAt(0) + hex2[3].charAt(0);
  }
  return hex2.join("");
}
function rgbaToArgbHex(r, g, b, a) {
  var hex2 = [pad2(convertDecimalToHex(a)), pad2(Math.round(r).toString(16)), pad2(Math.round(g).toString(16)), pad2(Math.round(b).toString(16))];
  return hex2.join("");
}
tinycolor.equals = function(color1, color22) {
  if (!color1 || !color22) return false;
  return tinycolor(color1).toRgbString() == tinycolor(color22).toRgbString();
};
tinycolor.random = function() {
  return tinycolor.fromRatio({
    r: Math.random(),
    g: Math.random(),
    b: Math.random()
  });
};
function _desaturate(color4, amount) {
  amount = amount === 0 ? 0 : amount || 10;
  var hsl3 = tinycolor(color4).toHsl();
  hsl3.s -= amount / 100;
  hsl3.s = clamp01(hsl3.s);
  return tinycolor(hsl3);
}
function _saturate(color4, amount) {
  amount = amount === 0 ? 0 : amount || 10;
  var hsl3 = tinycolor(color4).toHsl();
  hsl3.s += amount / 100;
  hsl3.s = clamp01(hsl3.s);
  return tinycolor(hsl3);
}
function _greyscale(color4) {
  return tinycolor(color4).desaturate(100);
}
function _lighten(color4, amount) {
  amount = amount === 0 ? 0 : amount || 10;
  var hsl3 = tinycolor(color4).toHsl();
  hsl3.l += amount / 100;
  hsl3.l = clamp01(hsl3.l);
  return tinycolor(hsl3);
}
function _brighten(color4, amount) {
  amount = amount === 0 ? 0 : amount || 10;
  var rgb2 = tinycolor(color4).toRgb();
  rgb2.r = Math.max(0, Math.min(255, rgb2.r - Math.round(255 * -(amount / 100))));
  rgb2.g = Math.max(0, Math.min(255, rgb2.g - Math.round(255 * -(amount / 100))));
  rgb2.b = Math.max(0, Math.min(255, rgb2.b - Math.round(255 * -(amount / 100))));
  return tinycolor(rgb2);
}
function _darken(color4, amount) {
  amount = amount === 0 ? 0 : amount || 10;
  var hsl3 = tinycolor(color4).toHsl();
  hsl3.l -= amount / 100;
  hsl3.l = clamp01(hsl3.l);
  return tinycolor(hsl3);
}
function _spin(color4, amount) {
  var hsl3 = tinycolor(color4).toHsl();
  var hue4 = (hsl3.h + amount) % 360;
  hsl3.h = hue4 < 0 ? 360 + hue4 : hue4;
  return tinycolor(hsl3);
}
function _complement(color4) {
  var hsl3 = tinycolor(color4).toHsl();
  hsl3.h = (hsl3.h + 180) % 360;
  return tinycolor(hsl3);
}
function polyad(color4, number3) {
  if (isNaN(number3) || number3 <= 0) {
    throw new Error("Argument to polyad must be a positive number");
  }
  var hsl3 = tinycolor(color4).toHsl();
  var result = [tinycolor(color4)];
  var step3 = 360 / number3;
  for (var i = 1; i < number3; i++) {
    result.push(tinycolor({
      h: (hsl3.h + i * step3) % 360,
      s: hsl3.s,
      l: hsl3.l
    }));
  }
  return result;
}
function _splitcomplement(color4) {
  var hsl3 = tinycolor(color4).toHsl();
  var h = hsl3.h;
  return [tinycolor(color4), tinycolor({
    h: (h + 72) % 360,
    s: hsl3.s,
    l: hsl3.l
  }), tinycolor({
    h: (h + 216) % 360,
    s: hsl3.s,
    l: hsl3.l
  })];
}
function _analogous(color4, results, slices) {
  results = results || 6;
  slices = slices || 30;
  var hsl3 = tinycolor(color4).toHsl();
  var part = 360 / slices;
  var ret = [tinycolor(color4)];
  for (hsl3.h = (hsl3.h - (part * results >> 1) + 720) % 360; --results; ) {
    hsl3.h = (hsl3.h + part) % 360;
    ret.push(tinycolor(hsl3));
  }
  return ret;
}
function _monochromatic(color4, results) {
  results = results || 6;
  var hsv = tinycolor(color4).toHsv();
  var h = hsv.h, s = hsv.s, v2 = hsv.v;
  var ret = [];
  var modification = 1 / results;
  while (results--) {
    ret.push(tinycolor({
      h,
      s,
      v: v2
    }));
    v2 = (v2 + modification) % 1;
  }
  return ret;
}
tinycolor.mix = function(color1, color22, amount) {
  amount = amount === 0 ? 0 : amount || 50;
  var rgb1 = tinycolor(color1).toRgb();
  var rgb2 = tinycolor(color22).toRgb();
  var p = amount / 100;
  var rgba2 = {
    r: (rgb2.r - rgb1.r) * p + rgb1.r,
    g: (rgb2.g - rgb1.g) * p + rgb1.g,
    b: (rgb2.b - rgb1.b) * p + rgb1.b,
    a: (rgb2.a - rgb1.a) * p + rgb1.a
  };
  return tinycolor(rgba2);
};
tinycolor.readability = function(color1, color22) {
  var c1 = tinycolor(color1);
  var c22 = tinycolor(color22);
  return (Math.max(c1.getLuminance(), c22.getLuminance()) + 0.05) / (Math.min(c1.getLuminance(), c22.getLuminance()) + 0.05);
};
tinycolor.isReadable = function(color1, color22, wcag2) {
  var readability = tinycolor.readability(color1, color22);
  var wcag2Parms, out;
  out = false;
  wcag2Parms = validateWCAG2Parms(wcag2);
  switch (wcag2Parms.level + wcag2Parms.size) {
    case "AAsmall":
    case "AAAlarge":
      out = readability >= 4.5;
      break;
    case "AAlarge":
      out = readability >= 3;
      break;
    case "AAAsmall":
      out = readability >= 7;
      break;
  }
  return out;
};
tinycolor.mostReadable = function(baseColor, colorList, args) {
  var bestColor = null;
  var bestScore = 0;
  var readability;
  var includeFallbackColors, level, size;
  args = args || {};
  includeFallbackColors = args.includeFallbackColors;
  level = args.level;
  size = args.size;
  for (var i = 0; i < colorList.length; i++) {
    readability = tinycolor.readability(baseColor, colorList[i]);
    if (readability > bestScore) {
      bestScore = readability;
      bestColor = tinycolor(colorList[i]);
    }
  }
  if (tinycolor.isReadable(baseColor, bestColor, {
    level,
    size
  }) || !includeFallbackColors) {
    return bestColor;
  } else {
    args.includeFallbackColors = false;
    return tinycolor.mostReadable(baseColor, ["#fff", "#000"], args);
  }
};
var names = tinycolor.names = {
  aliceblue: "f0f8ff",
  antiquewhite: "faebd7",
  aqua: "0ff",
  aquamarine: "7fffd4",
  azure: "f0ffff",
  beige: "f5f5dc",
  bisque: "ffe4c4",
  black: "000",
  blanchedalmond: "ffebcd",
  blue: "00f",
  blueviolet: "8a2be2",
  brown: "a52a2a",
  burlywood: "deb887",
  burntsienna: "ea7e5d",
  cadetblue: "5f9ea0",
  chartreuse: "7fff00",
  chocolate: "d2691e",
  coral: "ff7f50",
  cornflowerblue: "6495ed",
  cornsilk: "fff8dc",
  crimson: "dc143c",
  cyan: "0ff",
  darkblue: "00008b",
  darkcyan: "008b8b",
  darkgoldenrod: "b8860b",
  darkgray: "a9a9a9",
  darkgreen: "006400",
  darkgrey: "a9a9a9",
  darkkhaki: "bdb76b",
  darkmagenta: "8b008b",
  darkolivegreen: "556b2f",
  darkorange: "ff8c00",
  darkorchid: "9932cc",
  darkred: "8b0000",
  darksalmon: "e9967a",
  darkseagreen: "8fbc8f",
  darkslateblue: "483d8b",
  darkslategray: "2f4f4f",
  darkslategrey: "2f4f4f",
  darkturquoise: "00ced1",
  darkviolet: "9400d3",
  deeppink: "ff1493",
  deepskyblue: "00bfff",
  dimgray: "696969",
  dimgrey: "696969",
  dodgerblue: "1e90ff",
  firebrick: "b22222",
  floralwhite: "fffaf0",
  forestgreen: "228b22",
  fuchsia: "f0f",
  gainsboro: "dcdcdc",
  ghostwhite: "f8f8ff",
  gold: "ffd700",
  goldenrod: "daa520",
  gray: "808080",
  green: "008000",
  greenyellow: "adff2f",
  grey: "808080",
  honeydew: "f0fff0",
  hotpink: "ff69b4",
  indianred: "cd5c5c",
  indigo: "4b0082",
  ivory: "fffff0",
  khaki: "f0e68c",
  lavender: "e6e6fa",
  lavenderblush: "fff0f5",
  lawngreen: "7cfc00",
  lemonchiffon: "fffacd",
  lightblue: "add8e6",
  lightcoral: "f08080",
  lightcyan: "e0ffff",
  lightgoldenrodyellow: "fafad2",
  lightgray: "d3d3d3",
  lightgreen: "90ee90",
  lightgrey: "d3d3d3",
  lightpink: "ffb6c1",
  lightsalmon: "ffa07a",
  lightseagreen: "20b2aa",
  lightskyblue: "87cefa",
  lightslategray: "789",
  lightslategrey: "789",
  lightsteelblue: "b0c4de",
  lightyellow: "ffffe0",
  lime: "0f0",
  limegreen: "32cd32",
  linen: "faf0e6",
  magenta: "f0f",
  maroon: "800000",
  mediumaquamarine: "66cdaa",
  mediumblue: "0000cd",
  mediumorchid: "ba55d3",
  mediumpurple: "9370db",
  mediumseagreen: "3cb371",
  mediumslateblue: "7b68ee",
  mediumspringgreen: "00fa9a",
  mediumturquoise: "48d1cc",
  mediumvioletred: "c71585",
  midnightblue: "191970",
  mintcream: "f5fffa",
  mistyrose: "ffe4e1",
  moccasin: "ffe4b5",
  navajowhite: "ffdead",
  navy: "000080",
  oldlace: "fdf5e6",
  olive: "808000",
  olivedrab: "6b8e23",
  orange: "ffa500",
  orangered: "ff4500",
  orchid: "da70d6",
  palegoldenrod: "eee8aa",
  palegreen: "98fb98",
  paleturquoise: "afeeee",
  palevioletred: "db7093",
  papayawhip: "ffefd5",
  peachpuff: "ffdab9",
  peru: "cd853f",
  pink: "ffc0cb",
  plum: "dda0dd",
  powderblue: "b0e0e6",
  purple: "800080",
  rebeccapurple: "663399",
  red: "f00",
  rosybrown: "bc8f8f",
  royalblue: "4169e1",
  saddlebrown: "8b4513",
  salmon: "fa8072",
  sandybrown: "f4a460",
  seagreen: "2e8b57",
  seashell: "fff5ee",
  sienna: "a0522d",
  silver: "c0c0c0",
  skyblue: "87ceeb",
  slateblue: "6a5acd",
  slategray: "708090",
  slategrey: "708090",
  snow: "fffafa",
  springgreen: "00ff7f",
  steelblue: "4682b4",
  tan: "d2b48c",
  teal: "008080",
  thistle: "d8bfd8",
  tomato: "ff6347",
  turquoise: "40e0d0",
  violet: "ee82ee",
  wheat: "f5deb3",
  white: "fff",
  whitesmoke: "f5f5f5",
  yellow: "ff0",
  yellowgreen: "9acd32"
};
var hexNames = tinycolor.hexNames = flip(names);
function flip(o) {
  var flipped = {};
  for (var i in o) {
    if (o.hasOwnProperty(i)) {
      flipped[o[i]] = i;
    }
  }
  return flipped;
}
function boundAlpha(a) {
  a = parseFloat(a);
  if (isNaN(a) || a < 0 || a > 1) {
    a = 1;
  }
  return a;
}
function bound01(n, max5) {
  if (isOnePointZero(n)) n = "100%";
  var processPercent = isPercentage(n);
  n = Math.min(max5, Math.max(0, parseFloat(n)));
  if (processPercent) {
    n = parseInt(n * max5, 10) / 100;
  }
  if (Math.abs(n - max5) < 1e-6) {
    return 1;
  }
  return n % max5 / parseFloat(max5);
}
function clamp01(val) {
  return Math.min(1, Math.max(0, val));
}
function parseIntFromHex(val) {
  return parseInt(val, 16);
}
function isOnePointZero(n) {
  return typeof n == "string" && n.indexOf(".") != -1 && parseFloat(n) === 1;
}
function isPercentage(n) {
  return typeof n === "string" && n.indexOf("%") != -1;
}
function pad2(c3) {
  return c3.length == 1 ? "0" + c3 : "" + c3;
}
function convertToPercentage(n) {
  if (n <= 1) {
    n = n * 100 + "%";
  }
  return n;
}
function convertDecimalToHex(d) {
  return Math.round(parseFloat(d) * 255).toString(16);
}
function convertHexToDecimal(h) {
  return parseIntFromHex(h) / 255;
}
var matchers = function() {
  var CSS_INTEGER = "[-\\+]?\\d+%?";
  var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";
  var CSS_UNIT = "(?:" + CSS_NUMBER + ")|(?:" + CSS_INTEGER + ")";
  var PERMISSIVE_MATCH3 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
  var PERMISSIVE_MATCH4 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
  return {
    CSS_UNIT: new RegExp(CSS_UNIT),
    rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
    rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
    hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
    hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
    hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
    hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
    hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
    hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
  };
}();
function isValidCSSUnit(color4) {
  return !!matchers.CSS_UNIT.exec(color4);
}
function stringInputToObject(color4) {
  color4 = color4.replace(trimLeft, "").replace(trimRight, "").toLowerCase();
  var named2 = false;
  if (names[color4]) {
    color4 = names[color4];
    named2 = true;
  } else if (color4 == "transparent") {
    return {
      r: 0,
      g: 0,
      b: 0,
      a: 0,
      format: "name"
    };
  }
  var match;
  if (match = matchers.rgb.exec(color4)) {
    return {
      r: match[1],
      g: match[2],
      b: match[3]
    };
  }
  if (match = matchers.rgba.exec(color4)) {
    return {
      r: match[1],
      g: match[2],
      b: match[3],
      a: match[4]
    };
  }
  if (match = matchers.hsl.exec(color4)) {
    return {
      h: match[1],
      s: match[2],
      l: match[3]
    };
  }
  if (match = matchers.hsla.exec(color4)) {
    return {
      h: match[1],
      s: match[2],
      l: match[3],
      a: match[4]
    };
  }
  if (match = matchers.hsv.exec(color4)) {
    return {
      h: match[1],
      s: match[2],
      v: match[3]
    };
  }
  if (match = matchers.hsva.exec(color4)) {
    return {
      h: match[1],
      s: match[2],
      v: match[3],
      a: match[4]
    };
  }
  if (match = matchers.hex8.exec(color4)) {
    return {
      r: parseIntFromHex(match[1]),
      g: parseIntFromHex(match[2]),
      b: parseIntFromHex(match[3]),
      a: convertHexToDecimal(match[4]),
      format: named2 ? "name" : "hex8"
    };
  }
  if (match = matchers.hex6.exec(color4)) {
    return {
      r: parseIntFromHex(match[1]),
      g: parseIntFromHex(match[2]),
      b: parseIntFromHex(match[3]),
      format: named2 ? "name" : "hex"
    };
  }
  if (match = matchers.hex4.exec(color4)) {
    return {
      r: parseIntFromHex(match[1] + "" + match[1]),
      g: parseIntFromHex(match[2] + "" + match[2]),
      b: parseIntFromHex(match[3] + "" + match[3]),
      a: convertHexToDecimal(match[4] + "" + match[4]),
      format: named2 ? "name" : "hex8"
    };
  }
  if (match = matchers.hex3.exec(color4)) {
    return {
      r: parseIntFromHex(match[1] + "" + match[1]),
      g: parseIntFromHex(match[2] + "" + match[2]),
      b: parseIntFromHex(match[3] + "" + match[3]),
      format: named2 ? "name" : "hex"
    };
  }
  return false;
}
function validateWCAG2Parms(parms) {
  var level, size;
  parms = parms || {
    level: "AA",
    size: "small"
  };
  level = (parms.level || "AA").toUpperCase();
  size = (parms.size || "small").toLowerCase();
  if (level !== "AA" && level !== "AAA") {
    level = "AA";
  }
  if (size !== "small" && size !== "large") {
    size = "small";
  }
  return {
    level,
    size
  };
}

// node_modules/data-bind-mapper/dist/data-bind-mapper.mjs
function _arrayLikeToArray4(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}
function _arrayWithHoles4(r) {
  if (Array.isArray(r)) return r;
}
function _arrayWithoutHoles3(r) {
  if (Array.isArray(r)) return _arrayLikeToArray4(r);
}
function _assertClassBrand2(e, t, n) {
  if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n;
  throw new TypeError("Private element is not present on this object");
}
function _checkPrivateRedeclaration2(e, t) {
  if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object");
}
function _classCallCheck4(a, n) {
  if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
}
function _classPrivateFieldGet22(s, a) {
  return s.get(_assertClassBrand2(s, a));
}
function _classPrivateFieldInitSpec2(e, t, a) {
  _checkPrivateRedeclaration2(e, t), t.set(e, a);
}
function _classPrivateFieldSet22(s, a, r) {
  return s.set(_assertClassBrand2(s, a), r), r;
}
function _defineProperties2(e, r) {
  for (var t = 0; t < r.length; t++) {
    var o = r[t];
    o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey2(o.key), o);
  }
}
function _createClass4(e, r, t) {
  return r && _defineProperties2(e.prototype, r), Object.defineProperty(e, "prototype", {
    writable: false
  }), e;
}
function _iterableToArray3(r) {
  if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
}
function _iterableToArrayLimit4(r, l) {
  var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (null != t) {
    var e, n, i, u4, a = [], f = true, o = false;
    try {
      if (i = (t = t.call(r)).next, 0 === l) ;
      else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = true) ;
    } catch (r2) {
      o = true, n = r2;
    } finally {
      try {
        if (!f && null != t.return && (u4 = t.return(), Object(u4) !== u4)) return;
      } finally {
        if (o) throw n;
      }
    }
    return a;
  }
}
function _nonIterableRest4() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _nonIterableSpread3() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _slicedToArray4(r, e) {
  return _arrayWithHoles4(r) || _iterableToArrayLimit4(r, e) || _unsupportedIterableToArray4(r, e) || _nonIterableRest4();
}
function _toConsumableArray3(r) {
  return _arrayWithoutHoles3(r) || _iterableToArray3(r) || _unsupportedIterableToArray4(r) || _nonIterableSpread3();
}
function _toPrimitive2(t, r) {
  if ("object" != typeof t || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r);
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(t);
}
function _toPropertyKey2(t) {
  var i = _toPrimitive2(t, "string");
  return "symbol" == typeof i ? i : i + "";
}
function _unsupportedIterableToArray4(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray4(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray4(r, a) : void 0;
  }
}
var _dataMap = /* @__PURE__ */ new WeakMap();
var _objMap = /* @__PURE__ */ new WeakMap();
var _id = /* @__PURE__ */ new WeakMap();
var _createObj = /* @__PURE__ */ new WeakMap();
var _updateObj = /* @__PURE__ */ new WeakMap();
var _removeObj = /* @__PURE__ */ new WeakMap();
var DataBindMapper = function() {
  function DataBindMapper2() {
    _classCallCheck4(this, DataBindMapper2);
    _classPrivateFieldInitSpec2(this, _dataMap, /* @__PURE__ */ new Map());
    _classPrivateFieldInitSpec2(this, _objMap, /* @__PURE__ */ new Map());
    _classPrivateFieldInitSpec2(this, _id, function(d) {
      return d;
    });
    _classPrivateFieldInitSpec2(this, _createObj, function() {
      return {};
    });
    _classPrivateFieldInitSpec2(this, _updateObj, function() {
    });
    _classPrivateFieldInitSpec2(this, _removeObj, function() {
    });
  }
  return _createClass4(DataBindMapper2, [{
    key: "getObj",
    value: function getObj(d) {
      return _classPrivateFieldGet22(_dataMap, this).get(_classPrivateFieldGet22(_id, this).call(this, d));
    }
  }, {
    key: "getData",
    value: function getData2(o) {
      return _classPrivateFieldGet22(_objMap, this).get(o);
    }
  }, {
    key: "entries",
    value: function entries() {
      return _toConsumableArray3(_classPrivateFieldGet22(_objMap, this).entries()).map(function(_ref) {
        var _ref2 = _slicedToArray4(_ref, 2), o = _ref2[0], d = _ref2[1];
        return [d, o];
      });
    }
  }, {
    key: "id",
    value: function id(p) {
      _classPrivateFieldSet22(_id, this, index3(p));
      return this;
    }
  }, {
    key: "onCreateObj",
    value: function onCreateObj(fn) {
      _classPrivateFieldSet22(_createObj, this, fn);
      return this;
    }
  }, {
    key: "onUpdateObj",
    value: function onUpdateObj(fn) {
      _classPrivateFieldSet22(_updateObj, this, fn);
      return this;
    }
  }, {
    key: "onRemoveObj",
    value: function onRemoveObj(fn) {
      _classPrivateFieldSet22(_removeObj, this, fn);
      return this;
    }
  }, {
    key: "digest",
    value: function digest(data) {
      var _this = this;
      data.filter(function(d) {
        return !_classPrivateFieldGet22(_dataMap, _this).has(_classPrivateFieldGet22(_id, _this).call(_this, d));
      }).forEach(function(d) {
        var obj = _classPrivateFieldGet22(_createObj, _this).call(_this, d);
        _classPrivateFieldGet22(_dataMap, _this).set(_classPrivateFieldGet22(_id, _this).call(_this, d), obj);
        _classPrivateFieldGet22(_objMap, _this).set(obj, d);
      });
      var dataIdsMap = new Map(data.map(function(d) {
        return [_classPrivateFieldGet22(_id, _this).call(_this, d), d];
      }));
      _classPrivateFieldGet22(_dataMap, this).forEach(function(o, dId) {
        if (!dataIdsMap.has(dId)) {
          _classPrivateFieldGet22(_removeObj, _this).call(_this, o, dId);
          _classPrivateFieldGet22(_dataMap, _this)["delete"](dId);
          _classPrivateFieldGet22(_objMap, _this)["delete"](o);
        } else {
          _classPrivateFieldGet22(_updateObj, _this).call(_this, o, dataIdsMap.get(dId));
        }
      });
      return this;
    }
  }, {
    key: "clear",
    value: function clear() {
      this.digest([]);
      return this;
    }
  }]);
}();

// node_modules/three-globe/dist/three-globe.mjs
var import_frame_ticker = __toESM(require_FrameTicker(), 1);

// node_modules/robust-predicates/esm/util.js
var epsilon3 = 11102230246251565e-32;
var splitter = 134217729;
var resulterrbound = (3 + 8 * epsilon3) * epsilon3;
function sum2(elen, e, flen, f, h) {
  let Q, Qnew, hh, bvirt;
  let enow = e[0];
  let fnow = f[0];
  let eindex = 0;
  let findex = 0;
  if (fnow > enow === fnow > -enow) {
    Q = enow;
    enow = e[++eindex];
  } else {
    Q = fnow;
    fnow = f[++findex];
  }
  let hindex = 0;
  if (eindex < elen && findex < flen) {
    if (fnow > enow === fnow > -enow) {
      Qnew = enow + Q;
      hh = Q - (Qnew - enow);
      enow = e[++eindex];
    } else {
      Qnew = fnow + Q;
      hh = Q - (Qnew - fnow);
      fnow = f[++findex];
    }
    Q = Qnew;
    if (hh !== 0) {
      h[hindex++] = hh;
    }
    while (eindex < elen && findex < flen) {
      if (fnow > enow === fnow > -enow) {
        Qnew = Q + enow;
        bvirt = Qnew - Q;
        hh = Q - (Qnew - bvirt) + (enow - bvirt);
        enow = e[++eindex];
      } else {
        Qnew = Q + fnow;
        bvirt = Qnew - Q;
        hh = Q - (Qnew - bvirt) + (fnow - bvirt);
        fnow = f[++findex];
      }
      Q = Qnew;
      if (hh !== 0) {
        h[hindex++] = hh;
      }
    }
  }
  while (eindex < elen) {
    Qnew = Q + enow;
    bvirt = Qnew - Q;
    hh = Q - (Qnew - bvirt) + (enow - bvirt);
    enow = e[++eindex];
    Q = Qnew;
    if (hh !== 0) {
      h[hindex++] = hh;
    }
  }
  while (findex < flen) {
    Qnew = Q + fnow;
    bvirt = Qnew - Q;
    hh = Q - (Qnew - bvirt) + (fnow - bvirt);
    fnow = f[++findex];
    Q = Qnew;
    if (hh !== 0) {
      h[hindex++] = hh;
    }
  }
  if (Q !== 0 || hindex === 0) {
    h[hindex++] = Q;
  }
  return hindex;
}
function estimate(elen, e) {
  let Q = e[0];
  for (let i = 1; i < elen; i++) Q += e[i];
  return Q;
}
function vec(n) {
  return new Float64Array(n);
}

// node_modules/robust-predicates/esm/orient2d.js
var ccwerrboundA = (3 + 16 * epsilon3) * epsilon3;
var ccwerrboundB = (2 + 12 * epsilon3) * epsilon3;
var ccwerrboundC = (9 + 64 * epsilon3) * epsilon3 * epsilon3;
var B2 = vec(4);
var C1 = vec(8);
var C2 = vec(12);
var D2 = vec(16);
var u = vec(4);
function orient2dadapt(ax, ay, bx, by, cx, cy, detsum) {
  let acxtail, acytail, bcxtail, bcytail;
  let bvirt, c3, ahi, alo, bhi, blo, _i, _j, _0, s1, s0, t13, t03, u32;
  const acx = ax - cx;
  const bcx = bx - cx;
  const acy = ay - cy;
  const bcy = by - cy;
  s1 = acx * bcy;
  c3 = splitter * acx;
  ahi = c3 - (c3 - acx);
  alo = acx - ahi;
  c3 = splitter * bcy;
  bhi = c3 - (c3 - bcy);
  blo = bcy - bhi;
  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
  t13 = acy * bcx;
  c3 = splitter * acy;
  ahi = c3 - (c3 - acy);
  alo = acy - ahi;
  c3 = splitter * bcx;
  bhi = c3 - (c3 - bcx);
  blo = bcx - bhi;
  t03 = alo * blo - (t13 - ahi * bhi - alo * bhi - ahi * blo);
  _i = s0 - t03;
  bvirt = s0 - _i;
  B2[0] = s0 - (_i + bvirt) + (bvirt - t03);
  _j = s1 + _i;
  bvirt = _j - s1;
  _0 = s1 - (_j - bvirt) + (_i - bvirt);
  _i = _0 - t13;
  bvirt = _0 - _i;
  B2[1] = _0 - (_i + bvirt) + (bvirt - t13);
  u32 = _j + _i;
  bvirt = u32 - _j;
  B2[2] = _j - (u32 - bvirt) + (_i - bvirt);
  B2[3] = u32;
  let det2 = estimate(4, B2);
  let errbound = ccwerrboundB * detsum;
  if (det2 >= errbound || -det2 >= errbound) {
    return det2;
  }
  bvirt = ax - acx;
  acxtail = ax - (acx + bvirt) + (bvirt - cx);
  bvirt = bx - bcx;
  bcxtail = bx - (bcx + bvirt) + (bvirt - cx);
  bvirt = ay - acy;
  acytail = ay - (acy + bvirt) + (bvirt - cy);
  bvirt = by - bcy;
  bcytail = by - (bcy + bvirt) + (bvirt - cy);
  if (acxtail === 0 && acytail === 0 && bcxtail === 0 && bcytail === 0) {
    return det2;
  }
  errbound = ccwerrboundC * detsum + resulterrbound * Math.abs(det2);
  det2 += acx * bcytail + bcy * acxtail - (acy * bcxtail + bcx * acytail);
  if (det2 >= errbound || -det2 >= errbound) return det2;
  s1 = acxtail * bcy;
  c3 = splitter * acxtail;
  ahi = c3 - (c3 - acxtail);
  alo = acxtail - ahi;
  c3 = splitter * bcy;
  bhi = c3 - (c3 - bcy);
  blo = bcy - bhi;
  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
  t13 = acytail * bcx;
  c3 = splitter * acytail;
  ahi = c3 - (c3 - acytail);
  alo = acytail - ahi;
  c3 = splitter * bcx;
  bhi = c3 - (c3 - bcx);
  blo = bcx - bhi;
  t03 = alo * blo - (t13 - ahi * bhi - alo * bhi - ahi * blo);
  _i = s0 - t03;
  bvirt = s0 - _i;
  u[0] = s0 - (_i + bvirt) + (bvirt - t03);
  _j = s1 + _i;
  bvirt = _j - s1;
  _0 = s1 - (_j - bvirt) + (_i - bvirt);
  _i = _0 - t13;
  bvirt = _0 - _i;
  u[1] = _0 - (_i + bvirt) + (bvirt - t13);
  u32 = _j + _i;
  bvirt = u32 - _j;
  u[2] = _j - (u32 - bvirt) + (_i - bvirt);
  u[3] = u32;
  const C1len = sum2(4, B2, 4, u, C1);
  s1 = acx * bcytail;
  c3 = splitter * acx;
  ahi = c3 - (c3 - acx);
  alo = acx - ahi;
  c3 = splitter * bcytail;
  bhi = c3 - (c3 - bcytail);
  blo = bcytail - bhi;
  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
  t13 = acy * bcxtail;
  c3 = splitter * acy;
  ahi = c3 - (c3 - acy);
  alo = acy - ahi;
  c3 = splitter * bcxtail;
  bhi = c3 - (c3 - bcxtail);
  blo = bcxtail - bhi;
  t03 = alo * blo - (t13 - ahi * bhi - alo * bhi - ahi * blo);
  _i = s0 - t03;
  bvirt = s0 - _i;
  u[0] = s0 - (_i + bvirt) + (bvirt - t03);
  _j = s1 + _i;
  bvirt = _j - s1;
  _0 = s1 - (_j - bvirt) + (_i - bvirt);
  _i = _0 - t13;
  bvirt = _0 - _i;
  u[1] = _0 - (_i + bvirt) + (bvirt - t13);
  u32 = _j + _i;
  bvirt = u32 - _j;
  u[2] = _j - (u32 - bvirt) + (_i - bvirt);
  u[3] = u32;
  const C2len = sum2(C1len, C1, 4, u, C2);
  s1 = acxtail * bcytail;
  c3 = splitter * acxtail;
  ahi = c3 - (c3 - acxtail);
  alo = acxtail - ahi;
  c3 = splitter * bcytail;
  bhi = c3 - (c3 - bcytail);
  blo = bcytail - bhi;
  s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
  t13 = acytail * bcxtail;
  c3 = splitter * acytail;
  ahi = c3 - (c3 - acytail);
  alo = acytail - ahi;
  c3 = splitter * bcxtail;
  bhi = c3 - (c3 - bcxtail);
  blo = bcxtail - bhi;
  t03 = alo * blo - (t13 - ahi * bhi - alo * bhi - ahi * blo);
  _i = s0 - t03;
  bvirt = s0 - _i;
  u[0] = s0 - (_i + bvirt) + (bvirt - t03);
  _j = s1 + _i;
  bvirt = _j - s1;
  _0 = s1 - (_j - bvirt) + (_i - bvirt);
  _i = _0 - t13;
  bvirt = _0 - _i;
  u[1] = _0 - (_i + bvirt) + (bvirt - t13);
  u32 = _j + _i;
  bvirt = u32 - _j;
  u[2] = _j - (u32 - bvirt) + (_i - bvirt);
  u[3] = u32;
  const Dlen = sum2(C2len, C2, 4, u, D2);
  return D2[Dlen - 1];
}
function orient2d(ax, ay, bx, by, cx, cy) {
  const detleft = (ay - cy) * (bx - cx);
  const detright = (ax - cx) * (by - cy);
  const det2 = detleft - detright;
  const detsum = Math.abs(detleft + detright);
  if (Math.abs(det2) >= ccwerrboundA * detsum) return det2;
  return -orient2dadapt(ax, ay, bx, by, cx, cy, detsum);
}

// node_modules/robust-predicates/esm/orient3d.js
var o3derrboundA = (7 + 56 * epsilon3) * epsilon3;
var o3derrboundB = (3 + 28 * epsilon3) * epsilon3;
var o3derrboundC = (26 + 288 * epsilon3) * epsilon3 * epsilon3;
var bc = vec(4);
var ca = vec(4);
var ab = vec(4);
var at_b = vec(4);
var at_c = vec(4);
var bt_c = vec(4);
var bt_a = vec(4);
var ct_a = vec(4);
var ct_b = vec(4);
var bct = vec(8);
var cat = vec(8);
var abt = vec(8);
var u2 = vec(4);
var _8 = vec(8);
var _8b = vec(8);
var _16 = vec(8);
var _12 = vec(12);
var fin = vec(192);
var fin2 = vec(192);

// node_modules/robust-predicates/esm/incircle.js
var iccerrboundA = (10 + 96 * epsilon3) * epsilon3;
var iccerrboundB = (4 + 48 * epsilon3) * epsilon3;
var iccerrboundC = (44 + 576 * epsilon3) * epsilon3 * epsilon3;
var bc2 = vec(4);
var ca2 = vec(4);
var ab2 = vec(4);
var aa = vec(4);
var bb = vec(4);
var cc = vec(4);
var u3 = vec(4);
var v = vec(4);
var axtbc = vec(8);
var aytbc = vec(8);
var bxtca = vec(8);
var bytca = vec(8);
var cxtab = vec(8);
var cytab = vec(8);
var abt2 = vec(8);
var bct2 = vec(8);
var cat2 = vec(8);
var abtt = vec(4);
var bctt = vec(4);
var catt = vec(4);
var _82 = vec(8);
var _162 = vec(16);
var _16b = vec(16);
var _16c = vec(16);
var _32 = vec(32);
var _32b = vec(32);
var _48 = vec(48);
var _64 = vec(64);
var fin3 = vec(1152);
var fin22 = vec(1152);

// node_modules/robust-predicates/esm/insphere.js
var isperrboundA = (16 + 224 * epsilon3) * epsilon3;
var isperrboundB = (5 + 72 * epsilon3) * epsilon3;
var isperrboundC = (71 + 1408 * epsilon3) * epsilon3 * epsilon3;
var ab3 = vec(4);
var bc3 = vec(4);
var cd = vec(4);
var de = vec(4);
var ea = vec(4);
var ac = vec(4);
var bd = vec(4);
var ce = vec(4);
var da = vec(4);
var eb = vec(4);
var abc = vec(24);
var bcd = vec(24);
var cde = vec(24);
var dea = vec(24);
var eab = vec(24);
var abd = vec(24);
var bce = vec(24);
var cda = vec(24);
var deb = vec(24);
var eac = vec(24);
var adet = vec(1152);
var bdet = vec(1152);
var cdet = vec(1152);
var ddet = vec(1152);
var edet = vec(1152);
var abdet = vec(2304);
var cddet = vec(2304);
var cdedet = vec(3456);
var deter = vec(5760);
var _83 = vec(8);
var _8b2 = vec(8);
var _8c = vec(8);
var _163 = vec(16);
var _24 = vec(24);
var _482 = vec(48);
var _48b = vec(48);
var _96 = vec(96);
var _192 = vec(192);
var _384x = vec(384);
var _384y = vec(384);
var _384z = vec(384);
var _768 = vec(768);
var xdet = vec(96);
var ydet = vec(96);
var zdet = vec(96);
var fin4 = vec(1152);

// node_modules/delaunator/index.js
var EPSILON = Math.pow(2, -52);
var EDGE_STACK = new Uint32Array(512);
var Delaunator = class _Delaunator {
  static from(points, getX = defaultGetX, getY = defaultGetY) {
    const n = points.length;
    const coords = new Float64Array(n * 2);
    for (let i = 0; i < n; i++) {
      const p = points[i];
      coords[2 * i] = getX(p);
      coords[2 * i + 1] = getY(p);
    }
    return new _Delaunator(coords);
  }
  constructor(coords) {
    const n = coords.length >> 1;
    if (n > 0 && typeof coords[0] !== "number") throw new Error("Expected coords to contain numbers.");
    this.coords = coords;
    const maxTriangles = Math.max(2 * n - 5, 0);
    this._triangles = new Uint32Array(maxTriangles * 3);
    this._halfedges = new Int32Array(maxTriangles * 3);
    this._hashSize = Math.ceil(Math.sqrt(n));
    this._hullPrev = new Uint32Array(n);
    this._hullNext = new Uint32Array(n);
    this._hullTri = new Uint32Array(n);
    this._hullHash = new Int32Array(this._hashSize);
    this._ids = new Uint32Array(n);
    this._dists = new Float64Array(n);
    this.update();
  }
  update() {
    const { coords, _hullPrev: hullPrev, _hullNext: hullNext, _hullTri: hullTri, _hullHash: hullHash } = this;
    const n = coords.length >> 1;
    let minX = Infinity;
    let minY = Infinity;
    let maxX = -Infinity;
    let maxY = -Infinity;
    for (let i = 0; i < n; i++) {
      const x = coords[2 * i];
      const y = coords[2 * i + 1];
      if (x < minX) minX = x;
      if (y < minY) minY = y;
      if (x > maxX) maxX = x;
      if (y > maxY) maxY = y;
      this._ids[i] = i;
    }
    const cx = (minX + maxX) / 2;
    const cy = (minY + maxY) / 2;
    let i0, i1, i2;
    for (let i = 0, minDist = Infinity; i < n; i++) {
      const d = dist(cx, cy, coords[2 * i], coords[2 * i + 1]);
      if (d < minDist) {
        i0 = i;
        minDist = d;
      }
    }
    const i0x = coords[2 * i0];
    const i0y = coords[2 * i0 + 1];
    for (let i = 0, minDist = Infinity; i < n; i++) {
      if (i === i0) continue;
      const d = dist(i0x, i0y, coords[2 * i], coords[2 * i + 1]);
      if (d < minDist && d > 0) {
        i1 = i;
        minDist = d;
      }
    }
    let i1x = coords[2 * i1];
    let i1y = coords[2 * i1 + 1];
    let minRadius = Infinity;
    for (let i = 0; i < n; i++) {
      if (i === i0 || i === i1) continue;
      const r = circumradius(i0x, i0y, i1x, i1y, coords[2 * i], coords[2 * i + 1]);
      if (r < minRadius) {
        i2 = i;
        minRadius = r;
      }
    }
    let i2x = coords[2 * i2];
    let i2y = coords[2 * i2 + 1];
    if (minRadius === Infinity) {
      for (let i = 0; i < n; i++) {
        this._dists[i] = coords[2 * i] - coords[0] || coords[2 * i + 1] - coords[1];
      }
      quicksort(this._ids, this._dists, 0, n - 1);
      const hull = new Uint32Array(n);
      let j = 0;
      for (let i = 0, d0 = -Infinity; i < n; i++) {
        const id = this._ids[i];
        const d = this._dists[id];
        if (d > d0) {
          hull[j++] = id;
          d0 = d;
        }
      }
      this.hull = hull.subarray(0, j);
      this.triangles = new Uint32Array(0);
      this.halfedges = new Uint32Array(0);
      return;
    }
    if (orient2d(i0x, i0y, i1x, i1y, i2x, i2y) < 0) {
      const i = i1;
      const x = i1x;
      const y = i1y;
      i1 = i2;
      i1x = i2x;
      i1y = i2y;
      i2 = i;
      i2x = x;
      i2y = y;
    }
    const center = circumcenter(i0x, i0y, i1x, i1y, i2x, i2y);
    this._cx = center.x;
    this._cy = center.y;
    for (let i = 0; i < n; i++) {
      this._dists[i] = dist(coords[2 * i], coords[2 * i + 1], center.x, center.y);
    }
    quicksort(this._ids, this._dists, 0, n - 1);
    this._hullStart = i0;
    let hullSize = 3;
    hullNext[i0] = hullPrev[i2] = i1;
    hullNext[i1] = hullPrev[i0] = i2;
    hullNext[i2] = hullPrev[i1] = i0;
    hullTri[i0] = 0;
    hullTri[i1] = 1;
    hullTri[i2] = 2;
    hullHash.fill(-1);
    hullHash[this._hashKey(i0x, i0y)] = i0;
    hullHash[this._hashKey(i1x, i1y)] = i1;
    hullHash[this._hashKey(i2x, i2y)] = i2;
    this.trianglesLen = 0;
    this._addTriangle(i0, i1, i2, -1, -1, -1);
    for (let k = 0, xp, yp; k < this._ids.length; k++) {
      const i = this._ids[k];
      const x = coords[2 * i];
      const y = coords[2 * i + 1];
      if (k > 0 && Math.abs(x - xp) <= EPSILON && Math.abs(y - yp) <= EPSILON) continue;
      xp = x;
      yp = y;
      if (i === i0 || i === i1 || i === i2) continue;
      let start = 0;
      for (let j = 0, key = this._hashKey(x, y); j < this._hashSize; j++) {
        start = hullHash[(key + j) % this._hashSize];
        if (start !== -1 && start !== hullNext[start]) break;
      }
      start = hullPrev[start];
      let e = start, q;
      while (q = hullNext[e], orient2d(x, y, coords[2 * e], coords[2 * e + 1], coords[2 * q], coords[2 * q + 1]) >= 0) {
        e = q;
        if (e === start) {
          e = -1;
          break;
        }
      }
      if (e === -1) continue;
      let t = this._addTriangle(e, i, hullNext[e], -1, -1, hullTri[e]);
      hullTri[i] = this._legalize(t + 2);
      hullTri[e] = t;
      hullSize++;
      let n2 = hullNext[e];
      while (q = hullNext[n2], orient2d(x, y, coords[2 * n2], coords[2 * n2 + 1], coords[2 * q], coords[2 * q + 1]) < 0) {
        t = this._addTriangle(n2, i, q, hullTri[i], -1, hullTri[n2]);
        hullTri[i] = this._legalize(t + 2);
        hullNext[n2] = n2;
        hullSize--;
        n2 = q;
      }
      if (e === start) {
        while (q = hullPrev[e], orient2d(x, y, coords[2 * q], coords[2 * q + 1], coords[2 * e], coords[2 * e + 1]) < 0) {
          t = this._addTriangle(q, i, e, -1, hullTri[e], hullTri[q]);
          this._legalize(t + 2);
          hullTri[q] = t;
          hullNext[e] = e;
          hullSize--;
          e = q;
        }
      }
      this._hullStart = hullPrev[i] = e;
      hullNext[e] = hullPrev[n2] = i;
      hullNext[i] = n2;
      hullHash[this._hashKey(x, y)] = i;
      hullHash[this._hashKey(coords[2 * e], coords[2 * e + 1])] = e;
    }
    this.hull = new Uint32Array(hullSize);
    for (let i = 0, e = this._hullStart; i < hullSize; i++) {
      this.hull[i] = e;
      e = hullNext[e];
    }
    this.triangles = this._triangles.subarray(0, this.trianglesLen);
    this.halfedges = this._halfedges.subarray(0, this.trianglesLen);
  }
  _hashKey(x, y) {
    return Math.floor(pseudoAngle(x - this._cx, y - this._cy) * this._hashSize) % this._hashSize;
  }
  _legalize(a) {
    const { _triangles: triangles, _halfedges: halfedges, coords } = this;
    let i = 0;
    let ar = 0;
    while (true) {
      const b = halfedges[a];
      const a0 = a - a % 3;
      ar = a0 + (a + 2) % 3;
      if (b === -1) {
        if (i === 0) break;
        a = EDGE_STACK[--i];
        continue;
      }
      const b0 = b - b % 3;
      const al = a0 + (a + 1) % 3;
      const bl = b0 + (b + 2) % 3;
      const p02 = triangles[ar];
      const pr = triangles[a];
      const pl = triangles[al];
      const p1 = triangles[bl];
      const illegal = inCircle(
        coords[2 * p02],
        coords[2 * p02 + 1],
        coords[2 * pr],
        coords[2 * pr + 1],
        coords[2 * pl],
        coords[2 * pl + 1],
        coords[2 * p1],
        coords[2 * p1 + 1]
      );
      if (illegal) {
        triangles[a] = p1;
        triangles[b] = p02;
        const hbl = halfedges[bl];
        if (hbl === -1) {
          let e = this._hullStart;
          do {
            if (this._hullTri[e] === bl) {
              this._hullTri[e] = a;
              break;
            }
            e = this._hullPrev[e];
          } while (e !== this._hullStart);
        }
        this._link(a, hbl);
        this._link(b, halfedges[ar]);
        this._link(ar, bl);
        const br = b0 + (b + 1) % 3;
        if (i < EDGE_STACK.length) {
          EDGE_STACK[i++] = br;
        }
      } else {
        if (i === 0) break;
        a = EDGE_STACK[--i];
      }
    }
    return ar;
  }
  _link(a, b) {
    this._halfedges[a] = b;
    if (b !== -1) this._halfedges[b] = a;
  }
  // add a new triangle given vertex indices and adjacent half-edge ids
  _addTriangle(i0, i1, i2, a, b, c3) {
    const t = this.trianglesLen;
    this._triangles[t] = i0;
    this._triangles[t + 1] = i1;
    this._triangles[t + 2] = i2;
    this._link(t, a);
    this._link(t + 1, b);
    this._link(t + 2, c3);
    this.trianglesLen += 3;
    return t;
  }
};
function pseudoAngle(dx, dy) {
  const p = dx / (Math.abs(dx) + Math.abs(dy));
  return (dy > 0 ? 3 - p : 1 + p) / 4;
}
function dist(ax, ay, bx, by) {
  const dx = ax - bx;
  const dy = ay - by;
  return dx * dx + dy * dy;
}
function inCircle(ax, ay, bx, by, cx, cy, px, py) {
  const dx = ax - px;
  const dy = ay - py;
  const ex = bx - px;
  const ey = by - py;
  const fx = cx - px;
  const fy = cy - py;
  const ap = dx * dx + dy * dy;
  const bp = ex * ex + ey * ey;
  const cp = fx * fx + fy * fy;
  return dx * (ey * cp - bp * fy) - dy * (ex * cp - bp * fx) + ap * (ex * fy - ey * fx) < 0;
}
function circumradius(ax, ay, bx, by, cx, cy) {
  const dx = bx - ax;
  const dy = by - ay;
  const ex = cx - ax;
  const ey = cy - ay;
  const bl = dx * dx + dy * dy;
  const cl = ex * ex + ey * ey;
  const d = 0.5 / (dx * ey - dy * ex);
  const x = (ey * bl - dy * cl) * d;
  const y = (dx * cl - ex * bl) * d;
  return x * x + y * y;
}
function circumcenter(ax, ay, bx, by, cx, cy) {
  const dx = bx - ax;
  const dy = by - ay;
  const ex = cx - ax;
  const ey = cy - ay;
  const bl = dx * dx + dy * dy;
  const cl = ex * ex + ey * ey;
  const d = 0.5 / (dx * ey - dy * ex);
  const x = ax + (ey * bl - dy * cl) * d;
  const y = ay + (dx * cl - ex * bl) * d;
  return { x, y };
}
function quicksort(ids, dists, left, right) {
  if (right - left <= 20) {
    for (let i = left + 1; i <= right; i++) {
      const temp = ids[i];
      const tempDist = dists[temp];
      let j = i - 1;
      while (j >= left && dists[ids[j]] > tempDist) ids[j + 1] = ids[j--];
      ids[j + 1] = temp;
    }
  } else {
    const median2 = left + right >> 1;
    let i = left + 1;
    let j = right;
    swap(ids, median2, i);
    if (dists[ids[left]] > dists[ids[right]]) swap(ids, left, right);
    if (dists[ids[i]] > dists[ids[right]]) swap(ids, i, right);
    if (dists[ids[left]] > dists[ids[i]]) swap(ids, left, i);
    const temp = ids[i];
    const tempDist = dists[temp];
    while (true) {
      do
        i++;
      while (dists[ids[i]] < tempDist);
      do
        j--;
      while (dists[ids[j]] > tempDist);
      if (j < i) break;
      swap(ids, i, j);
    }
    ids[left + 1] = ids[j];
    ids[j] = temp;
    if (right - i + 1 >= j - left) {
      quicksort(ids, dists, i, right);
      quicksort(ids, dists, left, j - 1);
    } else {
      quicksort(ids, dists, left, j - 1);
      quicksort(ids, dists, i, right);
    }
  }
}
function swap(arr, i, j) {
  const tmp = arr[i];
  arr[i] = arr[j];
  arr[j] = tmp;
}
function defaultGetX(p) {
  return p[0];
}
function defaultGetY(p) {
  return p[1];
}

// node_modules/point-in-polygon-hao/dist/esm/index.js
function pointInPolygon(p, polygon) {
  var i;
  var ii;
  var k = 0;
  var f;
  var u1;
  var v1;
  var u22;
  var v2;
  var currentP;
  var nextP;
  var x = p[0];
  var y = p[1];
  var numContours = polygon.length;
  for (i = 0; i < numContours; i++) {
    ii = 0;
    var contour = polygon[i];
    var contourLen = contour.length - 1;
    currentP = contour[0];
    if (currentP[0] !== contour[contourLen][0] && currentP[1] !== contour[contourLen][1]) {
      throw new Error("First and last coordinates in a ring must be the same");
    }
    u1 = currentP[0] - x;
    v1 = currentP[1] - y;
    for (ii; ii < contourLen; ii++) {
      nextP = contour[ii + 1];
      u22 = nextP[0] - x;
      v2 = nextP[1] - y;
      if (v1 === 0 && v2 === 0) {
        if (u22 <= 0 && u1 >= 0 || u1 <= 0 && u22 >= 0) {
          return 0;
        }
      } else if (v2 >= 0 && v1 <= 0 || v2 <= 0 && v1 >= 0) {
        f = orient2d(u1, u22, v1, v2, 0, 0);
        if (f === 0) {
          return 0;
        }
        if (f > 0 && v2 > 0 && v1 <= 0 || f < 0 && v2 <= 0 && v1 > 0) {
          k++;
        }
      }
      currentP = nextP;
      v1 = v2;
      u1 = u22;
    }
  }
  if (k % 2 === 0) {
    return false;
  }
  return true;
}

// node_modules/@turf/helpers/dist/esm/index.js
var earthRadius = 63710088e-1;
var factors = {
  centimeters: earthRadius * 100,
  centimetres: earthRadius * 100,
  degrees: 360 / (2 * Math.PI),
  feet: earthRadius * 3.28084,
  inches: earthRadius * 39.37,
  kilometers: earthRadius / 1e3,
  kilometres: earthRadius / 1e3,
  meters: earthRadius,
  metres: earthRadius,
  miles: earthRadius / 1609.344,
  millimeters: earthRadius * 1e3,
  millimetres: earthRadius * 1e3,
  nauticalmiles: earthRadius / 1852,
  radians: 1,
  yards: earthRadius * 1.0936
};

// node_modules/@turf/invariant/dist/esm/index.js
function getCoord(coord) {
  if (!coord) {
    throw new Error("coord is required");
  }
  if (!Array.isArray(coord)) {
    if (coord.type === "Feature" && coord.geometry !== null && coord.geometry.type === "Point") {
      return [...coord.geometry.coordinates];
    }
    if (coord.type === "Point") {
      return [...coord.coordinates];
    }
  }
  if (Array.isArray(coord) && coord.length >= 2 && !Array.isArray(coord[0]) && !Array.isArray(coord[1])) {
    return [...coord];
  }
  throw new Error("coord must be GeoJSON Point or an Array of numbers");
}
function getGeom(geojson) {
  if (geojson.type === "Feature") {
    return geojson.geometry;
  }
  return geojson;
}

// node_modules/@turf/boolean-point-in-polygon/dist/esm/index.js
function booleanPointInPolygon(point2, polygon, options = {}) {
  if (!point2) {
    throw new Error("point is required");
  }
  if (!polygon) {
    throw new Error("polygon is required");
  }
  const pt = getCoord(point2);
  const geom = getGeom(polygon);
  const type = geom.type;
  const bbox = polygon.bbox;
  let polys = geom.coordinates;
  if (bbox && inBBox(pt, bbox) === false) {
    return false;
  }
  if (type === "Polygon") {
    polys = [polys];
  }
  let result = false;
  for (var i = 0; i < polys.length; ++i) {
    const polyResult = pointInPolygon(pt, polys[i]);
    if (polyResult === 0) return options.ignoreBoundary ? false : true;
    else if (polyResult) result = true;
  }
  return result;
}
function inBBox(pt, bbox) {
  return bbox[0] <= pt[0] && bbox[1] <= pt[1] && bbox[2] >= pt[0] && bbox[3] >= pt[1];
}
var turf_boolean_point_in_polygon_default = booleanPointInPolygon;

// node_modules/d3-delaunay/src/path.js
var epsilon4 = 1e-6;
var Path = class {
  constructor() {
    this._x0 = this._y0 = // start of current subpath
    this._x1 = this._y1 = null;
    this._ = "";
  }
  moveTo(x, y) {
    this._ += `M${this._x0 = this._x1 = +x},${this._y0 = this._y1 = +y}`;
  }
  closePath() {
    if (this._x1 !== null) {
      this._x1 = this._x0, this._y1 = this._y0;
      this._ += "Z";
    }
  }
  lineTo(x, y) {
    this._ += `L${this._x1 = +x},${this._y1 = +y}`;
  }
  arc(x, y, r) {
    x = +x, y = +y, r = +r;
    const x03 = x + r;
    const y03 = y;
    if (r < 0) throw new Error("negative radius");
    if (this._x1 === null) this._ += `M${x03},${y03}`;
    else if (Math.abs(this._x1 - x03) > epsilon4 || Math.abs(this._y1 - y03) > epsilon4) this._ += "L" + x03 + "," + y03;
    if (!r) return;
    this._ += `A${r},${r},0,1,1,${x - r},${y}A${r},${r},0,1,1,${this._x1 = x03},${this._y1 = y03}`;
  }
  rect(x, y, w, h) {
    this._ += `M${this._x0 = this._x1 = +x},${this._y0 = this._y1 = +y}h${+w}v${+h}h${-w}Z`;
  }
  value() {
    return this._ || null;
  }
};

// node_modules/d3-delaunay/src/polygon.js
var Polygon = class {
  constructor() {
    this._ = [];
  }
  moveTo(x, y) {
    this._.push([x, y]);
  }
  closePath() {
    this._.push(this._[0].slice());
  }
  lineTo(x, y) {
    this._.push([x, y]);
  }
  value() {
    return this._.length ? this._ : null;
  }
};

// node_modules/d3-delaunay/src/voronoi.js
var Voronoi = class {
  constructor(delaunay, [xmin, ymin, xmax, ymax] = [0, 0, 960, 500]) {
    if (!((xmax = +xmax) >= (xmin = +xmin)) || !((ymax = +ymax) >= (ymin = +ymin))) throw new Error("invalid bounds");
    this.delaunay = delaunay;
    this._circumcenters = new Float64Array(delaunay.points.length * 2);
    this.vectors = new Float64Array(delaunay.points.length * 2);
    this.xmax = xmax, this.xmin = xmin;
    this.ymax = ymax, this.ymin = ymin;
    this._init();
  }
  update() {
    this.delaunay.update();
    this._init();
    return this;
  }
  _init() {
    const { delaunay: { points, hull, triangles }, vectors } = this;
    let bx, by;
    const circumcenters = this.circumcenters = this._circumcenters.subarray(0, triangles.length / 3 * 2);
    for (let i = 0, j = 0, n = triangles.length, x, y; i < n; i += 3, j += 2) {
      const t13 = triangles[i] * 2;
      const t22 = triangles[i + 1] * 2;
      const t32 = triangles[i + 2] * 2;
      const x13 = points[t13];
      const y13 = points[t13 + 1];
      const x2 = points[t22];
      const y2 = points[t22 + 1];
      const x3 = points[t32];
      const y3 = points[t32 + 1];
      const dx = x2 - x13;
      const dy = y2 - y13;
      const ex = x3 - x13;
      const ey = y3 - y13;
      const ab4 = (dx * ey - dy * ex) * 2;
      if (Math.abs(ab4) < 1e-9) {
        if (bx === void 0) {
          bx = by = 0;
          for (const i2 of hull) bx += points[i2 * 2], by += points[i2 * 2 + 1];
          bx /= hull.length, by /= hull.length;
        }
        const a = 1e9 * Math.sign((bx - x13) * ey - (by - y13) * ex);
        x = (x13 + x3) / 2 - a * ey;
        y = (y13 + y3) / 2 + a * ex;
      } else {
        const d = 1 / ab4;
        const bl = dx * dx + dy * dy;
        const cl = ex * ex + ey * ey;
        x = x13 + (ey * bl - dy * cl) * d;
        y = y13 + (dx * cl - ex * bl) * d;
      }
      circumcenters[j] = x;
      circumcenters[j + 1] = y;
    }
    let h = hull[hull.length - 1];
    let p02, p1 = h * 4;
    let x03, x12 = points[2 * h];
    let y03, y12 = points[2 * h + 1];
    vectors.fill(0);
    for (let i = 0; i < hull.length; ++i) {
      h = hull[i];
      p02 = p1, x03 = x12, y03 = y12;
      p1 = h * 4, x12 = points[2 * h], y12 = points[2 * h + 1];
      vectors[p02 + 2] = vectors[p1] = y03 - y12;
      vectors[p02 + 3] = vectors[p1 + 1] = x12 - x03;
    }
  }
  render(context3) {
    const buffer3 = context3 == null ? context3 = new Path() : void 0;
    const { delaunay: { halfedges, inedges, hull }, circumcenters, vectors } = this;
    if (hull.length <= 1) return null;
    for (let i = 0, n = halfedges.length; i < n; ++i) {
      const j = halfedges[i];
      if (j < i) continue;
      const ti = Math.floor(i / 3) * 2;
      const tj = Math.floor(j / 3) * 2;
      const xi = circumcenters[ti];
      const yi = circumcenters[ti + 1];
      const xj = circumcenters[tj];
      const yj = circumcenters[tj + 1];
      this._renderSegment(xi, yi, xj, yj, context3);
    }
    let h02, h12 = hull[hull.length - 1];
    for (let i = 0; i < hull.length; ++i) {
      h02 = h12, h12 = hull[i];
      const t = Math.floor(inedges[h12] / 3) * 2;
      const x = circumcenters[t];
      const y = circumcenters[t + 1];
      const v2 = h02 * 4;
      const p = this._project(x, y, vectors[v2 + 2], vectors[v2 + 3]);
      if (p) this._renderSegment(x, y, p[0], p[1], context3);
    }
    return buffer3 && buffer3.value();
  }
  renderBounds(context3) {
    const buffer3 = context3 == null ? context3 = new Path() : void 0;
    context3.rect(this.xmin, this.ymin, this.xmax - this.xmin, this.ymax - this.ymin);
    return buffer3 && buffer3.value();
  }
  renderCell(i, context3) {
    const buffer3 = context3 == null ? context3 = new Path() : void 0;
    const points = this._clip(i);
    if (points === null || !points.length) return;
    context3.moveTo(points[0], points[1]);
    let n = points.length;
    while (points[0] === points[n - 2] && points[1] === points[n - 1] && n > 1) n -= 2;
    for (let i2 = 2; i2 < n; i2 += 2) {
      if (points[i2] !== points[i2 - 2] || points[i2 + 1] !== points[i2 - 1])
        context3.lineTo(points[i2], points[i2 + 1]);
    }
    context3.closePath();
    return buffer3 && buffer3.value();
  }
  *cellPolygons() {
    const { delaunay: { points } } = this;
    for (let i = 0, n = points.length / 2; i < n; ++i) {
      const cell = this.cellPolygon(i);
      if (cell) cell.index = i, yield cell;
    }
  }
  cellPolygon(i) {
    const polygon = new Polygon();
    this.renderCell(i, polygon);
    return polygon.value();
  }
  _renderSegment(x03, y03, x12, y12, context3) {
    let S;
    const c0 = this._regioncode(x03, y03);
    const c1 = this._regioncode(x12, y12);
    if (c0 === 0 && c1 === 0) {
      context3.moveTo(x03, y03);
      context3.lineTo(x12, y12);
    } else if (S = this._clipSegment(x03, y03, x12, y12, c0, c1)) {
      context3.moveTo(S[0], S[1]);
      context3.lineTo(S[2], S[3]);
    }
  }
  contains(i, x, y) {
    if ((x = +x, x !== x) || (y = +y, y !== y)) return false;
    return this.delaunay._step(i, x, y) === i;
  }
  *neighbors(i) {
    const ci = this._clip(i);
    if (ci) for (const j of this.delaunay.neighbors(i)) {
      const cj = this._clip(j);
      if (cj) loop: for (let ai = 0, li = ci.length; ai < li; ai += 2) {
        for (let aj = 0, lj = cj.length; aj < lj; aj += 2) {
          if (ci[ai] === cj[aj] && ci[ai + 1] === cj[aj + 1] && ci[(ai + 2) % li] === cj[(aj + lj - 2) % lj] && ci[(ai + 3) % li] === cj[(aj + lj - 1) % lj]) {
            yield j;
            break loop;
          }
        }
      }
    }
  }
  _cell(i) {
    const { circumcenters, delaunay: { inedges, halfedges, triangles } } = this;
    const e0 = inedges[i];
    if (e0 === -1) return null;
    const points = [];
    let e = e0;
    do {
      const t = Math.floor(e / 3);
      points.push(circumcenters[t * 2], circumcenters[t * 2 + 1]);
      e = e % 3 === 2 ? e - 2 : e + 1;
      if (triangles[e] !== i) break;
      e = halfedges[e];
    } while (e !== e0 && e !== -1);
    return points;
  }
  _clip(i) {
    if (i === 0 && this.delaunay.hull.length === 1) {
      return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];
    }
    const points = this._cell(i);
    if (points === null) return null;
    const { vectors: V } = this;
    const v2 = i * 4;
    return this._simplify(V[v2] || V[v2 + 1] ? this._clipInfinite(i, points, V[v2], V[v2 + 1], V[v2 + 2], V[v2 + 3]) : this._clipFinite(i, points));
  }
  _clipFinite(i, points) {
    const n = points.length;
    let P = null;
    let x03, y03, x12 = points[n - 2], y12 = points[n - 1];
    let c0, c1 = this._regioncode(x12, y12);
    let e0, e1 = 0;
    for (let j = 0; j < n; j += 2) {
      x03 = x12, y03 = y12, x12 = points[j], y12 = points[j + 1];
      c0 = c1, c1 = this._regioncode(x12, y12);
      if (c0 === 0 && c1 === 0) {
        e0 = e1, e1 = 0;
        if (P) P.push(x12, y12);
        else P = [x12, y12];
      } else {
        let S, sx0, sy0, sx1, sy1;
        if (c0 === 0) {
          if ((S = this._clipSegment(x03, y03, x12, y12, c0, c1)) === null) continue;
          [sx0, sy0, sx1, sy1] = S;
        } else {
          if ((S = this._clipSegment(x12, y12, x03, y03, c1, c0)) === null) continue;
          [sx1, sy1, sx0, sy0] = S;
          e0 = e1, e1 = this._edgecode(sx0, sy0);
          if (e0 && e1) this._edge(i, e0, e1, P, P.length);
          if (P) P.push(sx0, sy0);
          else P = [sx0, sy0];
        }
        e0 = e1, e1 = this._edgecode(sx1, sy1);
        if (e0 && e1) this._edge(i, e0, e1, P, P.length);
        if (P) P.push(sx1, sy1);
        else P = [sx1, sy1];
      }
    }
    if (P) {
      e0 = e1, e1 = this._edgecode(P[0], P[1]);
      if (e0 && e1) this._edge(i, e0, e1, P, P.length);
    } else if (this.contains(i, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2)) {
      return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];
    }
    return P;
  }
  _clipSegment(x03, y03, x12, y12, c0, c1) {
    const flip2 = c0 < c1;
    if (flip2) [x03, y03, x12, y12, c0, c1] = [x12, y12, x03, y03, c1, c0];
    while (true) {
      if (c0 === 0 && c1 === 0) return flip2 ? [x12, y12, x03, y03] : [x03, y03, x12, y12];
      if (c0 & c1) return null;
      let x, y, c3 = c0 || c1;
      if (c3 & 8) x = x03 + (x12 - x03) * (this.ymax - y03) / (y12 - y03), y = this.ymax;
      else if (c3 & 4) x = x03 + (x12 - x03) * (this.ymin - y03) / (y12 - y03), y = this.ymin;
      else if (c3 & 2) y = y03 + (y12 - y03) * (this.xmax - x03) / (x12 - x03), x = this.xmax;
      else y = y03 + (y12 - y03) * (this.xmin - x03) / (x12 - x03), x = this.xmin;
      if (c0) x03 = x, y03 = y, c0 = this._regioncode(x03, y03);
      else x12 = x, y12 = y, c1 = this._regioncode(x12, y12);
    }
  }
  _clipInfinite(i, points, vx0, vy0, vxn, vyn) {
    let P = Array.from(points), p;
    if (p = this._project(P[0], P[1], vx0, vy0)) P.unshift(p[0], p[1]);
    if (p = this._project(P[P.length - 2], P[P.length - 1], vxn, vyn)) P.push(p[0], p[1]);
    if (P = this._clipFinite(i, P)) {
      for (let j = 0, n = P.length, c0, c1 = this._edgecode(P[n - 2], P[n - 1]); j < n; j += 2) {
        c0 = c1, c1 = this._edgecode(P[j], P[j + 1]);
        if (c0 && c1) j = this._edge(i, c0, c1, P, j), n = P.length;
      }
    } else if (this.contains(i, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2)) {
      P = [this.xmin, this.ymin, this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax];
    }
    return P;
  }
  _edge(i, e0, e1, P, j) {
    while (e0 !== e1) {
      let x, y;
      switch (e0) {
        case 5:
          e0 = 4;
          continue;
        case 4:
          e0 = 6, x = this.xmax, y = this.ymin;
          break;
        case 6:
          e0 = 2;
          continue;
        case 2:
          e0 = 10, x = this.xmax, y = this.ymax;
          break;
        case 10:
          e0 = 8;
          continue;
        case 8:
          e0 = 9, x = this.xmin, y = this.ymax;
          break;
        case 9:
          e0 = 1;
          continue;
        case 1:
          e0 = 5, x = this.xmin, y = this.ymin;
          break;
      }
      if ((P[j] !== x || P[j + 1] !== y) && this.contains(i, x, y)) {
        P.splice(j, 0, x, y), j += 2;
      }
    }
    return j;
  }
  _project(x03, y03, vx, vy) {
    let t = Infinity, c3, x, y;
    if (vy < 0) {
      if (y03 <= this.ymin) return null;
      if ((c3 = (this.ymin - y03) / vy) < t) y = this.ymin, x = x03 + (t = c3) * vx;
    } else if (vy > 0) {
      if (y03 >= this.ymax) return null;
      if ((c3 = (this.ymax - y03) / vy) < t) y = this.ymax, x = x03 + (t = c3) * vx;
    }
    if (vx > 0) {
      if (x03 >= this.xmax) return null;
      if ((c3 = (this.xmax - x03) / vx) < t) x = this.xmax, y = y03 + (t = c3) * vy;
    } else if (vx < 0) {
      if (x03 <= this.xmin) return null;
      if ((c3 = (this.xmin - x03) / vx) < t) x = this.xmin, y = y03 + (t = c3) * vy;
    }
    return [x, y];
  }
  _edgecode(x, y) {
    return (x === this.xmin ? 1 : x === this.xmax ? 2 : 0) | (y === this.ymin ? 4 : y === this.ymax ? 8 : 0);
  }
  _regioncode(x, y) {
    return (x < this.xmin ? 1 : x > this.xmax ? 2 : 0) | (y < this.ymin ? 4 : y > this.ymax ? 8 : 0);
  }
  _simplify(P) {
    if (P && P.length > 4) {
      for (let i = 0; i < P.length; i += 2) {
        const j = (i + 2) % P.length, k = (i + 4) % P.length;
        if (P[i] === P[j] && P[j] === P[k] || P[i + 1] === P[j + 1] && P[j + 1] === P[k + 1]) {
          P.splice(j, 2), i -= 2;
        }
      }
      if (!P.length) P = null;
    }
    return P;
  }
};

// node_modules/d3-delaunay/src/delaunay.js
var tau2 = 2 * Math.PI;
var pow3 = Math.pow;
function pointX(p) {
  return p[0];
}
function pointY(p) {
  return p[1];
}
function collinear(d) {
  const { triangles, coords } = d;
  for (let i = 0; i < triangles.length; i += 3) {
    const a = 2 * triangles[i], b = 2 * triangles[i + 1], c3 = 2 * triangles[i + 2], cross4 = (coords[c3] - coords[a]) * (coords[b + 1] - coords[a + 1]) - (coords[b] - coords[a]) * (coords[c3 + 1] - coords[a + 1]);
    if (cross4 > 1e-10) return false;
  }
  return true;
}
function jitter(x, y, r) {
  return [x + Math.sin(x + y) * r, y + Math.cos(x - y) * r];
}
var Delaunay = class _Delaunay {
  static from(points, fx = pointX, fy = pointY, that) {
    return new _Delaunay("length" in points ? flatArray(points, fx, fy, that) : Float64Array.from(flatIterable(points, fx, fy, that)));
  }
  constructor(points) {
    this._delaunator = new Delaunator(points);
    this.inedges = new Int32Array(points.length / 2);
    this._hullIndex = new Int32Array(points.length / 2);
    this.points = this._delaunator.coords;
    this._init();
  }
  update() {
    this._delaunator.update();
    this._init();
    return this;
  }
  _init() {
    const d = this._delaunator, points = this.points;
    if (d.hull && d.hull.length > 2 && collinear(d)) {
      this.collinear = Int32Array.from({ length: points.length / 2 }, (_, i) => i).sort((i, j) => points[2 * i] - points[2 * j] || points[2 * i + 1] - points[2 * j + 1]);
      const e = this.collinear[0], f = this.collinear[this.collinear.length - 1], bounds = [points[2 * e], points[2 * e + 1], points[2 * f], points[2 * f + 1]], r = 1e-8 * Math.hypot(bounds[3] - bounds[1], bounds[2] - bounds[0]);
      for (let i = 0, n = points.length / 2; i < n; ++i) {
        const p = jitter(points[2 * i], points[2 * i + 1], r);
        points[2 * i] = p[0];
        points[2 * i + 1] = p[1];
      }
      this._delaunator = new Delaunator(points);
    } else {
      delete this.collinear;
    }
    const halfedges = this.halfedges = this._delaunator.halfedges;
    const hull = this.hull = this._delaunator.hull;
    const triangles = this.triangles = this._delaunator.triangles;
    const inedges = this.inedges.fill(-1);
    const hullIndex = this._hullIndex.fill(-1);
    for (let e = 0, n = halfedges.length; e < n; ++e) {
      const p = triangles[e % 3 === 2 ? e - 2 : e + 1];
      if (halfedges[e] === -1 || inedges[p] === -1) inedges[p] = e;
    }
    for (let i = 0, n = hull.length; i < n; ++i) {
      hullIndex[hull[i]] = i;
    }
    if (hull.length <= 2 && hull.length > 0) {
      this.triangles = new Int32Array(3).fill(-1);
      this.halfedges = new Int32Array(3).fill(-1);
      this.triangles[0] = hull[0];
      inedges[hull[0]] = 1;
      if (hull.length === 2) {
        inedges[hull[1]] = 0;
        this.triangles[1] = hull[1];
        this.triangles[2] = hull[1];
      }
    }
  }
  voronoi(bounds) {
    return new Voronoi(this, bounds);
  }
  *neighbors(i) {
    const { inedges, hull, _hullIndex, halfedges, triangles, collinear: collinear2 } = this;
    if (collinear2) {
      const l = collinear2.indexOf(i);
      if (l > 0) yield collinear2[l - 1];
      if (l < collinear2.length - 1) yield collinear2[l + 1];
      return;
    }
    const e0 = inedges[i];
    if (e0 === -1) return;
    let e = e0, p02 = -1;
    do {
      yield p02 = triangles[e];
      e = e % 3 === 2 ? e - 2 : e + 1;
      if (triangles[e] !== i) return;
      e = halfedges[e];
      if (e === -1) {
        const p = hull[(_hullIndex[i] + 1) % hull.length];
        if (p !== p02) yield p;
        return;
      }
    } while (e !== e0);
  }
  find(x, y, i = 0) {
    if ((x = +x, x !== x) || (y = +y, y !== y)) return -1;
    const i0 = i;
    let c3;
    while ((c3 = this._step(i, x, y)) >= 0 && c3 !== i && c3 !== i0) i = c3;
    return c3;
  }
  _step(i, x, y) {
    const { inedges, hull, _hullIndex, halfedges, triangles, points } = this;
    if (inedges[i] === -1 || !points.length) return (i + 1) % (points.length >> 1);
    let c3 = i;
    let dc = pow3(x - points[i * 2], 2) + pow3(y - points[i * 2 + 1], 2);
    const e0 = inedges[i];
    let e = e0;
    do {
      let t = triangles[e];
      const dt = pow3(x - points[t * 2], 2) + pow3(y - points[t * 2 + 1], 2);
      if (dt < dc) dc = dt, c3 = t;
      e = e % 3 === 2 ? e - 2 : e + 1;
      if (triangles[e] !== i) break;
      e = halfedges[e];
      if (e === -1) {
        e = hull[(_hullIndex[i] + 1) % hull.length];
        if (e !== t) {
          if (pow3(x - points[e * 2], 2) + pow3(y - points[e * 2 + 1], 2) < dc) return e;
        }
        break;
      }
    } while (e !== e0);
    return c3;
  }
  render(context3) {
    const buffer3 = context3 == null ? context3 = new Path() : void 0;
    const { points, halfedges, triangles } = this;
    for (let i = 0, n = halfedges.length; i < n; ++i) {
      const j = halfedges[i];
      if (j < i) continue;
      const ti = triangles[i] * 2;
      const tj = triangles[j] * 2;
      context3.moveTo(points[ti], points[ti + 1]);
      context3.lineTo(points[tj], points[tj + 1]);
    }
    this.renderHull(context3);
    return buffer3 && buffer3.value();
  }
  renderPoints(context3, r) {
    if (r === void 0 && (!context3 || typeof context3.moveTo !== "function")) r = context3, context3 = null;
    r = r == void 0 ? 2 : +r;
    const buffer3 = context3 == null ? context3 = new Path() : void 0;
    const { points } = this;
    for (let i = 0, n = points.length; i < n; i += 2) {
      const x = points[i], y = points[i + 1];
      context3.moveTo(x + r, y);
      context3.arc(x, y, r, 0, tau2);
    }
    return buffer3 && buffer3.value();
  }
  renderHull(context3) {
    const buffer3 = context3 == null ? context3 = new Path() : void 0;
    const { hull, points } = this;
    const h = hull[0] * 2, n = hull.length;
    context3.moveTo(points[h], points[h + 1]);
    for (let i = 1; i < n; ++i) {
      const h2 = 2 * hull[i];
      context3.lineTo(points[h2], points[h2 + 1]);
    }
    context3.closePath();
    return buffer3 && buffer3.value();
  }
  hullPolygon() {
    const polygon = new Polygon();
    this.renderHull(polygon);
    return polygon.value();
  }
  renderTriangle(i, context3) {
    const buffer3 = context3 == null ? context3 = new Path() : void 0;
    const { points, triangles } = this;
    const t03 = triangles[i *= 3] * 2;
    const t13 = triangles[i + 1] * 2;
    const t22 = triangles[i + 2] * 2;
    context3.moveTo(points[t03], points[t03 + 1]);
    context3.lineTo(points[t13], points[t13 + 1]);
    context3.lineTo(points[t22], points[t22 + 1]);
    context3.closePath();
    return buffer3 && buffer3.value();
  }
  *trianglePolygons() {
    const { triangles } = this;
    for (let i = 0, n = triangles.length / 3; i < n; ++i) {
      yield this.trianglePolygon(i);
    }
  }
  trianglePolygon(i) {
    const polygon = new Polygon();
    this.renderTriangle(i, polygon);
    return polygon.value();
  }
};
function flatArray(points, fx, fy, that) {
  const n = points.length;
  const array4 = new Float64Array(n * 2);
  for (let i = 0; i < n; ++i) {
    const p = points[i];
    array4[i * 2] = fx.call(that, p, i, points);
    array4[i * 2 + 1] = fy.call(that, p, i, points);
  }
  return array4;
}
function* flatIterable(points, fx, fy, that) {
  let i = 0;
  for (const p of points) {
    yield fx.call(that, p, i, points);
    yield fy.call(that, p, i, points);
    ++i;
  }
}

// node_modules/d3-geo-voronoi/src/math.js
var pi2 = Math.PI;
var halfPi2 = pi2 / 2;
var quarterPi2 = pi2 / 4;
var tau3 = pi2 * 2;
var degrees4 = 180 / pi2;
var radians3 = pi2 / 180;
var atan22 = Math.atan2;
var cos2 = Math.cos;
var max2 = Math.max;
var min2 = Math.min;
var sin2 = Math.sin;
var sign3 = Math.sign || function(x) {
  return x > 0 ? 1 : x < 0 ? -1 : 0;
};
var sqrt3 = Math.sqrt;
function asin2(x) {
  return x > 1 ? halfPi2 : x < -1 ? -halfPi2 : Math.asin(x);
}

// node_modules/d3-geo-voronoi/src/cartesian.js
function cartesianDot2(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}
function cartesianCross2(a, b) {
  return [
    a[1] * b[2] - a[2] * b[1],
    a[2] * b[0] - a[0] * b[2],
    a[0] * b[1] - a[1] * b[0]
  ];
}
function cartesianAdd(a, b) {
  return [a[0] + b[0], a[1] + b[1], a[2] + b[2]];
}
function cartesianNormalize(d) {
  var l = sqrt3(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
  return [d[0] / l, d[1] / l, d[2] / l];
}

// node_modules/d3-geo-voronoi/src/delaunay.js
function spherical2(cartesian3) {
  return [
    atan22(cartesian3[1], cartesian3[0]) * degrees4,
    asin2(max2(-1, min2(1, cartesian3[2]))) * degrees4
  ];
}
function cartesian2(coordinates2) {
  const lambda = coordinates2[0] * radians3, phi = coordinates2[1] * radians3, cosphi = cos2(phi);
  return [cosphi * cos2(lambda), cosphi * sin2(lambda), sin2(phi)];
}
function excess(triangle) {
  triangle = triangle.map((p) => cartesian2(p));
  return cartesianDot2(triangle[0], cartesianCross2(triangle[2], triangle[1]));
}
function geoDelaunay(points) {
  const delaunay = geo_delaunay_from(points), triangles = geo_triangles(delaunay), edges = geo_edges(triangles, points), neighbors = geo_neighbors(triangles, points.length), find = geo_find(neighbors, points), circumcenters = geo_circumcenters(triangles, points), { polygons, centers } = geo_polygons(circumcenters, triangles, points), mesh = geo_mesh(polygons), hull = geo_hull(triangles, points), urquhart = geo_urquhart(edges, triangles);
  return {
    delaunay,
    edges,
    triangles,
    centers,
    neighbors,
    polygons,
    mesh,
    hull,
    urquhart,
    find
  };
}
function geo_find(neighbors, points) {
  function distance22(a, b) {
    let x = a[0] - b[0], y = a[1] - b[1], z = a[2] - b[2];
    return x * x + y * y + z * z;
  }
  return function find(x, y, next) {
    if (next === void 0) next = 0;
    let cell, dist2, found = next;
    const xyz = cartesian2([x, y]);
    do {
      cell = next;
      next = null;
      dist2 = distance22(xyz, cartesian2(points[cell]));
      neighbors[cell].forEach((i) => {
        let ndist = distance22(xyz, cartesian2(points[i]));
        if (ndist < dist2) {
          dist2 = ndist;
          next = i;
          found = i;
          return;
        }
      });
    } while (next !== null);
    return found;
  };
}
function geo_delaunay_from(points) {
  if (points.length < 2) return {};
  let pivot = 0;
  while (isNaN(points[pivot][0] + points[pivot][1]) && pivot++ < points.length) ;
  const r = rotation_default(points[pivot]), projection2 = stereographic_default().translate([0, 0]).scale(1).rotate(r.invert([180, 0]));
  points = points.map(projection2);
  const zeros = [];
  let max22 = 1;
  for (let i = 0, n = points.length; i < n; i++) {
    let m = points[i][0] ** 2 + points[i][1] ** 2;
    if (!isFinite(m) || m > 1e32) zeros.push(i);
    else if (m > max22) max22 = m;
  }
  const FAR = 1e6 * sqrt3(max22);
  zeros.forEach((i) => points[i] = [FAR, 0]);
  points.push([0, FAR]);
  points.push([-FAR, 0]);
  points.push([0, -FAR]);
  const delaunay = Delaunay.from(points);
  delaunay.projection = projection2;
  const { triangles, halfedges, inedges } = delaunay;
  const degenerate = [];
  for (let i = 0, l = halfedges.length; i < l; i++) {
    if (halfedges[i] < 0) {
      const j = i % 3 == 2 ? i - 2 : i + 1;
      const k = i % 3 == 0 ? i + 2 : i - 1;
      const a = halfedges[j];
      const b = halfedges[k];
      halfedges[a] = b;
      halfedges[b] = a;
      halfedges[j] = halfedges[k] = -1;
      triangles[i] = triangles[j] = triangles[k] = pivot;
      inedges[triangles[a]] = a % 3 == 0 ? a + 2 : a - 1;
      inedges[triangles[b]] = b % 3 == 0 ? b + 2 : b - 1;
      degenerate.push(Math.min(i, j, k));
      i += 2 - i % 3;
    } else if (triangles[i] > points.length - 3 - 1) {
      triangles[i] = pivot;
    }
  }
  return delaunay;
}
function geo_edges(triangles, points) {
  const _index = /* @__PURE__ */ new Set();
  if (points.length === 2) return [[0, 1]];
  triangles.forEach((tri2) => {
    if (tri2[0] === tri2[1]) return;
    if (excess(tri2.map((i) => points[i])) < 0) return;
    for (let i = 0, j; i < 3; i++) {
      j = (i + 1) % 3;
      _index.add(extent([tri2[i], tri2[j]]).join("-"));
    }
  });
  return Array.from(_index, (d) => d.split("-").map(Number));
}
function geo_triangles(delaunay) {
  const { triangles } = delaunay;
  if (!triangles) return [];
  const geo_triangles2 = [];
  for (let i = 0, n = triangles.length / 3; i < n; i++) {
    const a = triangles[3 * i], b = triangles[3 * i + 1], c3 = triangles[3 * i + 2];
    if (a !== b && b !== c3) {
      geo_triangles2.push([a, c3, b]);
    }
  }
  return geo_triangles2;
}
function geo_circumcenters(triangles, points) {
  return triangles.map((tri2) => {
    const c3 = tri2.map((i) => points[i]).map(cartesian2), V = cartesianAdd(
      cartesianAdd(cartesianCross2(c3[1], c3[0]), cartesianCross2(c3[2], c3[1])),
      cartesianCross2(c3[0], c3[2])
    );
    return spherical2(cartesianNormalize(V));
  });
}
function geo_neighbors(triangles, npoints) {
  const neighbors = [];
  triangles.forEach((tri2) => {
    for (let j = 0; j < 3; j++) {
      const a = tri2[j], b = tri2[(j + 1) % 3];
      neighbors[a] = neighbors[a] || [];
      neighbors[a].push(b);
    }
  });
  if (triangles.length === 0) {
    if (npoints === 2) neighbors[0] = [1], neighbors[1] = [0];
    else if (npoints === 1) neighbors[0] = [];
  }
  return neighbors;
}
function geo_polygons(circumcenters, triangles, points) {
  const polygons = [];
  const centers = circumcenters.slice();
  if (triangles.length === 0) {
    if (points.length < 2) return { polygons, centers };
    if (points.length === 2) {
      const a = cartesian2(points[0]), b = cartesian2(points[1]), m = cartesianNormalize(cartesianAdd(a, b)), d = cartesianNormalize(cartesianCross2(a, b)), c3 = cartesianCross2(m, d);
      const poly = [
        m,
        cartesianCross2(m, c3),
        cartesianCross2(cartesianCross2(m, c3), c3),
        cartesianCross2(cartesianCross2(cartesianCross2(m, c3), c3), c3)
      ].map(spherical2).map(supplement);
      return polygons.push(poly), polygons.push(poly.slice().reverse()), { polygons, centers };
    }
  }
  triangles.forEach((tri2, t) => {
    for (let j = 0; j < 3; j++) {
      const a = tri2[j], b = tri2[(j + 1) % 3], c3 = tri2[(j + 2) % 3];
      polygons[a] = polygons[a] || [];
      polygons[a].push([b, c3, t, [a, b, c3]]);
    }
  });
  const reordered = polygons.map((poly) => {
    const p = [poly[0][2]];
    let k = poly[0][1];
    for (let i = 1; i < poly.length; i++) {
      for (let j = 0; j < poly.length; j++) {
        if (poly[j][0] == k) {
          k = poly[j][1];
          p.push(poly[j][2]);
          break;
        }
      }
    }
    if (p.length > 2) {
      return p;
    } else if (p.length == 2) {
      const R0 = o_midpoint(
        points[poly[0][3][0]],
        points[poly[0][3][1]],
        centers[p[0]]
      ), R1 = o_midpoint(
        points[poly[0][3][2]],
        points[poly[0][3][0]],
        centers[p[0]]
      );
      const i0 = supplement(R0), i1 = supplement(R1);
      return [p[0], i1, p[1], i0];
    }
  });
  function supplement(point2) {
    let f = -1;
    centers.slice(triangles.length, Infinity).forEach((p, i) => {
      if (p[0] === point2[0] && p[1] === point2[1]) f = i + triangles.length;
    });
    if (f < 0) f = centers.length, centers.push(point2);
    return f;
  }
  return { polygons: reordered, centers };
}
function o_midpoint(a, b, c3) {
  a = cartesian2(a);
  b = cartesian2(b);
  c3 = cartesian2(c3);
  const s = sign3(cartesianDot2(cartesianCross2(b, a), c3));
  return spherical2(cartesianNormalize(cartesianAdd(a, b)).map((d) => s * d));
}
function geo_mesh(polygons) {
  const mesh = [];
  polygons.forEach((poly) => {
    if (!poly) return;
    let p = poly[poly.length - 1];
    for (let q of poly) {
      if (q > p) mesh.push([p, q]);
      p = q;
    }
  });
  return mesh;
}
function geo_urquhart(edges, triangles) {
  return function(distances) {
    const _lengths = /* @__PURE__ */ new Map(), _urquhart = /* @__PURE__ */ new Map();
    edges.forEach((edge, i) => {
      const u4 = edge.join("-");
      _lengths.set(u4, distances[i]);
      _urquhart.set(u4, true);
    });
    triangles.forEach((tri2) => {
      let l = 0, remove2 = -1;
      for (let j = 0; j < 3; j++) {
        let u4 = extent([tri2[j], tri2[(j + 1) % 3]]).join("-");
        if (_lengths.get(u4) > l) {
          l = _lengths.get(u4);
          remove2 = u4;
        }
      }
      _urquhart.set(remove2, false);
    });
    return edges.map((edge) => _urquhart.get(edge.join("-")));
  };
}
function geo_hull(triangles, points) {
  const _hull = /* @__PURE__ */ new Set(), hull = [];
  triangles.map((tri2) => {
    if (excess(tri2.map((i) => points[i > points.length ? 0 : i])) > 1e-12)
      return;
    for (let i = 0; i < 3; i++) {
      let e = [tri2[i], tri2[(i + 1) % 3]], code3 = `${e[0]}-${e[1]}`;
      if (_hull.has(code3)) _hull.delete(code3);
      else _hull.add(`${e[1]}-${e[0]}`);
    }
  });
  const _index = /* @__PURE__ */ new Map();
  let start;
  _hull.forEach((e) => {
    e = e.split("-").map(Number);
    _index.set(e[0], e[1]);
    start = e[0];
  });
  if (start === void 0) return hull;
  let next = start;
  do {
    hull.push(next);
    let n = _index.get(next);
    _index.set(next, -1);
    next = n;
  } while (next > -1 && next !== start);
  return hull;
}

// node_modules/d3-geo-voronoi/src/voronoi.js
function geoVoronoi(data) {
  const v2 = function(data2) {
    v2.delaunay = null;
    v2._data = data2;
    if (typeof v2._data === "object" && v2._data.type === "FeatureCollection") {
      v2._data = v2._data.features;
    }
    if (typeof v2._data === "object") {
      const temp = v2._data.map((d) => [v2._vx(d), v2._vy(d), d]).filter((d) => isFinite(d[0] + d[1]));
      v2.points = temp.map((d) => [d[0], d[1]]);
      v2.valid = temp.map((d) => d[2]);
      v2.delaunay = geoDelaunay(v2.points);
    }
    return v2;
  };
  v2._vx = function(d) {
    if (typeof d == "object" && "type" in d) {
      return centroid_default(d)[0];
    }
    if (0 in d) return d[0];
  };
  v2._vy = function(d) {
    if (typeof d == "object" && "type" in d) {
      return centroid_default(d)[1];
    }
    if (1 in d) return d[1];
  };
  v2.x = function(f) {
    if (!f) return v2._vx;
    v2._vx = f;
    return v2;
  };
  v2.y = function(f) {
    if (!f) return v2._vy;
    v2._vy = f;
    return v2;
  };
  v2.polygons = function(data2) {
    if (data2 !== void 0) {
      v2(data2);
    }
    if (!v2.delaunay) return false;
    const coll = {
      type: "FeatureCollection",
      features: []
    };
    if (v2.valid.length === 0) return coll;
    v2.delaunay.polygons.forEach(
      (poly, i) => coll.features.push({
        type: "Feature",
        geometry: !poly ? null : {
          type: "Polygon",
          coordinates: [
            [...poly, poly[0]].map((i2) => v2.delaunay.centers[i2])
          ]
        },
        properties: {
          site: v2.valid[i],
          sitecoordinates: v2.points[i],
          neighbours: v2.delaunay.neighbors[i]
          // not part of the public API
        }
      })
    );
    if (v2.valid.length === 1)
      coll.features.push({
        type: "Feature",
        geometry: { type: "Sphere" },
        properties: {
          site: v2.valid[0],
          sitecoordinates: v2.points[0],
          neighbours: []
        }
      });
    return coll;
  };
  v2.triangles = function(data2) {
    if (data2 !== void 0) {
      v2(data2);
    }
    if (!v2.delaunay) return false;
    return {
      type: "FeatureCollection",
      features: v2.delaunay.triangles.map((tri2, index5) => {
        tri2 = tri2.map((i) => v2.points[i]);
        tri2.center = v2.delaunay.centers[index5];
        return tri2;
      }).filter((tri2) => excess(tri2) > 0).map((tri2) => ({
        type: "Feature",
        properties: {
          circumcenter: tri2.center
        },
        geometry: {
          type: "Polygon",
          coordinates: [[...tri2, tri2[0]]]
        }
      }))
    };
  };
  v2.links = function(data2) {
    if (data2 !== void 0) {
      v2(data2);
    }
    if (!v2.delaunay) return false;
    const _distances = v2.delaunay.edges.map(
      (e) => distance_default(v2.points[e[0]], v2.points[e[1]])
    ), _urquart = v2.delaunay.urquhart(_distances);
    return {
      type: "FeatureCollection",
      features: v2.delaunay.edges.map((e, i) => ({
        type: "Feature",
        properties: {
          source: v2.valid[e[0]],
          target: v2.valid[e[1]],
          length: _distances[i],
          urquhart: !!_urquart[i]
        },
        geometry: {
          type: "LineString",
          coordinates: [v2.points[e[0]], v2.points[e[1]]]
        }
      }))
    };
  };
  v2.mesh = function(data2) {
    if (data2 !== void 0) {
      v2(data2);
    }
    if (!v2.delaunay) return false;
    return {
      type: "MultiLineString",
      coordinates: v2.delaunay.edges.map((e) => [
        v2.points[e[0]],
        v2.points[e[1]]
      ])
    };
  };
  v2.cellMesh = function(data2) {
    if (data2 !== void 0) {
      v2(data2);
    }
    if (!v2.delaunay) return false;
    const { centers, polygons } = v2.delaunay;
    const coordinates2 = [];
    for (const p of polygons) {
      if (!p) continue;
      for (let n = p.length, p02 = p[n - 1], p1 = p[0], i = 0; i < n; p02 = p1, p1 = p[++i]) {
        if (p1 > p02) {
          coordinates2.push([centers[p02], centers[p1]]);
        }
      }
    }
    return {
      type: "MultiLineString",
      coordinates: coordinates2
    };
  };
  v2._found = void 0;
  v2.find = function(x, y, radius) {
    v2._found = v2.delaunay.find(x, y, v2._found);
    if (!radius || distance_default([x, y], v2.points[v2._found]) < radius)
      return v2._found;
  };
  v2.hull = function(data2) {
    if (data2 !== void 0) {
      v2(data2);
    }
    const hull = v2.delaunay.hull, points = v2.points;
    return hull.length === 0 ? null : {
      type: "Polygon",
      coordinates: [[...hull.map((i) => points[i]), points[hull[0]]]]
    };
  };
  return data ? v2(data) : v2;
}

// node_modules/three-conic-polygon-geometry/dist/three-conic-polygon-geometry.mjs
function _arrayLikeToArray5(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}
function _arrayWithHoles5(r) {
  if (Array.isArray(r)) return r;
}
function _arrayWithoutHoles4(r) {
  if (Array.isArray(r)) return _arrayLikeToArray5(r);
}
function _assertThisInitialized3(e) {
  if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function _callSuper3(t, o, e) {
  return o = _getPrototypeOf3(o), _possibleConstructorReturn3(t, _isNativeReflectConstruct3() ? Reflect.construct(o, [], _getPrototypeOf3(t).constructor) : o.apply(t, e));
}
function _classCallCheck5(a, n) {
  if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
}
function _createClass5(e, r, t) {
  return Object.defineProperty(e, "prototype", {
    writable: false
  }), e;
}
function _getPrototypeOf3(t) {
  return _getPrototypeOf3 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t4) {
    return t4.__proto__ || Object.getPrototypeOf(t4);
  }, _getPrototypeOf3(t);
}
function _inherits3(t, e) {
  if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
  t.prototype = Object.create(e && e.prototype, {
    constructor: {
      value: t,
      writable: true,
      configurable: true
    }
  }), Object.defineProperty(t, "prototype", {
    writable: false
  }), e && _setPrototypeOf3(t, e);
}
function _isNativeReflectConstruct3() {
  try {
    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (t4) {
  }
  return (_isNativeReflectConstruct3 = function() {
    return !!t;
  })();
}
function _iterableToArray4(r) {
  if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
}
function _iterableToArrayLimit5(r, l) {
  var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (null != t) {
    var e, n, i, u4, a = [], f = true, o = false;
    try {
      if (i = (t = t.call(r)).next, 0 === l) ;
      else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = true) ;
    } catch (r2) {
      o = true, n = r2;
    } finally {
      try {
        if (!f && null != t.return && (u4 = t.return(), Object(u4) !== u4)) return;
      } finally {
        if (o) throw n;
      }
    }
    return a;
  }
}
function _nonIterableRest5() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _nonIterableSpread4() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _possibleConstructorReturn3(t, e) {
  if (e && ("object" == typeof e || "function" == typeof e)) return e;
  if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
  return _assertThisInitialized3(t);
}
function _setPrototypeOf3(t, e) {
  return _setPrototypeOf3 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t4, e3) {
    return t4.__proto__ = e3, t4;
  }, _setPrototypeOf3(t, e);
}
function _slicedToArray5(r, e) {
  return _arrayWithHoles5(r) || _iterableToArrayLimit5(r, e) || _unsupportedIterableToArray5(r, e) || _nonIterableRest5();
}
function _toConsumableArray4(r) {
  return _arrayWithoutHoles4(r) || _iterableToArray4(r) || _unsupportedIterableToArray5(r) || _nonIterableSpread4();
}
function _unsupportedIterableToArray5(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray5(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray5(r, a) : void 0;
  }
}
function geoPolygonTriangulate(polygon) {
  var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$resolution = _ref.resolution, resolution2 = _ref$resolution === void 0 ? Infinity : _ref$resolution;
  var contour = interpolateContourPoints(polygon, resolution2);
  var edgePoints = merge(contour);
  var innerPoints = getInnerGeoPoints(polygon, resolution2);
  var points = [].concat(_toConsumableArray4(edgePoints), _toConsumableArray4(innerPoints));
  var boundariesGeojson = {
    type: "Polygon",
    coordinates: polygon
  };
  var _geoBounds = bounds_default(boundariesGeojson), _geoBounds2 = _slicedToArray5(_geoBounds, 2), _geoBounds2$ = _slicedToArray5(_geoBounds2[0], 2), minLng = _geoBounds2$[0], minLat = _geoBounds2$[1], _geoBounds2$2 = _slicedToArray5(_geoBounds2[1], 2), maxLng = _geoBounds2$2[0], maxLat = _geoBounds2$2[1];
  var crossesPoleOrAntimeridian = minLng > maxLng || maxLat >= 89 || minLat <= -89;
  var indices = [];
  if (crossesPoleOrAntimeridian) {
    var vt = geoVoronoi(points).triangles();
    var pntMap = new Map(points.map(function(_ref2, idx) {
      var _ref3 = _slicedToArray5(_ref2, 2), lng = _ref3[0], lat = _ref3[1];
      return ["".concat(lng, "-").concat(lat), idx];
    }));
    vt.features.forEach(function(f) {
      var _indices;
      var triangle = f.geometry.coordinates[0].slice(0, 3).reverse();
      var inds = [];
      triangle.forEach(function(_ref4) {
        var _ref5 = _slicedToArray5(_ref4, 2), lng = _ref5[0], lat = _ref5[1];
        var k = "".concat(lng, "-").concat(lat);
        pntMap.has(k) && inds.push(pntMap.get(k));
      });
      if (inds.length !== 3) return;
      if (inds.some(function(ind) {
        return ind < edgePoints.length;
      })) {
        var triangleCentroid = f.properties.circumcenter;
        if (!pointInside(triangleCentroid, boundariesGeojson, crossesPoleOrAntimeridian)) return;
      }
      (_indices = indices).push.apply(_indices, inds);
    });
  } else if (!innerPoints.length) {
    var _earcutFlatten = flatten2(contour), vertices = _earcutFlatten.vertices, _earcutFlatten$holes = _earcutFlatten.holes, holes = _earcutFlatten$holes === void 0 ? [] : _earcutFlatten$holes;
    indices = earcut(vertices, holes, 2);
  } else {
    var delaunay = Delaunator.from(points);
    var _loop = function _loop2(i2) {
      var _indices2;
      var inds = [2, 1, 0].map(function(idx) {
        return delaunay.triangles[i2 + idx];
      });
      var triangle = inds.map(function(indice) {
        return points[indice];
      });
      if (inds.some(function(ind) {
        return ind < edgePoints.length;
      })) {
        var triangleCentroid = [0, 1].map(function(coordIdx) {
          return mean(triangle, function(p) {
            return p[coordIdx];
          });
        });
        if (!pointInside(triangleCentroid, boundariesGeojson, crossesPoleOrAntimeridian)) return 1;
      }
      (_indices2 = indices).push.apply(_indices2, _toConsumableArray4(inds));
    };
    for (var i = 0, len = delaunay.triangles.length; i < len; i += 3) {
      if (_loop(i)) continue;
    }
  }
  var lngUvScale = linear2(extent(points, function(d) {
    return d[0];
  }), [0, 1]);
  var latUvScale = linear2(extent(points, function(d) {
    return d[1];
  }), [0, 1]);
  var uvs = points.map(function(_ref6) {
    var _ref7 = _slicedToArray5(_ref6, 2), lng = _ref7[0], lat = _ref7[1];
    return [lngUvScale(lng), latUvScale(lat)];
  });
  var triangles = {
    points,
    indices,
    uvs
  };
  return {
    contour,
    triangles
  };
}
function interpolateContourPoints(polygon, maxDistance) {
  return polygon.map(function(coords) {
    var pnts = [];
    var prevPnt;
    coords.forEach(function(pnt) {
      if (prevPnt) {
        var dist2 = distance_default(pnt, prevPnt) * 180 / Math.PI;
        if (dist2 > maxDistance) {
          var interpol = interpolate_default(prevPnt, pnt);
          var tStep = 1 / Math.ceil(dist2 / maxDistance);
          var t = tStep;
          while (t < 1) {
            pnts.push(interpol(t));
            t += tStep;
          }
        }
      }
      pnts.push(prevPnt = pnt);
    });
    return pnts;
  });
}
function getInnerGeoPoints(polygon, maxDistance) {
  var boundariesGeojson = {
    type: "Polygon",
    coordinates: polygon
  };
  var _geoBounds3 = bounds_default(boundariesGeojson), _geoBounds4 = _slicedToArray5(_geoBounds3, 2), _geoBounds4$ = _slicedToArray5(_geoBounds4[0], 2), minLng = _geoBounds4$[0], minLat = _geoBounds4$[1], _geoBounds4$2 = _slicedToArray5(_geoBounds4[1], 2), maxLng = _geoBounds4$2[0], maxLat = _geoBounds4$2[1];
  if (Math.min(Math.abs(maxLng - minLng), Math.abs(maxLat - minLat)) < maxDistance) return [];
  var crossesPoleOrAntimeridian = minLng > maxLng || maxLat >= 89 || minLat <= -89;
  return getGeoSpiralGrid(maxDistance, {
    minLng,
    maxLng,
    minLat,
    maxLat
  }).filter(function(pnt) {
    return pointInside(pnt, boundariesGeojson, crossesPoleOrAntimeridian);
  });
}
function getGeoSpiralGrid(distanceBetweenPoints) {
  var _ref8 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, minLng = _ref8.minLng, maxLng = _ref8.maxLng, minLat = _ref8.minLat, maxLat = _ref8.maxLat;
  var numPoints = Math.round(Math.pow(360 / distanceBetweenPoints, 2) / Math.PI);
  var phi = (1 + Math.sqrt(5)) / 2;
  var getPntLng = function getPntLng2(idx) {
    return idx / phi * 360 % 360 - 180;
  };
  var getPntLat = function getPntLat2(idx) {
    return Math.acos(2 * idx / numPoints - 1) / Math.PI * 180 - 90;
  };
  var getPntIdx = function getPntIdx2(lat) {
    return numPoints * (Math.cos((lat + 90) * Math.PI / 180) + 1) / 2;
  };
  var pntIdxRange = [maxLat !== void 0 ? Math.ceil(getPntIdx(maxLat)) : 0, minLat !== void 0 ? Math.floor(getPntIdx(minLat)) : numPoints - 1];
  var isLngInRange = minLng === void 0 && maxLng === void 0 ? function() {
    return true;
  } : minLng === void 0 ? function(lng2) {
    return lng2 <= maxLng;
  } : maxLng === void 0 ? function(lng2) {
    return lng2 >= minLng;
  } : maxLng >= minLng ? function(lng2) {
    return lng2 >= minLng && lng2 <= maxLng;
  } : function(lng2) {
    return lng2 >= minLng || lng2 <= maxLng;
  };
  var pnts = [];
  for (var i = pntIdxRange[0]; i <= pntIdxRange[1]; i++) {
    var lng = getPntLng(i);
    isLngInRange(lng) && pnts.push([lng, getPntLat(i)]);
  }
  return pnts;
}
function pointInside(pnt, polygon) {
  var crossesPoleOrAntimeridian = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  return crossesPoleOrAntimeridian ? contains_default(polygon, pnt) : turf_boolean_point_in_polygon_default(pnt, polygon);
}
var THREE2 = window.THREE ? window.THREE : {
  BufferGeometry,
  Float32BufferAttribute
};
var setAttributeFn2 = new THREE2.BufferGeometry().setAttribute ? "setAttribute" : "addAttribute";
var ConicPolygonGeometry = function(_THREE$BufferGeometry) {
  function ConicPolygonGeometry2(polygonGeoJson, bottomHeight, topHeight, closedBottom, closedTop, includeSides, curvatureResolution) {
    var _this;
    _classCallCheck5(this, ConicPolygonGeometry2);
    _this = _callSuper3(this, ConicPolygonGeometry2);
    _this.type = "ConicPolygonGeometry";
    _this.parameters = {
      polygonGeoJson,
      bottomHeight,
      topHeight,
      closedBottom,
      closedTop,
      includeSides,
      curvatureResolution
    };
    bottomHeight = bottomHeight || 0;
    topHeight = topHeight || 1;
    closedBottom = closedBottom !== void 0 ? closedBottom : true;
    closedTop = closedTop !== void 0 ? closedTop : true;
    includeSides = includeSides !== void 0 ? includeSides : true;
    curvatureResolution = curvatureResolution || 5;
    var _geoPolygonTriangulat = geoPolygonTriangulate(polygonGeoJson, {
      resolution: curvatureResolution
    }), contour = _geoPolygonTriangulat.contour, triangles = _geoPolygonTriangulat.triangles;
    var flatUvs = merge(triangles.uvs);
    var vertices = [];
    var uvs = [];
    var indices = [];
    var groupCnt = 0;
    var addGroup = function addGroup2(groupData) {
      var prevVertCnt = Math.round(vertices.length / 3);
      var prevIndCnt = indices.length;
      vertices = vertices.concat(groupData.vertices);
      uvs = uvs.concat(groupData.uvs);
      indices = indices.concat(!prevVertCnt ? groupData.indices : groupData.indices.map(function(ind) {
        return ind + prevVertCnt;
      }));
      _this.addGroup(prevIndCnt, indices.length - prevIndCnt, groupCnt++);
    };
    includeSides && addGroup(generateTorso());
    closedBottom && addGroup(generateCap(bottomHeight, false));
    closedTop && addGroup(generateCap(topHeight, true));
    _this.setIndex(indices);
    _this[setAttributeFn2]("position", new THREE2.Float32BufferAttribute(vertices, 3));
    _this[setAttributeFn2]("uv", new THREE2.Float32BufferAttribute(uvs, 2));
    _this.computeVertexNormals();
    function generateVertices(polygon, altitude) {
      var altFn = typeof altitude === "function" ? altitude : function() {
        return altitude;
      };
      var coords3d = polygon.map(function(coords) {
        return coords.map(function(_ref) {
          var _ref2 = _slicedToArray5(_ref, 2), lng = _ref2[0], lat = _ref2[1];
          return polar2Cartesian3(lat, lng, altFn(lng, lat));
        });
      });
      return flatten2(coords3d);
    }
    function generateTorso() {
      var _generateVertices = generateVertices(contour, bottomHeight), bottomVerts = _generateVertices.vertices, holes = _generateVertices.holes;
      var _generateVertices2 = generateVertices(contour, topHeight), topVerts = _generateVertices2.vertices;
      var vertices2 = merge([topVerts, bottomVerts]);
      var numPoints = Math.round(topVerts.length / 3);
      var holesIdx = new Set(holes);
      var lastHoleIdx = 0;
      var indices2 = [];
      for (var v0Idx = 0; v0Idx < numPoints; v0Idx++) {
        var v1Idx = v0Idx + 1;
        if (v1Idx === numPoints) {
          v1Idx = lastHoleIdx;
        } else if (holesIdx.has(v1Idx)) {
          var holeIdx = v1Idx;
          v1Idx = lastHoleIdx;
          lastHoleIdx = holeIdx;
        }
        indices2.push(v0Idx, v0Idx + numPoints, v1Idx + numPoints);
        indices2.push(v1Idx + numPoints, v1Idx, v0Idx);
      }
      var uvs2 = [];
      for (var v2 = 1; v2 >= 0; v2--) for (var i = 0; i < numPoints; i += 1) uvs2.push(i / (numPoints - 1), v2);
      return {
        indices: indices2,
        vertices: vertices2,
        uvs: uvs2
      };
    }
    function generateCap(radius) {
      var isTop = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      return {
        // need to reverse-wind the bottom triangles to make them face outwards
        indices: isTop ? triangles.indices : triangles.indices.slice().reverse(),
        vertices: generateVertices([triangles.points], radius).vertices,
        uvs: flatUvs
      };
    }
    return _this;
  }
  _inherits3(ConicPolygonGeometry2, _THREE$BufferGeometry);
  return _createClass5(ConicPolygonGeometry2);
}(THREE2.BufferGeometry);
function polar2Cartesian3(lat, lng) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
  var phi = (90 - lat) * Math.PI / 180;
  var theta = (90 - lng) * Math.PI / 180;
  return [
    r * Math.sin(phi) * Math.cos(theta),
    // x
    r * Math.cos(phi),
    // y
    r * Math.sin(phi) * Math.sin(theta)
    // z
  ];
}

// node_modules/index-array-by/dist/index-array-by.mjs
function _arrayLikeToArray6(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}
function _arrayWithHoles6(r) {
  if (Array.isArray(r)) return r;
}
function _arrayWithoutHoles5(r) {
  if (Array.isArray(r)) return _arrayLikeToArray6(r);
}
function _iterableToArray5(r) {
  if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
}
function _iterableToArrayLimit6(r, l) {
  var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (null != t) {
    var e, n, i, u4, a = [], f = true, o = false;
    try {
      if (i = (t = t.call(r)).next, 0 === l) ;
      else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = true) ;
    } catch (r2) {
      o = true, n = r2;
    } finally {
      try {
        if (!f && null != t.return && (u4 = t.return(), Object(u4) !== u4)) return;
      } finally {
        if (o) throw n;
      }
    }
    return a;
  }
}
function _nonIterableRest6() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _nonIterableSpread5() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _objectWithoutProperties(e, t) {
  if (null == e) return {};
  var o, r, i = _objectWithoutPropertiesLoose(e, t);
  if (Object.getOwnPropertySymbols) {
    var s = Object.getOwnPropertySymbols(e);
    for (r = 0; r < s.length; r++) o = s[r], t.includes(o) || {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
  }
  return i;
}
function _objectWithoutPropertiesLoose(r, e) {
  if (null == r) return {};
  var t = {};
  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
    if (e.includes(n)) continue;
    t[n] = r[n];
  }
  return t;
}
function _slicedToArray6(r, e) {
  return _arrayWithHoles6(r) || _iterableToArrayLimit6(r, e) || _unsupportedIterableToArray6(r, e) || _nonIterableRest6();
}
function _toConsumableArray5(r) {
  return _arrayWithoutHoles5(r) || _iterableToArray5(r) || _unsupportedIterableToArray6(r) || _nonIterableSpread5();
}
function _toPrimitive3(t, r) {
  if ("object" != typeof t || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r);
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(t);
}
function _toPropertyKey3(t) {
  var i = _toPrimitive3(t, "string");
  return "symbol" == typeof i ? i : i + "";
}
function _unsupportedIterableToArray6(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray6(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray6(r, a) : void 0;
  }
}
var index4 = function() {
  var list = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  var keyAccessors = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  var multiItem = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
  var flattenKeys = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
  var keys = (keyAccessors instanceof Array ? keyAccessors.length ? keyAccessors : [void 0] : [keyAccessors]).map(function(key) {
    return {
      keyAccessor: key,
      isProp: !(key instanceof Function)
    };
  });
  var indexedResult = list.reduce(function(res, item) {
    var iterObj = res;
    var itemVal = item;
    keys.forEach(function(_ref, idx) {
      var keyAccessor = _ref.keyAccessor, isProp = _ref.isProp;
      var key;
      if (isProp) {
        var _itemVal = itemVal, propVal = _itemVal[keyAccessor], rest = _objectWithoutProperties(_itemVal, [keyAccessor].map(_toPropertyKey3));
        key = propVal;
        itemVal = rest;
      } else {
        key = keyAccessor(itemVal, idx);
      }
      if (idx + 1 < keys.length) {
        if (!iterObj.hasOwnProperty(key)) {
          iterObj[key] = {};
        }
        iterObj = iterObj[key];
      } else {
        if (multiItem) {
          if (!iterObj.hasOwnProperty(key)) {
            iterObj[key] = [];
          }
          iterObj[key].push(itemVal);
        } else {
          iterObj[key] = itemVal;
        }
      }
    });
    return res;
  }, {});
  if (multiItem instanceof Function) {
    (function reduce2(node) {
      var level = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
      if (level === keys.length) {
        Object.keys(node).forEach(function(k) {
          return node[k] = multiItem(node[k]);
        });
      } else {
        Object.values(node).forEach(function(child) {
          return reduce2(child, level + 1);
        });
      }
    })(indexedResult);
  }
  var result = indexedResult;
  if (flattenKeys) {
    result = [];
    (function flatten3(node) {
      var accKeys = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
      if (accKeys.length === keys.length) {
        result.push({
          keys: accKeys,
          vals: node
        });
      } else {
        Object.entries(node).forEach(function(_ref2) {
          var _ref3 = _slicedToArray6(_ref2, 2), key = _ref3[0], val = _ref3[1];
          return flatten3(val, [].concat(_toConsumableArray5(accKeys), [key]));
        });
      }
    })(indexedResult);
    if (keyAccessors instanceof Array && keyAccessors.length === 0 && result.length === 1) {
      result[0].keys = [];
    }
  }
  return result;
};

// node_modules/h3-js/dist/browser/h3-js.es.js
var libh3 = function(libh32) {
  libh32 = libh32 || {};
  var Module = typeof libh32 !== "undefined" ? libh32 : {};
  var moduleOverrides = {};
  var key;
  for (key in Module) {
    if (Module.hasOwnProperty(key)) {
      moduleOverrides[key] = Module[key];
    }
  }
  var arguments_ = [];
  var scriptDirectory = "";
  function locateFile(path) {
    if (Module["locateFile"]) {
      return Module["locateFile"](path, scriptDirectory);
    }
    return scriptDirectory + path;
  }
  var readAsync;
  {
    if (typeof document !== "undefined" && document.currentScript) {
      scriptDirectory = document.currentScript.src;
    }
    if (scriptDirectory.indexOf("blob:") !== 0) {
      scriptDirectory = scriptDirectory.substr(0, scriptDirectory.lastIndexOf("/") + 1);
    } else {
      scriptDirectory = "";
    }
    readAsync = function readAsync2(url, onload, onerror) {
      var xhr = new XMLHttpRequest();
      xhr.open("GET", url, true);
      xhr.responseType = "arraybuffer";
      xhr.onload = function xhr_onload() {
        if (xhr.status == 200 || xhr.status == 0 && xhr.response) {
          onload(xhr.response);
          return;
        }
        var data = tryParseAsDataURI(url);
        if (data) {
          onload(data.buffer);
          return;
        }
        onerror();
      };
      xhr.onerror = onerror;
      xhr.send(null);
    };
  }
  var out = Module["print"] || console.log.bind(console);
  var err = Module["printErr"] || console.warn.bind(console);
  for (key in moduleOverrides) {
    if (moduleOverrides.hasOwnProperty(key)) {
      Module[key] = moduleOverrides[key];
    }
  }
  moduleOverrides = null;
  if (Module["arguments"]) {
    arguments_ = Module["arguments"];
  }
  var tempRet0 = 0;
  var setTempRet0 = function(value) {
    tempRet0 = value;
  };
  var getTempRet0 = function() {
    return tempRet0;
  };
  var GLOBAL_BASE = 8;
  function setValue(ptr, value, type, noSafe) {
    type = type || "i8";
    if (type.charAt(type.length - 1) === "*") {
      type = "i32";
    }
    switch (type) {
      case "i1":
        HEAP8[ptr >> 0] = value;
        break;
      case "i8":
        HEAP8[ptr >> 0] = value;
        break;
      case "i16":
        HEAP16[ptr >> 1] = value;
        break;
      case "i32":
        HEAP32[ptr >> 2] = value;
        break;
      case "i64":
        tempI64 = [value >>> 0, (tempDouble = value, +Math_abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math_min(+Math_floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math_ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[ptr >> 2] = tempI64[0], HEAP32[ptr + 4 >> 2] = tempI64[1];
        break;
      case "float":
        HEAPF32[ptr >> 2] = value;
        break;
      case "double":
        HEAPF64[ptr >> 3] = value;
        break;
      default:
        abort("invalid type for setValue: " + type);
    }
  }
  function getValue(ptr, type, noSafe) {
    type = type || "i8";
    if (type.charAt(type.length - 1) === "*") {
      type = "i32";
    }
    switch (type) {
      case "i1":
        return HEAP8[ptr >> 0];
      case "i8":
        return HEAP8[ptr >> 0];
      case "i16":
        return HEAP16[ptr >> 1];
      case "i32":
        return HEAP32[ptr >> 2];
      case "i64":
        return HEAP32[ptr >> 2];
      case "float":
        return HEAPF32[ptr >> 2];
      case "double":
        return HEAPF64[ptr >> 3];
      default:
        abort("invalid type for getValue: " + type);
    }
    return null;
  }
  var ABORT = false;
  function assert(condition, text) {
    if (!condition) {
      abort("Assertion failed: " + text);
    }
  }
  function getCFunc(ident) {
    var func = Module["_" + ident];
    assert(func, "Cannot call unknown function " + ident + ", make sure it is exported");
    return func;
  }
  function ccall(ident, returnType, argTypes, args, opts) {
    var toC = {
      "string": function(str) {
        var ret2 = 0;
        if (str !== null && str !== void 0 && str !== 0) {
          var len = (str.length << 2) + 1;
          ret2 = stackAlloc(len);
          stringToUTF8(str, ret2, len);
        }
        return ret2;
      },
      "array": function(arr) {
        var ret2 = stackAlloc(arr.length);
        writeArrayToMemory(arr, ret2);
        return ret2;
      }
    };
    function convertReturnValue(ret2) {
      if (returnType === "string") {
        return UTF8ToString(ret2);
      }
      if (returnType === "boolean") {
        return Boolean(ret2);
      }
      return ret2;
    }
    var func = getCFunc(ident);
    var cArgs = [];
    var stack3 = 0;
    if (args) {
      for (var i = 0; i < args.length; i++) {
        var converter = toC[argTypes[i]];
        if (converter) {
          if (stack3 === 0) {
            stack3 = stackSave();
          }
          cArgs[i] = converter(args[i]);
        } else {
          cArgs[i] = args[i];
        }
      }
    }
    var ret = func.apply(null, cArgs);
    ret = convertReturnValue(ret);
    if (stack3 !== 0) {
      stackRestore(stack3);
    }
    return ret;
  }
  function cwrap(ident, returnType, argTypes, opts) {
    argTypes = argTypes || [];
    var numericArgs = argTypes.every(function(type) {
      return type === "number";
    });
    var numericRet = returnType !== "string";
    if (numericRet && numericArgs && !opts) {
      return getCFunc(ident);
    }
    return function() {
      return ccall(ident, returnType, argTypes, arguments, opts);
    };
  }
  var UTF8Decoder = typeof TextDecoder !== "undefined" ? new TextDecoder("utf8") : void 0;
  function UTF8ArrayToString(u8Array, idx, maxBytesToRead) {
    var endIdx = idx + maxBytesToRead;
    var endPtr = idx;
    while (u8Array[endPtr] && !(endPtr >= endIdx)) {
      ++endPtr;
    }
    if (endPtr - idx > 16 && u8Array.subarray && UTF8Decoder) {
      return UTF8Decoder.decode(u8Array.subarray(idx, endPtr));
    } else {
      var str = "";
      while (idx < endPtr) {
        var u0 = u8Array[idx++];
        if (!(u0 & 128)) {
          str += String.fromCharCode(u0);
          continue;
        }
        var u1 = u8Array[idx++] & 63;
        if ((u0 & 224) == 192) {
          str += String.fromCharCode((u0 & 31) << 6 | u1);
          continue;
        }
        var u22 = u8Array[idx++] & 63;
        if ((u0 & 240) == 224) {
          u0 = (u0 & 15) << 12 | u1 << 6 | u22;
        } else {
          u0 = (u0 & 7) << 18 | u1 << 12 | u22 << 6 | u8Array[idx++] & 63;
        }
        if (u0 < 65536) {
          str += String.fromCharCode(u0);
        } else {
          var ch = u0 - 65536;
          str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
        }
      }
    }
    return str;
  }
  function UTF8ToString(ptr, maxBytesToRead) {
    return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : "";
  }
  function stringToUTF8Array(str, outU8Array, outIdx, maxBytesToWrite) {
    if (!(maxBytesToWrite > 0)) {
      return 0;
    }
    var startIdx = outIdx;
    var endIdx = outIdx + maxBytesToWrite - 1;
    for (var i = 0; i < str.length; ++i) {
      var u4 = str.charCodeAt(i);
      if (u4 >= 55296 && u4 <= 57343) {
        var u1 = str.charCodeAt(++i);
        u4 = 65536 + ((u4 & 1023) << 10) | u1 & 1023;
      }
      if (u4 <= 127) {
        if (outIdx >= endIdx) {
          break;
        }
        outU8Array[outIdx++] = u4;
      } else if (u4 <= 2047) {
        if (outIdx + 1 >= endIdx) {
          break;
        }
        outU8Array[outIdx++] = 192 | u4 >> 6;
        outU8Array[outIdx++] = 128 | u4 & 63;
      } else if (u4 <= 65535) {
        if (outIdx + 2 >= endIdx) {
          break;
        }
        outU8Array[outIdx++] = 224 | u4 >> 12;
        outU8Array[outIdx++] = 128 | u4 >> 6 & 63;
        outU8Array[outIdx++] = 128 | u4 & 63;
      } else {
        if (outIdx + 3 >= endIdx) {
          break;
        }
        outU8Array[outIdx++] = 240 | u4 >> 18;
        outU8Array[outIdx++] = 128 | u4 >> 12 & 63;
        outU8Array[outIdx++] = 128 | u4 >> 6 & 63;
        outU8Array[outIdx++] = 128 | u4 & 63;
      }
    }
    outU8Array[outIdx] = 0;
    return outIdx - startIdx;
  }
  function stringToUTF8(str, outPtr, maxBytesToWrite) {
    return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
  }
  var UTF16Decoder = typeof TextDecoder !== "undefined" ? new TextDecoder("utf-16le") : void 0;
  function writeArrayToMemory(array4, buffer4) {
    HEAP8.set(array4, buffer4);
  }
  function alignUp(x, multiple) {
    if (x % multiple > 0) {
      x += multiple - x % multiple;
    }
    return x;
  }
  var buffer3, HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;
  function updateGlobalBufferAndViews(buf) {
    buffer3 = buf;
    Module["HEAP8"] = HEAP8 = new Int8Array(buf);
    Module["HEAP16"] = HEAP16 = new Int16Array(buf);
    Module["HEAP32"] = HEAP32 = new Int32Array(buf);
    Module["HEAPU8"] = HEAPU8 = new Uint8Array(buf);
    Module["HEAPU16"] = HEAPU16 = new Uint16Array(buf);
    Module["HEAPU32"] = HEAPU32 = new Uint32Array(buf);
    Module["HEAPF32"] = HEAPF32 = new Float32Array(buf);
    Module["HEAPF64"] = HEAPF64 = new Float64Array(buf);
  }
  var DYNAMIC_BASE = 5271520, DYNAMICTOP_PTR = 28608;
  var INITIAL_TOTAL_MEMORY = Module["TOTAL_MEMORY"] || 33554432;
  if (Module["buffer"]) {
    buffer3 = Module["buffer"];
  } else {
    buffer3 = new ArrayBuffer(INITIAL_TOTAL_MEMORY);
  }
  INITIAL_TOTAL_MEMORY = buffer3.byteLength;
  updateGlobalBufferAndViews(buffer3);
  HEAP32[DYNAMICTOP_PTR >> 2] = DYNAMIC_BASE;
  function callRuntimeCallbacks(callbacks) {
    while (callbacks.length > 0) {
      var callback = callbacks.shift();
      if (typeof callback == "function") {
        callback();
        continue;
      }
      var func = callback.func;
      if (typeof func === "number") {
        if (callback.arg === void 0) {
          Module["dynCall_v"](func);
        } else {
          Module["dynCall_vi"](func, callback.arg);
        }
      } else {
        func(callback.arg === void 0 ? null : callback.arg);
      }
    }
  }
  var __ATPRERUN__ = [];
  var __ATINIT__ = [];
  var __ATMAIN__ = [];
  var __ATPOSTRUN__ = [];
  function preRun() {
    if (Module["preRun"]) {
      if (typeof Module["preRun"] == "function") {
        Module["preRun"] = [Module["preRun"]];
      }
      while (Module["preRun"].length) {
        addOnPreRun(Module["preRun"].shift());
      }
    }
    callRuntimeCallbacks(__ATPRERUN__);
  }
  function initRuntime() {
    callRuntimeCallbacks(__ATINIT__);
  }
  function preMain() {
    callRuntimeCallbacks(__ATMAIN__);
  }
  function postRun() {
    if (Module["postRun"]) {
      if (typeof Module["postRun"] == "function") {
        Module["postRun"] = [Module["postRun"]];
      }
      while (Module["postRun"].length) {
        addOnPostRun(Module["postRun"].shift());
      }
    }
    callRuntimeCallbacks(__ATPOSTRUN__);
  }
  function addOnPreRun(cb) {
    __ATPRERUN__.unshift(cb);
  }
  function addOnPostRun(cb) {
    __ATPOSTRUN__.unshift(cb);
  }
  var Math_abs = Math.abs;
  var Math_ceil = Math.ceil;
  var Math_floor = Math.floor;
  var Math_min = Math.min;
  var runDependencies = 0;
  var runDependencyWatcher = null;
  var dependenciesFulfilled = null;
  function addRunDependency(id) {
    runDependencies++;
    if (Module["monitorRunDependencies"]) {
      Module["monitorRunDependencies"](runDependencies);
    }
  }
  function removeRunDependency(id) {
    runDependencies--;
    if (Module["monitorRunDependencies"]) {
      Module["monitorRunDependencies"](runDependencies);
    }
    if (runDependencies == 0) {
      if (runDependencyWatcher !== null) {
        clearInterval(runDependencyWatcher);
        runDependencyWatcher = null;
      }
      if (dependenciesFulfilled) {
        var callback = dependenciesFulfilled;
        dependenciesFulfilled = null;
        callback();
      }
    }
  }
  Module["preloadedImages"] = {};
  Module["preloadedAudios"] = {};
  var memoryInitializer = null;
  var dataURIPrefix = "data:application/octet-stream;base64,";
  function isDataURI(filename) {
    return String.prototype.startsWith ? filename.startsWith(dataURIPrefix) : filename.indexOf(dataURIPrefix) === 0;
  }
  var tempDouble;
  var tempI64;
  memoryInitializer = "data:application/octet-stream;base64,AAAAAAAAAAAAAAAAAQAAAAIAAAADAAAABAAAAAUAAAAGAAAAAQAAAAQAAAADAAAABgAAAAUAAAACAAAAAAAAAAIAAAADAAAAAQAAAAQAAAAGAAAAAAAAAAUAAAADAAAABgAAAAQAAAAFAAAAAAAAAAEAAAACAAAABAAAAAUAAAAGAAAAAAAAAAIAAAADAAAAAQAAAAUAAAACAAAAAAAAAAEAAAADAAAABgAAAAQAAAAGAAAAAAAAAAUAAAACAAAAAQAAAAQAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAEAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAIAAAADAAAAAAAAAAAAAAACAAAAAAAAAAEAAAADAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAABAAAAAYAAAAAAAAABQAAAAAAAAAAAAAABAAAAAUAAAAAAAAAAAAAAAAAAAACAAAAAAAAAAYAAAAAAAAABgAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAgAAAAMAAAAEAAAABQAAAAYAAAABAAAAAgAAAAMAAAAEAAAABQAAAAYAAAAAAAAAAgAAAAMAAAAEAAAABQAAAAYAAAAAAAAAAQAAAAMAAAAEAAAABQAAAAYAAAAAAAAAAQAAAAIAAAAEAAAABQAAAAYAAAAAAAAAAQAAAAIAAAADAAAABQAAAAYAAAAAAAAAAQAAAAIAAAADAAAABAAAAAYAAAAAAAAAAQAAAAIAAAADAAAABAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAwAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAgAAAAIAAAAAAAAAAAAAAAYAAAAAAAAAAwAAAAIAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAFAAAABAAAAAAAAAABAAAAAAAAAAAAAAAFAAAABQAAAAAAAAAAAAAAAAAAAAYAAAAAAAAABAAAAAAAAAAGAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAFAAAAAgAAAAQAAAADAAAACAAAAAEAAAAHAAAABgAAAAkAAAAAAAAAAwAAAAIAAAACAAAABgAAAAoAAAALAAAAAAAAAAEAAAAFAAAAAwAAAA0AAAABAAAABwAAAAQAAAAMAAAAAAAAAAQAAAB/AAAADwAAAAgAAAADAAAAAAAAAAwAAAAFAAAAAgAAABIAAAAKAAAACAAAAAAAAAAQAAAABgAAAA4AAAALAAAAEQAAAAEAAAAJAAAAAgAAAAcAAAAVAAAACQAAABMAAAADAAAADQAAAAEAAAAIAAAABQAAABYAAAAQAAAABAAAAAAAAAAPAAAACQAAABMAAAAOAAAAFAAAAAEAAAAHAAAABgAAAAoAAAALAAAAGAAAABcAAAAFAAAAAgAAABIAAAALAAAAEQAAABcAAAAZAAAAAgAAAAYAAAAKAAAADAAAABwAAAANAAAAGgAAAAQAAAAPAAAAAwAAAA0AAAAaAAAAFQAAAB0AAAADAAAADAAAAAcAAAAOAAAAfwAAABEAAAAbAAAACQAAABQAAAAGAAAADwAAABYAAAAcAAAAHwAAAAQAAAAIAAAADAAAABAAAAASAAAAIQAAAB4AAAAIAAAABQAAABYAAAARAAAACwAAAA4AAAAGAAAAIwAAABkAAAAbAAAAEgAAABgAAAAeAAAAIAAAAAUAAAAKAAAAEAAAABMAAAAiAAAAFAAAACQAAAAHAAAAFQAAAAkAAAAUAAAADgAAABMAAAAJAAAAKAAAABsAAAAkAAAAFQAAACYAAAATAAAAIgAAAA0AAAAdAAAABwAAABYAAAAQAAAAKQAAACEAAAAPAAAACAAAAB8AAAAXAAAAGAAAAAsAAAAKAAAAJwAAACUAAAAZAAAAGAAAAH8AAAAgAAAAJQAAAAoAAAAXAAAAEgAAABkAAAAXAAAAEQAAAAsAAAAtAAAAJwAAACMAAAAaAAAAKgAAAB0AAAArAAAADAAAABwAAAANAAAAGwAAACgAAAAjAAAALgAAAA4AAAAUAAAAEQAAABwAAAAfAAAAKgAAACwAAAAMAAAADwAAABoAAAAdAAAAKwAAACYAAAAvAAAADQAAABoAAAAVAAAAHgAAACAAAAAwAAAAMgAAABAAAAASAAAAIQAAAB8AAAApAAAALAAAADUAAAAPAAAAFgAAABwAAAAgAAAAHgAAABgAAAASAAAANAAAADIAAAAlAAAAIQAAAB4AAAAxAAAAMAAAABYAAAAQAAAAKQAAACIAAAATAAAAJgAAABUAAAA2AAAAJAAAADMAAAAjAAAALgAAAC0AAAA4AAAAEQAAABsAAAAZAAAAJAAAABQAAAAiAAAAEwAAADcAAAAoAAAANgAAACUAAAAnAAAANAAAADkAAAAYAAAAFwAAACAAAAAmAAAAfwAAACIAAAAzAAAAHQAAAC8AAAAVAAAAJwAAACUAAAAZAAAAFwAAADsAAAA5AAAALQAAACgAAAAbAAAAJAAAABQAAAA8AAAALgAAADcAAAApAAAAMQAAADUAAAA9AAAAFgAAACEAAAAfAAAAKgAAADoAAAArAAAAPgAAABwAAAAsAAAAGgAAACsAAAA+AAAALwAAAEAAAAAaAAAAKgAAAB0AAAAsAAAANQAAADoAAABBAAAAHAAAAB8AAAAqAAAALQAAACcAAAAjAAAAGQAAAD8AAAA7AAAAOAAAAC4AAAA8AAAAOAAAAEQAAAAbAAAAKAAAACMAAAAvAAAAJgAAACsAAAAdAAAARQAAADMAAABAAAAAMAAAADEAAAAeAAAAIQAAAEMAAABCAAAAMgAAADEAAAB/AAAAPQAAAEIAAAAhAAAAMAAAACkAAAAyAAAAMAAAACAAAAAeAAAARgAAAEMAAAA0AAAAMwAAAEUAAAA2AAAARwAAACYAAAAvAAAAIgAAADQAAAA5AAAARgAAAEoAAAAgAAAAJQAAADIAAAA1AAAAPQAAAEEAAABLAAAAHwAAACkAAAAsAAAANgAAAEcAAAA3AAAASQAAACIAAAAzAAAAJAAAADcAAAAoAAAANgAAACQAAABIAAAAPAAAAEkAAAA4AAAARAAAAD8AAABNAAAAIwAAAC4AAAAtAAAAOQAAADsAAABKAAAATgAAACUAAAAnAAAANAAAADoAAAB/AAAAPgAAAEwAAAAsAAAAQQAAACoAAAA7AAAAPwAAAE4AAABPAAAAJwAAAC0AAAA5AAAAPAAAAEgAAABEAAAAUAAAACgAAAA3AAAALgAAAD0AAAA1AAAAMQAAACkAAABRAAAASwAAAEIAAAA+AAAAKwAAADoAAAAqAAAAUgAAAEAAAABMAAAAPwAAAH8AAAA4AAAALQAAAE8AAAA7AAAATQAAAEAAAAAvAAAAPgAAACsAAABUAAAARQAAAFIAAABBAAAAOgAAADUAAAAsAAAAVgAAAEwAAABLAAAAQgAAAEMAAABRAAAAVQAAADEAAAAwAAAAPQAAAEMAAABCAAAAMgAAADAAAABXAAAAVQAAAEYAAABEAAAAOAAAADwAAAAuAAAAWgAAAE0AAABQAAAARQAAADMAAABAAAAALwAAAFkAAABHAAAAVAAAAEYAAABDAAAANAAAADIAAABTAAAAVwAAAEoAAABHAAAAWQAAAEkAAABbAAAAMwAAAEUAAAA2AAAASAAAAH8AAABJAAAANwAAAFAAAAA8AAAAWAAAAEkAAABbAAAASAAAAFgAAAA2AAAARwAAADcAAABKAAAATgAAAFMAAABcAAAANAAAADkAAABGAAAASwAAAEEAAAA9AAAANQAAAF4AAABWAAAAUQAAAEwAAABWAAAAUgAAAGAAAAA6AAAAQQAAAD4AAABNAAAAPwAAAEQAAAA4AAAAXQAAAE8AAABaAAAATgAAAEoAAAA7AAAAOQAAAF8AAABcAAAATwAAAE8AAABOAAAAPwAAADsAAABdAAAAXwAAAE0AAABQAAAARAAAAEgAAAA8AAAAYwAAAFoAAABYAAAAUQAAAFUAAABeAAAAZQAAAD0AAABCAAAASwAAAFIAAABgAAAAVAAAAGIAAAA+AAAATAAAAEAAAABTAAAAfwAAAEoAAABGAAAAZAAAAFcAAABcAAAAVAAAAEUAAABSAAAAQAAAAGEAAABZAAAAYgAAAFUAAABXAAAAZQAAAGYAAABCAAAAQwAAAFEAAABWAAAATAAAAEsAAABBAAAAaAAAAGAAAABeAAAAVwAAAFMAAABmAAAAZAAAAEMAAABGAAAAVQAAAFgAAABIAAAAWwAAAEkAAABjAAAAUAAAAGkAAABZAAAAYQAAAFsAAABnAAAARQAAAFQAAABHAAAAWgAAAE0AAABQAAAARAAAAGoAAABdAAAAYwAAAFsAAABJAAAAWQAAAEcAAABpAAAAWAAAAGcAAABcAAAAUwAAAE4AAABKAAAAbAAAAGQAAABfAAAAXQAAAE8AAABaAAAATQAAAG0AAABfAAAAagAAAF4AAABWAAAAUQAAAEsAAABrAAAAaAAAAGUAAABfAAAAXAAAAE8AAABOAAAAbQAAAGwAAABdAAAAYAAAAGgAAABiAAAAbgAAAEwAAABWAAAAUgAAAGEAAAB/AAAAYgAAAFQAAABnAAAAWQAAAG8AAABiAAAAbgAAAGEAAABvAAAAUgAAAGAAAABUAAAAYwAAAFAAAABpAAAAWAAAAGoAAABaAAAAcQAAAGQAAABmAAAAUwAAAFcAAABsAAAAcgAAAFwAAABlAAAAZgAAAGsAAABwAAAAUQAAAFUAAABeAAAAZgAAAGUAAABXAAAAVQAAAHIAAABwAAAAZAAAAGcAAABbAAAAYQAAAFkAAAB0AAAAaQAAAG8AAABoAAAAawAAAG4AAABzAAAAVgAAAF4AAABgAAAAaQAAAFgAAABnAAAAWwAAAHEAAABjAAAAdAAAAGoAAABdAAAAYwAAAFoAAAB1AAAAbQAAAHEAAABrAAAAfwAAAGUAAABeAAAAcwAAAGgAAABwAAAAbAAAAGQAAABfAAAAXAAAAHYAAAByAAAAbQAAAG0AAABsAAAAXQAAAF8AAAB1AAAAdgAAAGoAAABuAAAAYgAAAGgAAABgAAAAdwAAAG8AAABzAAAAbwAAAGEAAABuAAAAYgAAAHQAAABnAAAAdwAAAHAAAABrAAAAZgAAAGUAAAB4AAAAcwAAAHIAAABxAAAAYwAAAHQAAABpAAAAdQAAAGoAAAB5AAAAcgAAAHAAAABkAAAAZgAAAHYAAAB4AAAAbAAAAHMAAABuAAAAawAAAGgAAAB4AAAAdwAAAHAAAAB0AAAAZwAAAHcAAABvAAAAcQAAAGkAAAB5AAAAdQAAAH8AAABtAAAAdgAAAHEAAAB5AAAAagAAAHYAAAB4AAAAbAAAAHIAAAB1AAAAeQAAAG0AAAB3AAAAbwAAAHMAAABuAAAAeQAAAHQAAAB4AAAAeAAAAHMAAAByAAAAcAAAAHkAAAB3AAAAdgAAAHkAAAB0AAAAeAAAAHcAAAB1AAAAcQAAAHYAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAABAAAABQAAAAEAAAAAAAAAAAAAAAEAAAAAAAAAAQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAACAAAABQAAAAEAAAAAAAAA/////wEAAAAAAAAAAwAAAAQAAAACAAAAAAAAAAAAAAABAAAAAAAAAAEAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAMAAAAFAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAFAAAAAQAAAAAAAAAAAAAAAQAAAAMAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAEAAAADAAAAAAAAAAAAAAABAAAAAAAAAAMAAAADAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAADAAAABQAAAAEAAAAAAAAAAAAAAAEAAAAAAAAAAQAAAAAAAAABAAAAAAAAAP////8DAAAAAAAAAAUAAAACAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAEAAAABQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAMAAAADAAAAAwAAAAMAAAAAAAAAAwAAAAAAAAAAAAAAAAAAAAMAAAAFAAAABQAAAAAAAAAAAAAAAwAAAAMAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAADAAAAAwAAAAAAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAFAAAABQAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAQAAAAAAAAABAAAAAAAAAAMAAAADAAAAAwAAAAAAAAADAAAAAAAAAAAAAAD/////AwAAAAAAAAAFAAAAAgAAAAAAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAAAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAADAAAAAAAAAAAAAAAAAAAAAwAAAAMAAAAAAAAAAAAAAAEAAAAAAAAAAQAAAAAAAAABAAAAAAAAAAAAAAABAAAAAwAAAAAAAAAAAAAAAQAAAAAAAAADAAAAAwAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAMAAAADAAAAAwAAAAMAAAAAAAAAAwAAAAAAAAAAAAAAAQAAAAMAAAAAAAAAAAAAAAEAAAAAAAAAAwAAAAMAAAADAAAAAwAAAAAAAAADAAAAAAAAAAAAAAADAAAAAAAAAAMAAAAAAAAAAwAAAAAAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAAMAAAAAAAAAAwAAAAAAAAAAAAAAAAAAAAMAAAADAAAAAAAAAP////8DAAAAAAAAAAUAAAACAAAAAAAAAAAAAAADAAAAAAAAAAAAAAADAAAAAwAAAAAAAAAAAAAAAwAAAAAAAAAAAAAAAwAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAUAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAFAAAABQAAAAAAAAAAAAAAAwAAAAMAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAwAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAwAAAAAAAAAAAAAAAwAAAAMAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAMAAAAAAAAAAAAAAAMAAAADAAAAAwAAAAAAAAADAAAAAAAAAAAAAAADAAAAAwAAAAMAAAAAAAAAAwAAAAAAAAAAAAAA/////wMAAAAAAAAABQAAAAIAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAAAAAAAAwAAAAAAAAADAAAAAAAAAAAAAAAAAAAAAwAAAAMAAAAAAAAAAAAAAAMAAAAAAAAAAwAAAAAAAAADAAAAAAAAAAMAAAADAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAADAAAAAAAAAAMAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAAMAAAADAAAAAAAAAAMAAAADAAAAAwAAAAAAAAAAAAAAAwAAAAAAAAAAAAAAAAAAAAMAAAAAAAAAAwAAAAAAAAAAAAAA/////wMAAAAAAAAABQAAAAIAAAAAAAAAAAAAAAMAAAADAAAAAwAAAAMAAAADAAAAAAAAAAAAAAADAAAAAwAAAAMAAAADAAAAAwAAAAAAAAAAAAAAAwAAAAMAAAADAAAAAwAAAAAAAAADAAAAAAAAAAMAAAADAAAAAwAAAAMAAAAAAAAAAwAAAAAAAAD/////AwAAAAAAAAAFAAAAAgAAAAAAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAAAAAADAAAAAAAAAAMAAAADAAAAAwAAAAAAAAADAAAAAAAAAAAAAAADAAAAAAAAAAAAAAAAAAAAAwAAAAMAAAAAAAAAAwAAAAAAAAAAAAAAAwAAAAMAAAAAAAAAAAAAAAMAAAADAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAAAAAADAAAAAwAAAAAAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAAMAAAADAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAADAAAAAAAAAAAAAAD/////AwAAAAAAAAAFAAAAAgAAAAAAAAAAAAAAAwAAAAMAAAADAAAAAAAAAAAAAAADAAAAAAAAAAMAAAADAAAAAwAAAAAAAAAAAAAAAwAAAAAAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAAMAAAAAAAAAAwAAAAAAAAAAAAAAAAAAAAMAAAADAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAAFAAAAAAAAAAAAAAADAAAAAwAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAADAAAAAQAAAAAAAAABAAAAAAAAAAAAAAABAAAAAwAAAAEAAAAAAAAAAQAAAAAAAAAAAAAAAwAAAAAAAAADAAAAAAAAAAMAAAAAAAAAAAAAAAMAAAAAAAAAAwAAAAAAAAADAAAAAAAAAP////8DAAAAAAAAAAUAAAACAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAAAAAAAAwAAAAMAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAMAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAAMAAAADAAAAAAAAAAAAAAADAAAAAwAAAAMAAAADAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAUAAAAAAAAAAAAAAAMAAAADAAAAAwAAAAMAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAwAAAAMAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAAFAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAFAAAABQAAAAAAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAAMAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAMAAAAAAAAAAwAAAAAAAAAAAAAA/////wMAAAAAAAAABQAAAAIAAAAAAAAAAAAAAAMAAAADAAAAAwAAAAAAAAAAAAAAAwAAAAAAAAAFAAAAAAAAAAAAAAAFAAAABQAAAAAAAAAAAAAAAAAAAAEAAAADAAAAAQAAAAAAAAABAAAAAAAAAAMAAAADAAAAAwAAAAAAAAAAAAAAAwAAAAAAAAADAAAAAwAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAADAAAAAQAAAAAAAAABAAAAAAAAAAMAAAADAAAAAwAAAAMAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAEAAAAAAAAAAwAAAAUAAAABAAAAAAAAAP////8DAAAAAAAAAAUAAAACAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAFAAAABQAAAAAAAAAAAAAAAAAAAAEAAAAAAAAABAAAAAUAAAABAAAAAAAAAAMAAAADAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAIAAAAFAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAEAAAADAAAAAQAAAAAAAAABAAAAAAAAAAUAAAAAAAAAAAAAAAUAAAAFAAAAAAAAAAAAAAD/////AQAAAAAAAAADAAAABAAAAAIAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAUAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAFAAAAAAAAAAAAAAAFAAAABQAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAQAAAAUAAAABAAAAAAAAAAAAAAABAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAEAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAAAAAAAAAAAAAEAAAD//////////wEAAAABAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAQAAAAEAAAAAAAAAAAAAAAAAAAADAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAEAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAsAAAACAAAAAAAAAAAAAAABAAAAAgAAAAYAAAAEAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAYAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAgAAAAAAAAABAAAAAQAAAAAAAAAAAAAAAAAAAAcAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAACAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAYAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAKAAAAAgAAAAAAAAAAAAAAAQAAAAEAAAAFAAAABgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAEAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAABAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAABwAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAsAAAABAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAACAAAAAAAAAAAAAAABAAAAAwAAAAcAAAAGAAAAAQAAAAAAAAABAAAAAAAAAAAAAAAAAAAABwAAAAEAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAADAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAABAAAAAQAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAGAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAADgAAAAIAAAAAAAAAAAAAAAEAAAAAAAAACQAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACgAAAAEAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAQAAAAEAAAAAAAAAAAAAAAAAAAAMAAAAAQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAABwAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAsAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADQAAAAIAAAAAAAAAAAAAAAEAAAAEAAAACAAAAAoAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAALAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAACQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAGAAAAAgAAAAAAAAAAAAAAAQAAAAsAAAAPAAAACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAkAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAOAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAEAAAAAAAAAAQAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAQAAAAEAAAAAAAAAAAAAAAAAAAAIAAAAAQAAAAAAAAABAAAAAAAAAAAAAAAAAAAABQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAAAAgAAAAAAAAAAAAAAAQAAAAwAAAAQAAAADAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAoAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAJAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAPAAAAAAAAAAEAAAABAAAAAAAAAAAAAAAAAAAADwAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAADQAAAAEAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAACAAAAAAAAAAAAAAABAAAACgAAABMAAAAIAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAkAAAABAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAEQAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAwAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEQAAAAAAAAABAAAAAQAAAAAAAAAAAAAAAAAAAA8AAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAQAAAAAQAAAAAAAAABAAAAAAAAAAAAAAAAAAAACQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAANAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAAAIAAAAAAAAAAAAAAAEAAAANAAAAEQAAAA0AAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAARAAAAAQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAEwAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAA4AAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAATAAAAAAAAAAEAAAABAAAAAAAAAAAAAAAAAAAAEQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAA0AAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAARAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAkAAAACAAAAAAAAAAAAAAABAAAADgAAABIAAAAPAAAAAQAAAAAAAAABAAAAAAAAAAAAAAAAAAAADwAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABIAAAAAAAAAAQAAAAEAAAAAAAAAAAAAAAAAAAASAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAEwAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAABEAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAATAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEgAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAABIAAAABAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAATAAAAAgAAAAAAAAAAAAAAAQAAAP//////////EwAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAATAAAAAQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAEgAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAASAAAAAAAAABgAAAAAAAAAIQAAAAAAAAAeAAAAAAAAACAAAAADAAAAMQAAAAEAAAAwAAAAAwAAADIAAAADAAAACAAAAAAAAAAFAAAABQAAAAoAAAAFAAAAFgAAAAAAAAAQAAAAAAAAABIAAAAAAAAAKQAAAAEAAAAhAAAAAAAAAB4AAAAAAAAABAAAAAAAAAAAAAAABQAAAAIAAAAFAAAADwAAAAEAAAAIAAAAAAAAAAUAAAAFAAAAHwAAAAEAAAAWAAAAAAAAABAAAAAAAAAAAgAAAAAAAAAGAAAAAAAAAA4AAAAAAAAACgAAAAAAAAALAAAAAAAAABEAAAADAAAAGAAAAAEAAAAXAAAAAwAAABkAAAADAAAAAAAAAAAAAAABAAAABQAAAAkAAAAFAAAABQAAAAAAAAACAAAAAAAAAAYAAAAAAAAAEgAAAAEAAAAKAAAAAAAAAAsAAAAAAAAABAAAAAEAAAADAAAABQAAAAcAAAAFAAAACAAAAAEAAAAAAAAAAAAAAAEAAAAFAAAAEAAAAAEAAAAFAAAAAAAAAAIAAAAAAAAABwAAAAAAAAAVAAAAAAAAACYAAAAAAAAACQAAAAAAAAATAAAAAAAAACIAAAADAAAADgAAAAEAAAAUAAAAAwAAACQAAAADAAAAAwAAAAAAAAANAAAABQAAAB0AAAAFAAAAAQAAAAAAAAAHAAAAAAAAABUAAAAAAAAABgAAAAEAAAAJAAAAAAAAABMAAAAAAAAABAAAAAIAAAAMAAAABQAAABoAAAAFAAAAAAAAAAEAAAADAAAAAAAAAA0AAAAFAAAAAgAAAAEAAAABAAAAAAAAAAcAAAAAAAAAGgAAAAAAAAAqAAAAAAAAADoAAAAAAAAAHQAAAAAAAAArAAAAAAAAAD4AAAADAAAAJgAAAAEAAAAvAAAAAwAAAEAAAAADAAAADAAAAAAAAAAcAAAABQAAACwAAAAFAAAADQAAAAAAAAAaAAAAAAAAACoAAAAAAAAAFQAAAAEAAAAdAAAAAAAAACsAAAAAAAAABAAAAAMAAAAPAAAABQAAAB8AAAAFAAAAAwAAAAEAAAAMAAAAAAAAABwAAAAFAAAABwAAAAEAAAANAAAAAAAAABoAAAAAAAAAHwAAAAAAAAApAAAAAAAAADEAAAAAAAAALAAAAAAAAAA1AAAAAAAAAD0AAAADAAAAOgAAAAEAAABBAAAAAwAAAEsAAAADAAAADwAAAAAAAAAWAAAABQAAACEAAAAFAAAAHAAAAAAAAAAfAAAAAAAAACkAAAAAAAAAKgAAAAEAAAAsAAAAAAAAADUAAAAAAAAABAAAAAQAAAAIAAAABQAAABAAAAAFAAAADAAAAAEAAAAPAAAAAAAAABYAAAAFAAAAGgAAAAEAAAAcAAAAAAAAAB8AAAAAAAAAMgAAAAAAAAAwAAAAAAAAADEAAAADAAAAIAAAAAAAAAAeAAAAAwAAACEAAAADAAAAGAAAAAMAAAASAAAAAwAAABAAAAADAAAARgAAAAAAAABDAAAAAAAAAEIAAAADAAAANAAAAAMAAAAyAAAAAAAAADAAAAAAAAAAJQAAAAMAAAAgAAAAAAAAAB4AAAADAAAAUwAAAAAAAABXAAAAAwAAAFUAAAADAAAASgAAAAMAAABGAAAAAAAAAEMAAAAAAAAAOQAAAAEAAAA0AAAAAwAAADIAAAAAAAAAGQAAAAAAAAAXAAAAAAAAABgAAAADAAAAEQAAAAAAAAALAAAAAwAAAAoAAAADAAAADgAAAAMAAAAGAAAAAwAAAAIAAAADAAAALQAAAAAAAAAnAAAAAAAAACUAAAADAAAAIwAAAAMAAAAZAAAAAAAAABcAAAAAAAAAGwAAAAMAAAARAAAAAAAAAAsAAAADAAAAPwAAAAAAAAA7AAAAAwAAADkAAAADAAAAOAAAAAMAAAAtAAAAAAAAACcAAAAAAAAALgAAAAMAAAAjAAAAAwAAABkAAAAAAAAAJAAAAAAAAAAUAAAAAAAAAA4AAAADAAAAIgAAAAAAAAATAAAAAwAAAAkAAAADAAAAJgAAAAMAAAAVAAAAAwAAAAcAAAADAAAANwAAAAAAAAAoAAAAAAAAABsAAAADAAAANgAAAAMAAAAkAAAAAAAAABQAAAAAAAAAMwAAAAMAAAAiAAAAAAAAABMAAAADAAAASAAAAAAAAAA8AAAAAwAAAC4AAAADAAAASQAAAAMAAAA3AAAAAAAAACgAAAAAAAAARwAAAAMAAAA2AAAAAwAAACQAAAAAAAAAQAAAAAAAAAAvAAAAAAAAACYAAAADAAAAPgAAAAAAAAArAAAAAwAAAB0AAAADAAAAOgAAAAMAAAAqAAAAAwAAABoAAAADAAAAVAAAAAAAAABFAAAAAAAAADMAAAADAAAAUgAAAAMAAABAAAAAAAAAAC8AAAAAAAAATAAAAAMAAAA+AAAAAAAAACsAAAADAAAAYQAAAAAAAABZAAAAAwAAAEcAAAADAAAAYgAAAAMAAABUAAAAAAAAAEUAAAAAAAAAYAAAAAMAAABSAAAAAwAAAEAAAAAAAAAASwAAAAAAAABBAAAAAAAAADoAAAADAAAAPQAAAAAAAAA1AAAAAwAAACwAAAADAAAAMQAAAAMAAAApAAAAAwAAAB8AAAADAAAAXgAAAAAAAABWAAAAAAAAAEwAAAADAAAAUQAAAAMAAABLAAAAAAAAAEEAAAAAAAAAQgAAAAMAAAA9AAAAAAAAADUAAAADAAAAawAAAAAAAABoAAAAAwAAAGAAAAADAAAAZQAAAAMAAABeAAAAAAAAAFYAAAAAAAAAVQAAAAMAAABRAAAAAwAAAEsAAAAAAAAAOQAAAAAAAAA7AAAAAAAAAD8AAAADAAAASgAAAAAAAABOAAAAAwAAAE8AAAADAAAAUwAAAAMAAABcAAAAAwAAAF8AAAADAAAAJQAAAAAAAAAnAAAAAwAAAC0AAAADAAAANAAAAAAAAAA5AAAAAAAAADsAAAAAAAAARgAAAAMAAABKAAAAAAAAAE4AAAADAAAAGAAAAAAAAAAXAAAAAwAAABkAAAADAAAAIAAAAAMAAAAlAAAAAAAAACcAAAADAAAAMgAAAAMAAAA0AAAAAAAAADkAAAAAAAAALgAAAAAAAAA8AAAAAAAAAEgAAAADAAAAOAAAAAAAAABEAAAAAwAAAFAAAAADAAAAPwAAAAMAAABNAAAAAwAAAFoAAAADAAAAGwAAAAAAAAAoAAAAAwAAADcAAAADAAAAIwAAAAAAAAAuAAAAAAAAADwAAAAAAAAALQAAAAMAAAA4AAAAAAAAAEQAAAADAAAADgAAAAAAAAAUAAAAAwAAACQAAAADAAAAEQAAAAMAAAAbAAAAAAAAACgAAAADAAAAGQAAAAMAAAAjAAAAAAAAAC4AAAAAAAAARwAAAAAAAABZAAAAAAAAAGEAAAADAAAASQAAAAAAAABbAAAAAwAAAGcAAAADAAAASAAAAAMAAABYAAAAAwAAAGkAAAADAAAAMwAAAAAAAABFAAAAAwAAAFQAAAADAAAANgAAAAAAAABHAAAAAAAAAFkAAAAAAAAANwAAAAMAAABJAAAAAAAAAFsAAAADAAAAJgAAAAAAAAAvAAAAAwAAAEAAAAADAAAAIgAAAAMAAAAzAAAAAAAAAEUAAAADAAAAJAAAAAMAAAA2AAAAAAAAAEcAAAAAAAAAYAAAAAAAAABoAAAAAAAAAGsAAAADAAAAYgAAAAAAAABuAAAAAwAAAHMAAAADAAAAYQAAAAMAAABvAAAAAwAAAHcAAAADAAAATAAAAAAAAABWAAAAAwAAAF4AAAADAAAAUgAAAAAAAABgAAAAAAAAAGgAAAAAAAAAVAAAAAMAAABiAAAAAAAAAG4AAAADAAAAOgAAAAAAAABBAAAAAwAAAEsAAAADAAAAPgAAAAMAAABMAAAAAAAAAFYAAAADAAAAQAAAAAMAAABSAAAAAAAAAGAAAAAAAAAAVQAAAAAAAABXAAAAAAAAAFMAAAADAAAAZQAAAAAAAABmAAAAAwAAAGQAAAADAAAAawAAAAMAAABwAAAAAwAAAHIAAAADAAAAQgAAAAAAAABDAAAAAwAAAEYAAAADAAAAUQAAAAAAAABVAAAAAAAAAFcAAAAAAAAAXgAAAAMAAABlAAAAAAAAAGYAAAADAAAAMQAAAAAAAAAwAAAAAwAAADIAAAADAAAAPQAAAAMAAABCAAAAAAAAAEMAAAADAAAASwAAAAMAAABRAAAAAAAAAFUAAAAAAAAAXwAAAAAAAABcAAAAAAAAAFMAAAAAAAAATwAAAAAAAABOAAAAAAAAAEoAAAADAAAAPwAAAAEAAAA7AAAAAwAAADkAAAADAAAAbQAAAAAAAABsAAAAAAAAAGQAAAAFAAAAXQAAAAEAAABfAAAAAAAAAFwAAAAAAAAATQAAAAEAAABPAAAAAAAAAE4AAAAAAAAAdQAAAAQAAAB2AAAABQAAAHIAAAAFAAAAagAAAAEAAABtAAAAAAAAAGwAAAAAAAAAWgAAAAEAAABdAAAAAQAAAF8AAAAAAAAAWgAAAAAAAABNAAAAAAAAAD8AAAAAAAAAUAAAAAAAAABEAAAAAAAAADgAAAADAAAASAAAAAEAAAA8AAAAAwAAAC4AAAADAAAAagAAAAAAAABdAAAAAAAAAE8AAAAFAAAAYwAAAAEAAABaAAAAAAAAAE0AAAAAAAAAWAAAAAEAAABQAAAAAAAAAEQAAAAAAAAAdQAAAAMAAABtAAAABQAAAF8AAAAFAAAAcQAAAAEAAABqAAAAAAAAAF0AAAAAAAAAaQAAAAEAAABjAAAAAQAAAFoAAAAAAAAAaQAAAAAAAABYAAAAAAAAAEgAAAAAAAAAZwAAAAAAAABbAAAAAAAAAEkAAAADAAAAYQAAAAEAAABZAAAAAwAAAEcAAAADAAAAcQAAAAAAAABjAAAAAAAAAFAAAAAFAAAAdAAAAAEAAABpAAAAAAAAAFgAAAAAAAAAbwAAAAEAAABnAAAAAAAAAFsAAAAAAAAAdQAAAAIAAABqAAAABQAAAFoAAAAFAAAAeQAAAAEAAABxAAAAAAAAAGMAAAAAAAAAdwAAAAEAAAB0AAAAAQAAAGkAAAAAAAAAdwAAAAAAAABvAAAAAAAAAGEAAAAAAAAAcwAAAAAAAABuAAAAAAAAAGIAAAADAAAAawAAAAEAAABoAAAAAwAAAGAAAAADAAAAeQAAAAAAAAB0AAAAAAAAAGcAAAAFAAAAeAAAAAEAAAB3AAAAAAAAAG8AAAAAAAAAcAAAAAEAAABzAAAAAAAAAG4AAAAAAAAAdQAAAAEAAABxAAAABQAAAGkAAAAFAAAAdgAAAAEAAAB5AAAAAAAAAHQAAAAAAAAAcgAAAAEAAAB4AAAAAQAAAHcAAAAAAAAAcgAAAAAAAABwAAAAAAAAAGsAAAAAAAAAZAAAAAAAAABmAAAAAAAAAGUAAAADAAAAUwAAAAEAAABXAAAAAwAAAFUAAAADAAAAdgAAAAAAAAB4AAAAAAAAAHMAAAAFAAAAbAAAAAEAAAByAAAAAAAAAHAAAAAAAAAAXAAAAAEAAABkAAAAAAAAAGYAAAAAAAAAdQAAAAAAAAB5AAAABQAAAHcAAAAFAAAAbQAAAAEAAAB2AAAAAAAAAHgAAAAAAAAAXwAAAAEAAABsAAAAAQAAAHIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAEAAAAAAAAAAAAAAAEAAAABAAAAAQAAAAAAAAAAAAAAAQAAAAAAAAABAAAAAQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAGAAAAAgAAAAUAAAABAAAABAAAAAAAAAAAAAAABQAAAAMAAAABAAAABgAAAAQAAAACAAAAAAAAAH6iBfbytuk/Gq6akm/58z/Xrm0Liez0P5doSdOpSwRAWs602ULg8D/dT7Rcbo/1v1N1RQHFNOM/g9Snx7HW3L8HWsP8Q3jfP6VwOLosutk/9rjk1YQcxj+gnmKMsNn6P/HDeuPFY+M/YHwDjqKhB0Ci19/fCVrbP4UxKkDWOP6/pvljWa09tL9wi7wrQXjnv/Z6yLImkM2/3yTlOzY14D+m+WNZrT20PzwKVQnrQwNA9nrIsiaQzT/g40rFrRQFwPa45NWEHMa/kbslHEZq97/xw3rjxWPjv4cLC2SMBci/otff3wla27+rKF5oIAv0P1N1RQHFNOO/iDJPGyWHBUAHWsP8Q3jfvwQf/by16gXAfqIF9vK26b8XrO0Vh0r+v9eubQuJ7PS/BxLrA0ZZ479azrTZQuDwv1MK1EuItPw/yscgV9Z6FkAwHBR2WjQMQJNRzXsQ5vY/GlUHVJYKF0DONuFv2lMNQNCGZ28QJfk/0WUwoIL36D8ggDOMQuATQNqMOeAy/wZAWFYOYM+M2z/LWC4uH3oSQDE+LyTsMgRAkJzhRGWFGEDd4soovCQQQKqk0DJMEP8/rGmNdwOLBUAW2X/9xCbjP4hu3dcqJhNAzuYItRvdB0CgzW3zJW/sPxotm/Y2TxRAQAk9XmdDDEC1Kx9MKgT3P1M+NctcghZAFVqcLlb0C0Bgzd3sB2b2P77mZDPUWhZAFROHJpUGCEDAfma5CxXtPz1DWq/zYxRAmhYY5824F0DOuQKWSbAOQNCMqrvu3fs/L6DR22K2wT9nAAxPBU8RQGiN6mW43AFAZhu25b633D8c1YgmzowSQNM25BRKWARArGS08/lNxD+LFssHwmMRQLC5aNcxBgJABL9HT0WRF0CjCmJmOGEOQHsuaVzMP/s/TWJCaGGwBUCeu1PAPLzjP9nqN9DZOBNAKE4JcydbCkCGtbd1qjPzP8dgm9U8jhVAtPeKTkVwDkCeCLss5l37P401XMPLmBdAFd29VMVQDUBg0yA55h75Pz6odcYLCRdApBM4rBrkAkDyAVWgQxbRP4XDMnK20hFAymLlF7EmzD8GUgo9XBHlP3lbK7T9COc/k+OhPthhy7+YGEpnrOvCPzBFhLs15u4/epbqB6H4uz9IuuLF5svev6lzLKY31es/CaQ0envF5z8ZY0xlUADXv7zaz7HYEuI/CfbK1sn16T8uAQfWwxLWPzKn/YuFN94/5KdbC1AFu793fyCSnlfvPzK2y4doAMY/NRg5t1/X6b/shq4QJaHDP5yNIAKPOeI/vpn7BSE30r/X4YQrO6nrv78Ziv/Thto/DqJ1Y6+y5z9l51NaxFrlv8QlA65HOLS/86dxiEc96z+Hj0+LFjneP6LzBZ8LTc2/DaJ1Y6+y579l51NaxFrlP8QlA65HOLQ/8qdxiEc967+Jj0+LFjnev6LzBZ8LTc0/1qdbC1AFuz93fyCSnlfvvzK2y4doAMa/NRg5t1/X6T/vhq4QJaHDv5yNIAKPOeK/wJn7BSE30j/W4YQrO6nrP78Ziv/Thtq/CaQ0envF578XY0xlUADXP7zaz7HYEuK/CvbK1sn16b8rAQfWwxLWvzKn/YuFN96/zWLlF7EmzL8GUgo9XBHlv3lbK7T9COe/kOOhPthhyz+cGEpnrOvCvzBFhLs15u6/c5bqB6H4u79IuuLF5sveP6lzLKY31eu/AQAAAP////8HAAAA/////zEAAAD/////VwEAAP////9hCQAA/////6dBAAD/////kcsBAP/////3kAwA/////8H2VwAAAAAAAAAAAAAAAAACAAAA/////w4AAAD/////YgAAAP////+uAgAA/////8ISAAD/////ToMAAP////8ilwMA/////+4hGQD/////gu2vAAAAAAAAAAAAAAAAAAAAAAACAAAA//////////8BAAAAAwAAAP//////////////////////////////////////////////////////////////////////////AQAAAAAAAAACAAAA////////////////AwAAAP//////////////////////////////////////////////////////////////////////////AQAAAAAAAAACAAAA////////////////AwAAAP//////////////////////////////////////////////////////////////////////////AQAAAAAAAAACAAAA////////////////AwAAAP//////////////////////////////////////////////////////////AgAAAP//////////AQAAAAAAAAD/////////////////////AwAAAP////////////////////////////////////////////////////8DAAAA/////////////////////wAAAAD/////////////////////AQAAAP///////////////wIAAAD///////////////////////////////8DAAAA/////////////////////wAAAAD///////////////8CAAAAAQAAAP////////////////////////////////////////////////////8DAAAA/////////////////////wAAAAD///////////////8CAAAAAQAAAP////////////////////////////////////////////////////8DAAAA/////////////////////wAAAAD///////////////8CAAAAAQAAAP////////////////////////////////////////////////////8DAAAA/////////////////////wAAAAD///////////////8CAAAAAQAAAP////////////////////////////////////////////////////8BAAAAAgAAAP///////////////wAAAAD/////////////////////AwAAAP////////////////////////////////////////////////////8BAAAAAgAAAP///////////////wAAAAD/////////////////////AwAAAP////////////////////////////////////////////////////8BAAAAAgAAAP///////////////wAAAAD/////////////////////AwAAAP////////////////////////////////////////////////////8BAAAAAgAAAP///////////////wAAAAD/////////////////////AwAAAP///////////////////////////////wIAAAD///////////////8BAAAA/////////////////////wAAAAD/////////////////////AwAAAP////////////////////////////////////////////////////8DAAAA/////////////////////wAAAAABAAAA//////////8CAAAA//////////////////////////////////////////////////////////8DAAAA////////////////AgAAAAAAAAABAAAA//////////////////////////////////////////////////////////////////////////8DAAAA////////////////AgAAAAAAAAABAAAA//////////////////////////////////////////////////////////////////////////8DAAAA////////////////AgAAAAAAAAABAAAA//////////////////////////////////////////////////////////////////////////8DAAAAAQAAAP//////////AgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAACAAAAAAAAAAIAAAABAAAAAQAAAAIAAAACAAAAAAAAAAUAAAAFAAAAAAAAAAIAAAACAAAAAwAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAAAAAAAAgAAAAEAAAACAAAAAgAAAAIAAAAAAAAABQAAAAYAAAAAAAAAAgAAAAIAAAADAAAAAgAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAgAAAAAAAAACAAAAAQAAAAMAAAACAAAAAgAAAAAAAAAFAAAABwAAAAAAAAACAAAAAgAAAAMAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAACAAAAAAAAAAIAAAABAAAABAAAAAIAAAACAAAAAAAAAAUAAAAIAAAAAAAAAAIAAAACAAAAAwAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAwAAAAIAAAAAAAAAAgAAAAEAAAAAAAAAAgAAAAIAAAAAAAAABQAAAAkAAAAAAAAAAgAAAAIAAAADAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAKAAAAAgAAAAIAAAAAAAAAAwAAAA4AAAACAAAAAAAAAAIAAAADAAAAAAAAAAAAAAACAAAAAgAAAAMAAAAGAAAAAAAAAAAAAAAAAAAAAAAAAAsAAAACAAAAAgAAAAAAAAADAAAACgAAAAIAAAAAAAAAAgAAAAMAAAABAAAAAAAAAAIAAAACAAAAAwAAAAcAAAAAAAAAAAAAAAAAAAAAAAAADAAAAAIAAAACAAAAAAAAAAMAAAALAAAAAgAAAAAAAAACAAAAAwAAAAIAAAAAAAAAAgAAAAIAAAADAAAACAAAAAAAAAAAAAAAAAAAAAAAAAANAAAAAgAAAAIAAAAAAAAAAwAAAAwAAAACAAAAAAAAAAIAAAADAAAAAwAAAAAAAAACAAAAAgAAAAMAAAAJAAAAAAAAAAAAAAAAAAAAAAAAAA4AAAACAAAAAgAAAAAAAAADAAAADQAAAAIAAAAAAAAAAgAAAAMAAAAEAAAAAAAAAAIAAAACAAAAAwAAAAoAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAIAAAACAAAAAAAAAAMAAAAGAAAAAgAAAAAAAAACAAAAAwAAAA8AAAAAAAAAAgAAAAIAAAADAAAACwAAAAAAAAAAAAAAAAAAAAAAAAAGAAAAAgAAAAIAAAAAAAAAAwAAAAcAAAACAAAAAAAAAAIAAAADAAAAEAAAAAAAAAACAAAAAgAAAAMAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAcAAAACAAAAAgAAAAAAAAADAAAACAAAAAIAAAAAAAAAAgAAAAMAAAARAAAAAAAAAAIAAAACAAAAAwAAAA0AAAAAAAAAAAAAAAAAAAAAAAAACAAAAAIAAAACAAAAAAAAAAMAAAAJAAAAAgAAAAAAAAACAAAAAwAAABIAAAAAAAAAAgAAAAIAAAADAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAJAAAAAgAAAAIAAAAAAAAAAwAAAAUAAAACAAAAAAAAAAIAAAADAAAAEwAAAAAAAAACAAAAAgAAAAMAAAAPAAAAAAAAAAAAAAAAAAAAAAAAABAAAAACAAAAAAAAAAIAAAABAAAAEwAAAAIAAAACAAAAAAAAAAUAAAAKAAAAAAAAAAIAAAACAAAAAwAAABAAAAAAAAAAAAAAAAAAAAAAAAAAEQAAAAIAAAAAAAAAAgAAAAEAAAAPAAAAAgAAAAIAAAAAAAAABQAAAAsAAAAAAAAAAgAAAAIAAAADAAAAEQAAAAAAAAAAAAAAAAAAAAAAAAASAAAAAgAAAAAAAAACAAAAAQAAABAAAAACAAAAAgAAAAAAAAAFAAAADAAAAAAAAAACAAAAAgAAAAMAAAASAAAAAAAAAAAAAAAAAAAAAAAAABMAAAACAAAAAAAAAAIAAAABAAAAEQAAAAIAAAACAAAAAAAAAAUAAAANAAAAAAAAAAIAAAACAAAAAwAAABMAAAAAAAAAAAAAAAAAAAAAAAAADwAAAAIAAAAAAAAAAgAAAAEAAAASAAAAAgAAAAIAAAAAAAAABQAAAA4AAAAAAAAAAgAAAAIAAAADAAAAAgAAAAEAAAAAAAAAAQAAAAIAAAAAAAAAAAAAAAIAAAABAAAAAAAAAAEAAAACAAAAAQAAAAAAAAACAAAAAAAAAAUAAAAEAAAAAAAAAAEAAAAFAAAAAAAAAAAAAAAFAAAABAAAAAAAAAABAAAABQAAAAQAAAAAAAAABQAAAAAAAAACAAAAAQAAAAAAAAABAAAAAgAAAAAAAAAAAAAAAgAAAAEAAAAAAAAAAQAAAAIAAAABAAAAAAAAAAIAAAACAAAAAAAAAAEAAAAAAAAAAAAAAAUAAAAEAAAAAAAAAAEAAAAFAAAAAAAAAAAAAAAFAAAABAAAAAAAAAABAAAABQAAAAQAAAAAAAAABQAAAAUAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAABAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAEAAAAAAAAAAAEAAAAAAQAAAAAAAAAAAQAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAABAAAAAAAAAAAAAQAAAAAAAAAAAAA6B6FaUp9QQTPXMuL4myJBraiDfBwx9UBYJseitzTIQOL5if9jqZtAnXX+Z+ycb0C3pucbhRBCQG8wJBYqpRRAlWbDCzCY5z/eFWBUEve6P/+qo4Q50Y4/D9YM3iCcYT8fcA2QJSA0P4ADxu0qAAc/BNcGolVJ2j5d9FACqwquPh9z7MthtI9CSUSYJke/YUJQ/64OyjU0Qpi0+HCmFQdCm3GfIVdh2kHsJ11kAyauQYC3UDFJOoFBSJsFV1OwU0FK5fcxX4AmQWhy/zZIt/lACqaCPsBjzUDbdUNIScugQMYQlVJ4MXNANiuq8GTvRUDxTXnulxEZQFZ8QX5kpuw/qmG/JwYFlEAluh3Q6DB+QKn4vyNq0GZAKOXekas+UUB8xabXXhI6QG63C2pLtSNAdDBtyNfLDUDyOcu67ID2P0rCMvRXAeE/Ki2TSVyzyT9Dk+8Sz2uzP5J+w5ARWp0/NQAoOiMuhj9YnP+RyMJwPxgW7TvQVFk/KgsLYF0kQz9g5dAC6IwzQcgHPVvDex1B1XjppodHBkHJq3OMM9fwQNvcmJ7wddlAInGPpQs/w0BRobq5EBmtQJZ2ai7n+ZVAtv2G5E+bgECG+gIfKBlpQK5f8jdI91JAL39sL/WpPEB8rGxhDqklQK6yUf43XhBAxL9y/tK8+D86XyZpgrHiPwAAAAD/////AAAAAAAAAAAAAAAAAAAAAAAAAAD/////////////////////////////////////AAAAAP////8AAAAAAAAAAAAAAAABAAAAAAAAAAAAAAD/////AAAAAAAAAAABAAAAAQAAAAAAAAAAAAAA/////wAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAP////8FAAAABQAAAAAAAAAAAAAAAAAAAAAAAAD/////AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/////////////////////////////////////wAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP////////////////////////////////////8AAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAFAAAAAQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/////////////////////////////////////AAAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAQAAAAEAAAABAAAAAAAAAAEAAAAAAAAABQAAAAEAAAABAAAAAAAAAAAAAAABAAAAAQAAAAAAAAABAAAAAQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQAAAAAAAQABAAABAQAAAAAAAQAAAAEAAAABAAEAAAAAAAAAAAAAAAAAAAAAquJYWJZl+D9jaeZNtj/zPwwdI9KqaeO/qGefXwdHdz+q4lhYlmX4P+OrlPMN3PI/DB0j0qpp47+7SQLV4VIEQKriWFiWZfg/r2kma3tz8T82eQmLqNIGwMRIWXMqSvo/fcCszPux9j+jara6ozTwP6hnn18HR3c/MSoKLequ8r+SabgA2nj0P7jBLbDOHO8/1Ym/ICfH4T+6lxjvlFXHv73m373LRPU/0vXyDVxo7T+ToKRHJXMAQF/33578aPE/pAyy64tD9T8+U/hCvyruPwxv8Y7YYwLAuXYr8NAiCEB4+LDK0Sn0P1Qeuy4j+eo/OMx50n7K7L+TrGB/nyf8v5ehC2fbYPM/aXMKexiT6z8mFRIMjg/zP7yUVwGGBNw/E6opHERf8z/z0wR2g9DqPw4pBpcOhvu/NbA29uWAA8DMaTExyXzyP02biiQ+Ruk/S8jz2/FKBEB1pzZnpbb9P7pQU4wLfPI//7ZcQXeG6D9CqEQvAYoIwDB2VB6sSgRAVyv8H5We8T+EHWF8XNPmPzB2wT8Nrrg/SEi+cX+w4L8of+GtdSDxP1sjk5AdouU/6ZjOVru13r8K0obqI6bxvwVbdNXyhfA/w5GG024n5z+rwmtMzP8BwLw9pSX49QXABe/2uQxP8D+b6wCzCvXkP7uGT87fK+Q/pz/JWw4coj+qoBf2J0nwP/yE3PUo0+I/vFJeHcaC+D96luSIqvntP/bf8sHUYu8/gZNN41mL4z9bhOqVOF4FwO6lmAh1hQhAbCVxbdhk7z+1C8NdDcfiPwG36x/0OQBAx0WJ76c2+D9nlSHXANfuP2HlfZ3gqOE/EwnVlVPg9r96+oHzEH//v5bXzdT1Auw/DM3GwLsA4D9p/8uoKcr+v+U9x5DQVAPAehjSdghb7D9sc1IetODgP8MVwwB1pu6/azPk6OGe978W8t/TUc3rP+0QMvYfP+A/RsG/QpSE8D+l3uwScxzgPwQaifgujuw/k1Vti1I43z8MAwLnSh0GQH5nYnwwZgJAiGUzWC5s6j8WyyI/BbLgPw4iUapGeQJAB3W+imnp/j9BLWR4ssrpP2t+gG5Pstk/cpBsfm6DCMCOpU9dOZsFQEv8nFypHeo/ehJ6i+6S2D9jqlGEmarLv7STC5TRiOa/bC+x8WZD6D9H3yUkWpDZP8gZvmCMuQLAreY19/eRBsCoPOc8UzzpP6KI/QV+y9g/t/MoboyWzT+Hv5q3Zu3Mvy2xROCT4uY/9gQitMMg1T9abAqhWMDkv1oLTavoUfG/PMUJP9CD5j+fHRX3t6fSPz7W2gk6bvs/WRnuHwqN9D8YFturGCTmP1EZczv0b9I/5t4exabB5D/1ESLh5fTEP9X2z6SYweQ/6lv3I2zT0D9zkRGNUNMAQKoSvc4EIfs/Xggt8wQI5T+mJHHg/w/SP4lhT/9t8vQ/DrZ/DbwH7D+XlhbYZrjkP34LIpFt6c4/lwfp8fLX9L+j96CTTf76v3WdNhEv9uM/d8c3o4lV0D/vFdCHVcsFwAHeDq0F1QhApbYqcZiN5D9KoilqByXLPwX0/diA0vq/0fo0GxnxAMBbaTkvlCzjP/RrFrWXrMs/UYTrky7jA0DB9f4FiZYAQEGAk/3QzeE/r/TeqE8t0D/OqjlsnPbvvz8RKU8JOfW/smSEbK/O4T8MzuyPm3DDP/rFtctq9gZAfb1EVEaSA0Dts5dVInnhP18SFMc79MM/7y34cw6LAMDFrRJsZO0DwC2KLvLSYuA/hx5wcUHewz+49SnK/4ruPyeS0PX9a+E/ZxaaLvvZ3z8WPu5T2QS8Pygo4RIvMqa/BJ0Kqsd0279cKW4ay8jdP3b05bmZ364/10/qtdxk2r+Bcz6CDMvpv54qOw+Amdw/qLV71pW7sT/YKc80nIPUP8OfIaBJ77G/LyTuD1un2z+diYu8efWzP1wU7ACkfwjAZroyPL1yBkAmv3lKJJbbPysKSE4W+p0/dIgqY79TA8ATLTOQ3tsGwJ2zweD/Xdg/XO/jXeFUaL8VW2qLFKfov1cA9Aa6XfK/tIa7YGgI2T+f3hu/sxqPv2nXdPpf3Pc/jkw8Jbda8j+tT/z8tGPVP1yBHpJd35k/KYvYOy1s8j/yz+kCQjPrP9+agH7x59g/PZfJ9aBhpr/rDKzvYBb+PwtkiaGCt/c/vb1mVr+f1T/JIHwHc8Govw7aeF6+9vG/Xv7kD6fp979isYioQYHVP7AIQZuSFrG/3z1AdUTnAUDN3XY9O7f9P0AdQ9ljYNQ/dJANJPTOrb8kLECUiiPlP4yF7UgmStA/9xGmXxCG1T9qZzix4W2zv2SGJRJVrPe/Fh9a2M/B/b8IexzFCoPSP9y1QFD2bLe/Q86cWLJe/b+mOOfYm78BwOTjkPAGE9E/8aPCUKu/ub9pPZyLCiUGwBA7Mev/BQlALOmrlRi+0j+AMJ/dKULBv7iLtL6a6QRAEMDV/yajAUDa62dE3crJP1P70RgBUbq/38hVnR6esT/s1tG10Z/Ov/zLwalHPss/dTS9NKTXx78nMcRzCIEHQAabxDsAmQRA0tyLK3gSyT+Aui7nOhDGv5Gs58z3WgHATN3forJuBMCAui7nOhDGP9Lciyt4Esm/WAJyHQ4c7z8UP5HFIs3iP3U0vTSk18c//MvBqUc+y7+cvv8HLg/Kvy1I/mHsI+K/U/vRGAFRuj/a62dE3crJv8p+WV8KlQjAuQ/nOP43B0CAMJ/dKULBPyzpq5UYvtK/ZoU+VoLh4L9etLlRUfvtv/GjwlCrv7k/5OOQ8AYT0b9DfT9FhufXPwUX8hJp+4u/3LVAUPZstz8IexzFCoPSv9+L609E5fQ/q9Fz7X2J7T9qZzix4W2zP/cRpl8QhtW/vtNilqGX+j8MOy7QJoL0P3SQDST0zq0/QB1D2WNg1L8IIjSvGNkDwGB8Jou2GAfAsAhBm5IWsT9isYioQYHVvyS9D3zb6uy/gnwRa7uM9L/JIHwHc8GoP729Zla/n9W/CsAHJZwmAEDEW6OYT1r6Pz2XyfWgYaY/35qAfvHn2L83Tdy4lS30vxf2/gZ0jPq/XIEekl3fmb+tT/z8tGPVvybPr2zJ1/+/K7mJ0ypVAsCf3hu/sxqPPwCGu2BoCNm/5oITrpZn+r+UDUyDP+n/v1zv413hVGg/nbPB4P9d2L9MlmkxNvgCQMtZlKE85v8/KwpIThb6nb8mv3lKJJbbv8+SZsTvOOc/pQCIIOYw0j+diYu8efWzvy8k7g9bp9u/kxYDa+pKtD9XlYvA8HnVv6i1e9aVu7G/nio7D4CZ3L/WR6rNh5EGwCkgQweBkghAdvTluZnfrr9cKW4ay8jdvxbjhr1f1QVAR5C0MzivAkAWPu5T2QS8v2cWmi772d+/cKj4lzLJCEBx2QJfYrMFQIcecHFB3sO/LYou8tJi4L+jr7lhO38BwIcI0Nb7xgTAXxIUxzv0w7/ts5dVInnhv0T+l8DZLfE/MP3FoFvS5D8MzuyPm3DDv7JkhGyvzuG/tzhzRIRc0b9Ovv3/0z7mv6/03qhPLdC/m4CT/dDN4b9dwjU5VCQBQBBJX1ntCv0/9GsWtZesy79baTkvlCzjv1mjYgEz++S/oW6KnOQW8b9KoilqByXLv6W2KnGYjeS/SmaKz3Vx9z+BZB5yxGHwP3fHN6OJVdC/dZ02ES/2478PuaBjLrXaP4/JU81pPaO/fgsikW3pzr+XlhbYZrjkv4tSn7YDbP0/f2LnFKlF9z+mJHHg/w/Sv14ILfMECOW/mfg4qYhR/b+OP+RQDCACwOpb9yNs09C/1fbPpJjB5L9pN2WOVZ3wv3hHy9nxIve/URlzO/Rv0r8YFturGCTmv1d1/KKR8QPA8gsy9qzSB8CfHRX3t6fSvzzFCT/Qg+a/EYStnrzV9r/2QJqI7Lb9v/YEIrTDINW/LbFE4JPi5r/7kQEs5fEDQHunnf4GeQBAooj9BX7L2L+oPOc8Uzzpv+ydYY2SSAfAL4HK6CRTB0BH3yUkWpDZv2wvsfFmQ+i/Ik0Yzruh6T8fM3LoGoDUP3oSeovukti/S/ycXKkd6r9rEv+7UWcHQCRIQe/GfwNAa36Abk+y2b9BLWR4ssrpv9KT87qa0bM/FTyktw823L8WyyI/BbLgv4hlM1gubOq/DizMp9Ki6r8b5ckdjVrzv5NVbYtSON+/BBqJ+C6O7L/dUBFqgyXYv00Wh18r7+q/7RAy9h8/4L8W8t/TUc3rv4RM5DKx3wDAfvWIj94aBcBsc1IetODgv3oY0nYIW+y/oGcTFF54AUDkJqS/FKX6PwzNxsC7AOC/ltfN1PUC7L+5Wrz/zHnzP6688w2rNOc/YeV9neCo4b9nlSHXANfuvw9RsxKjY/s/1V8GteXE8j+1C8NdDcfiv2wlcW3YZO+/IOywaA7Q8b9bFP+4Tg36v4GTTeNZi+O/9t/ywdRi77+tRc3yFR7eP2bkcHXJkLO//ITc9SjT4r+qoBf2J0nwv2YHKoswwfm/iQcLspCjAcCb6wCzCvXkvwXv9rkMT/C/YkuwYAMXBMApCNUai9kIwMORhtNuJ+e/BVt01fKF8L+ZqWEfvIjsP6h693QZYNk/WyOTkB2i5b8of+GtdSDxvwpaaulDSwVADMQAX+lOAECEHWF8XNPmv1cr/B+VnvG/XyFG6opcCMD/mtR32/UEQP+2XEF3hui/ulBTjAt88r/imfCfRP+yP9zbvtc8XeO/TZuKJD5G6b/MaTExyXzyvxiTQeElXOO/rbJRQVGN9L/z0wR2g9DqvxOqKRxEX/O/FDGCEei99j9x8zV4VYTmP2lzCnsYk+u/l6ELZ9tg878pRXacaDT/v3k6GZRqoQXAVB67LiP56r94+LDK0Sn0vwO6pZ9b7wFAvK0nKVcc9j8+U/hCvyruv6QMsuuLQ/W/FPhKFYv46j8MyxaDTOW/v9L18g1caO2/vebfvctE9b/7GD8ZrF3xv3gx1AR9bQDAuMEtsM4c77+SabgA2nj0v5xKFIwxsATArKNSBaKsB0Cjara6ozTwv33ArMz7sfa/dF2U0FcWCcDxL357DJX/P69pJmt7c/G/quJYWJZl+L/YntVJlnrSP4sRLzXM+fe/46uU8w3c8r+q4lhYlmX4v85lu5+QRwRAsI0H/WU8479jaeZNtj/zv6riWFiWZfi/sI0H/WU847/OZbufkEcEQHAoPUBrnss/9exKzDtFtT88wM8kax+gP9OqeKeAYog/MW0ItiZvcj+ph+smvt5bP2lCaV5dEUU/StaUmQDaLz+kK9y22BMYP0O3whZuMwI/IIbgZGWE6z7UkjYaEM3UPuezxwa9cr8+LybxRMnFpz6E1N8DbPiRPsYjySMvK3s+//////8fAAj//////zMQCP////9/MiAI/////28yMAj/////YzJACP///z9iMlAI////N2IyYAj///8zYjJwCP//vzNiMoAI//+rM2IykAj/f6szYjKgCP8PqzNiMrAI/wOrM2IywAi/A6szYjLQCJ8DqzNiMuAImQOrM2Iy8Aj//////z8PCP//////Kx8I/////38pLwj/////Pyk/CP////85KU8I////PzgpXwj///8POClvCP///w44KX8I//8fDjgpjwj//w8OOCmfCP9/DQ44Ka8I/w8NDjgpvwj/DQ0OOCnPCP8MDQ44Kd8IxwwNDjgp7wjEDA0OOCn/CAcAAAAHAAAAAQAAAAIAAAAEAAAAAwAAAAAAAAAAAAAABwAAAAMAAAABAAAAAgAAAAUAAAAEAAAAAAAAAAAAAAAEAAAABAAAAAAAAAACAAAAAQAAAAMAAAAOAAAABgAAAAsAAAACAAAABwAAAAEAAAAYAAAABQAAAAoAAAABAAAABgAAAAAAAAAmAAAABwAAAAwAAAADAAAACAAAAAIAAAAxAAAACQAAAA4AAAAAAAAABQAAAAQAAAA6AAAACAAAAA0AAAAEAAAACQAAAAMAAAA/AAAACwAAAAYAAAAPAAAACgAAABAAAABIAAAADAAAAAcAAAAQAAAACwAAABEAAABTAAAACgAAAAUAAAATAAAADgAAAA8AAABhAAAADQAAAAgAAAARAAAADAAAABIAAABrAAAADgAAAAkAAAASAAAADQAAABMAAAB1AAAADwAAABMAAAARAAAAEgAAABAAAAAGAAAAAgAAAAMAAAAFAAAABAAAAAAAAAAAAAAAAAAAAAYAAAACAAAAAwAAAAEAAAAFAAAABAAAAAAAAAAAAAAABwAAAAUAAAADAAAABAAAAAEAAAAAAAAAAgAAAAAAAAACAAAAAwAAAAEAAAAFAAAABAAAAAYAAAAAAAAAAAAAABgtRFT7Ifk/GC1EVPsh+b8YLURU+yEJQBgtRFT7IQnAYWxnb3MuYwBoM05laWdoYm9yUm90YXRpb25zAGNvb3JkaWprLmMAX3VwQXA3Q2hlY2tlZABfdXBBcDdyQ2hlY2tlZABkaXJlY3RlZEVkZ2UuYwBkaXJlY3RlZEVkZ2VUb0JvdW5kYXJ5AGFkamFjZW50RmFjZURpclt0bXBGaWprLmZhY2VdW2ZpamsuZmFjZV0gPT0gS0kAZmFjZWlqay5jAF9mYWNlSWprUGVudFRvQ2VsbEJvdW5kYXJ5AGFkamFjZW50RmFjZURpcltjZW50ZXJJSksuZmFjZV1bZmFjZTJdID09IEtJAF9mYWNlSWprVG9DZWxsQm91bmRhcnkAaDNJbmRleC5jAGNvbXBhY3RDZWxscwBsYXRMbmdUb0NlbGwAY2VsbFRvQ2hpbGRQb3MAdmFsaWRhdGVDaGlsZFBvcwBsYXRMbmcuYwBjZWxsQXJlYVJhZHMyAHBvbHlnb24tPm5leHQgPT0gTlVMTABsaW5rZWRHZW8uYwBhZGROZXdMaW5rZWRQb2x5Z29uAG5leHQgIT0gTlVMTABsb29wICE9IE5VTEwAYWRkTmV3TGlua2VkTG9vcABwb2x5Z29uLT5maXJzdCA9PSBOVUxMAGFkZExpbmtlZExvb3AAY29vcmQgIT0gTlVMTABhZGRMaW5rZWRDb29yZABsb29wLT5maXJzdCA9PSBOVUxMAGlubmVyTG9vcHMgIT0gTlVMTABub3JtYWxpemVNdWx0aVBvbHlnb24AYmJveGVzICE9IE5VTEwAY2FuZGlkYXRlcyAhPSBOVUxMAGZpbmRQb2x5Z29uRm9ySG9sZQBjYW5kaWRhdGVCQm94ZXMgIT0gTlVMTAByZXZEaXIgIT0gSU5WQUxJRF9ESUdJVABsb2NhbGlqLmMAY2VsbFRvTG9jYWxJamsAYmFzZUNlbGwgIT0gb3JpZ2luQmFzZUNlbGwAIShvcmlnaW5PblBlbnQgJiYgaW5kZXhPblBlbnQpAGJhc2VDZWxsID09IG9yaWdpbkJhc2VDZWxsAGJhc2VDZWxsICE9IElOVkFMSURfQkFTRV9DRUxMAGxvY2FsSWprVG9DZWxsACFfaXNCYXNlQ2VsbFBlbnRhZ29uKGJhc2VDZWxsKQBiYXNlQ2VsbFJvdGF0aW9ucyA+PSAwAGdyaWRQYXRoQ2VsbHMAcG9seWZpbGwuYwBpdGVyU3RlcFBvbHlnb25Db21wYWN0ADAAdmVydGV4LmMAY2VsbFRvVmVydGV4AGdyYXBoLT5idWNrZXRzICE9IE5VTEwAdmVydGV4R3JhcGguYwBpbml0VmVydGV4R3JhcGgAbm9kZSAhPSBOVUxMAGFkZFZlcnRleE5vZGU=";
  var tempDoublePtr = 28624;
  function demangle(func) {
    return func;
  }
  function demangleAll(text) {
    var regex = /\b__Z[\w\d_]+/g;
    return text.replace(regex, function(x) {
      var y = demangle(x);
      return x === y ? x : y + " [" + x + "]";
    });
  }
  function jsStackTrace() {
    var err2 = new Error();
    if (!err2.stack) {
      try {
        throw new Error(0);
      } catch (e) {
        err2 = e;
      }
      if (!err2.stack) {
        return "(no stack trace available)";
      }
    }
    return err2.stack.toString();
  }
  function stackTrace() {
    var js3 = jsStackTrace();
    if (Module["extraStackTrace"]) {
      js3 += "\n" + Module["extraStackTrace"]();
    }
    return demangleAll(js3);
  }
  function ___assert_fail(condition, filename, line, func) {
    abort("Assertion failed: " + UTF8ToString(condition) + ", at: " + [filename ? UTF8ToString(filename) : "unknown filename", line, func ? UTF8ToString(func) : "unknown function"]);
  }
  function _emscripten_get_heap_size() {
    return HEAP8.length;
  }
  function _emscripten_memcpy_big(dest, src, num) {
    HEAPU8.set(HEAPU8.subarray(src, src + num), dest);
  }
  function ___setErrNo(value) {
    if (Module["___errno_location"]) {
      HEAP32[Module["___errno_location"]() >> 2] = value;
    }
    return value;
  }
  function abortOnCannotGrowMemory(requestedSize) {
    abort("OOM");
  }
  function emscripten_realloc_buffer(size) {
    try {
      var newBuffer = new ArrayBuffer(size);
      if (newBuffer.byteLength != size) {
        return;
      }
      new Int8Array(newBuffer).set(HEAP8);
      _emscripten_replace_memory(newBuffer);
      updateGlobalBufferAndViews(newBuffer);
      return 1;
    } catch (e) {
    }
  }
  function _emscripten_resize_heap(requestedSize) {
    var oldSize = _emscripten_get_heap_size();
    var PAGE_MULTIPLE = 16777216;
    var LIMIT = 2147483648 - PAGE_MULTIPLE;
    if (requestedSize > LIMIT) {
      return false;
    }
    var MIN_TOTAL_MEMORY = 16777216;
    var newSize = Math.max(oldSize, MIN_TOTAL_MEMORY);
    while (newSize < requestedSize) {
      if (newSize <= 536870912) {
        newSize = alignUp(2 * newSize, PAGE_MULTIPLE);
      } else {
        newSize = Math.min(alignUp((3 * newSize + 2147483648) / 4, PAGE_MULTIPLE), LIMIT);
      }
    }
    var replacement = emscripten_realloc_buffer(newSize);
    if (!replacement) {
      return false;
    }
    return true;
  }
  var decodeBase64 = typeof atob === "function" ? atob : function(input) {
    var keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    var output3 = "";
    var chr1, chr2, chr3;
    var enc1, enc2, enc3, enc4;
    var i = 0;
    input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
    do {
      enc1 = keyStr.indexOf(input.charAt(i++));
      enc2 = keyStr.indexOf(input.charAt(i++));
      enc3 = keyStr.indexOf(input.charAt(i++));
      enc4 = keyStr.indexOf(input.charAt(i++));
      chr1 = enc1 << 2 | enc2 >> 4;
      chr2 = (enc2 & 15) << 4 | enc3 >> 2;
      chr3 = (enc3 & 3) << 6 | enc4;
      output3 = output3 + String.fromCharCode(chr1);
      if (enc3 !== 64) {
        output3 = output3 + String.fromCharCode(chr2);
      }
      if (enc4 !== 64) {
        output3 = output3 + String.fromCharCode(chr3);
      }
    } while (i < input.length);
    return output3;
  };
  function intArrayFromBase64(s) {
    try {
      var decoded = decodeBase64(s);
      var bytes = new Uint8Array(decoded.length);
      for (var i = 0; i < decoded.length; ++i) {
        bytes[i] = decoded.charCodeAt(i);
      }
      return bytes;
    } catch (_) {
      throw new Error("Converting base64 string to bytes failed.");
    }
  }
  function tryParseAsDataURI(filename) {
    if (!isDataURI(filename)) {
      return;
    }
    return intArrayFromBase64(filename.slice(dataURIPrefix.length));
  }
  var asmGlobalArg = {
    "Math": Math,
    "Int8Array": Int8Array,
    "Int32Array": Int32Array,
    "Uint8Array": Uint8Array,
    "Float32Array": Float32Array,
    "Float64Array": Float64Array
  };
  var asmLibraryArg = {
    "a": abort,
    "b": setTempRet0,
    "c": getTempRet0,
    "d": ___assert_fail,
    "e": ___setErrNo,
    "f": _emscripten_get_heap_size,
    "g": _emscripten_memcpy_big,
    "h": _emscripten_resize_heap,
    "i": abortOnCannotGrowMemory,
    "j": demangle,
    "k": demangleAll,
    "l": emscripten_realloc_buffer,
    "m": jsStackTrace,
    "n": stackTrace,
    "o": tempDoublePtr,
    "p": DYNAMICTOP_PTR
  };
  var asm = (
    /** @suppress {uselessCode} */
    function(global2, env, buffer4) {
      "almost asm";
      var a = new global2.Int8Array(buffer4), b = new global2.Int32Array(buffer4), c3 = new global2.Uint8Array(buffer4), d = new global2.Float32Array(buffer4), e = new global2.Float64Array(buffer4), f = env.o | 0, g = env.p | 0, p = global2.Math.floor, q = global2.Math.abs, r = global2.Math.sqrt, s = global2.Math.pow, t = global2.Math.cos, u4 = global2.Math.sin, v2 = global2.Math.tan, w = global2.Math.acos, x = global2.Math.asin, y = global2.Math.atan, z = global2.Math.atan2, A5 = global2.Math.ceil, B4 = global2.Math.imul, C3 = global2.Math.min, D3 = global2.Math.max, E2 = global2.Math.clz32, G = env.b, H = env.c, I = env.d, J = env.e, K2 = env.f, L = env.g, M2 = env.h, N2 = env.i, T2 = 28640;
      function W(newBuffer) {
        a = new Int8Array(newBuffer);
        c3 = new Uint8Array(newBuffer);
        b = new Int32Array(newBuffer);
        d = new Float32Array(newBuffer);
        e = new Float64Array(newBuffer);
        buffer4 = newBuffer;
        return true;
      }
      function X(a2) {
        a2 = a2 | 0;
        var b2 = 0;
        b2 = T2;
        T2 = T2 + a2 | 0;
        T2 = T2 + 15 & -16;
        return b2 | 0;
      }
      function Y() {
        return T2 | 0;
      }
      function Z(a2) {
        a2 = a2 | 0;
        T2 = a2;
      }
      function _(a2, b2) {
        a2 = a2 | 0;
        b2 = b2 | 0;
        T2 = a2;
      }
      function $(a2, c4) {
        a2 = a2 | 0;
        c4 = c4 | 0;
        var d2 = 0, e3 = 0, f2 = 0;
        if ((a2 | 0) < 0) {
          c4 = 2;
          return c4 | 0;
        }
        if ((a2 | 0) > 13780509) {
          c4 = uc(15, c4) | 0;
          return c4 | 0;
        } else {
          d2 = ((a2 | 0) < 0) << 31 >> 31;
          f2 = Md(a2 | 0, d2 | 0, 3, 0) | 0;
          e3 = H() | 0;
          d2 = Gd(a2 | 0, d2 | 0, 1, 0) | 0;
          d2 = Md(f2 | 0, e3 | 0, d2 | 0, H() | 0) | 0;
          d2 = Gd(d2 | 0, H() | 0, 1, 0) | 0;
          a2 = H() | 0;
          b[c4 >> 2] = d2;
          b[c4 + 4 >> 2] = a2;
          c4 = 0;
          return c4 | 0;
        }
        return 0;
      }
      function aa2(a2, b2, c4, d2) {
        a2 = a2 | 0;
        b2 = b2 | 0;
        c4 = c4 | 0;
        d2 = d2 | 0;
        return ba(a2, b2, c4, d2, 0) | 0;
      }
      function ba(a2, c4, d2, e3, f2) {
        a2 = a2 | 0;
        c4 = c4 | 0;
        d2 = d2 | 0;
        e3 = e3 | 0;
        f2 = f2 | 0;
        var g2 = 0, h = 0, i = 0, j = 0, k = 0;
        j = T2;
        T2 = T2 + 16 | 0;
        h = j;
        if (!(ca3(a2, c4, d2, e3, f2) | 0)) {
          e3 = 0;
          T2 = j;
          return e3 | 0;
        }
        do {
          if ((d2 | 0) >= 0) {
            if ((d2 | 0) > 13780509) {
              g2 = uc(15, h) | 0;
              if (g2 | 0) {
                break;
              }
              i = h;
              h = b[i >> 2] | 0;
              i = b[i + 4 >> 2] | 0;
            } else {
              g2 = ((d2 | 0) < 0) << 31 >> 31;
              k = Md(d2 | 0, g2 | 0, 3, 0) | 0;
              i = H() | 0;
              g2 = Gd(d2 | 0, g2 | 0, 1, 0) | 0;
              g2 = Md(k | 0, i | 0, g2 | 0, H() | 0) | 0;
              g2 = Gd(g2 | 0, H() | 0, 1, 0) | 0;
              i = H() | 0;
              b[h >> 2] = g2;
              b[h + 4 >> 2] = i;
              h = g2;
            }
            Xd(e3 | 0, 0, h << 3 | 0) | 0;
            if (f2 | 0) {
              Xd(f2 | 0, 0, h << 2 | 0) | 0;
              g2 = da2(a2, c4, d2, e3, f2, h, i, 0) | 0;
              break;
            }
            g2 = Fd(h, 4) | 0;
            if (!g2) {
              g2 = 13;
            } else {
              k = da2(a2, c4, d2, e3, g2, h, i, 0) | 0;
              Ed(g2);
              g2 = k;
            }
          } else {
            g2 = 2;
          }
        } while (0);
        k = g2;
        T2 = j;
        return k | 0;
      }
      function ca3(a2, c4, d2, e3, f2) {
        a2 = a2 | 0;
        c4 = c4 | 0;
        d2 = d2 | 0;
        e3 = e3 | 0;
        f2 = f2 | 0;
        var g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p2 = 0, q2 = 0;
        q2 = T2;
        T2 = T2 + 16 | 0;
        o = q2;
        p2 = q2 + 8 | 0;
        n = o;
        b[n >> 2] = a2;
        b[n + 4 >> 2] = c4;
        if ((d2 | 0) < 0) {
          p2 = 2;
          T2 = q2;
          return p2 | 0;
        }
        g2 = e3;
        b[g2 >> 2] = a2;
        b[g2 + 4 >> 2] = c4;
        g2 = (f2 | 0) != 0;
        if (g2) {
          b[f2 >> 2] = 0;
        }
        if (Hb(a2, c4) | 0) {
          p2 = 9;
          T2 = q2;
          return p2 | 0;
        }
        b[p2 >> 2] = 0;
        a: do {
          if ((d2 | 0) >= 1) {
            if (g2) {
              l = 1;
              k = 0;
              m = 0;
              n = 1;
              g2 = a2;
              while (1) {
                if (!(k | m)) {
                  g2 = ea2(g2, c4, 4, p2, o) | 0;
                  if (g2 | 0) {
                    break a;
                  }
                  c4 = o;
                  g2 = b[c4 >> 2] | 0;
                  c4 = b[c4 + 4 >> 2] | 0;
                  if (Hb(g2, c4) | 0) {
                    g2 = 9;
                    break a;
                  }
                }
                g2 = ea2(g2, c4, b[26800 + (m << 2) >> 2] | 0, p2, o) | 0;
                if (g2 | 0) {
                  break a;
                }
                c4 = o;
                g2 = b[c4 >> 2] | 0;
                c4 = b[c4 + 4 >> 2] | 0;
                a2 = e3 + (l << 3) | 0;
                b[a2 >> 2] = g2;
                b[a2 + 4 >> 2] = c4;
                b[f2 + (l << 2) >> 2] = n;
                a2 = k + 1 | 0;
                h = (a2 | 0) == (n | 0);
                i = m + 1 | 0;
                j = (i | 0) == 6;
                if (Hb(g2, c4) | 0) {
                  g2 = 9;
                  break a;
                }
                n = n + (j & h & 1) | 0;
                if ((n | 0) > (d2 | 0)) {
                  g2 = 0;
                  break;
                } else {
                  l = l + 1 | 0;
                  k = h ? 0 : a2;
                  m = h ? j ? 0 : i : m;
                }
              }
            } else {
              l = 1;
              k = 0;
              m = 0;
              n = 1;
              g2 = a2;
              while (1) {
                if (!(k | m)) {
                  g2 = ea2(g2, c4, 4, p2, o) | 0;
                  if (g2 | 0) {
                    break a;
                  }
                  c4 = o;
                  g2 = b[c4 >> 2] | 0;
                  c4 = b[c4 + 4 >> 2] | 0;
                  if (Hb(g2, c4) | 0) {
                    g2 = 9;
                    break a;
                  }
                }
                g2 = ea2(g2, c4, b[26800 + (m << 2) >> 2] | 0, p2, o) | 0;
                if (g2 | 0) {
                  break a;
                }
                c4 = o;
                g2 = b[c4 >> 2] | 0;
                c4 = b[c4 + 4 >> 2] | 0;
                a2 = e3 + (l << 3) | 0;
                b[a2 >> 2] = g2;
                b[a2 + 4 >> 2] = c4;
                a2 = k + 1 | 0;
                h = (a2 | 0) == (n | 0);
                i = m + 1 | 0;
                j = (i | 0) == 6;
                if (Hb(g2, c4) | 0) {
                  g2 = 9;
                  break a;
                }
                n = n + (j & h & 1) | 0;
                if ((n | 0) > (d2 | 0)) {
                  g2 = 0;
                  break;
                } else {
                  l = l + 1 | 0;
                  k = h ? 0 : a2;
                  m = h ? j ? 0 : i : m;
                }
              }
            }
          } else {
            g2 = 0;
          }
        } while (0);
        p2 = g2;
        T2 = q2;
        return p2 | 0;
      }
      function da2(a2, c4, d2, e3, f2, g2, h, i) {
        a2 = a2 | 0;
        c4 = c4 | 0;
        d2 = d2 | 0;
        e3 = e3 | 0;
        f2 = f2 | 0;
        g2 = g2 | 0;
        h = h | 0;
        i = i | 0;
        var j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p2 = 0, q2 = 0, r2 = 0, s2 = 0;
        q2 = T2;
        T2 = T2 + 16 | 0;
        o = q2 + 8 | 0;
        p2 = q2;
        j = Od(a2 | 0, c4 | 0, g2 | 0, h | 0) | 0;
        l = H() | 0;
        m = e3 + (j << 3) | 0;
        r2 = m;
        s2 = b[r2 >> 2] | 0;
        r2 = b[r2 + 4 >> 2] | 0;
        k = (s2 | 0) == (a2 | 0) & (r2 | 0) == (c4 | 0);
        if (!((s2 | 0) == 0 & (r2 | 0) == 0 | k)) {
          do {
            j = Gd(j | 0, l | 0, 1, 0) | 0;
            j = Nd(j | 0, H() | 0, g2 | 0, h | 0) | 0;
            l = H() | 0;
            m = e3 + (j << 3) | 0;
            s2 = m;
            r2 = b[s2 >> 2] | 0;
            s2 = b[s2 + 4 >> 2] | 0;
            k = (r2 | 0) == (a2 | 0) & (s2 | 0) == (c4 | 0);
          } while (!((r2 | 0) == 0 & (s2 | 0) == 0 | k));
        }
        j = f2 + (j << 2) | 0;
        if (k ? (b[j >> 2] | 0) <= (i | 0) : 0) {
          s2 = 0;
          T2 = q2;
          return s2 | 0;
        }
        s2 = m;
        b[s2 >> 2] = a2;
        b[s2 + 4 >> 2] = c4;
        b[j >> 2] = i;
        if ((i | 0) >= (d2 | 0)) {
          s2 = 0;
          T2 = q2;
          return s2 | 0;
        }
        k = i + 1 | 0;
        b[o >> 2] = 0;
        j = ea2(a2, c4, 2, o, p2) | 0;
        switch (j | 0) {
          case 9: {
            n = 9;
            break;
          }
          case 0: {
            j = p2;
            j = da2(b[j >> 2] | 0, b[j + 4 >> 2] | 0, d2, e3, f2, g2, h, k) | 0;
            if (!j) {
              n = 9;
            }
            break;
          }
          default:
        }
        a: do {
          if ((n | 0) == 9) {
            b[o >> 2] = 0;
            j = ea2(a2, c4, 3, o, p2) | 0;
            switch (j | 0) {
              case 9:
                break;
              case 0: {
                j = p2;
                j = da2(b[j >> 2] | 0, b[j + 4 >> 2] | 0, d2, e3, f2, g2, h, k) | 0;
                if (j | 0) {
                  break a;
                }
                break;
              }
              default:
                break a;
            }
            b[o >> 2] = 0;
            j = ea2(a2, c4, 1, o, p2) | 0;
            switch (j | 0) {
              case 9:
                break;
              case 0: {
                j = p2;
                j = da2(b[j >> 2] | 0, b[j + 4 >> 2] | 0, d2, e3, f2, g2, h, k) | 0;
                if (j | 0) {
                  break a;
                }
                break;
              }
              default:
                break a;
            }
            b[o >> 2] = 0;
            j = ea2(a2, c4, 5, o, p2) | 0;
            switch (j | 0) {
              case 9:
                break;
              case 0: {
                j = p2;
                j = da2(b[j >> 2] | 0, b[j + 4 >> 2] | 0, d2, e3, f2, g2, h, k) | 0;
                if (j | 0) {
                  break a;
                }
                break;
              }
              default:
                break a;
            }
            b[o >> 2] = 0;
            j = ea2(a2, c4, 4, o, p2) | 0;
            switch (j | 0) {
              case 9:
                break;
              case 0: {
                j = p2;
                j = da2(b[j >> 2] | 0, b[j + 4 >> 2] | 0, d2, e3, f2, g2, h, k) | 0;
                if (j | 0) {
                  break a;
                }
                break;
              }
              default:
                break a;
            }
            b[o >> 2] = 0;
            j = ea2(a2, c4, 6, o, p2) | 0;
            switch (j | 0) {
              case 9:
                break;
              case 0: {
                j = p2;
                j = da2(b[j >> 2] | 0, b[j + 4 >> 2] | 0, d2, e3, f2, g2, h, k) | 0;
                if (j | 0) {
                  break a;
                }
                break;
              }
              default:
                break a;
            }
            s2 = 0;
            T2 = q2;
            return s2 | 0;
          }
        } while (0);
        s2 = j;
        T2 = q2;
        return s2 | 0;
      }
      function ea2(a2, c4, d2, e3, f2) {
        a2 = a2 | 0;
        c4 = c4 | 0;
        d2 = d2 | 0;
        e3 = e3 | 0;
        f2 = f2 | 0;
        var g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p2 = 0;
        if (d2 >>> 0 > 6) {
          f2 = 1;
          return f2 | 0;
        }
        m = (b[e3 >> 2] | 0) % 6 | 0;
        b[e3 >> 2] = m;
        if ((m | 0) > 0) {
          g2 = 0;
          do {
            d2 = $a(d2) | 0;
            g2 = g2 + 1 | 0;
          } while ((g2 | 0) < (b[e3 >> 2] | 0));
        }
        m = Qd(a2 | 0, c4 | 0, 45) | 0;
        H() | 0;
        l = m & 127;
        if (l >>> 0 > 121) {
          f2 = 5;
          return f2 | 0;
        }
        j = Pb(a2, c4) | 0;
        g2 = Qd(a2 | 0, c4 | 0, 52) | 0;
        H() | 0;
        g2 = g2 & 15;
        a: do {
          if (!g2) {
            k = 8;
          } else {
            while (1) {
              h = (15 - g2 | 0) * 3 | 0;
              i = Qd(a2 | 0, c4 | 0, h | 0) | 0;
              H() | 0;
              i = i & 7;
              if ((i | 0) == 7) {
                c4 = 5;
                break;
              }
              p2 = (Vb(g2) | 0) == 0;
              g2 = g2 + -1 | 0;
              n = Rd(7, 0, h | 0) | 0;
              c4 = c4 & ~(H() | 0);
              o = Rd(b[(p2 ? 432 : 16) + (i * 28 | 0) + (d2 << 2) >> 2] | 0, 0, h | 0) | 0;
              h = H() | 0;
              d2 = b[(p2 ? 640 : 224) + (i * 28 | 0) + (d2 << 2) >> 2] | 0;
              a2 = o | a2 & ~n;
              c4 = h | c4;
              if (!d2) {
                d2 = 0;
                break a;
              }
              if (!g2) {
                k = 8;
                break a;
              }
            }
            return c4 | 0;
          }
        } while (0);
        if ((k | 0) == 8) {
          p2 = b[848 + (l * 28 | 0) + (d2 << 2) >> 2] | 0;
          o = Rd(p2 | 0, 0, 45) | 0;
          a2 = o | a2;
          c4 = H() | 0 | c4 & -1040385;
          d2 = b[4272 + (l * 28 | 0) + (d2 << 2) >> 2] | 0;
          if ((p2 & 127 | 0) == 127) {
            p2 = Rd(b[848 + (l * 28 | 0) + 20 >> 2] | 0, 0, 45) | 0;
            c4 = H() | 0 | c4 & -1040385;
            d2 = b[4272 + (l * 28 | 0) + 20 >> 2] | 0;
            a2 = Rb(p2 | a2, c4) | 0;
            c4 = H() | 0;
            b[e3 >> 2] = (b[e3 >> 2] | 0) + 1;
          }
        }
        i = Qd(a2 | 0, c4 | 0, 45) | 0;
        H() | 0;
        i = i & 127;
        b: do {
          if (!(oa(i) | 0)) {
            if ((d2 | 0) > 0) {
              g2 = 0;
              do {
                a2 = Rb(a2, c4) | 0;
                c4 = H() | 0;
                g2 = g2 + 1 | 0;
              } while ((g2 | 0) != (d2 | 0));
            }
          } else {
            c: do {
              if ((Pb(a2, c4) | 0) == 1) {
                if ((l | 0) != (i | 0)) {
                  if (ua(i, b[7696 + (l * 28 | 0) >> 2] | 0) | 0) {
                    a2 = Tb(a2, c4) | 0;
                    h = 1;
                    c4 = H() | 0;
                    break;
                  } else {
                    I(27795, 26864, 533, 26872);
                  }
                }
                switch (j | 0) {
                  case 3: {
                    a2 = Rb(a2, c4) | 0;
                    c4 = H() | 0;
                    b[e3 >> 2] = (b[e3 >> 2] | 0) + 1;
                    h = 0;
                    break c;
                  }
                  case 5: {
                    a2 = Tb(a2, c4) | 0;
                    c4 = H() | 0;
                    b[e3 >> 2] = (b[e3 >> 2] | 0) + 5;
                    h = 0;
                    break c;
                  }
                  case 0: {
                    p2 = 9;
                    return p2 | 0;
                  }
                  default: {
                    p2 = 1;
                    return p2 | 0;
                  }
                }
              } else {
                h = 0;
              }
            } while (0);
            if ((d2 | 0) > 0) {
              g2 = 0;
              do {
                a2 = Qb(a2, c4) | 0;
                c4 = H() | 0;
                g2 = g2 + 1 | 0;
              } while ((g2 | 0) != (d2 | 0));
            }
            if ((l | 0) != (i | 0)) {
              if (!(pa(i) | 0)) {
                if ((h | 0) != 0 | (Pb(a2, c4) | 0) != 5) {
                  break;
                }
                b[e3 >> 2] = (b[e3 >> 2] | 0) + 1;
                break;
              }
              switch (m & 127) {
                case 8:
                case 118:
                  break b;
                default:
              }
              if ((Pb(a2, c4) | 0) != 3) {
                b[e3 >> 2] = (b[e3 >> 2] | 0) + 1;
              }
            }
          }
        } while (0);
        b[e3 >> 2] = ((b[e3 >> 2] | 0) + d2 | 0) % 6 | 0;
        p2 = f2;
        b[p2 >> 2] = a2;
        b[p2 + 4 >> 2] = c4;
        p2 = 0;
        return p2 | 0;
      }
      function fa(a2, b2, c4, d2) {
        a2 = a2 | 0;
        b2 = b2 | 0;
        c4 = c4 | 0;
        d2 = d2 | 0;
        if (!(ga(a2, b2, c4, d2) | 0)) {
          d2 = 0;
          return d2 | 0;
        }
        Xd(d2 | 0, 0, c4 * 48 | 0) | 0;
        d2 = ha(a2, b2, c4, d2) | 0;
        return d2 | 0;
      }
      function ga(a2, c4, d2, e3) {
        a2 = a2 | 0;
        c4 = c4 | 0;
        d2 = d2 | 0;
        e3 = e3 | 0;
        var f2 = 0, g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p2 = 0;
        p2 = T2;
        T2 = T2 + 16 | 0;
        n = p2;
        o = p2 + 8 | 0;
        m = n;
        b[m >> 2] = a2;
        b[m + 4 >> 2] = c4;
        if ((d2 | 0) < 0) {
          o = 2;
          T2 = p2;
          return o | 0;
        }
        if (!d2) {
          o = e3;
          b[o >> 2] = a2;
          b[o + 4 >> 2] = c4;
          o = 0;
          T2 = p2;
          return o | 0;
        }
        b[o >> 2] = 0;
        a: do {
          if (!(Hb(a2, c4) | 0)) {
            f2 = 0;
            m = a2;
            do {
              a2 = ea2(m, c4, 4, o, n) | 0;
              if (a2 | 0) {
                break a;
              }
              c4 = n;
              m = b[c4 >> 2] | 0;
              c4 = b[c4 + 4 >> 2] | 0;
              f2 = f2 + 1 | 0;
              if (Hb(m, c4) | 0) {
                a2 = 9;
                break a;
              }
            } while ((f2 | 0) < (d2 | 0));
            l = e3;
            b[l >> 2] = m;
            b[l + 4 >> 2] = c4;
            l = d2 + -1 | 0;
            k = 0;
            a2 = 1;
            do {
              f2 = 26800 + (k << 2) | 0;
              if ((k | 0) == 5) {
                h = b[f2 >> 2] | 0;
                g2 = 0;
                f2 = a2;
                while (1) {
                  a2 = n;
                  a2 = ea2(b[a2 >> 2] | 0, b[a2 + 4 >> 2] | 0, h, o, n) | 0;
                  if (a2 | 0) {
                    break a;
                  }
                  if ((g2 | 0) != (l | 0)) {
                    j = n;
                    i = b[j >> 2] | 0;
                    j = b[j + 4 >> 2] | 0;
                    a2 = e3 + (f2 << 3) | 0;
                    b[a2 >> 2] = i;
                    b[a2 + 4 >> 2] = j;
                    if (!(Hb(i, j) | 0)) {
                      a2 = f2 + 1 | 0;
                    } else {
                      a2 = 9;
                      break a;
                    }
                  } else {
                    a2 = f2;
                  }
                  g2 = g2 + 1 | 0;
                  if ((g2 | 0) >= (d2 | 0)) {
                    break;
                  } else {
                    f2 = a2;
                  }
                }
              } else {
                h = n;
                j = b[f2 >> 2] | 0;
                i = 0;
                f2 = a2;
                g2 = b[h >> 2] | 0;
                h = b[h + 4 >> 2] | 0;
                while (1) {
                  a2 = ea2(g2, h, j, o, n) | 0;
                  if (a2 | 0) {
                    break a;
                  }
                  h = n;
                  g2 = b[h >> 2] | 0;
                  h = b[h + 4 >> 2] | 0;
                  a2 = e3 + (f2 << 3) | 0;
                  b[a2 >> 2] = g2;
                  b[a2 + 4 >> 2] = h;
                  a2 = f2 + 1 | 0;
                  if (Hb(g2, h) | 0) {
                    a2 = 9;
                    break a;
                  }
                  i = i + 1 | 0;
                  if ((i | 0) >= (d2 | 0)) {
                    break;
                  } else {
                    f2 = a2;
                  }
                }
              }
              k = k + 1 | 0;
            } while (k >>> 0 < 6);
            a2 = n;
            a2 = ((m | 0) == (b[a2 >> 2] | 0) ? (c4 | 0) == (b[a2 + 4 >> 2] | 0) : 0) ? 0 : 9;
          } else {
            a2 = 9;
          }
        } while (0);
        o = a2;
        T2 = p2;
        return o | 0;
      }
      function ha(a2, c4, d2, e3) {
        a2 = a2 | 0;
        c4 = c4 | 0;
        d2 = d2 | 0;
        e3 = e3 | 0;
        var f2 = 0, g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0;
        m = T2;
        T2 = T2 + 16 | 0;
        h = m;
        if (!d2) {
          b[e3 >> 2] = a2;
          b[e3 + 4 >> 2] = c4;
          e3 = 0;
          T2 = m;
          return e3 | 0;
        }
        do {
          if ((d2 | 0) >= 0) {
            if ((d2 | 0) > 13780509) {
              f2 = uc(15, h) | 0;
              if (f2 | 0) {
                break;
              }
              g2 = h;
              f2 = b[g2 >> 2] | 0;
              g2 = b[g2 + 4 >> 2] | 0;
            } else {
              f2 = ((d2 | 0) < 0) << 31 >> 31;
              l = Md(d2 | 0, f2 | 0, 3, 0) | 0;
              g2 = H() | 0;
              f2 = Gd(d2 | 0, f2 | 0, 1, 0) | 0;
              f2 = Md(l | 0, g2 | 0, f2 | 0, H() | 0) | 0;
              f2 = Gd(f2 | 0, H() | 0, 1, 0) | 0;
              g2 = H() | 0;
              l = h;
              b[l >> 2] = f2;
              b[l + 4 >> 2] = g2;
            }
            k = Fd(f2, 8) | 0;
            if (!k) {
              f2 = 13;
            } else {
              l = Fd(f2, 4) | 0;
              if (!l) {
                Ed(k);
                f2 = 13;
                break;
              }
              f2 = da2(a2, c4, d2, k, l, f2, g2, 0) | 0;
              if (f2 | 0) {
                Ed(k);
                Ed(l);
                break;
              }
              c4 = b[h >> 2] | 0;
              h = b[h + 4 >> 2] | 0;
              if ((h | 0) > 0 | (h | 0) == 0 & c4 >>> 0 > 0) {
                f2 = 0;
                i = 0;
                j = 0;
                do {
                  a2 = k + (i << 3) | 0;
                  g2 = b[a2 >> 2] | 0;
                  a2 = b[a2 + 4 >> 2] | 0;
                  if (!((g2 | 0) == 0 & (a2 | 0) == 0) ? (b[l + (i << 2) >> 2] | 0) == (d2 | 0) : 0) {
                    n = e3 + (f2 << 3) | 0;
                    b[n >> 2] = g2;
                    b[n + 4 >> 2] = a2;
                    f2 = f2 + 1 | 0;
                  }
                  i = Gd(i | 0, j | 0, 1, 0) | 0;
                  j = H() | 0;
                } while ((j | 0) < (h | 0) | (j | 0) == (h | 0) & i >>> 0 < c4 >>> 0);
              }
              Ed(k);
              Ed(l);
              f2 = 0;
            }
          } else {
            f2 = 2;
          }
        } while (0);
        n = f2;
        T2 = m;
        return n | 0;
      }
      function ia(a2, c4, d2, e3) {
        a2 = a2 | 0;
        c4 = c4 | 0;
        d2 = d2 | 0;
        e3 = e3 | 0;
        var f2 = 0, g2 = 0, h = 0, i = 0, j = 0, k = 0;
        i = T2;
        T2 = T2 + 16 | 0;
        g2 = i;
        h = i + 8 | 0;
        f2 = (Hb(a2, c4) | 0) == 0;
        f2 = f2 ? 1 : 2;
        while (1) {
          b[h >> 2] = 0;
          k = (ea2(a2, c4, f2, h, g2) | 0) == 0;
          j = g2;
          if (k & ((b[j >> 2] | 0) == (d2 | 0) ? (b[j + 4 >> 2] | 0) == (e3 | 0) : 0)) {
            a2 = 4;
            break;
          }
          f2 = f2 + 1 | 0;
          if (f2 >>> 0 >= 7) {
            f2 = 7;
            a2 = 4;
            break;
          }
        }
        if ((a2 | 0) == 4) {
          T2 = i;
          return f2 | 0;
        }
        return 0;
      }
      function ja(a2, c4, d2, e3) {
        a2 = a2 | 0;
        c4 = c4 | 0;
        d2 = d2 | 0;
        e3 = e3 | 0;
        var f2 = 0, g2 = 0, h = 0, i = 0, j = 0, k = 0;
        i = T2;
        T2 = T2 + 48 | 0;
        f2 = i + 16 | 0;
        g2 = i + 8 | 0;
        h = i;
        d2 = Xc(d2) | 0;
        if (d2 | 0) {
          h = d2;
          T2 = i;
          return h | 0;
        }
        k = a2;
        j = b[k + 4 >> 2] | 0;
        d2 = g2;
        b[d2 >> 2] = b[k >> 2];
        b[d2 + 4 >> 2] = j;
        Wc(g2, f2);
        d2 = Ha(f2, c4, h) | 0;
        if (!d2) {
          c4 = b[g2 >> 2] | 0;
          g2 = b[a2 + 8 >> 2] | 0;
          if ((g2 | 0) > 0) {
            f2 = b[a2 + 12 >> 2] | 0;
            d2 = 0;
            do {
              c4 = (b[f2 + (d2 << 3) >> 2] | 0) + c4 | 0;
              d2 = d2 + 1 | 0;
            } while ((d2 | 0) < (g2 | 0));
          }
          d2 = h;
          f2 = b[d2 >> 2] | 0;
          d2 = b[d2 + 4 >> 2] | 0;
          g2 = ((c4 | 0) < 0) << 31 >> 31;
          if ((d2 | 0) < (g2 | 0) | (d2 | 0) == (g2 | 0) & f2 >>> 0 < c4 >>> 0) {
            d2 = h;
            b[d2 >> 2] = c4;
            b[d2 + 4 >> 2] = g2;
            d2 = g2;
          } else {
            c4 = f2;
          }
          j = Gd(c4 | 0, d2 | 0, 12, 0) | 0;
          k = H() | 0;
          d2 = h;
          b[d2 >> 2] = j;
          b[d2 + 4 >> 2] = k;
          d2 = e3;
          b[d2 >> 2] = j;
          b[d2 + 4 >> 2] = k;
          d2 = 0;
        }
        k = d2;
        T2 = i;
        return k | 0;
      }
      function ka(a2, c4, d2, f2, g2, h, i) {
        a2 = a2 | 0;
        c4 = c4 | 0;
        d2 = d2 | 0;
        f2 = f2 | 0;
        g2 = g2 | 0;
        h = h | 0;
        i = i | 0;
        var j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p2 = 0, q2 = 0, r2 = 0, s2 = 0, t4 = 0, u5 = 0, v3 = 0, w4 = 0, x2 = 0, y2 = 0, z2 = 0, A6 = 0, B5 = 0, C4 = 0, D4 = 0, E3 = 0, F = 0, G2 = 0, I2 = 0, J2 = 0, K3 = 0, L2 = 0, M3 = 0;
        I2 = T2;
        T2 = T2 + 64 | 0;
        D4 = I2 + 48 | 0;
        E3 = I2 + 32 | 0;
        F = I2 + 24 | 0;
        x2 = I2 + 8 | 0;
        y2 = I2;
        k = b[a2 >> 2] | 0;
        if ((k | 0) <= 0) {
          G2 = 0;
          T2 = I2;
          return G2 | 0;
        }
        z2 = a2 + 4 | 0;
        A6 = D4 + 8 | 0;
        B5 = E3 + 8 | 0;
        C4 = x2 + 8 | 0;
        j = 0;
        v3 = 0;
        while (1) {
          l = b[z2 >> 2] | 0;
          u5 = l + (v3 << 4) | 0;
          b[D4 >> 2] = b[u5 >> 2];
          b[D4 + 4 >> 2] = b[u5 + 4 >> 2];
          b[D4 + 8 >> 2] = b[u5 + 8 >> 2];
          b[D4 + 12 >> 2] = b[u5 + 12 >> 2];
          if ((v3 | 0) == (k + -1 | 0)) {
            b[E3 >> 2] = b[l >> 2];
            b[E3 + 4 >> 2] = b[l + 4 >> 2];
            b[E3 + 8 >> 2] = b[l + 8 >> 2];
            b[E3 + 12 >> 2] = b[l + 12 >> 2];
          } else {
            u5 = l + (v3 + 1 << 4) | 0;
            b[E3 >> 2] = b[u5 >> 2];
            b[E3 + 4 >> 2] = b[u5 + 4 >> 2];
            b[E3 + 8 >> 2] = b[u5 + 8 >> 2];
            b[E3 + 12 >> 2] = b[u5 + 12 >> 2];
          }
          k = Ia(D4, E3, f2, F) | 0;
          a: do {
            if (!k) {
              k = F;
              l = b[k >> 2] | 0;
              k = b[k + 4 >> 2] | 0;
              if ((k | 0) > 0 | (k | 0) == 0 & l >>> 0 > 0) {
                t4 = 0;
                u5 = 0;
                b: while (1) {
                  K3 = 1 / (+(l >>> 0) + 4294967296 * +(k | 0));
                  M3 = +e[D4 >> 3];
                  k = Hd(l | 0, k | 0, t4 | 0, u5 | 0) | 0;
                  L2 = +(k >>> 0) + 4294967296 * +(H() | 0);
                  J2 = +(t4 >>> 0) + 4294967296 * +(u5 | 0);
                  e[x2 >> 3] = K3 * (M3 * L2) + K3 * (+e[E3 >> 3] * J2);
                  e[C4 >> 3] = K3 * (+e[A6 >> 3] * L2) + K3 * (+e[B5 >> 3] * J2);
                  k = Wb(x2, f2, y2) | 0;
                  if (k | 0) {
                    j = k;
                    break;
                  }
                  s2 = y2;
                  r2 = b[s2 >> 2] | 0;
                  s2 = b[s2 + 4 >> 2] | 0;
                  o = Od(r2 | 0, s2 | 0, c4 | 0, d2 | 0) | 0;
                  m = H() | 0;
                  k = i + (o << 3) | 0;
                  n = k;
                  l = b[n >> 2] | 0;
                  n = b[n + 4 >> 2] | 0;
                  c: do {
                    if ((l | 0) == 0 & (n | 0) == 0) {
                      w4 = k;
                      G2 = 16;
                    } else {
                      p2 = 0;
                      q2 = 0;
                      while (1) {
                        if ((p2 | 0) > (d2 | 0) | (p2 | 0) == (d2 | 0) & q2 >>> 0 > c4 >>> 0) {
                          j = 1;
                          break b;
                        }
                        if ((l | 0) == (r2 | 0) & (n | 0) == (s2 | 0)) {
                          break c;
                        }
                        k = Gd(o | 0, m | 0, 1, 0) | 0;
                        o = Nd(k | 0, H() | 0, c4 | 0, d2 | 0) | 0;
                        m = H() | 0;
                        q2 = Gd(q2 | 0, p2 | 0, 1, 0) | 0;
                        p2 = H() | 0;
                        k = i + (o << 3) | 0;
                        n = k;
                        l = b[n >> 2] | 0;
                        n = b[n + 4 >> 2] | 0;
                        if ((l | 0) == 0 & (n | 0) == 0) {
                          w4 = k;
                          G2 = 16;
                          break;
                        }
                      }
                    }
                  } while (0);
                  if ((G2 | 0) == 16 ? (G2 = 0, !((r2 | 0) == 0 & (s2 | 0) == 0)) : 0) {
                    q2 = w4;
                    b[q2 >> 2] = r2;
                    b[q2 + 4 >> 2] = s2;
                    q2 = h + (b[g2 >> 2] << 3) | 0;
                    b[q2 >> 2] = r2;
                    b[q2 + 4 >> 2] = s2;
                    q2 = g2;
                    q2 = Gd(b[q2 >> 2] | 0, b[q2 + 4 >> 2] | 0, 1, 0) | 0;
                    r2 = H() | 0;
                    s2 = g2;
                    b[s2 >> 2] = q2;
                    b[s2 + 4 >> 2] = r2;
                  }
                  t4 = Gd(t4 | 0, u5 | 0, 1, 0) | 0;
                  u5 = H() | 0;
                  k = F;
                  l = b[k >> 2] | 0;
                  k = b[k + 4 >> 2] | 0;
                  if (!((k | 0) > (u5 | 0) | (k | 0) == (u5 | 0) & l >>> 0 > t4 >>> 0)) {
                    l = 1;
                    break a;
                  }
                }
                l = 0;
              } else {
                l = 1;
              }
            } else {
              l = 0;
              j = k;
            }
          } while (0);
          v3 = v3 + 1 | 0;
          if (!l) {
            G2 = 21;
            break;
          }
          k = b[a2 >> 2] | 0;
          if ((v3 | 0) >= (k | 0)) {
            j = 0;
            G2 = 21;
            break;
          }
        }
        if ((G2 | 0) == 21) {
          T2 = I2;
          return j | 0;
        }
        return 0;
      }
      function la(a2, c4, d2, e3) {
        a2 = a2 | 0;
        c4 = c4 | 0;
        d2 = d2 | 0;
        e3 = e3 | 0;
        var f2 = 0, g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p2 = 0, q2 = 0, r2 = 0, s2 = 0, t4 = 0, u5 = 0, v3 = 0, w4 = 0, x2 = 0, y2 = 0, z2 = 0, A6 = 0, B5 = 0, C4 = 0, D4 = 0, E3 = 0, F = 0, G2 = 0, I2 = 0, J2 = 0, K3 = 0;
        K3 = T2;
        T2 = T2 + 112 | 0;
        F = K3 + 80 | 0;
        j = K3 + 72 | 0;
        G2 = K3;
        I2 = K3 + 56 | 0;
        f2 = Xc(d2) | 0;
        if (f2 | 0) {
          J2 = f2;
          T2 = K3;
          return J2 | 0;
        }
        k = a2 + 8 | 0;
        J2 = Dd((b[k >> 2] << 5) + 32 | 0) | 0;
        if (!J2) {
          J2 = 13;
          T2 = K3;
          return J2 | 0;
        }
        Yc(a2, J2);
        f2 = Xc(d2) | 0;
        if (!f2) {
          D4 = a2;
          E3 = b[D4 + 4 >> 2] | 0;
          f2 = j;
          b[f2 >> 2] = b[D4 >> 2];
          b[f2 + 4 >> 2] = E3;
          Wc(j, F);
          f2 = Ha(F, c4, G2) | 0;
          if (!f2) {
            f2 = b[j >> 2] | 0;
            g2 = b[k >> 2] | 0;
            if ((g2 | 0) > 0) {
              h = b[a2 + 12 >> 2] | 0;
              d2 = 0;
              do {
                f2 = (b[h + (d2 << 3) >> 2] | 0) + f2 | 0;
                d2 = d2 + 1 | 0;
              } while ((d2 | 0) != (g2 | 0));
              d2 = f2;
            } else {
              d2 = f2;
            }
            f2 = G2;
            g2 = b[f2 >> 2] | 0;
            f2 = b[f2 + 4 >> 2] | 0;
            h = ((d2 | 0) < 0) << 31 >> 31;
            if ((f2 | 0) < (h | 0) | (f2 | 0) == (h | 0) & g2 >>> 0 < d2 >>> 0) {
              f2 = G2;
              b[f2 >> 2] = d2;
              b[f2 + 4 >> 2] = h;
              f2 = h;
            } else {
              d2 = g2;
            }
            D4 = Gd(d2 | 0, f2 | 0, 12, 0) | 0;
            E3 = H() | 0;
            f2 = G2;
            b[f2 >> 2] = D4;
            b[f2 + 4 >> 2] = E3;
            f2 = 0;
          } else {
            D4 = 0;
            E3 = 0;
          }
          if (!f2) {
            d2 = Fd(D4, 8) | 0;
            if (!d2) {
              Ed(J2);
              J2 = 13;
              T2 = K3;
              return J2 | 0;
            }
            i = Fd(D4, 8) | 0;
            if (!i) {
              Ed(J2);
              Ed(d2);
              J2 = 13;
              T2 = K3;
              return J2 | 0;
            }
            B5 = F;
            b[B5 >> 2] = 0;
            b[B5 + 4 >> 2] = 0;
            B5 = a2;
            C4 = b[B5 + 4 >> 2] | 0;
            f2 = j;
            b[f2 >> 2] = b[B5 >> 2];
            b[f2 + 4 >> 2] = C4;
            f2 = ka(j, D4, E3, c4, F, d2, i) | 0;
            a: do {
              if (!f2) {
                b: do {
                  if ((b[k >> 2] | 0) > 0) {
                    h = a2 + 12 | 0;
                    g2 = 0;
                    while (1) {
                      f2 = ka((b[h >> 2] | 0) + (g2 << 3) | 0, D4, E3, c4, F, d2, i) | 0;
                      g2 = g2 + 1 | 0;
                      if (f2 | 0) {
                        break;
                      }
                      if ((g2 | 0) >= (b[k >> 2] | 0)) {
                        break b;
                      }
                    }
                    Ed(d2);
                    Ed(i);
                    Ed(J2);
                    break a;
                  }
                } while (0);
                if ((E3 | 0) > 0 | (E3 | 0) == 0 & D4 >>> 0 > 0) {
                  Xd(i | 0, 0, D4 << 3 | 0) | 0;
                }
                C4 = F;
                B5 = b[C4 + 4 >> 2] | 0;
                c: do {
                  if ((B5 | 0) > 0 | (B5 | 0) == 0 & (b[C4 >> 2] | 0) >>> 0 > 0) {
                    y2 = d2;
                    z2 = i;
                    A6 = d2;
                    B5 = i;
                    C4 = d2;
                    f2 = d2;
                    v3 = d2;
                    w4 = i;
                    x2 = i;
                    d2 = i;
                    d: while (1) {
                      r2 = 0;
                      s2 = 0;
                      t4 = 0;
                      u5 = 0;
                      g2 = 0;
                      h = 0;
                      while (1) {
                        i = G2;
                        j = i + 56 | 0;
                        do {
                          b[i >> 2] = 0;
                          i = i + 4 | 0;
                        } while ((i | 0) < (j | 0));
                        c4 = y2 + (r2 << 3) | 0;
                        k = b[c4 >> 2] | 0;
                        c4 = b[c4 + 4 >> 2] | 0;
                        if (ca3(k, c4, 1, G2, 0) | 0) {
                          i = G2;
                          j = i + 56 | 0;
                          do {
                            b[i >> 2] = 0;
                            i = i + 4 | 0;
                          } while ((i | 0) < (j | 0));
                          i = Fd(7, 4) | 0;
                          if (i | 0) {
                            da2(k, c4, 1, G2, i, 7, 0, 0) | 0;
                            Ed(i);
                          }
                        }
                        q2 = 0;
                        while (1) {
                          p2 = G2 + (q2 << 3) | 0;
                          o = b[p2 >> 2] | 0;
                          p2 = b[p2 + 4 >> 2] | 0;
                          e: do {
                            if ((o | 0) == 0 & (p2 | 0) == 0) {
                              i = g2;
                              j = h;
                            } else {
                              l = Od(o | 0, p2 | 0, D4 | 0, E3 | 0) | 0;
                              k = H() | 0;
                              i = e3 + (l << 3) | 0;
                              c4 = i;
                              j = b[c4 >> 2] | 0;
                              c4 = b[c4 + 4 >> 2] | 0;
                              if (!((j | 0) == 0 & (c4 | 0) == 0)) {
                                m = 0;
                                n = 0;
                                do {
                                  if ((m | 0) > (E3 | 0) | (m | 0) == (E3 | 0) & n >>> 0 > D4 >>> 0) {
                                    break d;
                                  }
                                  if ((j | 0) == (o | 0) & (c4 | 0) == (p2 | 0)) {
                                    i = g2;
                                    j = h;
                                    break e;
                                  }
                                  i = Gd(l | 0, k | 0, 1, 0) | 0;
                                  l = Nd(i | 0, H() | 0, D4 | 0, E3 | 0) | 0;
                                  k = H() | 0;
                                  n = Gd(n | 0, m | 0, 1, 0) | 0;
                                  m = H() | 0;
                                  i = e3 + (l << 3) | 0;
                                  c4 = i;
                                  j = b[c4 >> 2] | 0;
                                  c4 = b[c4 + 4 >> 2] | 0;
                                } while (!((j | 0) == 0 & (c4 | 0) == 0));
                              }
                              if ((o | 0) == 0 & (p2 | 0) == 0) {
                                i = g2;
                                j = h;
                                break;
                              }
                              Zb(o, p2, I2) | 0;
                              if (Zc(a2, J2, I2) | 0) {
                                n = Gd(g2 | 0, h | 0, 1, 0) | 0;
                                h = H() | 0;
                                m = i;
                                b[m >> 2] = o;
                                b[m + 4 >> 2] = p2;
                                g2 = z2 + (g2 << 3) | 0;
                                b[g2 >> 2] = o;
                                b[g2 + 4 >> 2] = p2;
                                g2 = n;
                              }
                              i = g2;
                              j = h;
                            }
                          } while (0);
                          q2 = q2 + 1 | 0;
                          if (q2 >>> 0 >= 7) {
                            break;
                          } else {
                            g2 = i;
                            h = j;
                          }
                        }
                        r2 = Gd(r2 | 0, s2 | 0, 1, 0) | 0;
                        s2 = H() | 0;
                        t4 = Gd(t4 | 0, u5 | 0, 1, 0) | 0;
                        u5 = H() | 0;
                        h = F;
                        g2 = b[h >> 2] | 0;
                        h = b[h + 4 >> 2] | 0;
                        if (!((u5 | 0) < (h | 0) | (u5 | 0) == (h | 0) & t4 >>> 0 < g2 >>> 0)) {
                          break;
                        } else {
                          g2 = i;
                          h = j;
                        }
                      }
                      if ((h | 0) > 0 | (h | 0) == 0 & g2 >>> 0 > 0) {
                        g2 = 0;
                        h = 0;
                        do {
                          u5 = y2 + (g2 << 3) | 0;
                          b[u5 >> 2] = 0;
                          b[u5 + 4 >> 2] = 0;
                          g2 = Gd(g2 | 0, h | 0, 1, 0) | 0;
                          h = H() | 0;
                          u5 = F;
                          t4 = b[u5 + 4 >> 2] | 0;
                        } while ((h | 0) < (t4 | 0) | ((h | 0) == (t4 | 0) ? g2 >>> 0 < (b[u5 >> 2] | 0) >>> 0 : 0));
                      }
                      u5 = F;
                      b[u5 >> 2] = i;
                      b[u5 + 4 >> 2] = j;
                      if ((j | 0) > 0 | (j | 0) == 0 & i >>> 0 > 0) {
                        q2 = d2;
                        r2 = x2;
                        s2 = C4;
                        t4 = w4;
                        u5 = z2;
                        d2 = v3;
                        x2 = f2;
                        w4 = A6;
                        v3 = q2;
                        f2 = r2;
                        C4 = B5;
                        B5 = s2;
                        A6 = t4;
                        z2 = y2;
                        y2 = u5;
                      } else {
                        break c;
                      }
                    }
                    Ed(A6);
                    Ed(B5);
                    Ed(J2);
                    f2 = 1;
                    break a;
                  } else {
                    f2 = i;
                  }
                } while (0);
                Ed(J2);
                Ed(d2);
                Ed(f2);
                f2 = 0;
              } else {
                Ed(d2);
                Ed(i);
                Ed(J2);
              }
            } while (0);
            J2 = f2;
            T2 = K3;
            return J2 | 0;
          }
        }
        Ed(J2);
        J2 = f2;
        T2 = K3;
        return J2 | 0;
      }
      function ma(a2, c4, d2) {
        a2 = a2 | 0;
        c4 = c4 | 0;
        d2 = d2 | 0;
        var e3 = 0, f2 = 0, g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0;
        l = T2;
        T2 = T2 + 176 | 0;
        j = l;
        if ((c4 | 0) < 1) {
          ud(d2, 0, 0);
          k = 0;
          T2 = l;
          return k | 0;
        }
        i = a2;
        i = Qd(b[i >> 2] | 0, b[i + 4 >> 2] | 0, 52) | 0;
        H() | 0;
        ud(d2, (c4 | 0) > 6 ? c4 : 6, i & 15);
        i = 0;
        while (1) {
          e3 = a2 + (i << 3) | 0;
          e3 = _b2(b[e3 >> 2] | 0, b[e3 + 4 >> 2] | 0, j) | 0;
          if (e3 | 0) {
            break;
          }
          e3 = b[j >> 2] | 0;
          if ((e3 | 0) > 0) {
            h = 0;
            do {
              g2 = j + 8 + (h << 4) | 0;
              h = h + 1 | 0;
              e3 = j + 8 + (((h | 0) % (e3 | 0) | 0) << 4) | 0;
              f2 = zd(d2, e3, g2) | 0;
              if (!f2) {
                yd(d2, g2, e3) | 0;
              } else {
                xd(d2, f2) | 0;
              }
              e3 = b[j >> 2] | 0;
            } while ((h | 0) < (e3 | 0));
          }
          i = i + 1 | 0;
          if ((i | 0) >= (c4 | 0)) {
            e3 = 0;
            k = 13;
            break;
          }
        }
        if ((k | 0) == 13) {
          T2 = l;
          return e3 | 0;
        }
        vd(d2);
        k = e3;
        T2 = l;
        return k | 0;
      }
      function na(a2, c4, d2) {
        a2 = a2 | 0;
        c4 = c4 | 0;
        d2 = d2 | 0;
        var e3 = 0, f2 = 0, g2 = 0, h = 0;
        g2 = T2;
        T2 = T2 + 32 | 0;
        e3 = g2;
        f2 = g2 + 16 | 0;
        a2 = ma(a2, c4, f2) | 0;
        if (a2 | 0) {
          d2 = a2;
          T2 = g2;
          return d2 | 0;
        }
        b[d2 >> 2] = 0;
        b[d2 + 4 >> 2] = 0;
        b[d2 + 8 >> 2] = 0;
        a2 = wd(f2) | 0;
        if (a2 | 0) {
          do {
            c4 = Cc(d2) | 0;
            do {
              Dc(c4, a2) | 0;
              h = a2 + 16 | 0;
              b[e3 >> 2] = b[h >> 2];
              b[e3 + 4 >> 2] = b[h + 4 >> 2];
              b[e3 + 8 >> 2] = b[h + 8 >> 2];
              b[e3 + 12 >> 2] = b[h + 12 >> 2];
              xd(f2, a2) | 0;
              a2 = Ad(f2, e3) | 0;
            } while ((a2 | 0) != 0);
            a2 = wd(f2) | 0;
          } while ((a2 | 0) != 0);
        }
        vd(f2);
        a2 = Fc(d2) | 0;
        if (!a2) {
          h = 0;
          T2 = g2;
          return h | 0;
        }
        Ec(d2);
        h = a2;
        T2 = g2;
        return h | 0;
      }
      function oa(a2) {
        a2 = a2 | 0;
        if (a2 >>> 0 > 121) {
          a2 = 0;
          return a2 | 0;
        }
        a2 = b[7696 + (a2 * 28 | 0) + 16 >> 2] | 0;
        return a2 | 0;
      }
      function pa(a2) {
        a2 = a2 | 0;
        return (a2 | 0) == 4 | (a2 | 0) == 117 | 0;
      }
      function qa(a2) {
        a2 = a2 | 0;
        return b[11120 + ((b[a2 >> 2] | 0) * 216 | 0) + ((b[a2 + 4 >> 2] | 0) * 72 | 0) + ((b[a2 + 8 >> 2] | 0) * 24 | 0) + (b[a2 + 12 >> 2] << 3) >> 2] | 0;
      }
      function ra(a2) {
        a2 = a2 | 0;
        return b[11120 + ((b[a2 >> 2] | 0) * 216 | 0) + ((b[a2 + 4 >> 2] | 0) * 72 | 0) + ((b[a2 + 8 >> 2] | 0) * 24 | 0) + (b[a2 + 12 >> 2] << 3) + 4 >> 2] | 0;
      }
      function sa(a2, c4) {
        a2 = a2 | 0;
        c4 = c4 | 0;
        a2 = 7696 + (a2 * 28 | 0) | 0;
        b[c4 >> 2] = b[a2 >> 2];
        b[c4 + 4 >> 2] = b[a2 + 4 >> 2];
        b[c4 + 8 >> 2] = b[a2 + 8 >> 2];
        b[c4 + 12 >> 2] = b[a2 + 12 >> 2];
        return;
      }
      function ta(a2, c4) {
        a2 = a2 | 0;
        c4 = c4 | 0;
        var d2 = 0, e3 = 0;
        if (c4 >>> 0 > 20) {
          c4 = -1;
          return c4 | 0;
        }
        do {
          if ((b[11120 + (c4 * 216 | 0) >> 2] | 0) != (a2 | 0)) {
            if ((b[11120 + (c4 * 216 | 0) + 8 >> 2] | 0) != (a2 | 0)) {
              if ((b[11120 + (c4 * 216 | 0) + 16 >> 2] | 0) != (a2 | 0)) {
                if ((b[11120 + (c4 * 216 | 0) + 24 >> 2] | 0) != (a2 | 0)) {
                  if ((b[11120 + (c4 * 216 | 0) + 32 >> 2] | 0) != (a2 | 0)) {
                    if ((b[11120 + (c4 * 216 | 0) + 40 >> 2] | 0) != (a2 | 0)) {
                      if ((b[11120 + (c4 * 216 | 0) + 48 >> 2] | 0) != (a2 | 0)) {
                        if ((b[11120 + (c4 * 216 | 0) + 56 >> 2] | 0) != (a2 | 0)) {
                          if ((b[11120 + (c4 * 216 | 0) + 64 >> 2] | 0) != (a2 | 0)) {
                            if ((b[11120 + (c4 * 216 | 0) + 72 >> 2] | 0) != (a2 | 0)) {
                              if ((b[11120 + (c4 * 216 | 0) + 80 >> 2] | 0) != (a2 | 0)) {
                                if ((b[11120 + (c4 * 216 | 0) + 88 >> 2] | 0) != (a2 | 0)) {
                                  if ((b[11120 + (c4 * 216 | 0) + 96 >> 2] | 0) != (a2 | 0)) {
                                    if ((b[11120 + (c4 * 216 | 0) + 104 >> 2] | 0) != (a2 | 0)) {
                                      if ((b[11120 + (c4 * 216 | 0) + 112 >> 2] | 0) != (a2 | 0)) {
                                        if ((b[11120 + (c4 * 216 | 0) + 120 >> 2] | 0) != (a2 | 0)) {
                                          if ((b[11120 + (c4 * 216 | 0) + 128 >> 2] | 0) != (a2 | 0)) {
                                            if ((b[11120 + (c4 * 216 | 0) + 136 >> 2] | 0) == (a2 | 0)) {
                                              a2 = 2;
                                              d2 = 1;
                                              e3 = 2;
                                            } else {
                                              if ((b[11120 + (c4 * 216 | 0) + 144 >> 2] | 0) == (a2 | 0)) {
                                                a2 = 0;
                                                d2 = 2;
                                                e3 = 0;
                                                break;
                                              }
                                              if ((b[11120 + (c4 * 216 | 0) + 152 >> 2] | 0) == (a2 | 0)) {
                                                a2 = 0;
                                                d2 = 2;
                                                e3 = 1;
                                                break;
                                              }
                                              if ((b[11120 + (c4 * 216 | 0) + 160 >> 2] | 0) == (a2 | 0)) {
                                                a2 = 0;
                                                d2 = 2;
                                                e3 = 2;
                                                break;
                                              }
                                              if ((b[11120 + (c4 * 216 | 0) + 168 >> 2] | 0) == (a2 | 0)) {
                                                a2 = 1;
                                                d2 = 2;
                                                e3 = 0;
                                                break;
                                              }
                                              if ((b[11120 + (c4 * 216 | 0) + 176 >> 2] | 0) == (a2 | 0)) {
                                                a2 = 1;
                                                d2 = 2;
                                                e3 = 1;
                                                break;
                                              }
                                              if ((b[11120 + (c4 * 216 | 0) + 184 >> 2] | 0) == (a2 | 0)) {
                                                a2 = 1;
                                                d2 = 2;
                                                e3 = 2;
                                                break;
                                              }
                                              if ((b[11120 + (c4 * 216 | 0) + 192 >> 2] | 0) == (a2 | 0)) {
                                                a2 = 2;
                                                d2 = 2;
                                                e3 = 0;
                                                break;
                                              }
                                              if ((b[11120 + (c4 * 216 | 0) + 200 >> 2] | 0) == (a2 | 0)) {
                                                a2 = 2;
                                                d2 = 2;
                                                e3 = 1;
                                                break;
                                              }
                                              if ((b[11120 + (c4 * 216 | 0) + 208 >> 2] | 0) == (a2 | 0)) {
                                                a2 = 2;
                                                d2 = 2;
                                                e3 = 2;
                                                break;
                                              } else {
                                                a2 = -1;
                                              }
                                              return a2 | 0;
                                            }
                                          } else {
                                            a2 = 2;
                                            d2 = 1;
                                            e3 = 1;
                                          }
                                        } else {
                                          a2 = 2;
                                          d2 = 1;
                                          e3 = 0;
                                        }
                                      } else {
                                        a2 = 1;
                                        d2 = 1;
                                        e3 = 2;
                                      }
                                    } else {
                                      a2 = 1;
                                      d2 = 1;
                                      e3 = 1;
                                    }
                                  } else {
                                    a2 = 1;
                                    d2 = 1;
                                    e3 = 0;
                                  }
                                } else {
                                  a2 = 0;
                                  d2 = 1;
                                  e3 = 2;
                                }
                              } else {
                                a2 = 0;
                                d2 = 1;
                                e3 = 1;
                              }
                            } else {
                              a2 = 0;
                              d2 = 1;
                              e3 = 0;
                            }
                          } else {
                            a2 = 2;
                            d2 = 0;
                            e3 = 2;
                          }
                        } else {
                          a2 = 2;
                          d2 = 0;
                          e3 = 1;
                        }
                      } else {
                        a2 = 2;
                        d2 = 0;
                        e3 = 0;
                      }
                    } else {
                      a2 = 1;
                      d2 = 0;
                      e3 = 2;
                    }
                  } else {
                    a2 = 1;
                    d2 = 0;
                    e3 = 1;
                  }
                } else {
                  a2 = 1;
                  d2 = 0;
                  e3 = 0;
                }
              } else {
                a2 = 0;
                d2 = 0;
                e3 = 2;
              }
            } else {
              a2 = 0;
              d2 = 0;
              e3 = 1;
            }
          } else {
            a2 = 0;
            d2 = 0;
            e3 = 0;
          }
        } while (0);
        c4 = b[11120 + (c4 * 216 | 0) + (d2 * 72 | 0) + (a2 * 24 | 0) + (e3 << 3) + 4 >> 2] | 0;
        return c4 | 0;
      }
      function ua(a2, c4) {
        a2 = a2 | 0;
        c4 = c4 | 0;
        if ((b[7696 + (a2 * 28 | 0) + 20 >> 2] | 0) == (c4 | 0)) {
          c4 = 1;
          return c4 | 0;
        }
        c4 = (b[7696 + (a2 * 28 | 0) + 24 >> 2] | 0) == (c4 | 0);
        return c4 | 0;
      }
      function va(a2, c4) {
        a2 = a2 | 0;
        c4 = c4 | 0;
        return b[848 + (a2 * 28 | 0) + (c4 << 2) >> 2] | 0;
      }
      function wa(a2, c4) {
        a2 = a2 | 0;
        c4 = c4 | 0;
        if ((b[848 + (a2 * 28 | 0) >> 2] | 0) == (c4 | 0)) {
          c4 = 0;
          return c4 | 0;
        }
        if ((b[848 + (a2 * 28 | 0) + 4 >> 2] | 0) == (c4 | 0)) {
          c4 = 1;
          return c4 | 0;
        }
        if ((b[848 + (a2 * 28 | 0) + 8 >> 2] | 0) == (c4 | 0)) {
          c4 = 2;
          return c4 | 0;
        }
        if ((b[848 + (a2 * 28 | 0) + 12 >> 2] | 0) == (c4 | 0)) {
          c4 = 3;
          return c4 | 0;
        }
        if ((b[848 + (a2 * 28 | 0) + 16 >> 2] | 0) == (c4 | 0)) {
          c4 = 4;
          return c4 | 0;
        }
        if ((b[848 + (a2 * 28 | 0) + 20 >> 2] | 0) == (c4 | 0)) {
          c4 = 5;
          return c4 | 0;
        } else {
          return ((b[848 + (a2 * 28 | 0) + 24 >> 2] | 0) == (c4 | 0) ? 6 : 7) | 0;
        }
        return 0;
      }
      function xa() {
        return 122;
      }
      function ya(a2) {
        a2 = a2 | 0;
        var c4 = 0, d2 = 0, e3 = 0;
        c4 = 0;
        do {
          Rd(c4 | 0, 0, 45) | 0;
          e3 = H() | 0 | 134225919;
          d2 = a2 + (c4 << 3) | 0;
          b[d2 >> 2] = -1;
          b[d2 + 4 >> 2] = e3;
          c4 = c4 + 1 | 0;
        } while ((c4 | 0) != 122);
        return 0;
      }
      function za(a2) {
        a2 = a2 | 0;
        var b2 = 0, c4 = 0, d2 = 0;
        d2 = +e[a2 + 16 >> 3];
        c4 = +e[a2 + 24 >> 3];
        b2 = d2 - c4;
        return +(d2 < c4 ? b2 + 6.283185307179586 : b2);
      }
      function Aa(a2) {
        a2 = a2 | 0;
        return +e[a2 + 16 >> 3] < +e[a2 + 24 >> 3] | 0;
      }
      function Ba(a2) {
        a2 = a2 | 0;
        return +(+e[a2 >> 3] - +e[a2 + 8 >> 3]);
      }
      function Ca(a2, b2) {
        a2 = a2 | 0;
        b2 = b2 | 0;
        var c4 = 0, d2 = 0, f2 = 0;
        c4 = +e[b2 >> 3];
        if (!(c4 >= +e[a2 + 8 >> 3])) {
          b2 = 0;
          return b2 | 0;
        }
        if (!(c4 <= +e[a2 >> 3])) {
          b2 = 0;
          return b2 | 0;
        }
        d2 = +e[a2 + 16 >> 3];
        c4 = +e[a2 + 24 >> 3];
        f2 = +e[b2 + 8 >> 3];
        b2 = f2 >= c4;
        a2 = f2 <= d2 & 1;
        if (d2 < c4) {
          if (b2) {
            a2 = 1;
          }
        } else if (!b2) {
          a2 = 0;
        }
        b2 = (a2 | 0) != 0;
        return b2 | 0;
      }
      function Da(a2, b2) {
        a2 = a2 | 0;
        b2 = b2 | 0;
        var c4 = 0, d2 = 0, f2 = 0, g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0;
        if (+e[a2 >> 3] < +e[b2 + 8 >> 3]) {
          d2 = 0;
          return d2 | 0;
        }
        if (+e[a2 + 8 >> 3] > +e[b2 >> 3]) {
          d2 = 0;
          return d2 | 0;
        }
        g2 = +e[a2 + 16 >> 3];
        c4 = a2 + 24 | 0;
        l = +e[c4 >> 3];
        h = g2 < l;
        d2 = b2 + 16 | 0;
        k = +e[d2 >> 3];
        f2 = b2 + 24 | 0;
        j = +e[f2 >> 3];
        i = k < j;
        b2 = l - k < j - g2;
        a2 = h ? i | b2 ? 1 : 2 : 0;
        b2 = i ? h ? 1 : b2 ? 2 : 1 : 0;
        g2 = +kc(g2, a2);
        if (g2 < +kc(+e[f2 >> 3], b2)) {
          i = 0;
          return i | 0;
        }
        l = +kc(+e[c4 >> 3], a2);
        if (l > +kc(+e[d2 >> 3], b2)) {
          i = 0;
          return i | 0;
        }
        i = 1;
        return i | 0;
      }
      function Ea(a2, c4, d2, f2) {
        a2 = a2 | 0;
        c4 = c4 | 0;
        d2 = d2 | 0;
        f2 = f2 | 0;
        var g2 = 0, h = 0, i = 0, j = 0, k = 0;
        h = +e[a2 + 16 >> 3];
        k = +e[a2 + 24 >> 3];
        a2 = h < k;
        j = +e[c4 + 16 >> 3];
        i = +e[c4 + 24 >> 3];
        g2 = j < i;
        c4 = k - j < i - h;
        b[d2 >> 2] = a2 ? g2 | c4 ? 1 : 2 : 0;
        b[f2 >> 2] = g2 ? a2 ? 1 : c4 ? 2 : 1 : 0;
        return;
      }
      function Fa(a2, b2) {
        a2 = a2 | 0;
        b2 = b2 | 0;
        var c4 = 0, d2 = 0, f2 = 0, g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0;
        if (+e[a2 >> 3] < +e[b2 >> 3]) {
          d2 = 0;
          return d2 | 0;
        }
        if (+e[a2 + 8 >> 3] > +e[b2 + 8 >> 3]) {
          d2 = 0;
          return d2 | 0;
        }
        d2 = a2 + 16 | 0;
        j = +e[d2 >> 3];
        g2 = +e[a2 + 24 >> 3];
        h = j < g2;
        c4 = b2 + 16 | 0;
        l = +e[c4 >> 3];
        f2 = b2 + 24 | 0;
        k = +e[f2 >> 3];
        i = l < k;
        b2 = g2 - l < k - j;
        a2 = h ? i | b2 ? 1 : 2 : 0;
        b2 = i ? h ? 1 : b2 ? 2 : 1 : 0;
        g2 = +kc(g2, a2);
        if (!(g2 <= +kc(+e[f2 >> 3], b2))) {
          i = 0;
          return i | 0;
        }
        l = +kc(+e[d2 >> 3], a2);
        i = l >= +kc(+e[c4 >> 3], b2);
        return i | 0;
      }
      function Ga(a2, c4) {
        a2 = a2 | 0;
        c4 = c4 | 0;
        var d2 = 0, f2 = 0, g2 = 0, h = 0, i = 0, j = 0;
        g2 = T2;
        T2 = T2 + 176 | 0;
        f2 = g2;
        b[f2 >> 2] = 4;
        j = +e[c4 >> 3];
        e[f2 + 8 >> 3] = j;
        h = +e[c4 + 16 >> 3];
        e[f2 + 16 >> 3] = h;
        e[f2 + 24 >> 3] = j;
        j = +e[c4 + 24 >> 3];
        e[f2 + 32 >> 3] = j;
        i = +e[c4 + 8 >> 3];
        e[f2 + 40 >> 3] = i;
        e[f2 + 48 >> 3] = j;
        e[f2 + 56 >> 3] = i;
        e[f2 + 64 >> 3] = h;
        c4 = f2 + 72 | 0;
        d2 = c4 + 96 | 0;
        do {
          b[c4 >> 2] = 0;
          c4 = c4 + 4 | 0;
        } while ((c4 | 0) < (d2 | 0));
        Wd(a2 | 0, f2 | 0, 168) | 0;
        T2 = g2;
        return;
      }
      function Ha(a2, c4, d2) {
        a2 = a2 | 0;
        c4 = c4 | 0;
        d2 = d2 | 0;
        var g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, r2 = 0, s2 = 0, t4 = 0, u5 = 0, v3 = 0;
        t4 = T2;
        T2 = T2 + 288 | 0;
        n = t4 + 264 | 0;
        o = t4 + 96 | 0;
        m = t4;
        k = m;
        l = k + 96 | 0;
        do {
          b[k >> 2] = 0;
          k = k + 4 | 0;
        } while ((k | 0) < (l | 0));
        c4 = cc2(c4, m) | 0;
        if (c4 | 0) {
          s2 = c4;
          T2 = t4;
          return s2 | 0;
        }
        l = m;
        m = b[l >> 2] | 0;
        l = b[l + 4 >> 2] | 0;
        Zb(m, l, n) | 0;
        _b2(m, l, o) | 0;
        j = +mc(n, o + 8 | 0);
        e[n >> 3] = +e[a2 >> 3];
        l = n + 8 | 0;
        e[l >> 3] = +e[a2 + 16 >> 3];
        e[o >> 3] = +e[a2 + 8 >> 3];
        m = o + 8 | 0;
        e[m >> 3] = +e[a2 + 24 >> 3];
        h = +mc(n, o);
        v3 = +e[l >> 3] - +e[m >> 3];
        i = +q(+v3);
        u5 = +e[n >> 3] - +e[o >> 3];
        g2 = +q(+u5);
        if (!(v3 == 0 | u5 == 0) ? (v3 = +Td(+i, +g2), v3 = +A5(+(h * h / +Ud(+(v3 / +Ud(+i, +g2)), 3) / (j * (j * 2.59807621135) * 0.8))), e[f >> 3] = v3, r2 = ~~v3 >>> 0, s2 = +q(v3) >= 1 ? v3 > 0 ? ~~+C3(+p(v3 / 4294967296), 4294967295) >>> 0 : ~~+A5((v3 - +(~~v3 >>> 0)) / 4294967296) >>> 0 : 0, !((b[f + 4 >> 2] & 2146435072 | 0) == 2146435072)) : 0) {
          o = (r2 | 0) == 0 & (s2 | 0) == 0;
          c4 = d2;
          b[c4 >> 2] = o ? 1 : r2;
          b[c4 + 4 >> 2] = o ? 0 : s2;
          c4 = 0;
        } else {
          c4 = 1;
        }
        s2 = c4;
        T2 = t4;
        return s2 | 0;
      }
      function Ia(a2, c4, d2, g2) {
        a2 = a2 | 0;
        c4 = c4 | 0;
        d2 = d2 | 0;
        g2 = g2 | 0;
        var h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0;
        m = T2;
        T2 = T2 + 288 | 0;
        j = m + 264 | 0;
        k = m + 96 | 0;
        l = m;
        h = l;
        i = h + 96 | 0;
        do {
          b[h >> 2] = 0;
          h = h + 4 | 0;
        } while ((h | 0) < (i | 0));
        d2 = cc2(d2, l) | 0;
        if (d2 | 0) {
          g2 = d2;
          T2 = m;
          return g2 | 0;
        }
        d2 = l;
        h = b[d2 >> 2] | 0;
        d2 = b[d2 + 4 >> 2] | 0;
        Zb(h, d2, j) | 0;
        _b2(h, d2, k) | 0;
        n = +mc(j, k + 8 | 0);
        n = +A5(+(+mc(a2, c4) / (n * 2)));
        e[f >> 3] = n;
        d2 = ~~n >>> 0;
        h = +q(n) >= 1 ? n > 0 ? ~~+C3(+p(n / 4294967296), 4294967295) >>> 0 : ~~+A5((n - +(~~n >>> 0)) / 4294967296) >>> 0 : 0;
        if ((b[f + 4 >> 2] & 2146435072 | 0) == 2146435072) {
          g2 = 1;
          T2 = m;
          return g2 | 0;
        }
        l = (d2 | 0) == 0 & (h | 0) == 0;
        b[g2 >> 2] = l ? 1 : d2;
        b[g2 + 4 >> 2] = l ? 0 : h;
        g2 = 0;
        T2 = m;
        return g2 | 0;
      }
      function Ja(a2, b2) {
        a2 = a2 | 0;
        b2 = +b2;
        var c4 = 0, d2 = 0, f2 = 0, g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0;
        g2 = a2 + 16 | 0;
        h = +e[g2 >> 3];
        c4 = a2 + 24 | 0;
        f2 = +e[c4 >> 3];
        d2 = h - f2;
        d2 = h < f2 ? d2 + 6.283185307179586 : d2;
        k = +e[a2 >> 3];
        i = a2 + 8 | 0;
        j = +e[i >> 3];
        l = k - j;
        d2 = (d2 * b2 - d2) * 0.5;
        b2 = (l * b2 - l) * 0.5;
        k = k + b2;
        e[a2 >> 3] = k > 1.5707963267948966 ? 1.5707963267948966 : k;
        b2 = j - b2;
        e[i >> 3] = b2 < -1.5707963267948966 ? -1.5707963267948966 : b2;
        b2 = h + d2;
        b2 = b2 > 3.141592653589793 ? b2 + -6.283185307179586 : b2;
        e[g2 >> 3] = b2 < -3.141592653589793 ? b2 + 6.283185307179586 : b2;
        b2 = f2 - d2;
        b2 = b2 > 3.141592653589793 ? b2 + -6.283185307179586 : b2;
        e[c4 >> 3] = b2 < -3.141592653589793 ? b2 + 6.283185307179586 : b2;
        return;
      }
      function Ka(a2, c4, d2, e3) {
        a2 = a2 | 0;
        c4 = c4 | 0;
        d2 = d2 | 0;
        e3 = e3 | 0;
        b[a2 >> 2] = c4;
        b[a2 + 4 >> 2] = d2;
        b[a2 + 8 >> 2] = e3;
        return;
      }
      function La(a2, c4) {
        a2 = a2 | 0;
        c4 = c4 | 0;
        var d2 = 0, f2 = 0, g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0;
        n = c4 + 8 | 0;
        b[n >> 2] = 0;
        k = +e[a2 >> 3];
        i = +q(+k);
        l = +e[a2 + 8 >> 3];
        j = +q(+l) * 1.1547005383792515;
        i = i + j * 0.5;
        d2 = ~~i;
        a2 = ~~j;
        i = i - +(d2 | 0);
        j = j - +(a2 | 0);
        do {
          if (i < 0.5) {
            if (i < 0.3333333333333333) {
              b[c4 >> 2] = d2;
              if (j < (i + 1) * 0.5) {
                b[c4 + 4 >> 2] = a2;
                break;
              } else {
                a2 = a2 + 1 | 0;
                b[c4 + 4 >> 2] = a2;
                break;
              }
            } else {
              o = 1 - i;
              a2 = (!(j < o) & 1) + a2 | 0;
              b[c4 + 4 >> 2] = a2;
              if (o <= j & j < i * 2) {
                d2 = d2 + 1 | 0;
                b[c4 >> 2] = d2;
                break;
              } else {
                b[c4 >> 2] = d2;
                break;
              }
            }
          } else {
            if (!(i < 0.6666666666666666)) {
              d2 = d2 + 1 | 0;
              b[c4 >> 2] = d2;
              if (j < i * 0.5) {
                b[c4 + 4 >> 2] = a2;
                break;
              } else {
                a2 = a2 + 1 | 0;
                b[c4 + 4 >> 2] = a2;
                break;
              }
            }
            if (j < 1 - i) {
              b[c4 + 4 >> 2] = a2;
              if (i * 2 + -1 < j) {
                b[c4 >> 2] = d2;
                break;
              }
            } else {
              a2 = a2 + 1 | 0;
              b[c4 + 4 >> 2] = a2;
            }
            d2 = d2 + 1 | 0;
            b[c4 >> 2] = d2;
          }
        } while (0);
        do {
          if (k < 0) {
            if (!(a2 & 1)) {
              m = (a2 | 0) / 2 | 0;
              m = Hd(d2 | 0, ((d2 | 0) < 0) << 31 >> 31 | 0, m | 0, ((m | 0) < 0) << 31 >> 31 | 0) | 0;
              d2 = ~~(+(d2 | 0) - (+(m >>> 0) + 4294967296 * +(H() | 0)) * 2);
              b[c4 >> 2] = d2;
              break;
            } else {
              m = (a2 + 1 | 0) / 2 | 0;
              m = Hd(d2 | 0, ((d2 | 0) < 0) << 31 >> 31 | 0, m | 0, ((m | 0) < 0) << 31 >> 31 | 0) | 0;
              d2 = ~~(+(d2 | 0) - ((+(m >>> 0) + 4294967296 * +(H() | 0)) * 2 + 1));
              b[c4 >> 2] = d2;
              break;
            }
          }
        } while (0);
        m = c4 + 4 | 0;
        if (l < 0) {
          d2 = d2 - ((a2 << 1 | 1 | 0) / 2 | 0) | 0;
          b[c4 >> 2] = d2;
          a2 = 0 - a2 | 0;
          b[m >> 2] = a2;
        }
        f2 = a2 - d2 | 0;
        if ((d2 | 0) < 0) {
          g2 = 0 - d2 | 0;
          b[m >> 2] = f2;
          b[n >> 2] = g2;
          b[c4 >> 2] = 0;
          a2 = f2;
          d2 = 0;
        } else {
          g2 = 0;
        }
        if ((a2 | 0) < 0) {
          d2 = d2 - a2 | 0;
          b[c4 >> 2] = d2;
          g2 = g2 - a2 | 0;
          b[n >> 2] = g2;
          b[m >> 2] = 0;
          a2 = 0;
        }
        h = d2 - g2 | 0;
        f2 = a2 - g2 | 0;
        if ((g2 | 0) < 0) {
          b[c4 >> 2] = h;
          b[m >> 2] = f2;
          b[n >> 2] = 0;
          a2 = f2;
          d2 = h;
          g2 = 0;
        }
        f2 = (a2 | 0) < (d2 | 0) ? a2 : d2;
        f2 = (g2 | 0) < (f2 | 0) ? g2 : f2;
        if ((f2 | 0) <= 0) {
          return;
        }
        b[c4 >> 2] = d2 - f2;
        b[m >> 2] = a2 - f2;
        b[n >> 2] = g2 - f2;
        return;
      }
      function Ma(a2) {
        a2 = a2 | 0;
        var c4 = 0, d2 = 0, e3 = 0, f2 = 0, g2 = 0, h = 0;
        c4 = b[a2 >> 2] | 0;
        h = a2 + 4 | 0;
        d2 = b[h >> 2] | 0;
        if ((c4 | 0) < 0) {
          d2 = d2 - c4 | 0;
          b[h >> 2] = d2;
          g2 = a2 + 8 | 0;
          b[g2 >> 2] = (b[g2 >> 2] | 0) - c4;
          b[a2 >> 2] = 0;
          c4 = 0;
        }
        if ((d2 | 0) < 0) {
          c4 = c4 - d2 | 0;
          b[a2 >> 2] = c4;
          g2 = a2 + 8 | 0;
          f2 = (b[g2 >> 2] | 0) - d2 | 0;
          b[g2 >> 2] = f2;
          b[h >> 2] = 0;
          d2 = 0;
        } else {
          f2 = a2 + 8 | 0;
          g2 = f2;
          f2 = b[f2 >> 2] | 0;
        }
        if ((f2 | 0) < 0) {
          c4 = c4 - f2 | 0;
          b[a2 >> 2] = c4;
          d2 = d2 - f2 | 0;
          b[h >> 2] = d2;
          b[g2 >> 2] = 0;
          f2 = 0;
        }
        e3 = (d2 | 0) < (c4 | 0) ? d2 : c4;
        e3 = (f2 | 0) < (e3 | 0) ? f2 : e3;
        if ((e3 | 0) <= 0) {
          return;
        }
        b[a2 >> 2] = c4 - e3;
        b[h >> 2] = d2 - e3;
        b[g2 >> 2] = f2 - e3;
        return;
      }
      function Na(a2, c4) {
        a2 = a2 | 0;
        c4 = c4 | 0;
        var d2 = 0, f2 = 0;
        f2 = b[a2 + 8 >> 2] | 0;
        d2 = +((b[a2 + 4 >> 2] | 0) - f2 | 0);
        e[c4 >> 3] = +((b[a2 >> 2] | 0) - f2 | 0) - d2 * 0.5;
        e[c4 + 8 >> 3] = d2 * 0.8660254037844386;
        return;
      }
      function Oa(a2, c4, d2) {
        a2 = a2 | 0;
        c4 = c4 | 0;
        d2 = d2 | 0;
        b[d2 >> 2] = (b[c4 >> 2] | 0) + (b[a2 >> 2] | 0);
        b[d2 + 4 >> 2] = (b[c4 + 4 >> 2] | 0) + (b[a2 + 4 >> 2] | 0);
        b[d2 + 8 >> 2] = (b[c4 + 8 >> 2] | 0) + (b[a2 + 8 >> 2] | 0);
        return;
      }
      function Pa(a2, c4, d2) {
        a2 = a2 | 0;
        c4 = c4 | 0;
        d2 = d2 | 0;
        b[d2 >> 2] = (b[a2 >> 2] | 0) - (b[c4 >> 2] | 0);
        b[d2 + 4 >> 2] = (b[a2 + 4 >> 2] | 0) - (b[c4 + 4 >> 2] | 0);
        b[d2 + 8 >> 2] = (b[a2 + 8 >> 2] | 0) - (b[c4 + 8 >> 2] | 0);
        return;
      }
      function Qa(a2, c4) {
        a2 = a2 | 0;
        c4 = c4 | 0;
        var d2 = 0, e3 = 0;
        d2 = B4(b[a2 >> 2] | 0, c4) | 0;
        b[a2 >> 2] = d2;
        d2 = a2 + 4 | 0;
        e3 = B4(b[d2 >> 2] | 0, c4) | 0;
        b[d2 >> 2] = e3;
        a2 = a2 + 8 | 0;
        c4 = B4(b[a2 >> 2] | 0, c4) | 0;
        b[a2 >> 2] = c4;
        return;
      }
      function Ra(a2) {
        a2 = a2 | 0;
        var c4 = 0, d2 = 0, e3 = 0, f2 = 0, g2 = 0, h = 0, i = 0;
        h = b[a2 >> 2] | 0;
        i = (h | 0) < 0;
        e3 = (b[a2 + 4 >> 2] | 0) - (i ? h : 0) | 0;
        g2 = (e3 | 0) < 0;
        f2 = (g2 ? 0 - e3 | 0 : 0) + ((b[a2 + 8 >> 2] | 0) - (i ? h : 0)) | 0;
        d2 = (f2 | 0) < 0;
        a2 = d2 ? 0 : f2;
        c4 = (g2 ? 0 : e3) - (d2 ? f2 : 0) | 0;
        f2 = (i ? 0 : h) - (g2 ? e3 : 0) - (d2 ? f2 : 0) | 0;
        d2 = (c4 | 0) < (f2 | 0) ? c4 : f2;
        d2 = (a2 | 0) < (d2 | 0) ? a2 : d2;
        e3 = (d2 | 0) > 0;
        a2 = a2 - (e3 ? d2 : 0) | 0;
        c4 = c4 - (e3 ? d2 : 0) | 0;
        a: do {
          switch (f2 - (e3 ? d2 : 0) | 0) {
            case 0:
              switch (c4 | 0) {
                case 0: {
                  i = (a2 | 0) == 0 ? 0 : (a2 | 0) == 1 ? 1 : 7;
                  return i | 0;
                }
                case 1: {
                  i = (a2 | 0) == 0 ? 2 : (a2 | 0) == 1 ? 3 : 7;
                  return i | 0;
                }
                default:
                  break a;
              }
            case 1:
              switch (c4 | 0) {
                case 0: {
                  i = (a2 | 0) == 0 ? 4 : (a2 | 0) == 1 ? 5 : 7;
                  return i | 0;
                }
                case 1: {
                  if (!a2) {
                    a2 = 6;
                  } else {
                    break a;
                  }
                  return a2 | 0;
                }
                default:
                  break a;
              }
            default:
          }
        } while (0);
        i = 7;
        return i | 0;
      }
      function Sa(a2) {
        a2 = a2 | 0;
        var c4 = 0, d2 = 0, e3 = 0, f2 = 0, g2 = 0, h = 0, i = 0, j = 0, k = 0;
        j = a2 + 8 | 0;
        h = b[j >> 2] | 0;
        i = (b[a2 >> 2] | 0) - h | 0;
        k = a2 + 4 | 0;
        h = (b[k >> 2] | 0) - h | 0;
        if (i >>> 0 > 715827881 | h >>> 0 > 715827881) {
          e3 = (i | 0) > 0;
          f2 = 2147483647 - i | 0;
          g2 = -2147483648 - i | 0;
          if (e3 ? (f2 | 0) < (i | 0) : (g2 | 0) > (i | 0)) {
            k = 1;
            return k | 0;
          }
          d2 = i << 1;
          if (e3 ? (2147483647 - d2 | 0) < (i | 0) : (-2147483648 - d2 | 0) > (i | 0)) {
            k = 1;
            return k | 0;
          }
          if ((h | 0) > 0 ? (2147483647 - h | 0) < (h | 0) : (-2147483648 - h | 0) > (h | 0)) {
            k = 1;
            return k | 0;
          }
          c4 = i * 3 | 0;
          d2 = h << 1;
          if ((e3 ? (f2 | 0) < (d2 | 0) : (g2 | 0) > (d2 | 0)) ? 1 : (i | 0) > -1 ? (c4 | -2147483648 | 0) >= (h | 0) : (c4 ^ -2147483648 | 0) < (h | 0)) {
            k = 1;
            return k | 0;
          }
        } else {
          d2 = h << 1;
          c4 = i * 3 | 0;
        }
        e3 = Cd(+(c4 - h | 0) * 0.14285714285714285) | 0;
        b[a2 >> 2] = e3;
        f2 = Cd(+(d2 + i | 0) * 0.14285714285714285) | 0;
        b[k >> 2] = f2;
        b[j >> 2] = 0;
        d2 = (f2 | 0) < (e3 | 0);
        c4 = d2 ? e3 : f2;
        d2 = d2 ? f2 : e3;
        if ((d2 | 0) < 0) {
          if ((d2 | 0) == -2147483648 ? 1 : (c4 | 0) > 0 ? (2147483647 - c4 | 0) < (d2 | 0) : (-2147483648 - c4 | 0) > (d2 | 0)) {
            I(27795, 26892, 354, 26903);
          }
          if ((c4 | 0) > -1 ? (c4 | -2147483648 | 0) >= (d2 | 0) : (c4 ^ -2147483648 | 0) < (d2 | 0)) {
            I(27795, 26892, 354, 26903);
          }
        }
        c4 = f2 - e3 | 0;
        if ((e3 | 0) < 0) {
          d2 = 0 - e3 | 0;
          b[k >> 2] = c4;
          b[j >> 2] = d2;
          b[a2 >> 2] = 0;
          e3 = 0;
        } else {
          c4 = f2;
          d2 = 0;
        }
        if ((c4 | 0) < 0) {
          e3 = e3 - c4 | 0;
          b[a2 >> 2] = e3;
          d2 = d2 - c4 | 0;
          b[j >> 2] = d2;
          b[k >> 2] = 0;
          c4 = 0;
        }
        g2 = e3 - d2 | 0;
        f2 = c4 - d2 | 0;
        if ((d2 | 0) < 0) {
          b[a2 >> 2] = g2;
          b[k >> 2] = f2;
          b[j >> 2] = 0;
          c4 = f2;
          f2 = g2;
          d2 = 0;
        } else {
          f2 = e3;
        }
        e3 = (c4 | 0) < (f2 | 0) ? c4 : f2;
        e3 = (d2 | 0) < (e3 | 0) ? d2 : e3;
        if ((e3 | 0) <= 0) {
          k = 0;
          return k | 0;
        }
        b[a2 >> 2] = f2 - e3;
        b[k >> 2] = c4 - e3;
        b[j >> 2] = d2 - e3;
        k = 0;
        return k | 0;
      }
      function Ta(a2) {
        a2 = a2 | 0;
        var c4 = 0, d2 = 0, e3 = 0, f2 = 0, g2 = 0, h = 0, i = 0, j = 0;
        h = a2 + 8 | 0;
        f2 = b[h >> 2] | 0;
        g2 = (b[a2 >> 2] | 0) - f2 | 0;
        i = a2 + 4 | 0;
        f2 = (b[i >> 2] | 0) - f2 | 0;
        if (g2 >>> 0 > 715827881 | f2 >>> 0 > 715827881) {
          d2 = (g2 | 0) > 0;
          if (d2 ? (2147483647 - g2 | 0) < (g2 | 0) : (-2147483648 - g2 | 0) > (g2 | 0)) {
            i = 1;
            return i | 0;
          }
          c4 = g2 << 1;
          e3 = (f2 | 0) > 0;
          if (e3 ? (2147483647 - f2 | 0) < (f2 | 0) : (-2147483648 - f2 | 0) > (f2 | 0)) {
            i = 1;
            return i | 0;
          }
          j = f2 << 1;
          if (e3 ? (2147483647 - j | 0) < (f2 | 0) : (-2147483648 - j | 0) > (f2 | 0)) {
            j = 1;
            return j | 0;
          }
          if (d2 ? (2147483647 - c4 | 0) < (f2 | 0) : (-2147483648 - c4 | 0) > (f2 | 0)) {
            j = 1;
            return j | 0;
          }
          d2 = f2 * 3 | 0;
          if ((f2 | 0) > -1 ? (d2 | -2147483648 | 0) >= (g2 | 0) : (d2 ^ -2147483648 | 0) < (g2 | 0)) {
            j = 1;
            return j | 0;
          }
        } else {
          d2 = f2 * 3 | 0;
          c4 = g2 << 1;
        }
        e3 = Cd(+(c4 + f2 | 0) * 0.14285714285714285) | 0;
        b[a2 >> 2] = e3;
        f2 = Cd(+(d2 - g2 | 0) * 0.14285714285714285) | 0;
        b[i >> 2] = f2;
        b[h >> 2] = 0;
        d2 = (f2 | 0) < (e3 | 0);
        c4 = d2 ? e3 : f2;
        d2 = d2 ? f2 : e3;
        if ((d2 | 0) < 0) {
          if ((d2 | 0) == -2147483648 ? 1 : (c4 | 0) > 0 ? (2147483647 - c4 | 0) < (d2 | 0) : (-2147483648 - c4 | 0) > (d2 | 0)) {
            I(27795, 26892, 402, 26917);
          }
          if ((c4 | 0) > -1 ? (c4 | -2147483648 | 0) >= (d2 | 0) : (c4 ^ -2147483648 | 0) < (d2 | 0)) {
            I(27795, 26892, 402, 26917);
          }
        }
        c4 = f2 - e3 | 0;
        if ((e3 | 0) < 0) {
          d2 = 0 - e3 | 0;
          b[i >> 2] = c4;
          b[h >> 2] = d2;
          b[a2 >> 2] = 0;
          e3 = 0;
        } else {
          c4 = f2;
          d2 = 0;
        }
        if ((c4 | 0) < 0) {
          e3 = e3 - c4 | 0;
          b[a2 >> 2] = e3;
          d2 = d2 - c4 | 0;
          b[h >> 2] = d2;
          b[i >> 2] = 0;
          c4 = 0;
        }
        g2 = e3 - d2 | 0;
        f2 = c4 - d2 | 0;
        if ((d2 | 0) < 0) {
          b[a2 >> 2] = g2;
          b[i >> 2] = f2;
          b[h >> 2] = 0;
          c4 = f2;
          f2 = g2;
          d2 = 0;
        } else {
          f2 = e3;
        }
        e3 = (c4 | 0) < (f2 | 0) ? c4 : f2;
        e3 = (d2 | 0) < (e3 | 0) ? d2 : e3;
        if ((e3 | 0) <= 0) {
          j = 0;
          return j | 0;
        }
        b[a2 >> 2] = f2 - e3;
        b[i >> 2] = c4 - e3;
        b[h >> 2] = d2 - e3;
        j = 0;
        return j | 0;
      }
      function Ua(a2) {
        a2 = a2 | 0;
        var c4 = 0, d2 = 0, e3 = 0, f2 = 0, g2 = 0, h = 0, i = 0;
        h = a2 + 8 | 0;
        d2 = b[h >> 2] | 0;
        c4 = (b[a2 >> 2] | 0) - d2 | 0;
        i = a2 + 4 | 0;
        d2 = (b[i >> 2] | 0) - d2 | 0;
        e3 = Cd(+((c4 * 3 | 0) - d2 | 0) * 0.14285714285714285) | 0;
        b[a2 >> 2] = e3;
        c4 = Cd(+((d2 << 1) + c4 | 0) * 0.14285714285714285) | 0;
        b[i >> 2] = c4;
        b[h >> 2] = 0;
        d2 = c4 - e3 | 0;
        if ((e3 | 0) < 0) {
          g2 = 0 - e3 | 0;
          b[i >> 2] = d2;
          b[h >> 2] = g2;
          b[a2 >> 2] = 0;
          c4 = d2;
          e3 = 0;
          d2 = g2;
        } else {
          d2 = 0;
        }
        if ((c4 | 0) < 0) {
          e3 = e3 - c4 | 0;
          b[a2 >> 2] = e3;
          d2 = d2 - c4 | 0;
          b[h >> 2] = d2;
          b[i >> 2] = 0;
          c4 = 0;
        }
        g2 = e3 - d2 | 0;
        f2 = c4 - d2 | 0;
        if ((d2 | 0) < 0) {
          b[a2 >> 2] = g2;
          b[i >> 2] = f2;
          b[h >> 2] = 0;
          c4 = f2;
          f2 = g2;
          d2 = 0;
        } else {
          f2 = e3;
        }
        e3 = (c4 | 0) < (f2 | 0) ? c4 : f2;
        e3 = (d2 | 0) < (e3 | 0) ? d2 : e3;
        if ((e3 | 0) <= 0) {
          return;
        }
        b[a2 >> 2] = f2 - e3;
        b[i >> 2] = c4 - e3;
        b[h >> 2] = d2 - e3;
        return;
      }
      function Va(a2) {
        a2 = a2 | 0;
        var c4 = 0, d2 = 0, e3 = 0, f2 = 0, g2 = 0, h = 0, i = 0;
        h = a2 + 8 | 0;
        d2 = b[h >> 2] | 0;
        c4 = (b[a2 >> 2] | 0) - d2 | 0;
        i = a2 + 4 | 0;
        d2 = (b[i >> 2] | 0) - d2 | 0;
        e3 = Cd(+((c4 << 1) + d2 | 0) * 0.14285714285714285) | 0;
        b[a2 >> 2] = e3;
        c4 = Cd(+((d2 * 3 | 0) - c4 | 0) * 0.14285714285714285) | 0;
        b[i >> 2] = c4;
        b[h >> 2] = 0;
        d2 = c4 - e3 | 0;
        if ((e3 | 0) < 0) {
          g2 = 0 - e3 | 0;
          b[i >> 2] = d2;
          b[h >> 2] = g2;
          b[a2 >> 2] = 0;
          c4 = d2;
          e3 = 0;
          d2 = g2;
        } else {
          d2 = 0;
        }
        if ((c4 | 0) < 0) {
          e3 = e3 - c4 | 0;
          b[a2 >> 2] = e3;
          d2 = d2 - c4 | 0;
          b[h >> 2] = d2;
          b[i >> 2] = 0;
          c4 = 0;
        }
        g2 = e3 - d2 | 0;
        f2 = c4 - d2 | 0;
        if ((d2 | 0) < 0) {
          b[a2 >> 2] = g2;
          b[i >> 2] = f2;
          b[h >> 2] = 0;
          c4 = f2;
          f2 = g2;
          d2 = 0;
        } else {
          f2 = e3;
        }
        e3 = (c4 | 0) < (f2 | 0) ? c4 : f2;
        e3 = (d2 | 0) < (e3 | 0) ? d2 : e3;
        if ((e3 | 0) <= 0) {
          return;
        }
        b[a2 >> 2] = f2 - e3;
        b[i >> 2] = c4 - e3;
        b[h >> 2] = d2 - e3;
        return;
      }
      function Wa(a2) {
        a2 = a2 | 0;
        var c4 = 0, d2 = 0, e3 = 0, f2 = 0, g2 = 0, h = 0, i = 0;
        c4 = b[a2 >> 2] | 0;
        h = a2 + 4 | 0;
        d2 = b[h >> 2] | 0;
        i = a2 + 8 | 0;
        e3 = b[i >> 2] | 0;
        f2 = d2 + (c4 * 3 | 0) | 0;
        b[a2 >> 2] = f2;
        d2 = e3 + (d2 * 3 | 0) | 0;
        b[h >> 2] = d2;
        c4 = (e3 * 3 | 0) + c4 | 0;
        b[i >> 2] = c4;
        e3 = d2 - f2 | 0;
        if ((f2 | 0) < 0) {
          c4 = c4 - f2 | 0;
          b[h >> 2] = e3;
          b[i >> 2] = c4;
          b[a2 >> 2] = 0;
          d2 = e3;
          e3 = 0;
        } else {
          e3 = f2;
        }
        if ((d2 | 0) < 0) {
          e3 = e3 - d2 | 0;
          b[a2 >> 2] = e3;
          c4 = c4 - d2 | 0;
          b[i >> 2] = c4;
          b[h >> 2] = 0;
          d2 = 0;
        }
        g2 = e3 - c4 | 0;
        f2 = d2 - c4 | 0;
        if ((c4 | 0) < 0) {
          b[a2 >> 2] = g2;
          b[h >> 2] = f2;
          b[i >> 2] = 0;
          e3 = g2;
          c4 = 0;
        } else {
          f2 = d2;
        }
        d2 = (f2 | 0) < (e3 | 0) ? f2 : e3;
        d2 = (c4 | 0) < (d2 | 0) ? c4 : d2;
        if ((d2 | 0) <= 0) {
          return;
        }
        b[a2 >> 2] = e3 - d2;
        b[h >> 2] = f2 - d2;
        b[i >> 2] = c4 - d2;
        return;
      }
      function Xa(a2) {
        a2 = a2 | 0;
        var c4 = 0, d2 = 0, e3 = 0, f2 = 0, g2 = 0, h = 0, i = 0;
        f2 = b[a2 >> 2] | 0;
        h = a2 + 4 | 0;
        c4 = b[h >> 2] | 0;
        i = a2 + 8 | 0;
        d2 = b[i >> 2] | 0;
        e3 = (c4 * 3 | 0) + f2 | 0;
        f2 = d2 + (f2 * 3 | 0) | 0;
        b[a2 >> 2] = f2;
        b[h >> 2] = e3;
        c4 = (d2 * 3 | 0) + c4 | 0;
        b[i >> 2] = c4;
        d2 = e3 - f2 | 0;
        if ((f2 | 0) < 0) {
          c4 = c4 - f2 | 0;
          b[h >> 2] = d2;
          b[i >> 2] = c4;
          b[a2 >> 2] = 0;
          f2 = 0;
        } else {
          d2 = e3;
        }
        if ((d2 | 0) < 0) {
          f2 = f2 - d2 | 0;
          b[a2 >> 2] = f2;
          c4 = c4 - d2 | 0;
          b[i >> 2] = c4;
          b[h >> 2] = 0;
          d2 = 0;
        }
        g2 = f2 - c4 | 0;
        e3 = d2 - c4 | 0;
        if ((c4 | 0) < 0) {
          b[a2 >> 2] = g2;
          b[h >> 2] = e3;
          b[i >> 2] = 0;
          f2 = g2;
          c4 = 0;
        } else {
          e3 = d2;
        }
        d2 = (e3 | 0) < (f2 | 0) ? e3 : f2;
        d2 = (c4 | 0) < (d2 | 0) ? c4 : d2;
        if ((d2 | 0) <= 0) {
          return;
        }
        b[a2 >> 2] = f2 - d2;
        b[h >> 2] = e3 - d2;
        b[i >> 2] = c4 - d2;
        return;
      }
      function Ya(a2, c4) {
        a2 = a2 | 0;
        c4 = c4 | 0;
        var d2 = 0, e3 = 0, f2 = 0, g2 = 0, h = 0, i = 0;
        if ((c4 + -1 | 0) >>> 0 >= 6) {
          return;
        }
        f2 = (b[15440 + (c4 * 12 | 0) >> 2] | 0) + (b[a2 >> 2] | 0) | 0;
        b[a2 >> 2] = f2;
        i = a2 + 4 | 0;
        e3 = (b[15440 + (c4 * 12 | 0) + 4 >> 2] | 0) + (b[i >> 2] | 0) | 0;
        b[i >> 2] = e3;
        h = a2 + 8 | 0;
        c4 = (b[15440 + (c4 * 12 | 0) + 8 >> 2] | 0) + (b[h >> 2] | 0) | 0;
        b[h >> 2] = c4;
        d2 = e3 - f2 | 0;
        if ((f2 | 0) < 0) {
          c4 = c4 - f2 | 0;
          b[i >> 2] = d2;
          b[h >> 2] = c4;
          b[a2 >> 2] = 0;
          e3 = 0;
        } else {
          d2 = e3;
          e3 = f2;
        }
        if ((d2 | 0) < 0) {
          e3 = e3 - d2 | 0;
          b[a2 >> 2] = e3;
          c4 = c4 - d2 | 0;
          b[h >> 2] = c4;
          b[i >> 2] = 0;
          d2 = 0;
        }
        g2 = e3 - c4 | 0;
        f2 = d2 - c4 | 0;
        if ((c4 | 0) < 0) {
          b[a2 >> 2] = g2;
          b[i >> 2] = f2;
          b[h >> 2] = 0;
          e3 = g2;
          c4 = 0;
        } else {
          f2 = d2;
        }
        d2 = (f2 | 0) < (e3 | 0) ? f2 : e3;
        d2 = (c4 | 0) < (d2 | 0) ? c4 : d2;
        if ((d2 | 0) <= 0) {
          return;
        }
        b[a2 >> 2] = e3 - d2;
        b[i >> 2] = f2 - d2;
        b[h >> 2] = c4 - d2;
        return;
      }
      function Za(a2) {
        a2 = a2 | 0;
        var c4 = 0, d2 = 0, e3 = 0, f2 = 0, g2 = 0, h = 0, i = 0;
        f2 = b[a2 >> 2] | 0;
        h = a2 + 4 | 0;
        c4 = b[h >> 2] | 0;
        i = a2 + 8 | 0;
        d2 = b[i >> 2] | 0;
        e3 = c4 + f2 | 0;
        f2 = d2 + f2 | 0;
        b[a2 >> 2] = f2;
        b[h >> 2] = e3;
        c4 = d2 + c4 | 0;
        b[i >> 2] = c4;
        d2 = e3 - f2 | 0;
        if ((f2 | 0) < 0) {
          c4 = c4 - f2 | 0;
          b[h >> 2] = d2;
          b[i >> 2] = c4;
          b[a2 >> 2] = 0;
          e3 = 0;
        } else {
          d2 = e3;
          e3 = f2;
        }
        if ((d2 | 0) < 0) {
          e3 = e3 - d2 | 0;
          b[a2 >> 2] = e3;
          c4 = c4 - d2 | 0;
          b[i >> 2] = c4;
          b[h >> 2] = 0;
          d2 = 0;
        }
        g2 = e3 - c4 | 0;
        f2 = d2 - c4 | 0;
        if ((c4 | 0) < 0) {
          b[a2 >> 2] = g2;
          b[h >> 2] = f2;
          b[i >> 2] = 0;
          e3 = g2;
          c4 = 0;
        } else {
          f2 = d2;
        }
        d2 = (f2 | 0) < (e3 | 0) ? f2 : e3;
        d2 = (c4 | 0) < (d2 | 0) ? c4 : d2;
        if ((d2 | 0) <= 0) {
          return;
        }
        b[a2 >> 2] = e3 - d2;
        b[h >> 2] = f2 - d2;
        b[i >> 2] = c4 - d2;
        return;
      }
      function _a2(a2) {
        a2 = a2 | 0;
        var c4 = 0, d2 = 0, e3 = 0, f2 = 0, g2 = 0, h = 0, i = 0;
        c4 = b[a2 >> 2] | 0;
        h = a2 + 4 | 0;
        e3 = b[h >> 2] | 0;
        i = a2 + 8 | 0;
        d2 = b[i >> 2] | 0;
        f2 = e3 + c4 | 0;
        b[a2 >> 2] = f2;
        e3 = d2 + e3 | 0;
        b[h >> 2] = e3;
        c4 = d2 + c4 | 0;
        b[i >> 2] = c4;
        d2 = e3 - f2 | 0;
        if ((f2 | 0) < 0) {
          c4 = c4 - f2 | 0;
          b[h >> 2] = d2;
          b[i >> 2] = c4;
          b[a2 >> 2] = 0;
          e3 = 0;
        } else {
          d2 = e3;
          e3 = f2;
        }
        if ((d2 | 0) < 0) {
          e3 = e3 - d2 | 0;
          b[a2 >> 2] = e3;
          c4 = c4 - d2 | 0;
          b[i >> 2] = c4;
          b[h >> 2] = 0;
          d2 = 0;
        }
        g2 = e3 - c4 | 0;
        f2 = d2 - c4 | 0;
        if ((c4 | 0) < 0) {
          b[a2 >> 2] = g2;
          b[h >> 2] = f2;
          b[i >> 2] = 0;
          e3 = g2;
          c4 = 0;
        } else {
          f2 = d2;
        }
        d2 = (f2 | 0) < (e3 | 0) ? f2 : e3;
        d2 = (c4 | 0) < (d2 | 0) ? c4 : d2;
        if ((d2 | 0) <= 0) {
          return;
        }
        b[a2 >> 2] = e3 - d2;
        b[h >> 2] = f2 - d2;
        b[i >> 2] = c4 - d2;
        return;
      }
      function $a(a2) {
        a2 = a2 | 0;
        switch (a2 | 0) {
          case 1: {
            a2 = 5;
            break;
          }
          case 5: {
            a2 = 4;
            break;
          }
          case 4: {
            a2 = 6;
            break;
          }
          case 6: {
            a2 = 2;
            break;
          }
          case 2: {
            a2 = 3;
            break;
          }
          case 3: {
            a2 = 1;
            break;
          }
          default:
        }
        return a2 | 0;
      }
      function ab4(a2) {
        a2 = a2 | 0;
        switch (a2 | 0) {
          case 1: {
            a2 = 3;
            break;
          }
          case 3: {
            a2 = 2;
            break;
          }
          case 2: {
            a2 = 6;
            break;
          }
          case 6: {
            a2 = 4;
            break;
          }
          case 4: {
            a2 = 5;
            break;
          }
          case 5: {
            a2 = 1;
            break;
          }
          default:
        }
        return a2 | 0;
      }
      function bb2(a2) {
        a2 = a2 | 0;
        var c4 = 0, d2 = 0, e3 = 0, f2 = 0, g2 = 0, h = 0, i = 0;
        c4 = b[a2 >> 2] | 0;
        h = a2 + 4 | 0;
        d2 = b[h >> 2] | 0;
        i = a2 + 8 | 0;
        e3 = b[i >> 2] | 0;
        f2 = d2 + (c4 << 1) | 0;
        b[a2 >> 2] = f2;
        d2 = e3 + (d2 << 1) | 0;
        b[h >> 2] = d2;
        c4 = (e3 << 1) + c4 | 0;
        b[i >> 2] = c4;
        e3 = d2 - f2 | 0;
        if ((f2 | 0) < 0) {
          c4 = c4 - f2 | 0;
          b[h >> 2] = e3;
          b[i >> 2] = c4;
          b[a2 >> 2] = 0;
          d2 = e3;
          e3 = 0;
        } else {
          e3 = f2;
        }
        if ((d2 | 0) < 0) {
          e3 = e3 - d2 | 0;
          b[a2 >> 2] = e3;
          c4 = c4 - d2 | 0;
          b[i >> 2] = c4;
          b[h >> 2] = 0;
          d2 = 0;
        }
        g2 = e3 - c4 | 0;
        f2 = d2 - c4 | 0;
        if ((c4 | 0) < 0) {
          b[a2 >> 2] = g2;
          b[h >> 2] = f2;
          b[i >> 2] = 0;
          e3 = g2;
          c4 = 0;
        } else {
          f2 = d2;
        }
        d2 = (f2 | 0) < (e3 | 0) ? f2 : e3;
        d2 = (c4 | 0) < (d2 | 0) ? c4 : d2;
        if ((d2 | 0) <= 0) {
          return;
        }
        b[a2 >> 2] = e3 - d2;
        b[h >> 2] = f2 - d2;
        b[i >> 2] = c4 - d2;
        return;
      }
      function cb(a2) {
        a2 = a2 | 0;
        var c4 = 0, d2 = 0, e3 = 0, f2 = 0, g2 = 0, h = 0, i = 0;
        f2 = b[a2 >> 2] | 0;
        h = a2 + 4 | 0;
        c4 = b[h >> 2] | 0;
        i = a2 + 8 | 0;
        d2 = b[i >> 2] | 0;
        e3 = (c4 << 1) + f2 | 0;
        f2 = d2 + (f2 << 1) | 0;
        b[a2 >> 2] = f2;
        b[h >> 2] = e3;
        c4 = (d2 << 1) + c4 | 0;
        b[i >> 2] = c4;
        d2 = e3 - f2 | 0;
        if ((f2 | 0) < 0) {
          c4 = c4 - f2 | 0;
          b[h >> 2] = d2;
          b[i >> 2] = c4;
          b[a2 >> 2] = 0;
          f2 = 0;
        } else {
          d2 = e3;
        }
        if ((d2 | 0) < 0) {
          f2 = f2 - d2 | 0;
          b[a2 >> 2] = f2;
          c4 = c4 - d2 | 0;
          b[i >> 2] = c4;
          b[h >> 2] = 0;
          d2 = 0;
        }
        g2 = f2 - c4 | 0;
        e3 = d2 - c4 | 0;
        if ((c4 | 0) < 0) {
          b[a2 >> 2] = g2;
          b[h >> 2] = e3;
          b[i >> 2] = 0;
          f2 = g2;
          c4 = 0;
        } else {
          e3 = d2;
        }
        d2 = (e3 | 0) < (f2 | 0) ? e3 : f2;
        d2 = (c4 | 0) < (d2 | 0) ? c4 : d2;
        if ((d2 | 0) <= 0) {
          return;
        }
        b[a2 >> 2] = f2 - d2;
        b[h >> 2] = e3 - d2;
        b[i >> 2] = c4 - d2;
        return;
      }
      function db(a2, c4) {
        a2 = a2 | 0;
        c4 = c4 | 0;
        var d2 = 0, e3 = 0, f2 = 0, g2 = 0, h = 0, i = 0;
        h = (b[a2 >> 2] | 0) - (b[c4 >> 2] | 0) | 0;
        i = (h | 0) < 0;
        e3 = (b[a2 + 4 >> 2] | 0) - (b[c4 + 4 >> 2] | 0) - (i ? h : 0) | 0;
        g2 = (e3 | 0) < 0;
        f2 = (i ? 0 - h | 0 : 0) + (b[a2 + 8 >> 2] | 0) - (b[c4 + 8 >> 2] | 0) + (g2 ? 0 - e3 | 0 : 0) | 0;
        a2 = (f2 | 0) < 0;
        c4 = a2 ? 0 : f2;
        d2 = (g2 ? 0 : e3) - (a2 ? f2 : 0) | 0;
        f2 = (i ? 0 : h) - (g2 ? e3 : 0) - (a2 ? f2 : 0) | 0;
        a2 = (d2 | 0) < (f2 | 0) ? d2 : f2;
        a2 = (c4 | 0) < (a2 | 0) ? c4 : a2;
        e3 = (a2 | 0) > 0;
        c4 = c4 - (e3 ? a2 : 0) | 0;
        d2 = d2 - (e3 ? a2 : 0) | 0;
        a2 = f2 - (e3 ? a2 : 0) | 0;
        a2 = (a2 | 0) > -1 ? a2 : 0 - a2 | 0;
        d2 = (d2 | 0) > -1 ? d2 : 0 - d2 | 0;
        c4 = (c4 | 0) > -1 ? c4 : 0 - c4 | 0;
        c4 = (d2 | 0) > (c4 | 0) ? d2 : c4;
        return ((a2 | 0) > (c4 | 0) ? a2 : c4) | 0;
      }
      function eb2(a2, c4) {
        a2 = a2 | 0;
        c4 = c4 | 0;
        var d2 = 0;
        d2 = b[a2 + 8 >> 2] | 0;
        b[c4 >> 2] = (b[a2 >> 2] | 0) - d2;
        b[c4 + 4 >> 2] = (b[a2 + 4 >> 2] | 0) - d2;
        return;
      }
      function fb(a2, c4) {
        a2 = a2 | 0;
        c4 = c4 | 0;
        var d2 = 0, e3 = 0, f2 = 0, g2 = 0, h = 0, i = 0;
        e3 = b[a2 >> 2] | 0;
        b[c4 >> 2] = e3;
        f2 = b[a2 + 4 >> 2] | 0;
        h = c4 + 4 | 0;
        b[h >> 2] = f2;
        i = c4 + 8 | 0;
        b[i >> 2] = 0;
        d2 = (f2 | 0) < (e3 | 0);
        a2 = d2 ? e3 : f2;
        d2 = d2 ? f2 : e3;
        if ((d2 | 0) < 0) {
          if ((d2 | 0) == -2147483648 ? 1 : (a2 | 0) > 0 ? (2147483647 - a2 | 0) < (d2 | 0) : (-2147483648 - a2 | 0) > (d2 | 0)) {
            c4 = 1;
            return c4 | 0;
          }
          if ((a2 | 0) > -1 ? (a2 | -2147483648 | 0) >= (d2 | 0) : (a2 ^ -2147483648 | 0) < (d2 | 0)) {
            c4 = 1;
            return c4 | 0;
          }
        }
        a2 = f2 - e3 | 0;
        if ((e3 | 0) < 0) {
          d2 = 0 - e3 | 0;
          b[h >> 2] = a2;
          b[i >> 2] = d2;
          b[c4 >> 2] = 0;
          e3 = 0;
        } else {
          a2 = f2;
          d2 = 0;
        }
        if ((a2 | 0) < 0) {
          e3 = e3 - a2 | 0;
          b[c4 >> 2] = e3;
          d2 = d2 - a2 | 0;
          b[i >> 2] = d2;
          b[h >> 2] = 0;
          a2 = 0;
        }
        g2 = e3 - d2 | 0;
        f2 = a2 - d2 | 0;
        if ((d2 | 0) < 0) {
          b[c4 >> 2] = g2;
          b[h >> 2] = f2;
          b[i >> 2] = 0;
          a2 = f2;
          f2 = g2;
          d2 = 0;
        } else {
          f2 = e3;
        }
        e3 = (a2 | 0) < (f2 | 0) ? a2 : f2;
        e3 = (d2 | 0) < (e3 | 0) ? d2 : e3;
        if ((e3 | 0) <= 0) {
          c4 = 0;
          return c4 | 0;
        }
        b[c4 >> 2] = f2 - e3;
        b[h >> 2] = a2 - e3;
        b[i >> 2] = d2 - e3;
        c4 = 0;
        return c4 | 0;
      }
      function gb(a2) {
        a2 = a2 | 0;
        var c4 = 0, d2 = 0, e3 = 0, f2 = 0;
        c4 = a2 + 8 | 0;
        f2 = b[c4 >> 2] | 0;
        d2 = f2 - (b[a2 >> 2] | 0) | 0;
        b[a2 >> 2] = d2;
        e3 = a2 + 4 | 0;
        a2 = (b[e3 >> 2] | 0) - f2 | 0;
        b[e3 >> 2] = a2;
        b[c4 >> 2] = 0 - (a2 + d2);
        return;
      }
      function hb(a2) {
        a2 = a2 | 0;
        var c4 = 0, d2 = 0, e3 = 0, f2 = 0, g2 = 0, h = 0, i = 0;
        d2 = b[a2 >> 2] | 0;
        c4 = 0 - d2 | 0;
        b[a2 >> 2] = c4;
        h = a2 + 8 | 0;
        b[h >> 2] = 0;
        i = a2 + 4 | 0;
        e3 = b[i >> 2] | 0;
        f2 = e3 + d2 | 0;
        if ((d2 | 0) > 0) {
          b[i >> 2] = f2;
          b[h >> 2] = d2;
          b[a2 >> 2] = 0;
          c4 = 0;
          e3 = f2;
        } else {
          d2 = 0;
        }
        if ((e3 | 0) < 0) {
          g2 = c4 - e3 | 0;
          b[a2 >> 2] = g2;
          d2 = d2 - e3 | 0;
          b[h >> 2] = d2;
          b[i >> 2] = 0;
          f2 = g2 - d2 | 0;
          c4 = 0 - d2 | 0;
          if ((d2 | 0) < 0) {
            b[a2 >> 2] = f2;
            b[i >> 2] = c4;
            b[h >> 2] = 0;
            e3 = c4;
            d2 = 0;
          } else {
            e3 = 0;
            f2 = g2;
          }
        } else {
          f2 = c4;
        }
        c4 = (e3 | 0) < (f2 | 0) ? e3 : f2;
        c4 = (d2 | 0) < (c4 | 0) ? d2 : c4;
        if ((c4 | 0) <= 0) {
          return;
        }
        b[a2 >> 2] = f2 - c4;
        b[i >> 2] = e3 - c4;
        b[h >> 2] = d2 - c4;
        return;
      }
      function ib(a2, c4, d2, e3, f2) {
        a2 = a2 | 0;
        c4 = c4 | 0;
        d2 = d2 | 0;
        e3 = e3 | 0;
        f2 = f2 | 0;
        var g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0;
        m = T2;
        T2 = T2 + 64 | 0;
        l = m;
        i = m + 56 | 0;
        if (!(true & (c4 & 2013265920 | 0) == 134217728 & (true & (e3 & 2013265920 | 0) == 134217728))) {
          f2 = 5;
          T2 = m;
          return f2 | 0;
        }
        if ((a2 | 0) == (d2 | 0) & (c4 | 0) == (e3 | 0)) {
          b[f2 >> 2] = 0;
          f2 = 0;
          T2 = m;
          return f2 | 0;
        }
        h = Qd(a2 | 0, c4 | 0, 52) | 0;
        H() | 0;
        h = h & 15;
        k = Qd(d2 | 0, e3 | 0, 52) | 0;
        H() | 0;
        if ((h | 0) != (k & 15 | 0)) {
          f2 = 12;
          T2 = m;
          return f2 | 0;
        }
        g2 = h + -1 | 0;
        if (h >>> 0 > 1) {
          Fb(a2, c4, g2, l) | 0;
          Fb(d2, e3, g2, i) | 0;
          k = l;
          j = b[k >> 2] | 0;
          k = b[k + 4 >> 2] | 0;
          a: do {
            if ((j | 0) == (b[i >> 2] | 0) ? (k | 0) == (b[i + 4 >> 2] | 0) : 0) {
              h = (h ^ 15) * 3 | 0;
              g2 = Qd(a2 | 0, c4 | 0, h | 0) | 0;
              H() | 0;
              g2 = g2 & 7;
              h = Qd(d2 | 0, e3 | 0, h | 0) | 0;
              H() | 0;
              h = h & 7;
              do {
                if (!((g2 | 0) == 0 | (h | 0) == 0)) {
                  if ((g2 | 0) == 7) {
                    g2 = 5;
                  } else {
                    if ((g2 | 0) == 1 | (h | 0) == 1 ? Hb(j, k) | 0 : 0) {
                      g2 = 5;
                      break;
                    }
                    if ((b[15536 + (g2 << 2) >> 2] | 0) != (h | 0) ? (b[15568 + (g2 << 2) >> 2] | 0) != (h | 0) : 0) {
                      break a;
                    }
                    b[f2 >> 2] = 1;
                    g2 = 0;
                  }
                } else {
                  b[f2 >> 2] = 1;
                  g2 = 0;
                }
              } while (0);
              f2 = g2;
              T2 = m;
              return f2 | 0;
            }
          } while (0);
        }
        g2 = l;
        h = g2 + 56 | 0;
        do {
          b[g2 >> 2] = 0;
          g2 = g2 + 4 | 0;
        } while ((g2 | 0) < (h | 0));
        aa2(a2, c4, 1, l) | 0;
        c4 = l;
        if (((((!((b[c4 >> 2] | 0) == (d2 | 0) ? (b[c4 + 4 >> 2] | 0) == (e3 | 0) : 0) ? (c4 = l + 8 | 0, !((b[c4 >> 2] | 0) == (d2 | 0) ? (b[c4 + 4 >> 2] | 0) == (e3 | 0) : 0)) : 0) ? (c4 = l + 16 | 0, !((b[c4 >> 2] | 0) == (d2 | 0) ? (b[c4 + 4 >> 2] | 0) == (e3 | 0) : 0)) : 0) ? (c4 = l + 24 | 0, !((b[c4 >> 2] | 0) == (d2 | 0) ? (b[c4 + 4 >> 2] | 0) == (e3 | 0) : 0)) : 0) ? (c4 = l + 32 | 0, !((b[c4 >> 2] | 0) == (d2 | 0) ? (b[c4 + 4 >> 2] | 0) == (e3 | 0) : 0)) : 0) ? (c4 = l + 40 | 0, !((b[c4 >> 2] | 0) == (d2 | 0) ? (b[c4 + 4 >> 2] | 0) == (e3 | 0) : 0)) : 0) {
          g2 = l + 48 | 0;
          g2 = ((b[g2 >> 2] | 0) == (d2 | 0) ? (b[g2 + 4 >> 2] | 0) == (e3 | 0) : 0) & 1;
        } else {
          g2 = 1;
        }
        b[f2 >> 2] = g2;
        f2 = 0;
        T2 = m;
        return f2 | 0;
      }
      function jb(a2, c4, d2, e3, f2) {
        a2 = a2 | 0;
        c4 = c4 | 0;
        d2 = d2 | 0;
        e3 = e3 | 0;
        f2 = f2 | 0;
        d2 = ia(a2, c4, d2, e3) | 0;
        if ((d2 | 0) == 7) {
          f2 = 11;
          return f2 | 0;
        }
        e3 = Rd(d2 | 0, 0, 56) | 0;
        c4 = c4 & -2130706433 | (H() | 0) | 268435456;
        b[f2 >> 2] = a2 | e3;
        b[f2 + 4 >> 2] = c4;
        f2 = 0;
        return f2 | 0;
      }
      function kb(a2, c4, d2) {
        a2 = a2 | 0;
        c4 = c4 | 0;
        d2 = d2 | 0;
        if (!(true & (c4 & 2013265920 | 0) == 268435456)) {
          d2 = 6;
          return d2 | 0;
        }
        b[d2 >> 2] = a2;
        b[d2 + 4 >> 2] = c4 & -2130706433 | 134217728;
        d2 = 0;
        return d2 | 0;
      }
      function lb(a2, c4, d2) {
        a2 = a2 | 0;
        c4 = c4 | 0;
        d2 = d2 | 0;
        var e3 = 0, f2 = 0, g2 = 0;
        f2 = T2;
        T2 = T2 + 16 | 0;
        e3 = f2;
        b[e3 >> 2] = 0;
        if (!(true & (c4 & 2013265920 | 0) == 268435456)) {
          e3 = 6;
          T2 = f2;
          return e3 | 0;
        }
        g2 = Qd(a2 | 0, c4 | 0, 56) | 0;
        H() | 0;
        e3 = ea2(a2, c4 & -2130706433 | 134217728, g2 & 7, e3, d2) | 0;
        T2 = f2;
        return e3 | 0;
      }
      function mb(a2, b2) {
        a2 = a2 | 0;
        b2 = b2 | 0;
        var c4 = 0;
        c4 = Qd(a2 | 0, b2 | 0, 56) | 0;
        H() | 0;
        switch (c4 & 7) {
          case 0:
          case 7: {
            c4 = 0;
            return c4 | 0;
          }
          default:
        }
        c4 = b2 & -2130706433 | 134217728;
        if (!(true & (b2 & 2013265920 | 0) == 268435456)) {
          c4 = 0;
          return c4 | 0;
        }
        if (true & (b2 & 117440512 | 0) == 16777216 & (Hb(a2, c4) | 0) != 0) {
          c4 = 0;
          return c4 | 0;
        }
        c4 = Db(a2, c4) | 0;
        return c4 | 0;
      }
      function nb(a2, c4, d2) {
        a2 = a2 | 0;
        c4 = c4 | 0;
        d2 = d2 | 0;
        var e3 = 0, f2 = 0, g2 = 0, h = 0;
        f2 = T2;
        T2 = T2 + 16 | 0;
        e3 = f2;
        if (!(true & (c4 & 2013265920 | 0) == 268435456)) {
          e3 = 6;
          T2 = f2;
          return e3 | 0;
        }
        g2 = c4 & -2130706433 | 134217728;
        h = d2;
        b[h >> 2] = a2;
        b[h + 4 >> 2] = g2;
        b[e3 >> 2] = 0;
        c4 = Qd(a2 | 0, c4 | 0, 56) | 0;
        H() | 0;
        e3 = ea2(a2, g2, c4 & 7, e3, d2 + 8 | 0) | 0;
        T2 = f2;
        return e3 | 0;
      }
      function ob(a2, c4, d2) {
        a2 = a2 | 0;
        c4 = c4 | 0;
        d2 = d2 | 0;
        var e3 = 0, f2 = 0;
        f2 = (Hb(a2, c4) | 0) == 0;
        c4 = c4 & -2130706433;
        e3 = d2;
        b[e3 >> 2] = f2 ? a2 : 0;
        b[e3 + 4 >> 2] = f2 ? c4 | 285212672 : 0;
        e3 = d2 + 8 | 0;
        b[e3 >> 2] = a2;
        b[e3 + 4 >> 2] = c4 | 301989888;
        e3 = d2 + 16 | 0;
        b[e3 >> 2] = a2;
        b[e3 + 4 >> 2] = c4 | 318767104;
        e3 = d2 + 24 | 0;
        b[e3 >> 2] = a2;
        b[e3 + 4 >> 2] = c4 | 335544320;
        e3 = d2 + 32 | 0;
        b[e3 >> 2] = a2;
        b[e3 + 4 >> 2] = c4 | 352321536;
        d2 = d2 + 40 | 0;
        b[d2 >> 2] = a2;
        b[d2 + 4 >> 2] = c4 | 369098752;
        return 0;
      }
      function pb(a2, c4, d2) {
        a2 = a2 | 0;
        c4 = c4 | 0;
        d2 = d2 | 0;
        var e3 = 0, f2 = 0, g2 = 0, h = 0;
        h = T2;
        T2 = T2 + 16 | 0;
        f2 = h;
        g2 = c4 & -2130706433 | 134217728;
        if (!(true & (c4 & 2013265920 | 0) == 268435456)) {
          g2 = 6;
          T2 = h;
          return g2 | 0;
        }
        e3 = Qd(a2 | 0, c4 | 0, 56) | 0;
        H() | 0;
        e3 = od(a2, g2, e3 & 7) | 0;
        if ((e3 | 0) == -1) {
          b[d2 >> 2] = 0;
          g2 = 6;
          T2 = h;
          return g2 | 0;
        }
        if (Yb(a2, g2, f2) | 0) {
          I(27795, 26932, 282, 26947);
        }
        c4 = Qd(a2 | 0, c4 | 0, 52) | 0;
        H() | 0;
        c4 = c4 & 15;
        if (!(Hb(a2, g2) | 0)) {
          zb(f2, c4, e3, 2, d2);
        } else {
          vb(f2, c4, e3, 2, d2);
        }
        g2 = 0;
        T2 = h;
        return g2 | 0;
      }
      function qb(a2, b2, c4) {
        a2 = a2 | 0;
        b2 = b2 | 0;
        c4 = c4 | 0;
        var d2 = 0, e3 = 0;
        d2 = T2;
        T2 = T2 + 16 | 0;
        e3 = d2;
        rb(a2, b2, c4, e3);
        La(e3, c4 + 4 | 0);
        T2 = d2;
        return;
      }
      function rb(a2, c4, d2, f2) {
        a2 = a2 | 0;
        c4 = c4 | 0;
        d2 = d2 | 0;
        f2 = f2 | 0;
        var g2 = 0, h = 0, i = 0, j = 0, k = 0;
        j = T2;
        T2 = T2 + 16 | 0;
        k = j;
        sb(a2, d2, k);
        h = +w(+(1 - +e[k >> 3] * 0.5));
        if (h < 1e-16) {
          b[f2 >> 2] = 0;
          b[f2 + 4 >> 2] = 0;
          b[f2 + 8 >> 2] = 0;
          b[f2 + 12 >> 2] = 0;
          T2 = j;
          return;
        }
        k = b[d2 >> 2] | 0;
        g2 = +e[15920 + (k * 24 | 0) >> 3];
        g2 = +ic(g2 - +ic(+oc(15600 + (k << 4) | 0, a2)));
        if (!(Vb(c4) | 0)) {
          i = g2;
        } else {
          i = +ic(g2 + -0.3334731722518321);
        }
        g2 = +v2(+h) * 2.618033988749896;
        if ((c4 | 0) > 0) {
          a2 = 0;
          do {
            g2 = g2 * 2.6457513110645907;
            a2 = a2 + 1 | 0;
          } while ((a2 | 0) != (c4 | 0));
        }
        h = +t(+i) * g2;
        e[f2 >> 3] = h;
        i = +u4(+i) * g2;
        e[f2 + 8 >> 3] = i;
        T2 = j;
        return;
      }
      function sb(a2, c4, d2) {
        a2 = a2 | 0;
        c4 = c4 | 0;
        d2 = d2 | 0;
        var f2 = 0, g2 = 0, h = 0;
        h = T2;
        T2 = T2 + 32 | 0;
        g2 = h;
        nd(a2, g2);
        b[c4 >> 2] = 0;
        e[d2 >> 3] = 5;
        f2 = +md(16400, g2);
        if (f2 < +e[d2 >> 3]) {
          b[c4 >> 2] = 0;
          e[d2 >> 3] = f2;
        }
        f2 = +md(16424, g2);
        if (f2 < +e[d2 >> 3]) {
          b[c4 >> 2] = 1;
          e[d2 >> 3] = f2;
        }
        f2 = +md(16448, g2);
        if (f2 < +e[d2 >> 3]) {
          b[c4 >> 2] = 2;
          e[d2 >> 3] = f2;
        }
        f2 = +md(16472, g2);
        if (f2 < +e[d2 >> 3]) {
          b[c4 >> 2] = 3;
          e[d2 >> 3] = f2;
        }
        f2 = +md(16496, g2);
        if (f2 < +e[d2 >> 3]) {
          b[c4 >> 2] = 4;
          e[d2 >> 3] = f2;
        }
        f2 = +md(16520, g2);
        if (f2 < +e[d2 >> 3]) {
          b[c4 >> 2] = 5;
          e[d2 >> 3] = f2;
        }
        f2 = +md(16544, g2);
        if (f2 < +e[d2 >> 3]) {
          b[c4 >> 2] = 6;
          e[d2 >> 3] = f2;
        }
        f2 = +md(16568, g2);
        if (f2 < +e[d2 >> 3]) {
          b[c4 >> 2] = 7;
          e[d2 >> 3] = f2;
        }
        f2 = +md(16592, g2);
        if (f2 < +e[d2 >> 3]) {
          b[c4 >> 2] = 8;
          e[d2 >> 3] = f2;
        }
        f2 = +md(16616, g2);
        if (f2 < +e[d2 >> 3]) {
          b[c4 >> 2] = 9;
          e[d2 >> 3] = f2;
        }
        f2 = +md(16640, g2);
        if (f2 < +e[d2 >> 3]) {
          b[c4 >> 2] = 10;
          e[d2 >> 3] = f2;
        }
        f2 = +md(16664, g2);
        if (f2 < +e[d2 >> 3]) {
          b[c4 >> 2] = 11;
          e[d2 >> 3] = f2;
        }
        f2 = +md(16688, g2);
        if (f2 < +e[d2 >> 3]) {
          b[c4 >> 2] = 12;
          e[d2 >> 3] = f2;
        }
        f2 = +md(16712, g2);
        if (f2 < +e[d2 >> 3]) {
          b[c4 >> 2] = 13;
          e[d2 >> 3] = f2;
        }
        f2 = +md(16736, g2);
        if (f2 < +e[d2 >> 3]) {
          b[c4 >> 2] = 14;
          e[d2 >> 3] = f2;
        }
        f2 = +md(16760, g2);
        if (f2 < +e[d2 >> 3]) {
          b[c4 >> 2] = 15;
          e[d2 >> 3] = f2;
        }
        f2 = +md(16784, g2);
        if (f2 < +e[d2 >> 3]) {
          b[c4 >> 2] = 16;
          e[d2 >> 3] = f2;
        }
        f2 = +md(16808, g2);
        if (f2 < +e[d2 >> 3]) {
          b[c4 >> 2] = 17;
          e[d2 >> 3] = f2;
        }
        f2 = +md(16832, g2);
        if (f2 < +e[d2 >> 3]) {
          b[c4 >> 2] = 18;
          e[d2 >> 3] = f2;
        }
        f2 = +md(16856, g2);
        if (!(f2 < +e[d2 >> 3])) {
          T2 = h;
          return;
        }
        b[c4 >> 2] = 19;
        e[d2 >> 3] = f2;
        T2 = h;
        return;
      }
      function tb(a2, c4, d2, f2, g2) {
        a2 = a2 | 0;
        c4 = c4 | 0;
        d2 = d2 | 0;
        f2 = f2 | 0;
        g2 = g2 | 0;
        var h = 0, i = 0, j = 0;
        h = +jd(a2);
        if (h < 1e-16) {
          c4 = 15600 + (c4 << 4) | 0;
          b[g2 >> 2] = b[c4 >> 2];
          b[g2 + 4 >> 2] = b[c4 + 4 >> 2];
          b[g2 + 8 >> 2] = b[c4 + 8 >> 2];
          b[g2 + 12 >> 2] = b[c4 + 12 >> 2];
          return;
        }
        i = +z(+ +e[a2 + 8 >> 3], + +e[a2 >> 3]);
        if ((d2 | 0) > 0) {
          a2 = 0;
          do {
            h = h * 0.37796447300922725;
            a2 = a2 + 1 | 0;
          } while ((a2 | 0) != (d2 | 0));
        }
        j = h * 0.3333333333333333;
        if (!f2) {
          h = +y(+(h * 0.381966011250105));
          if (Vb(d2) | 0) {
            i = +ic(i + 0.3334731722518321);
          }
        } else {
          d2 = (Vb(d2) | 0) == 0;
          h = +y(+((d2 ? j : j * 0.37796447300922725) * 0.381966011250105));
        }
        pc(15600 + (c4 << 4) | 0, +ic(+e[15920 + (c4 * 24 | 0) >> 3] - i), h, g2);
        return;
      }
      function ub(a2, c4, d2) {
        a2 = a2 | 0;
        c4 = c4 | 0;
        d2 = d2 | 0;
        var e3 = 0, f2 = 0;
        e3 = T2;
        T2 = T2 + 16 | 0;
        f2 = e3;
        Na(a2 + 4 | 0, f2);
        tb(f2, b[a2 >> 2] | 0, c4, 0, d2);
        T2 = e3;
        return;
      }
      function vb(a2, c4, d2, f2, g2) {
        a2 = a2 | 0;
        c4 = c4 | 0;
        d2 = d2 | 0;
        f2 = f2 | 0;
        g2 = g2 | 0;
        var h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p2 = 0, q2 = 0, r2 = 0, s2 = 0, t4 = 0, u5 = 0, v3 = 0, w4 = 0, x2 = 0, y2 = 0, z2 = 0, A6 = 0, B5 = 0, C4 = 0, D4 = 0, E3 = 0, F = 0, G2 = 0, H2 = 0, J2 = 0;
        G2 = T2;
        T2 = T2 + 272 | 0;
        h = G2 + 256 | 0;
        u5 = G2 + 240 | 0;
        D4 = G2;
        E3 = G2 + 224 | 0;
        F = G2 + 208 | 0;
        v3 = G2 + 176 | 0;
        w4 = G2 + 160 | 0;
        x2 = G2 + 192 | 0;
        y2 = G2 + 144 | 0;
        z2 = G2 + 128 | 0;
        A6 = G2 + 112 | 0;
        B5 = G2 + 96 | 0;
        C4 = G2 + 80 | 0;
        b[h >> 2] = c4;
        b[u5 >> 2] = b[a2 >> 2];
        b[u5 + 4 >> 2] = b[a2 + 4 >> 2];
        b[u5 + 8 >> 2] = b[a2 + 8 >> 2];
        b[u5 + 12 >> 2] = b[a2 + 12 >> 2];
        wb(u5, h, D4);
        b[g2 >> 2] = 0;
        u5 = f2 + d2 + ((f2 | 0) == 5 & 1) | 0;
        if ((u5 | 0) <= (d2 | 0)) {
          T2 = G2;
          return;
        }
        k = b[h >> 2] | 0;
        l = E3 + 4 | 0;
        m = v3 + 4 | 0;
        n = d2 + 5 | 0;
        o = 16880 + (k << 2) | 0;
        p2 = 16960 + (k << 2) | 0;
        q2 = z2 + 8 | 0;
        r2 = A6 + 8 | 0;
        s2 = B5 + 8 | 0;
        t4 = F + 4 | 0;
        j = d2;
        a: while (1) {
          i = D4 + (((j | 0) % 5 | 0) << 4) | 0;
          b[F >> 2] = b[i >> 2];
          b[F + 4 >> 2] = b[i + 4 >> 2];
          b[F + 8 >> 2] = b[i + 8 >> 2];
          b[F + 12 >> 2] = b[i + 12 >> 2];
          do {
          } while ((xb(F, k, 0, 1) | 0) == 2);
          if ((j | 0) > (d2 | 0) & (Vb(c4) | 0) != 0) {
            b[v3 >> 2] = b[F >> 2];
            b[v3 + 4 >> 2] = b[F + 4 >> 2];
            b[v3 + 8 >> 2] = b[F + 8 >> 2];
            b[v3 + 12 >> 2] = b[F + 12 >> 2];
            Na(l, w4);
            f2 = b[v3 >> 2] | 0;
            h = b[17040 + (f2 * 80 | 0) + (b[E3 >> 2] << 2) >> 2] | 0;
            b[v3 >> 2] = b[18640 + (f2 * 80 | 0) + (h * 20 | 0) >> 2];
            i = b[18640 + (f2 * 80 | 0) + (h * 20 | 0) + 16 >> 2] | 0;
            if ((i | 0) > 0) {
              a2 = 0;
              do {
                Za(m);
                a2 = a2 + 1 | 0;
              } while ((a2 | 0) < (i | 0));
            }
            i = 18640 + (f2 * 80 | 0) + (h * 20 | 0) + 4 | 0;
            b[x2 >> 2] = b[i >> 2];
            b[x2 + 4 >> 2] = b[i + 4 >> 2];
            b[x2 + 8 >> 2] = b[i + 8 >> 2];
            Qa(x2, (b[o >> 2] | 0) * 3 | 0);
            Oa(m, x2, m);
            Ma(m);
            Na(m, y2);
            H2 = +(b[p2 >> 2] | 0);
            e[z2 >> 3] = H2 * 3;
            e[q2 >> 3] = 0;
            J2 = H2 * -1.5;
            e[A6 >> 3] = J2;
            e[r2 >> 3] = H2 * 2.598076211353316;
            e[B5 >> 3] = J2;
            e[s2 >> 3] = H2 * -2.598076211353316;
            switch (b[17040 + ((b[v3 >> 2] | 0) * 80 | 0) + (b[F >> 2] << 2) >> 2] | 0) {
              case 1: {
                a2 = A6;
                f2 = z2;
                break;
              }
              case 3: {
                a2 = B5;
                f2 = A6;
                break;
              }
              case 2: {
                a2 = z2;
                f2 = B5;
                break;
              }
              default: {
                a2 = 12;
                break a;
              }
            }
            kd(w4, y2, f2, a2, C4);
            tb(C4, b[v3 >> 2] | 0, k, 1, g2 + 8 + (b[g2 >> 2] << 4) | 0);
            b[g2 >> 2] = (b[g2 >> 2] | 0) + 1;
          }
          if ((j | 0) < (n | 0)) {
            Na(t4, v3);
            tb(v3, b[F >> 2] | 0, k, 1, g2 + 8 + (b[g2 >> 2] << 4) | 0);
            b[g2 >> 2] = (b[g2 >> 2] | 0) + 1;
          }
          b[E3 >> 2] = b[F >> 2];
          b[E3 + 4 >> 2] = b[F + 4 >> 2];
          b[E3 + 8 >> 2] = b[F + 8 >> 2];
          b[E3 + 12 >> 2] = b[F + 12 >> 2];
          j = j + 1 | 0;
          if ((j | 0) >= (u5 | 0)) {
            a2 = 3;
            break;
          }
        }
        if ((a2 | 0) == 3) {
          T2 = G2;
          return;
        } else if ((a2 | 0) == 12) {
          I(26970, 27017, 572, 27027);
        }
      }
      function wb(a2, c4, d2) {
        a2 = a2 | 0;
        c4 = c4 | 0;
        d2 = d2 | 0;
        var e3 = 0, f2 = 0, g2 = 0, h = 0, i = 0, j = 0;
        j = T2;
        T2 = T2 + 128 | 0;
        e3 = j + 64 | 0;
        f2 = j;
        g2 = e3;
        h = 20240;
        i = g2 + 60 | 0;
        do {
          b[g2 >> 2] = b[h >> 2];
          g2 = g2 + 4 | 0;
          h = h + 4 | 0;
        } while ((g2 | 0) < (i | 0));
        g2 = f2;
        h = 20304;
        i = g2 + 60 | 0;
        do {
          b[g2 >> 2] = b[h >> 2];
          g2 = g2 + 4 | 0;
          h = h + 4 | 0;
        } while ((g2 | 0) < (i | 0));
        i = (Vb(b[c4 >> 2] | 0) | 0) == 0;
        e3 = i ? e3 : f2;
        f2 = a2 + 4 | 0;
        bb2(f2);
        cb(f2);
        if (Vb(b[c4 >> 2] | 0) | 0) {
          Xa(f2);
          b[c4 >> 2] = (b[c4 >> 2] | 0) + 1;
        }
        b[d2 >> 2] = b[a2 >> 2];
        c4 = d2 + 4 | 0;
        Oa(f2, e3, c4);
        Ma(c4);
        b[d2 + 16 >> 2] = b[a2 >> 2];
        c4 = d2 + 20 | 0;
        Oa(f2, e3 + 12 | 0, c4);
        Ma(c4);
        b[d2 + 32 >> 2] = b[a2 >> 2];
        c4 = d2 + 36 | 0;
        Oa(f2, e3 + 24 | 0, c4);
        Ma(c4);
        b[d2 + 48 >> 2] = b[a2 >> 2];
        c4 = d2 + 52 | 0;
        Oa(f2, e3 + 36 | 0, c4);
        Ma(c4);
        b[d2 + 64 >> 2] = b[a2 >> 2];
        d2 = d2 + 68 | 0;
        Oa(f2, e3 + 48 | 0, d2);
        Ma(d2);
        T2 = j;
        return;
      }
      function xb(a2, c4, d2, e3) {
        a2 = a2 | 0;
        c4 = c4 | 0;
        d2 = d2 | 0;
        e3 = e3 | 0;
        var f2 = 0, g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p2 = 0;
        p2 = T2;
        T2 = T2 + 32 | 0;
        n = p2 + 12 | 0;
        i = p2;
        o = a2 + 4 | 0;
        m = b[16960 + (c4 << 2) >> 2] | 0;
        l = (e3 | 0) != 0;
        m = l ? m * 3 | 0 : m;
        f2 = b[o >> 2] | 0;
        k = a2 + 8 | 0;
        h = b[k >> 2] | 0;
        if (l) {
          g2 = a2 + 12 | 0;
          e3 = b[g2 >> 2] | 0;
          f2 = h + f2 + e3 | 0;
          if ((f2 | 0) == (m | 0)) {
            o = 1;
            T2 = p2;
            return o | 0;
          } else {
            j = g2;
          }
        } else {
          j = a2 + 12 | 0;
          e3 = b[j >> 2] | 0;
          f2 = h + f2 + e3 | 0;
        }
        if ((f2 | 0) <= (m | 0)) {
          o = 0;
          T2 = p2;
          return o | 0;
        }
        do {
          if ((e3 | 0) > 0) {
            e3 = b[a2 >> 2] | 0;
            if ((h | 0) > 0) {
              g2 = 18640 + (e3 * 80 | 0) + 60 | 0;
              e3 = a2;
              break;
            }
            e3 = 18640 + (e3 * 80 | 0) + 40 | 0;
            if (!d2) {
              g2 = e3;
              e3 = a2;
            } else {
              Ka(n, m, 0, 0);
              Pa(o, n, i);
              _a2(i);
              Oa(i, n, o);
              g2 = e3;
              e3 = a2;
            }
          } else {
            g2 = 18640 + ((b[a2 >> 2] | 0) * 80 | 0) + 20 | 0;
            e3 = a2;
          }
        } while (0);
        b[e3 >> 2] = b[g2 >> 2];
        f2 = g2 + 16 | 0;
        if ((b[f2 >> 2] | 0) > 0) {
          e3 = 0;
          do {
            Za(o);
            e3 = e3 + 1 | 0;
          } while ((e3 | 0) < (b[f2 >> 2] | 0));
        }
        a2 = g2 + 4 | 0;
        b[n >> 2] = b[a2 >> 2];
        b[n + 4 >> 2] = b[a2 + 4 >> 2];
        b[n + 8 >> 2] = b[a2 + 8 >> 2];
        c4 = b[16880 + (c4 << 2) >> 2] | 0;
        Qa(n, l ? c4 * 3 | 0 : c4);
        Oa(o, n, o);
        Ma(o);
        if (l) {
          e3 = ((b[k >> 2] | 0) + (b[o >> 2] | 0) + (b[j >> 2] | 0) | 0) == (m | 0) ? 1 : 2;
        } else {
          e3 = 2;
        }
        o = e3;
        T2 = p2;
        return o | 0;
      }
      function yb(a2, b2) {
        a2 = a2 | 0;
        b2 = b2 | 0;
        var c4 = 0;
        do {
          c4 = xb(a2, b2, 0, 1) | 0;
        } while ((c4 | 0) == 2);
        return c4 | 0;
      }
      function zb(a2, c4, d2, f2, g2) {
        a2 = a2 | 0;
        c4 = c4 | 0;
        d2 = d2 | 0;
        f2 = f2 | 0;
        g2 = g2 | 0;
        var h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p2 = 0, q2 = 0, r2 = 0, s2 = 0, t4 = 0, u5 = 0, v3 = 0, w4 = 0, x2 = 0, y2 = 0, z2 = 0, A6 = 0, B5 = 0, C4 = 0, D4 = 0;
        B5 = T2;
        T2 = T2 + 240 | 0;
        h = B5 + 224 | 0;
        x2 = B5 + 208 | 0;
        y2 = B5;
        z2 = B5 + 192 | 0;
        A6 = B5 + 176 | 0;
        s2 = B5 + 160 | 0;
        t4 = B5 + 144 | 0;
        u5 = B5 + 128 | 0;
        v3 = B5 + 112 | 0;
        w4 = B5 + 96 | 0;
        b[h >> 2] = c4;
        b[x2 >> 2] = b[a2 >> 2];
        b[x2 + 4 >> 2] = b[a2 + 4 >> 2];
        b[x2 + 8 >> 2] = b[a2 + 8 >> 2];
        b[x2 + 12 >> 2] = b[a2 + 12 >> 2];
        Ab(x2, h, y2);
        b[g2 >> 2] = 0;
        r2 = f2 + d2 + ((f2 | 0) == 6 & 1) | 0;
        if ((r2 | 0) <= (d2 | 0)) {
          T2 = B5;
          return;
        }
        k = b[h >> 2] | 0;
        l = d2 + 6 | 0;
        m = 16960 + (k << 2) | 0;
        n = t4 + 8 | 0;
        o = u5 + 8 | 0;
        p2 = v3 + 8 | 0;
        q2 = z2 + 4 | 0;
        i = 0;
        j = d2;
        f2 = -1;
        a: while (1) {
          h = (j | 0) % 6 | 0;
          a2 = y2 + (h << 4) | 0;
          b[z2 >> 2] = b[a2 >> 2];
          b[z2 + 4 >> 2] = b[a2 + 4 >> 2];
          b[z2 + 8 >> 2] = b[a2 + 8 >> 2];
          b[z2 + 12 >> 2] = b[a2 + 12 >> 2];
          a2 = i;
          i = xb(z2, k, 0, 1) | 0;
          if ((j | 0) > (d2 | 0) & (Vb(c4) | 0) != 0 ? (a2 | 0) != 1 ? (b[z2 >> 2] | 0) != (f2 | 0) : 0 : 0) {
            Na(y2 + (((h + 5 | 0) % 6 | 0) << 4) + 4 | 0, A6);
            Na(y2 + (h << 4) + 4 | 0, s2);
            C4 = +(b[m >> 2] | 0);
            e[t4 >> 3] = C4 * 3;
            e[n >> 3] = 0;
            D4 = C4 * -1.5;
            e[u5 >> 3] = D4;
            e[o >> 3] = C4 * 2.598076211353316;
            e[v3 >> 3] = D4;
            e[p2 >> 3] = C4 * -2.598076211353316;
            h = b[x2 >> 2] | 0;
            switch (b[17040 + (h * 80 | 0) + (((f2 | 0) == (h | 0) ? b[z2 >> 2] | 0 : f2) << 2) >> 2] | 0) {
              case 1: {
                a2 = u5;
                f2 = t4;
                break;
              }
              case 3: {
                a2 = v3;
                f2 = u5;
                break;
              }
              case 2: {
                a2 = t4;
                f2 = v3;
                break;
              }
              default: {
                a2 = 8;
                break a;
              }
            }
            kd(A6, s2, f2, a2, w4);
            if (!(ld(A6, w4) | 0) ? !(ld(s2, w4) | 0) : 0) {
              tb(w4, b[x2 >> 2] | 0, k, 1, g2 + 8 + (b[g2 >> 2] << 4) | 0);
              b[g2 >> 2] = (b[g2 >> 2] | 0) + 1;
            }
          }
          if ((j | 0) < (l | 0)) {
            Na(q2, A6);
            tb(A6, b[z2 >> 2] | 0, k, 1, g2 + 8 + (b[g2 >> 2] << 4) | 0);
            b[g2 >> 2] = (b[g2 >> 2] | 0) + 1;
          }
          j = j + 1 | 0;
          if ((j | 0) >= (r2 | 0)) {
            a2 = 3;
            break;
          } else {
            f2 = b[z2 >> 2] | 0;
          }
        }
        if ((a2 | 0) == 3) {
          T2 = B5;
          return;
        } else if ((a2 | 0) == 8) {
          I(27054, 27017, 737, 27099);
        }
      }
      function Ab(a2, c4, d2) {
        a2 = a2 | 0;
        c4 = c4 | 0;
        d2 = d2 | 0;
        var e3 = 0, f2 = 0, g2 = 0, h = 0, i = 0, j = 0;
        j = T2;
        T2 = T2 + 160 | 0;
        e3 = j + 80 | 0;
        f2 = j;
        g2 = e3;
        h = 20368;
        i = g2 + 72 | 0;
        do {
          b[g2 >> 2] = b[h >> 2];
          g2 = g2 + 4 | 0;
          h = h + 4 | 0;
        } while ((g2 | 0) < (i | 0));
        g2 = f2;
        h = 20448;
        i = g2 + 72 | 0;
        do {
          b[g2 >> 2] = b[h >> 2];
          g2 = g2 + 4 | 0;
          h = h + 4 | 0;
        } while ((g2 | 0) < (i | 0));
        i = (Vb(b[c4 >> 2] | 0) | 0) == 0;
        e3 = i ? e3 : f2;
        f2 = a2 + 4 | 0;
        bb2(f2);
        cb(f2);
        if (Vb(b[c4 >> 2] | 0) | 0) {
          Xa(f2);
          b[c4 >> 2] = (b[c4 >> 2] | 0) + 1;
        }
        b[d2 >> 2] = b[a2 >> 2];
        c4 = d2 + 4 | 0;
        Oa(f2, e3, c4);
        Ma(c4);
        b[d2 + 16 >> 2] = b[a2 >> 2];
        c4 = d2 + 20 | 0;
        Oa(f2, e3 + 12 | 0, c4);
        Ma(c4);
        b[d2 + 32 >> 2] = b[a2 >> 2];
        c4 = d2 + 36 | 0;
        Oa(f2, e3 + 24 | 0, c4);
        Ma(c4);
        b[d2 + 48 >> 2] = b[a2 >> 2];
        c4 = d2 + 52 | 0;
        Oa(f2, e3 + 36 | 0, c4);
        Ma(c4);
        b[d2 + 64 >> 2] = b[a2 >> 2];
        c4 = d2 + 68 | 0;
        Oa(f2, e3 + 48 | 0, c4);
        Ma(c4);
        b[d2 + 80 >> 2] = b[a2 >> 2];
        d2 = d2 + 84 | 0;
        Oa(f2, e3 + 60 | 0, d2);
        Ma(d2);
        T2 = j;
        return;
      }
      function Bb(a2, b2) {
        a2 = a2 | 0;
        b2 = b2 | 0;
        b2 = Qd(a2 | 0, b2 | 0, 52) | 0;
        H() | 0;
        return b2 & 15 | 0;
      }
      function Cb(a2, b2) {
        a2 = a2 | 0;
        b2 = b2 | 0;
        b2 = Qd(a2 | 0, b2 | 0, 45) | 0;
        H() | 0;
        return b2 & 127 | 0;
      }
      function Db(b2, c4) {
        b2 = b2 | 0;
        c4 = c4 | 0;
        var d2 = 0, e3 = 0, f2 = 0, g2 = 0, h = 0;
        if (!(true & (c4 & -16777216 | 0) == 134217728)) {
          b2 = 0;
          return b2 | 0;
        }
        e3 = Qd(b2 | 0, c4 | 0, 52) | 0;
        H() | 0;
        e3 = e3 & 15;
        d2 = Qd(b2 | 0, c4 | 0, 45) | 0;
        H() | 0;
        d2 = d2 & 127;
        if (d2 >>> 0 > 121) {
          b2 = 0;
          return b2 | 0;
        }
        h = (e3 ^ 15) * 3 | 0;
        f2 = Qd(b2 | 0, c4 | 0, h | 0) | 0;
        h = Rd(f2 | 0, H() | 0, h | 0) | 0;
        f2 = H() | 0;
        g2 = Hd(-1227133514, -1171, h | 0, f2 | 0) | 0;
        if (!((h & 613566756 & g2 | 0) == 0 & (f2 & 4681 & (H() | 0) | 0) == 0)) {
          h = 0;
          return h | 0;
        }
        h = (e3 * 3 | 0) + 19 | 0;
        g2 = Rd(~b2 | 0, ~c4 | 0, h | 0) | 0;
        h = Qd(g2 | 0, H() | 0, h | 0) | 0;
        if (!((e3 | 0) == 15 | (h | 0) == 0 & (H() | 0) == 0)) {
          h = 0;
          return h | 0;
        }
        if (!(a[20528 + d2 >> 0] | 0)) {
          h = 1;
          return h | 0;
        }
        c4 = c4 & 8191;
        if ((b2 | 0) == 0 & (c4 | 0) == 0) {
          h = 1;
          return h | 0;
        } else {
          h = Sd(b2 | 0, c4 | 0, 0) | 0;
          H() | 0;
          return ((63 - h | 0) % 3 | 0 | 0) != 0 | 0;
        }
        return 0;
      }
      function Eb(a2, c4, d2, e3) {
        a2 = a2 | 0;
        c4 = c4 | 0;
        d2 = d2 | 0;
        e3 = e3 | 0;
        var f2 = 0, g2 = 0, h = 0, i = 0;
        f2 = Rd(c4 | 0, 0, 52) | 0;
        g2 = H() | 0;
        d2 = Rd(d2 | 0, 0, 45) | 0;
        d2 = g2 | (H() | 0) | 134225919;
        if ((c4 | 0) < 1) {
          g2 = -1;
          e3 = d2;
          c4 = a2;
          b[c4 >> 2] = g2;
          a2 = a2 + 4 | 0;
          b[a2 >> 2] = e3;
          return;
        }
        g2 = 1;
        f2 = -1;
        while (1) {
          h = (15 - g2 | 0) * 3 | 0;
          i = Rd(7, 0, h | 0) | 0;
          d2 = d2 & ~(H() | 0);
          h = Rd(e3 | 0, 0, h | 0) | 0;
          f2 = f2 & ~i | h;
          d2 = d2 | (H() | 0);
          if ((g2 | 0) == (c4 | 0)) {
            break;
          } else {
            g2 = g2 + 1 | 0;
          }
        }
        i = a2;
        h = i;
        b[h >> 2] = f2;
        i = i + 4 | 0;
        b[i >> 2] = d2;
        return;
      }
      function Fb(a2, c4, d2, e3) {
        a2 = a2 | 0;
        c4 = c4 | 0;
        d2 = d2 | 0;
        e3 = e3 | 0;
        var f2 = 0, g2 = 0;
        g2 = Qd(a2 | 0, c4 | 0, 52) | 0;
        H() | 0;
        g2 = g2 & 15;
        if (d2 >>> 0 > 15) {
          e3 = 4;
          return e3 | 0;
        }
        if ((g2 | 0) < (d2 | 0)) {
          e3 = 12;
          return e3 | 0;
        }
        if ((g2 | 0) == (d2 | 0)) {
          b[e3 >> 2] = a2;
          b[e3 + 4 >> 2] = c4;
          e3 = 0;
          return e3 | 0;
        }
        f2 = Rd(d2 | 0, 0, 52) | 0;
        f2 = f2 | a2;
        a2 = H() | 0 | c4 & -15728641;
        if ((g2 | 0) > (d2 | 0)) {
          do {
            c4 = Rd(7, 0, (14 - d2 | 0) * 3 | 0) | 0;
            d2 = d2 + 1 | 0;
            f2 = c4 | f2;
            a2 = H() | 0 | a2;
          } while ((d2 | 0) < (g2 | 0));
        }
        b[e3 >> 2] = f2;
        b[e3 + 4 >> 2] = a2;
        e3 = 0;
        return e3 | 0;
      }
      function Gb(a2, c4, d2, e3) {
        a2 = a2 | 0;
        c4 = c4 | 0;
        d2 = d2 | 0;
        e3 = e3 | 0;
        var f2 = 0, g2 = 0, h = 0;
        g2 = Qd(a2 | 0, c4 | 0, 52) | 0;
        H() | 0;
        g2 = g2 & 15;
        if (!((d2 | 0) < 16 & (g2 | 0) <= (d2 | 0))) {
          e3 = 4;
          return e3 | 0;
        }
        f2 = d2 - g2 | 0;
        d2 = Qd(a2 | 0, c4 | 0, 45) | 0;
        H() | 0;
        a: do {
          if (!(oa(d2 & 127) | 0)) {
            d2 = Oc(7, 0, f2, ((f2 | 0) < 0) << 31 >> 31) | 0;
            f2 = H() | 0;
          } else {
            b: do {
              if (g2 | 0) {
                d2 = 1;
                while (1) {
                  h = Rd(7, 0, (15 - d2 | 0) * 3 | 0) | 0;
                  if (!((h & a2 | 0) == 0 & ((H() | 0) & c4 | 0) == 0)) {
                    break;
                  }
                  if (d2 >>> 0 < g2 >>> 0) {
                    d2 = d2 + 1 | 0;
                  } else {
                    break b;
                  }
                }
                d2 = Oc(7, 0, f2, ((f2 | 0) < 0) << 31 >> 31) | 0;
                f2 = H() | 0;
                break a;
              }
            } while (0);
            d2 = Oc(7, 0, f2, ((f2 | 0) < 0) << 31 >> 31) | 0;
            d2 = Md(d2 | 0, H() | 0, 5, 0) | 0;
            d2 = Gd(d2 | 0, H() | 0, -5, -1) | 0;
            d2 = Kd(d2 | 0, H() | 0, 6, 0) | 0;
            d2 = Gd(d2 | 0, H() | 0, 1, 0) | 0;
            f2 = H() | 0;
          }
        } while (0);
        h = e3;
        b[h >> 2] = d2;
        b[h + 4 >> 2] = f2;
        h = 0;
        return h | 0;
      }
      function Hb(a2, b2) {
        a2 = a2 | 0;
        b2 = b2 | 0;
        var c4 = 0, d2 = 0, e3 = 0;
        e3 = Qd(a2 | 0, b2 | 0, 45) | 0;
        H() | 0;
        if (!(oa(e3 & 127) | 0)) {
          e3 = 0;
          return e3 | 0;
        }
        e3 = Qd(a2 | 0, b2 | 0, 52) | 0;
        H() | 0;
        e3 = e3 & 15;
        a: do {
          if (!e3) {
            c4 = 0;
          } else {
            d2 = 1;
            while (1) {
              c4 = Qd(a2 | 0, b2 | 0, (15 - d2 | 0) * 3 | 0) | 0;
              H() | 0;
              c4 = c4 & 7;
              if (c4 | 0) {
                break a;
              }
              if (d2 >>> 0 < e3 >>> 0) {
                d2 = d2 + 1 | 0;
              } else {
                c4 = 0;
                break;
              }
            }
          }
        } while (0);
        e3 = (c4 | 0) == 0 & 1;
        return e3 | 0;
      }
      function Ib(a2, c4, d2, e3) {
        a2 = a2 | 0;
        c4 = c4 | 0;
        d2 = d2 | 0;
        e3 = e3 | 0;
        var f2 = 0, g2 = 0, h = 0, i = 0;
        h = T2;
        T2 = T2 + 16 | 0;
        g2 = h;
        fc(g2, a2, c4, d2);
        c4 = g2;
        a2 = b[c4 >> 2] | 0;
        c4 = b[c4 + 4 >> 2] | 0;
        if ((a2 | 0) == 0 & (c4 | 0) == 0) {
          T2 = h;
          return 0;
        }
        f2 = 0;
        d2 = 0;
        do {
          i = e3 + (f2 << 3) | 0;
          b[i >> 2] = a2;
          b[i + 4 >> 2] = c4;
          f2 = Gd(f2 | 0, d2 | 0, 1, 0) | 0;
          d2 = H() | 0;
          hc(g2);
          i = g2;
          a2 = b[i >> 2] | 0;
          c4 = b[i + 4 >> 2] | 0;
        } while (!((a2 | 0) == 0 & (c4 | 0) == 0));
        T2 = h;
        return 0;
      }
      function Jb(a2, b2, c4, d2) {
        a2 = a2 | 0;
        b2 = b2 | 0;
        c4 = c4 | 0;
        d2 = d2 | 0;
        if ((d2 | 0) < (c4 | 0)) {
          c4 = b2;
          d2 = a2;
          G(c4 | 0);
          return d2 | 0;
        }
        c4 = Rd(-1, -1, ((d2 - c4 | 0) * 3 | 0) + 3 | 0) | 0;
        d2 = Rd(~c4 | 0, ~(H() | 0) | 0, (15 - d2 | 0) * 3 | 0) | 0;
        c4 = ~(H() | 0) & b2;
        d2 = ~d2 & a2;
        G(c4 | 0);
        return d2 | 0;
      }
      function Kb(a2, c4, d2, e3) {
        a2 = a2 | 0;
        c4 = c4 | 0;
        d2 = d2 | 0;
        e3 = e3 | 0;
        var f2 = 0;
        f2 = Qd(a2 | 0, c4 | 0, 52) | 0;
        H() | 0;
        f2 = f2 & 15;
        if (!((d2 | 0) < 16 & (f2 | 0) <= (d2 | 0))) {
          e3 = 4;
          return e3 | 0;
        }
        if ((f2 | 0) < (d2 | 0)) {
          f2 = Rd(-1, -1, ((d2 + -1 - f2 | 0) * 3 | 0) + 3 | 0) | 0;
          f2 = Rd(~f2 | 0, ~(H() | 0) | 0, (15 - d2 | 0) * 3 | 0) | 0;
          c4 = ~(H() | 0) & c4;
          a2 = ~f2 & a2;
        }
        f2 = Rd(d2 | 0, 0, 52) | 0;
        d2 = c4 & -15728641 | (H() | 0);
        b[e3 >> 2] = a2 | f2;
        b[e3 + 4 >> 2] = d2;
        e3 = 0;
        return e3 | 0;
      }
      function Lb(a2, c4, d2, e3) {
        a2 = a2 | 0;
        c4 = c4 | 0;
        d2 = d2 | 0;
        e3 = e3 | 0;
        var f2 = 0, g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p2 = 0, q2 = 0, r2 = 0, s2 = 0, t4 = 0, u5 = 0, v3 = 0, w4 = 0, x2 = 0, y2 = 0, z2 = 0, A6 = 0, B5 = 0, C4 = 0, D4 = 0, E3 = 0;
        if ((d2 | 0) == 0 & (e3 | 0) == 0) {
          E3 = 0;
          return E3 | 0;
        }
        f2 = a2;
        g2 = b[f2 >> 2] | 0;
        f2 = b[f2 + 4 >> 2] | 0;
        if (true & (f2 & 15728640 | 0) == 0) {
          if (!((e3 | 0) > 0 | (e3 | 0) == 0 & d2 >>> 0 > 0)) {
            E3 = 0;
            return E3 | 0;
          }
          E3 = c4;
          b[E3 >> 2] = g2;
          b[E3 + 4 >> 2] = f2;
          if ((d2 | 0) == 1 & (e3 | 0) == 0) {
            E3 = 0;
            return E3 | 0;
          }
          f2 = 1;
          g2 = 0;
          do {
            C4 = a2 + (f2 << 3) | 0;
            D4 = b[C4 + 4 >> 2] | 0;
            E3 = c4 + (f2 << 3) | 0;
            b[E3 >> 2] = b[C4 >> 2];
            b[E3 + 4 >> 2] = D4;
            f2 = Gd(f2 | 0, g2 | 0, 1, 0) | 0;
            g2 = H() | 0;
          } while ((g2 | 0) < (e3 | 0) | (g2 | 0) == (e3 | 0) & f2 >>> 0 < d2 >>> 0);
          f2 = 0;
          return f2 | 0;
        }
        B5 = d2 << 3;
        D4 = Dd(B5) | 0;
        if (!D4) {
          E3 = 13;
          return E3 | 0;
        }
        Wd(D4 | 0, a2 | 0, B5 | 0) | 0;
        C4 = Fd(d2, 8) | 0;
        if (!C4) {
          Ed(D4);
          E3 = 13;
          return E3 | 0;
        }
        a: while (1) {
          f2 = D4;
          k = b[f2 >> 2] | 0;
          f2 = b[f2 + 4 >> 2] | 0;
          z2 = Qd(k | 0, f2 | 0, 52) | 0;
          H() | 0;
          z2 = z2 & 15;
          A6 = z2 + -1 | 0;
          y2 = (z2 | 0) != 0;
          x2 = (e3 | 0) > 0 | (e3 | 0) == 0 & d2 >>> 0 > 0;
          b: do {
            if (y2 & x2) {
              t4 = Rd(A6 | 0, 0, 52) | 0;
              u5 = H() | 0;
              if (A6 >>> 0 > 15) {
                if (!((k | 0) == 0 & (f2 | 0) == 0)) {
                  E3 = 16;
                  break a;
                }
                g2 = 0;
                a2 = 0;
                while (1) {
                  g2 = Gd(g2 | 0, a2 | 0, 1, 0) | 0;
                  a2 = H() | 0;
                  if (!((a2 | 0) < (e3 | 0) | (a2 | 0) == (e3 | 0) & g2 >>> 0 < d2 >>> 0)) {
                    break b;
                  }
                  h = D4 + (g2 << 3) | 0;
                  w4 = b[h >> 2] | 0;
                  h = b[h + 4 >> 2] | 0;
                  if (!((w4 | 0) == 0 & (h | 0) == 0)) {
                    f2 = h;
                    E3 = 16;
                    break a;
                  }
                }
              }
              i = k;
              a2 = f2;
              g2 = 0;
              h = 0;
              while (1) {
                if (!((i | 0) == 0 & (a2 | 0) == 0)) {
                  if (!(true & (a2 & 117440512 | 0) == 0)) {
                    E3 = 21;
                    break a;
                  }
                  l = Qd(i | 0, a2 | 0, 52) | 0;
                  H() | 0;
                  l = l & 15;
                  if ((l | 0) < (A6 | 0)) {
                    f2 = 12;
                    E3 = 27;
                    break a;
                  }
                  if ((l | 0) != (A6 | 0)) {
                    i = i | t4;
                    a2 = a2 & -15728641 | u5;
                    if (l >>> 0 >= z2 >>> 0) {
                      j = A6;
                      do {
                        w4 = Rd(7, 0, (14 - j | 0) * 3 | 0) | 0;
                        j = j + 1 | 0;
                        i = w4 | i;
                        a2 = H() | 0 | a2;
                      } while (j >>> 0 < l >>> 0);
                    }
                  }
                  n = Od(i | 0, a2 | 0, d2 | 0, e3 | 0) | 0;
                  o = H() | 0;
                  j = C4 + (n << 3) | 0;
                  l = j;
                  m = b[l >> 2] | 0;
                  l = b[l + 4 >> 2] | 0;
                  if (!((m | 0) == 0 & (l | 0) == 0)) {
                    r2 = 0;
                    s2 = 0;
                    do {
                      if ((r2 | 0) > (e3 | 0) | (r2 | 0) == (e3 | 0) & s2 >>> 0 > d2 >>> 0) {
                        E3 = 31;
                        break a;
                      }
                      if ((m | 0) == (i | 0) & (l & -117440513 | 0) == (a2 | 0)) {
                        p2 = Qd(m | 0, l | 0, 56) | 0;
                        H() | 0;
                        p2 = p2 & 7;
                        q2 = p2 + 1 | 0;
                        w4 = Qd(m | 0, l | 0, 45) | 0;
                        H() | 0;
                        c: do {
                          if (!(oa(w4 & 127) | 0)) {
                            l = 7;
                          } else {
                            m = Qd(m | 0, l | 0, 52) | 0;
                            H() | 0;
                            m = m & 15;
                            if (!m) {
                              l = 6;
                              break;
                            }
                            l = 1;
                            while (1) {
                              w4 = Rd(7, 0, (15 - l | 0) * 3 | 0) | 0;
                              if (!((w4 & i | 0) == 0 & ((H() | 0) & a2 | 0) == 0)) {
                                l = 7;
                                break c;
                              }
                              if (l >>> 0 < m >>> 0) {
                                l = l + 1 | 0;
                              } else {
                                l = 6;
                                break;
                              }
                            }
                          }
                        } while (0);
                        if ((p2 + 2 | 0) >>> 0 > l >>> 0) {
                          E3 = 41;
                          break a;
                        }
                        w4 = Rd(q2 | 0, 0, 56) | 0;
                        a2 = H() | 0 | a2 & -117440513;
                        v3 = j;
                        b[v3 >> 2] = 0;
                        b[v3 + 4 >> 2] = 0;
                        i = w4 | i;
                      } else {
                        n = Gd(n | 0, o | 0, 1, 0) | 0;
                        n = Nd(n | 0, H() | 0, d2 | 0, e3 | 0) | 0;
                        o = H() | 0;
                      }
                      s2 = Gd(s2 | 0, r2 | 0, 1, 0) | 0;
                      r2 = H() | 0;
                      j = C4 + (n << 3) | 0;
                      l = j;
                      m = b[l >> 2] | 0;
                      l = b[l + 4 >> 2] | 0;
                    } while (!((m | 0) == 0 & (l | 0) == 0));
                  }
                  w4 = j;
                  b[w4 >> 2] = i;
                  b[w4 + 4 >> 2] = a2;
                }
                g2 = Gd(g2 | 0, h | 0, 1, 0) | 0;
                h = H() | 0;
                if (!((h | 0) < (e3 | 0) | (h | 0) == (e3 | 0) & g2 >>> 0 < d2 >>> 0)) {
                  break b;
                }
                a2 = D4 + (g2 << 3) | 0;
                i = b[a2 >> 2] | 0;
                a2 = b[a2 + 4 >> 2] | 0;
              }
            }
          } while (0);
          w4 = Gd(d2 | 0, e3 | 0, 5, 0) | 0;
          v3 = H() | 0;
          if (v3 >>> 0 < 0 | (v3 | 0) == 0 & w4 >>> 0 < 11) {
            E3 = 85;
            break;
          }
          w4 = Kd(d2 | 0, e3 | 0, 6, 0) | 0;
          H() | 0;
          w4 = Fd(w4, 8) | 0;
          if (!w4) {
            E3 = 48;
            break;
          }
          do {
            if (x2) {
              q2 = 0;
              a2 = 0;
              p2 = 0;
              r2 = 0;
              while (1) {
                l = C4 + (q2 << 3) | 0;
                h = l;
                g2 = b[h >> 2] | 0;
                h = b[h + 4 >> 2] | 0;
                if (!((g2 | 0) == 0 & (h | 0) == 0)) {
                  m = Qd(g2 | 0, h | 0, 56) | 0;
                  H() | 0;
                  m = m & 7;
                  i = m + 1 | 0;
                  n = h & -117440513;
                  v3 = Qd(g2 | 0, h | 0, 45) | 0;
                  H() | 0;
                  d: do {
                    if (oa(v3 & 127) | 0) {
                      o = Qd(g2 | 0, h | 0, 52) | 0;
                      H() | 0;
                      o = o & 15;
                      if (o | 0) {
                        j = 1;
                        while (1) {
                          v3 = Rd(7, 0, (15 - j | 0) * 3 | 0) | 0;
                          if (!((g2 & v3 | 0) == 0 & (n & (H() | 0) | 0) == 0)) {
                            break d;
                          }
                          if (j >>> 0 < o >>> 0) {
                            j = j + 1 | 0;
                          } else {
                            break;
                          }
                        }
                      }
                      h = Rd(i | 0, 0, 56) | 0;
                      g2 = h | g2;
                      h = H() | 0 | n;
                      i = l;
                      b[i >> 2] = g2;
                      b[i + 4 >> 2] = h;
                      i = m + 2 | 0;
                    }
                  } while (0);
                  if ((i | 0) == 7) {
                    v3 = w4 + (a2 << 3) | 0;
                    b[v3 >> 2] = g2;
                    b[v3 + 4 >> 2] = h & -117440513;
                    a2 = Gd(a2 | 0, p2 | 0, 1, 0) | 0;
                    v3 = H() | 0;
                  } else {
                    v3 = p2;
                  }
                } else {
                  v3 = p2;
                }
                q2 = Gd(q2 | 0, r2 | 0, 1, 0) | 0;
                r2 = H() | 0;
                if (!((r2 | 0) < (e3 | 0) | (r2 | 0) == (e3 | 0) & q2 >>> 0 < d2 >>> 0)) {
                  break;
                } else {
                  p2 = v3;
                }
              }
              if (x2) {
                s2 = A6 >>> 0 > 15;
                t4 = Rd(A6 | 0, 0, 52) | 0;
                u5 = H() | 0;
                if (!y2) {
                  g2 = 0;
                  j = 0;
                  i = 0;
                  h = 0;
                  while (1) {
                    if (!((k | 0) == 0 & (f2 | 0) == 0)) {
                      A6 = c4 + (g2 << 3) | 0;
                      b[A6 >> 2] = k;
                      b[A6 + 4 >> 2] = f2;
                      g2 = Gd(g2 | 0, j | 0, 1, 0) | 0;
                      j = H() | 0;
                    }
                    i = Gd(i | 0, h | 0, 1, 0) | 0;
                    h = H() | 0;
                    if (!((h | 0) < (e3 | 0) | (h | 0) == (e3 | 0) & i >>> 0 < d2 >>> 0)) {
                      break;
                    }
                    f2 = D4 + (i << 3) | 0;
                    k = b[f2 >> 2] | 0;
                    f2 = b[f2 + 4 >> 2] | 0;
                  }
                  f2 = v3;
                  break;
                }
                g2 = 0;
                j = 0;
                h = 0;
                i = 0;
                while (1) {
                  do {
                    if (!((k | 0) == 0 & (f2 | 0) == 0)) {
                      o = Qd(k | 0, f2 | 0, 52) | 0;
                      H() | 0;
                      o = o & 15;
                      if (s2 | (o | 0) < (A6 | 0)) {
                        E3 = 80;
                        break a;
                      }
                      if ((o | 0) != (A6 | 0)) {
                        l = k | t4;
                        m = f2 & -15728641 | u5;
                        if (o >>> 0 >= z2 >>> 0) {
                          n = A6;
                          do {
                            y2 = Rd(7, 0, (14 - n | 0) * 3 | 0) | 0;
                            n = n + 1 | 0;
                            l = y2 | l;
                            m = H() | 0 | m;
                          } while (n >>> 0 < o >>> 0);
                        }
                      } else {
                        l = k;
                        m = f2;
                      }
                      p2 = Od(l | 0, m | 0, d2 | 0, e3 | 0) | 0;
                      n = 0;
                      o = 0;
                      r2 = H() | 0;
                      do {
                        if ((n | 0) > (e3 | 0) | (n | 0) == (e3 | 0) & o >>> 0 > d2 >>> 0) {
                          E3 = 81;
                          break a;
                        }
                        y2 = C4 + (p2 << 3) | 0;
                        q2 = b[y2 + 4 >> 2] | 0;
                        if ((q2 & -117440513 | 0) == (m | 0) ? (b[y2 >> 2] | 0) == (l | 0) : 0) {
                          E3 = 65;
                          break;
                        }
                        y2 = Gd(p2 | 0, r2 | 0, 1, 0) | 0;
                        p2 = Nd(y2 | 0, H() | 0, d2 | 0, e3 | 0) | 0;
                        r2 = H() | 0;
                        o = Gd(o | 0, n | 0, 1, 0) | 0;
                        n = H() | 0;
                        y2 = C4 + (p2 << 3) | 0;
                      } while (!((b[y2 >> 2] | 0) == (l | 0) ? (b[y2 + 4 >> 2] | 0) == (m | 0) : 0));
                      if ((E3 | 0) == 65 ? (E3 = 0, true & (q2 & 117440512 | 0) == 100663296) : 0) {
                        break;
                      }
                      y2 = c4 + (g2 << 3) | 0;
                      b[y2 >> 2] = k;
                      b[y2 + 4 >> 2] = f2;
                      g2 = Gd(g2 | 0, j | 0, 1, 0) | 0;
                      j = H() | 0;
                    }
                  } while (0);
                  h = Gd(h | 0, i | 0, 1, 0) | 0;
                  i = H() | 0;
                  if (!((i | 0) < (e3 | 0) | (i | 0) == (e3 | 0) & h >>> 0 < d2 >>> 0)) {
                    break;
                  }
                  f2 = D4 + (h << 3) | 0;
                  k = b[f2 >> 2] | 0;
                  f2 = b[f2 + 4 >> 2] | 0;
                }
                f2 = v3;
              } else {
                g2 = 0;
                f2 = v3;
              }
            } else {
              g2 = 0;
              a2 = 0;
              f2 = 0;
            }
          } while (0);
          Xd(C4 | 0, 0, B5 | 0) | 0;
          Wd(D4 | 0, w4 | 0, a2 << 3 | 0) | 0;
          Ed(w4);
          if ((a2 | 0) == 0 & (f2 | 0) == 0) {
            E3 = 89;
            break;
          } else {
            c4 = c4 + (g2 << 3) | 0;
            e3 = f2;
            d2 = a2;
          }
        }
        if ((E3 | 0) == 16) {
          if (true & (f2 & 117440512 | 0) == 0) {
            f2 = 4;
            E3 = 27;
          } else {
            E3 = 21;
          }
        } else if ((E3 | 0) == 31) {
          I(27795, 27122, 529, 27132);
        } else if ((E3 | 0) == 41) {
          Ed(D4);
          Ed(C4);
          E3 = 10;
          return E3 | 0;
        } else if ((E3 | 0) == 48) {
          Ed(D4);
          Ed(C4);
          E3 = 13;
          return E3 | 0;
        } else if ((E3 | 0) == 80) {
          I(27795, 27122, 620, 27132);
        } else if ((E3 | 0) == 81) {
          I(27795, 27122, 632, 27132);
        } else if ((E3 | 0) == 85) {
          Wd(c4 | 0, D4 | 0, d2 << 3 | 0) | 0;
          E3 = 89;
        }
        if ((E3 | 0) == 21) {
          Ed(D4);
          Ed(C4);
          E3 = 5;
          return E3 | 0;
        } else if ((E3 | 0) == 27) {
          Ed(D4);
          Ed(C4);
          E3 = f2;
          return E3 | 0;
        } else if ((E3 | 0) == 89) {
          Ed(D4);
          Ed(C4);
          E3 = 0;
          return E3 | 0;
        }
        return 0;
      }
      function Mb(a2, c4, d2, e3, f2, g2, h) {
        a2 = a2 | 0;
        c4 = c4 | 0;
        d2 = d2 | 0;
        e3 = e3 | 0;
        f2 = f2 | 0;
        g2 = g2 | 0;
        h = h | 0;
        var i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p2 = 0, q2 = 0;
        q2 = T2;
        T2 = T2 + 16 | 0;
        p2 = q2;
        if (!((d2 | 0) > 0 | (d2 | 0) == 0 & c4 >>> 0 > 0)) {
          p2 = 0;
          T2 = q2;
          return p2 | 0;
        }
        if ((h | 0) >= 16) {
          p2 = 12;
          T2 = q2;
          return p2 | 0;
        }
        n = 0;
        o = 0;
        m = 0;
        i = 0;
        a: while (1) {
          k = a2 + (n << 3) | 0;
          j = b[k >> 2] | 0;
          k = b[k + 4 >> 2] | 0;
          l = Qd(j | 0, k | 0, 52) | 0;
          H() | 0;
          if ((l & 15 | 0) > (h | 0)) {
            i = 12;
            j = 11;
            break;
          }
          fc(p2, j, k, h);
          l = p2;
          k = b[l >> 2] | 0;
          l = b[l + 4 >> 2] | 0;
          if ((k | 0) == 0 & (l | 0) == 0) {
            j = m;
          } else {
            j = m;
            do {
              if (!((i | 0) < (g2 | 0) | (i | 0) == (g2 | 0) & j >>> 0 < f2 >>> 0)) {
                j = 10;
                break a;
              }
              m = e3 + (j << 3) | 0;
              b[m >> 2] = k;
              b[m + 4 >> 2] = l;
              j = Gd(j | 0, i | 0, 1, 0) | 0;
              i = H() | 0;
              hc(p2);
              m = p2;
              k = b[m >> 2] | 0;
              l = b[m + 4 >> 2] | 0;
            } while (!((k | 0) == 0 & (l | 0) == 0));
          }
          n = Gd(n | 0, o | 0, 1, 0) | 0;
          o = H() | 0;
          if (!((o | 0) < (d2 | 0) | (o | 0) == (d2 | 0) & n >>> 0 < c4 >>> 0)) {
            i = 0;
            j = 11;
            break;
          } else {
            m = j;
          }
        }
        if ((j | 0) == 10) {
          p2 = 14;
          T2 = q2;
          return p2 | 0;
        } else if ((j | 0) == 11) {
          T2 = q2;
          return i | 0;
        }
        return 0;
      }
      function Nb(a2, c4, d2, e3, f2) {
        a2 = a2 | 0;
        c4 = c4 | 0;
        d2 = d2 | 0;
        e3 = e3 | 0;
        f2 = f2 | 0;
        var g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0;
        n = T2;
        T2 = T2 + 16 | 0;
        m = n;
        a: do {
          if ((d2 | 0) > 0 | (d2 | 0) == 0 & c4 >>> 0 > 0) {
            k = 0;
            h = 0;
            g2 = 0;
            l = 0;
            while (1) {
              j = a2 + (k << 3) | 0;
              i = b[j >> 2] | 0;
              j = b[j + 4 >> 2] | 0;
              if (!((i | 0) == 0 & (j | 0) == 0)) {
                j = (Gb(i, j, e3, m) | 0) == 0;
                i = m;
                h = Gd(b[i >> 2] | 0, b[i + 4 >> 2] | 0, h | 0, g2 | 0) | 0;
                g2 = H() | 0;
                if (!j) {
                  g2 = 12;
                  break;
                }
              }
              k = Gd(k | 0, l | 0, 1, 0) | 0;
              l = H() | 0;
              if (!((l | 0) < (d2 | 0) | (l | 0) == (d2 | 0) & k >>> 0 < c4 >>> 0)) {
                break a;
              }
            }
            T2 = n;
            return g2 | 0;
          } else {
            h = 0;
            g2 = 0;
          }
        } while (0);
        b[f2 >> 2] = h;
        b[f2 + 4 >> 2] = g2;
        f2 = 0;
        T2 = n;
        return f2 | 0;
      }
      function Ob(a2, b2) {
        a2 = a2 | 0;
        b2 = b2 | 0;
        b2 = Qd(a2 | 0, b2 | 0, 52) | 0;
        H() | 0;
        return b2 & 1 | 0;
      }
      function Pb(a2, b2) {
        a2 = a2 | 0;
        b2 = b2 | 0;
        var c4 = 0, d2 = 0, e3 = 0;
        e3 = Qd(a2 | 0, b2 | 0, 52) | 0;
        H() | 0;
        e3 = e3 & 15;
        if (!e3) {
          e3 = 0;
          return e3 | 0;
        }
        d2 = 1;
        while (1) {
          c4 = Qd(a2 | 0, b2 | 0, (15 - d2 | 0) * 3 | 0) | 0;
          H() | 0;
          c4 = c4 & 7;
          if (c4 | 0) {
            d2 = 5;
            break;
          }
          if (d2 >>> 0 < e3 >>> 0) {
            d2 = d2 + 1 | 0;
          } else {
            c4 = 0;
            d2 = 5;
            break;
          }
        }
        if ((d2 | 0) == 5) {
          return c4 | 0;
        }
        return 0;
      }
      function Qb(a2, b2) {
        a2 = a2 | 0;
        b2 = b2 | 0;
        var c4 = 0, d2 = 0, e3 = 0, f2 = 0, g2 = 0, h = 0, i = 0;
        i = Qd(a2 | 0, b2 | 0, 52) | 0;
        H() | 0;
        i = i & 15;
        if (!i) {
          h = b2;
          i = a2;
          G(h | 0);
          return i | 0;
        }
        h = 1;
        c4 = 0;
        while (1) {
          f2 = (15 - h | 0) * 3 | 0;
          d2 = Rd(7, 0, f2 | 0) | 0;
          e3 = H() | 0;
          g2 = Qd(a2 | 0, b2 | 0, f2 | 0) | 0;
          H() | 0;
          f2 = Rd($a(g2 & 7) | 0, 0, f2 | 0) | 0;
          g2 = H() | 0;
          a2 = f2 | a2 & ~d2;
          b2 = g2 | b2 & ~e3;
          a: do {
            if (!c4) {
              if (!((f2 & d2 | 0) == 0 & (g2 & e3 | 0) == 0)) {
                d2 = Qd(a2 | 0, b2 | 0, 52) | 0;
                H() | 0;
                d2 = d2 & 15;
                if (!d2) {
                  c4 = 1;
                } else {
                  c4 = 1;
                  b: while (1) {
                    g2 = Qd(a2 | 0, b2 | 0, (15 - c4 | 0) * 3 | 0) | 0;
                    H() | 0;
                    switch (g2 & 7) {
                      case 1:
                        break b;
                      case 0:
                        break;
                      default: {
                        c4 = 1;
                        break a;
                      }
                    }
                    if (c4 >>> 0 < d2 >>> 0) {
                      c4 = c4 + 1 | 0;
                    } else {
                      c4 = 1;
                      break a;
                    }
                  }
                  c4 = 1;
                  while (1) {
                    g2 = (15 - c4 | 0) * 3 | 0;
                    e3 = Qd(a2 | 0, b2 | 0, g2 | 0) | 0;
                    H() | 0;
                    f2 = Rd(7, 0, g2 | 0) | 0;
                    b2 = b2 & ~(H() | 0);
                    g2 = Rd($a(e3 & 7) | 0, 0, g2 | 0) | 0;
                    a2 = a2 & ~f2 | g2;
                    b2 = b2 | (H() | 0);
                    if (c4 >>> 0 < d2 >>> 0) {
                      c4 = c4 + 1 | 0;
                    } else {
                      c4 = 1;
                      break;
                    }
                  }
                }
              } else {
                c4 = 0;
              }
            }
          } while (0);
          if (h >>> 0 < i >>> 0) {
            h = h + 1 | 0;
          } else {
            break;
          }
        }
        G(b2 | 0);
        return a2 | 0;
      }
      function Rb(a2, b2) {
        a2 = a2 | 0;
        b2 = b2 | 0;
        var c4 = 0, d2 = 0, e3 = 0, f2 = 0, g2 = 0;
        d2 = Qd(a2 | 0, b2 | 0, 52) | 0;
        H() | 0;
        d2 = d2 & 15;
        if (!d2) {
          c4 = b2;
          d2 = a2;
          G(c4 | 0);
          return d2 | 0;
        }
        c4 = 1;
        while (1) {
          f2 = (15 - c4 | 0) * 3 | 0;
          g2 = Qd(a2 | 0, b2 | 0, f2 | 0) | 0;
          H() | 0;
          e3 = Rd(7, 0, f2 | 0) | 0;
          b2 = b2 & ~(H() | 0);
          f2 = Rd($a(g2 & 7) | 0, 0, f2 | 0) | 0;
          a2 = f2 | a2 & ~e3;
          b2 = H() | 0 | b2;
          if (c4 >>> 0 < d2 >>> 0) {
            c4 = c4 + 1 | 0;
          } else {
            break;
          }
        }
        G(b2 | 0);
        return a2 | 0;
      }
      function Sb(a2, b2) {
        a2 = a2 | 0;
        b2 = b2 | 0;
        var c4 = 0, d2 = 0, e3 = 0, f2 = 0, g2 = 0, h = 0, i = 0;
        i = Qd(a2 | 0, b2 | 0, 52) | 0;
        H() | 0;
        i = i & 15;
        if (!i) {
          h = b2;
          i = a2;
          G(h | 0);
          return i | 0;
        }
        h = 1;
        c4 = 0;
        while (1) {
          f2 = (15 - h | 0) * 3 | 0;
          d2 = Rd(7, 0, f2 | 0) | 0;
          e3 = H() | 0;
          g2 = Qd(a2 | 0, b2 | 0, f2 | 0) | 0;
          H() | 0;
          f2 = Rd(ab4(g2 & 7) | 0, 0, f2 | 0) | 0;
          g2 = H() | 0;
          a2 = f2 | a2 & ~d2;
          b2 = g2 | b2 & ~e3;
          a: do {
            if (!c4) {
              if (!((f2 & d2 | 0) == 0 & (g2 & e3 | 0) == 0)) {
                d2 = Qd(a2 | 0, b2 | 0, 52) | 0;
                H() | 0;
                d2 = d2 & 15;
                if (!d2) {
                  c4 = 1;
                } else {
                  c4 = 1;
                  b: while (1) {
                    g2 = Qd(a2 | 0, b2 | 0, (15 - c4 | 0) * 3 | 0) | 0;
                    H() | 0;
                    switch (g2 & 7) {
                      case 1:
                        break b;
                      case 0:
                        break;
                      default: {
                        c4 = 1;
                        break a;
                      }
                    }
                    if (c4 >>> 0 < d2 >>> 0) {
                      c4 = c4 + 1 | 0;
                    } else {
                      c4 = 1;
                      break a;
                    }
                  }
                  c4 = 1;
                  while (1) {
                    e3 = (15 - c4 | 0) * 3 | 0;
                    f2 = Rd(7, 0, e3 | 0) | 0;
                    g2 = b2 & ~(H() | 0);
                    b2 = Qd(a2 | 0, b2 | 0, e3 | 0) | 0;
                    H() | 0;
                    b2 = Rd(ab4(b2 & 7) | 0, 0, e3 | 0) | 0;
                    a2 = a2 & ~f2 | b2;
                    b2 = g2 | (H() | 0);
                    if (c4 >>> 0 < d2 >>> 0) {
                      c4 = c4 + 1 | 0;
                    } else {
                      c4 = 1;
                      break;
                    }
                  }
                }
              } else {
                c4 = 0;
              }
            }
          } while (0);
          if (h >>> 0 < i >>> 0) {
            h = h + 1 | 0;
          } else {
            break;
          }
        }
        G(b2 | 0);
        return a2 | 0;
      }
      function Tb(a2, b2) {
        a2 = a2 | 0;
        b2 = b2 | 0;
        var c4 = 0, d2 = 0, e3 = 0, f2 = 0, g2 = 0;
        d2 = Qd(a2 | 0, b2 | 0, 52) | 0;
        H() | 0;
        d2 = d2 & 15;
        if (!d2) {
          c4 = b2;
          d2 = a2;
          G(c4 | 0);
          return d2 | 0;
        }
        c4 = 1;
        while (1) {
          g2 = (15 - c4 | 0) * 3 | 0;
          f2 = Rd(7, 0, g2 | 0) | 0;
          e3 = b2 & ~(H() | 0);
          b2 = Qd(a2 | 0, b2 | 0, g2 | 0) | 0;
          H() | 0;
          b2 = Rd(ab4(b2 & 7) | 0, 0, g2 | 0) | 0;
          a2 = b2 | a2 & ~f2;
          b2 = H() | 0 | e3;
          if (c4 >>> 0 < d2 >>> 0) {
            c4 = c4 + 1 | 0;
          } else {
            break;
          }
        }
        G(b2 | 0);
        return a2 | 0;
      }
      function Ub(a2, c4) {
        a2 = a2 | 0;
        c4 = c4 | 0;
        var d2 = 0, e3 = 0, f2 = 0, g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0;
        j = T2;
        T2 = T2 + 64 | 0;
        i = j + 40 | 0;
        e3 = j + 24 | 0;
        f2 = j + 12 | 0;
        g2 = j;
        Rd(c4 | 0, 0, 52) | 0;
        d2 = H() | 0 | 134225919;
        if (!c4) {
          if ((b[a2 + 4 >> 2] | 0) > 2) {
            h = 0;
            i = 0;
            G(h | 0);
            T2 = j;
            return i | 0;
          }
          if ((b[a2 + 8 >> 2] | 0) > 2) {
            h = 0;
            i = 0;
            G(h | 0);
            T2 = j;
            return i | 0;
          }
          if ((b[a2 + 12 >> 2] | 0) > 2) {
            h = 0;
            i = 0;
            G(h | 0);
            T2 = j;
            return i | 0;
          }
          Rd(qa(a2) | 0, 0, 45) | 0;
          h = H() | 0 | d2;
          i = -1;
          G(h | 0);
          T2 = j;
          return i | 0;
        }
        b[i >> 2] = b[a2 >> 2];
        b[i + 4 >> 2] = b[a2 + 4 >> 2];
        b[i + 8 >> 2] = b[a2 + 8 >> 2];
        b[i + 12 >> 2] = b[a2 + 12 >> 2];
        h = i + 4 | 0;
        if ((c4 | 0) > 0) {
          a2 = -1;
          while (1) {
            b[e3 >> 2] = b[h >> 2];
            b[e3 + 4 >> 2] = b[h + 4 >> 2];
            b[e3 + 8 >> 2] = b[h + 8 >> 2];
            if (!(c4 & 1)) {
              Va(h);
              b[f2 >> 2] = b[h >> 2];
              b[f2 + 4 >> 2] = b[h + 4 >> 2];
              b[f2 + 8 >> 2] = b[h + 8 >> 2];
              Xa(f2);
            } else {
              Ua(h);
              b[f2 >> 2] = b[h >> 2];
              b[f2 + 4 >> 2] = b[h + 4 >> 2];
              b[f2 + 8 >> 2] = b[h + 8 >> 2];
              Wa(f2);
            }
            Pa(e3, f2, g2);
            Ma(g2);
            l = (15 - c4 | 0) * 3 | 0;
            k = Rd(7, 0, l | 0) | 0;
            d2 = d2 & ~(H() | 0);
            l = Rd(Ra(g2) | 0, 0, l | 0) | 0;
            a2 = l | a2 & ~k;
            d2 = H() | 0 | d2;
            if ((c4 | 0) > 1) {
              c4 = c4 + -1 | 0;
            } else {
              break;
            }
          }
        } else {
          a2 = -1;
        }
        a: do {
          if (((b[h >> 2] | 0) <= 2 ? (b[i + 8 >> 2] | 0) <= 2 : 0) ? (b[i + 12 >> 2] | 0) <= 2 : 0) {
            e3 = qa(i) | 0;
            c4 = Rd(e3 | 0, 0, 45) | 0;
            c4 = c4 | a2;
            a2 = H() | 0 | d2 & -1040385;
            g2 = ra(i) | 0;
            if (!(oa(e3) | 0)) {
              if ((g2 | 0) <= 0) {
                break;
              }
              f2 = 0;
              while (1) {
                e3 = Qd(c4 | 0, a2 | 0, 52) | 0;
                H() | 0;
                e3 = e3 & 15;
                if (e3) {
                  d2 = 1;
                  while (1) {
                    l = (15 - d2 | 0) * 3 | 0;
                    i = Qd(c4 | 0, a2 | 0, l | 0) | 0;
                    H() | 0;
                    k = Rd(7, 0, l | 0) | 0;
                    a2 = a2 & ~(H() | 0);
                    l = Rd($a(i & 7) | 0, 0, l | 0) | 0;
                    c4 = c4 & ~k | l;
                    a2 = a2 | (H() | 0);
                    if (d2 >>> 0 < e3 >>> 0) {
                      d2 = d2 + 1 | 0;
                    } else {
                      break;
                    }
                  }
                }
                f2 = f2 + 1 | 0;
                if ((f2 | 0) == (g2 | 0)) {
                  break a;
                }
              }
            }
            f2 = Qd(c4 | 0, a2 | 0, 52) | 0;
            H() | 0;
            f2 = f2 & 15;
            b: do {
              if (f2) {
                d2 = 1;
                c: while (1) {
                  l = Qd(c4 | 0, a2 | 0, (15 - d2 | 0) * 3 | 0) | 0;
                  H() | 0;
                  switch (l & 7) {
                    case 1:
                      break c;
                    case 0:
                      break;
                    default:
                      break b;
                  }
                  if (d2 >>> 0 < f2 >>> 0) {
                    d2 = d2 + 1 | 0;
                  } else {
                    break b;
                  }
                }
                if (ua(e3, b[i >> 2] | 0) | 0) {
                  d2 = 1;
                  while (1) {
                    i = (15 - d2 | 0) * 3 | 0;
                    k = Rd(7, 0, i | 0) | 0;
                    l = a2 & ~(H() | 0);
                    a2 = Qd(c4 | 0, a2 | 0, i | 0) | 0;
                    H() | 0;
                    a2 = Rd(ab4(a2 & 7) | 0, 0, i | 0) | 0;
                    c4 = c4 & ~k | a2;
                    a2 = l | (H() | 0);
                    if (d2 >>> 0 < f2 >>> 0) {
                      d2 = d2 + 1 | 0;
                    } else {
                      break;
                    }
                  }
                } else {
                  d2 = 1;
                  while (1) {
                    l = (15 - d2 | 0) * 3 | 0;
                    i = Qd(c4 | 0, a2 | 0, l | 0) | 0;
                    H() | 0;
                    k = Rd(7, 0, l | 0) | 0;
                    a2 = a2 & ~(H() | 0);
                    l = Rd($a(i & 7) | 0, 0, l | 0) | 0;
                    c4 = c4 & ~k | l;
                    a2 = a2 | (H() | 0);
                    if (d2 >>> 0 < f2 >>> 0) {
                      d2 = d2 + 1 | 0;
                    } else {
                      break;
                    }
                  }
                }
              }
            } while (0);
            if ((g2 | 0) > 0) {
              d2 = 0;
              do {
                c4 = Qb(c4, a2) | 0;
                a2 = H() | 0;
                d2 = d2 + 1 | 0;
              } while ((d2 | 0) != (g2 | 0));
            }
          } else {
            c4 = 0;
            a2 = 0;
          }
        } while (0);
        k = a2;
        l = c4;
        G(k | 0);
        T2 = j;
        return l | 0;
      }
      function Vb(a2) {
        a2 = a2 | 0;
        return (a2 | 0) % 2 | 0 | 0;
      }
      function Wb(a2, c4, d2) {
        a2 = a2 | 0;
        c4 = c4 | 0;
        d2 = d2 | 0;
        var e3 = 0, f2 = 0;
        f2 = T2;
        T2 = T2 + 16 | 0;
        e3 = f2;
        if (c4 >>> 0 > 15) {
          e3 = 4;
          T2 = f2;
          return e3 | 0;
        }
        if ((b[a2 + 4 >> 2] & 2146435072 | 0) == 2146435072) {
          e3 = 3;
          T2 = f2;
          return e3 | 0;
        }
        if ((b[a2 + 8 + 4 >> 2] & 2146435072 | 0) == 2146435072) {
          e3 = 3;
          T2 = f2;
          return e3 | 0;
        }
        qb(a2, c4, e3);
        c4 = Ub(e3, c4) | 0;
        e3 = H() | 0;
        b[d2 >> 2] = c4;
        b[d2 + 4 >> 2] = e3;
        if ((c4 | 0) == 0 & (e3 | 0) == 0) {
          I(27795, 27122, 959, 27145);
        }
        e3 = 0;
        T2 = f2;
        return e3 | 0;
      }
      function Xb(a2, c4, d2) {
        a2 = a2 | 0;
        c4 = c4 | 0;
        d2 = d2 | 0;
        var e3 = 0, f2 = 0, g2 = 0, h = 0;
        f2 = d2 + 4 | 0;
        g2 = Qd(a2 | 0, c4 | 0, 52) | 0;
        H() | 0;
        g2 = g2 & 15;
        h = Qd(a2 | 0, c4 | 0, 45) | 0;
        H() | 0;
        e3 = (g2 | 0) == 0;
        if (!(oa(h & 127) | 0)) {
          if (e3) {
            h = 0;
            return h | 0;
          }
          if ((b[f2 >> 2] | 0) == 0 ? (b[d2 + 8 >> 2] | 0) == 0 : 0) {
            e3 = (b[d2 + 12 >> 2] | 0) != 0 & 1;
          } else {
            e3 = 1;
          }
        } else if (e3) {
          h = 1;
          return h | 0;
        } else {
          e3 = 1;
        }
        d2 = 1;
        while (1) {
          if (!(d2 & 1)) {
            Xa(f2);
          } else {
            Wa(f2);
          }
          h = Qd(a2 | 0, c4 | 0, (15 - d2 | 0) * 3 | 0) | 0;
          H() | 0;
          Ya(f2, h & 7);
          if (d2 >>> 0 < g2 >>> 0) {
            d2 = d2 + 1 | 0;
          } else {
            break;
          }
        }
        return e3 | 0;
      }
      function Yb(a2, c4, d2) {
        a2 = a2 | 0;
        c4 = c4 | 0;
        d2 = d2 | 0;
        var e3 = 0, f2 = 0, g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0;
        l = T2;
        T2 = T2 + 16 | 0;
        j = l;
        k = Qd(a2 | 0, c4 | 0, 45) | 0;
        H() | 0;
        k = k & 127;
        if (k >>> 0 > 121) {
          b[d2 >> 2] = 0;
          b[d2 + 4 >> 2] = 0;
          b[d2 + 8 >> 2] = 0;
          b[d2 + 12 >> 2] = 0;
          k = 5;
          T2 = l;
          return k | 0;
        }
        a: do {
          if ((oa(k) | 0) != 0 ? (g2 = Qd(a2 | 0, c4 | 0, 52) | 0, H() | 0, g2 = g2 & 15, (g2 | 0) != 0) : 0) {
            e3 = 1;
            b: while (1) {
              i = Qd(a2 | 0, c4 | 0, (15 - e3 | 0) * 3 | 0) | 0;
              H() | 0;
              switch (i & 7) {
                case 5:
                  break b;
                case 0:
                  break;
                default: {
                  e3 = c4;
                  break a;
                }
              }
              if (e3 >>> 0 < g2 >>> 0) {
                e3 = e3 + 1 | 0;
              } else {
                e3 = c4;
                break a;
              }
            }
            f2 = 1;
            e3 = c4;
            while (1) {
              c4 = (15 - f2 | 0) * 3 | 0;
              h = Rd(7, 0, c4 | 0) | 0;
              i = e3 & ~(H() | 0);
              e3 = Qd(a2 | 0, e3 | 0, c4 | 0) | 0;
              H() | 0;
              e3 = Rd(ab4(e3 & 7) | 0, 0, c4 | 0) | 0;
              a2 = a2 & ~h | e3;
              e3 = i | (H() | 0);
              if (f2 >>> 0 < g2 >>> 0) {
                f2 = f2 + 1 | 0;
              } else {
                break;
              }
            }
          } else {
            e3 = c4;
          }
        } while (0);
        i = 7696 + (k * 28 | 0) | 0;
        b[d2 >> 2] = b[i >> 2];
        b[d2 + 4 >> 2] = b[i + 4 >> 2];
        b[d2 + 8 >> 2] = b[i + 8 >> 2];
        b[d2 + 12 >> 2] = b[i + 12 >> 2];
        if (!(Xb(a2, e3, d2) | 0)) {
          k = 0;
          T2 = l;
          return k | 0;
        }
        h = d2 + 4 | 0;
        b[j >> 2] = b[h >> 2];
        b[j + 4 >> 2] = b[h + 4 >> 2];
        b[j + 8 >> 2] = b[h + 8 >> 2];
        g2 = Qd(a2 | 0, e3 | 0, 52) | 0;
        H() | 0;
        i = g2 & 15;
        if (!(g2 & 1)) {
          g2 = i;
        } else {
          Xa(h);
          g2 = i + 1 | 0;
        }
        if (!(oa(k) | 0)) {
          e3 = 0;
        } else {
          c: do {
            if (!i) {
              e3 = 0;
            } else {
              c4 = 1;
              while (1) {
                f2 = Qd(a2 | 0, e3 | 0, (15 - c4 | 0) * 3 | 0) | 0;
                H() | 0;
                f2 = f2 & 7;
                if (f2 | 0) {
                  e3 = f2;
                  break c;
                }
                if (c4 >>> 0 < i >>> 0) {
                  c4 = c4 + 1 | 0;
                } else {
                  e3 = 0;
                  break;
                }
              }
            }
          } while (0);
          e3 = (e3 | 0) == 4 & 1;
        }
        if (!(xb(d2, g2, e3, 0) | 0)) {
          if ((g2 | 0) != (i | 0)) {
            b[h >> 2] = b[j >> 2];
            b[h + 4 >> 2] = b[j + 4 >> 2];
            b[h + 8 >> 2] = b[j + 8 >> 2];
          }
        } else {
          if (oa(k) | 0) {
            do {
            } while ((xb(d2, g2, 0, 0) | 0) != 0);
          }
          if ((g2 | 0) != (i | 0)) {
            Va(h);
          }
        }
        k = 0;
        T2 = l;
        return k | 0;
      }
      function Zb(a2, b2, c4) {
        a2 = a2 | 0;
        b2 = b2 | 0;
        c4 = c4 | 0;
        var d2 = 0, e3 = 0, f2 = 0;
        f2 = T2;
        T2 = T2 + 16 | 0;
        d2 = f2;
        e3 = Yb(a2, b2, d2) | 0;
        if (e3 | 0) {
          T2 = f2;
          return e3 | 0;
        }
        e3 = Qd(a2 | 0, b2 | 0, 52) | 0;
        H() | 0;
        ub(d2, e3 & 15, c4);
        e3 = 0;
        T2 = f2;
        return e3 | 0;
      }
      function _b2(a2, b2, c4) {
        a2 = a2 | 0;
        b2 = b2 | 0;
        c4 = c4 | 0;
        var d2 = 0, e3 = 0, f2 = 0, g2 = 0, h = 0;
        g2 = T2;
        T2 = T2 + 16 | 0;
        f2 = g2;
        d2 = Yb(a2, b2, f2) | 0;
        if (d2 | 0) {
          f2 = d2;
          T2 = g2;
          return f2 | 0;
        }
        d2 = Qd(a2 | 0, b2 | 0, 45) | 0;
        H() | 0;
        d2 = (oa(d2 & 127) | 0) == 0;
        e3 = Qd(a2 | 0, b2 | 0, 52) | 0;
        H() | 0;
        e3 = e3 & 15;
        a: do {
          if (!d2) {
            if (e3 | 0) {
              d2 = 1;
              while (1) {
                h = Rd(7, 0, (15 - d2 | 0) * 3 | 0) | 0;
                if (!((h & a2 | 0) == 0 & ((H() | 0) & b2 | 0) == 0)) {
                  break a;
                }
                if (d2 >>> 0 < e3 >>> 0) {
                  d2 = d2 + 1 | 0;
                } else {
                  break;
                }
              }
            }
            vb(f2, e3, 0, 5, c4);
            h = 0;
            T2 = g2;
            return h | 0;
          }
        } while (0);
        zb(f2, e3, 0, 6, c4);
        h = 0;
        T2 = g2;
        return h | 0;
      }
      function $b(a2, c4, d2) {
        a2 = a2 | 0;
        c4 = c4 | 0;
        d2 = d2 | 0;
        var e3 = 0, f2 = 0, g2 = 0;
        f2 = Qd(a2 | 0, c4 | 0, 45) | 0;
        H() | 0;
        if (!(oa(f2 & 127) | 0)) {
          f2 = 2;
          b[d2 >> 2] = f2;
          return 0;
        }
        f2 = Qd(a2 | 0, c4 | 0, 52) | 0;
        H() | 0;
        f2 = f2 & 15;
        if (!f2) {
          f2 = 5;
          b[d2 >> 2] = f2;
          return 0;
        }
        e3 = 1;
        while (1) {
          g2 = Rd(7, 0, (15 - e3 | 0) * 3 | 0) | 0;
          if (!((g2 & a2 | 0) == 0 & ((H() | 0) & c4 | 0) == 0)) {
            e3 = 2;
            a2 = 6;
            break;
          }
          if (e3 >>> 0 < f2 >>> 0) {
            e3 = e3 + 1 | 0;
          } else {
            e3 = 5;
            a2 = 6;
            break;
          }
        }
        if ((a2 | 0) == 6) {
          b[d2 >> 2] = e3;
          return 0;
        }
        return 0;
      }
      function ac2(a2, c4, d2) {
        a2 = a2 | 0;
        c4 = c4 | 0;
        d2 = d2 | 0;
        var e3 = 0, f2 = 0, g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0;
        m = T2;
        T2 = T2 + 128 | 0;
        k = m + 112 | 0;
        g2 = m + 96 | 0;
        l = m;
        f2 = Qd(a2 | 0, c4 | 0, 52) | 0;
        H() | 0;
        i = f2 & 15;
        b[k >> 2] = i;
        h = Qd(a2 | 0, c4 | 0, 45) | 0;
        H() | 0;
        h = h & 127;
        a: do {
          if (oa(h) | 0) {
            if (i | 0) {
              e3 = 1;
              while (1) {
                j = Rd(7, 0, (15 - e3 | 0) * 3 | 0) | 0;
                if (!((j & a2 | 0) == 0 & ((H() | 0) & c4 | 0) == 0)) {
                  f2 = 0;
                  break a;
                }
                if (e3 >>> 0 < i >>> 0) {
                  e3 = e3 + 1 | 0;
                } else {
                  break;
                }
              }
            }
            if (!(f2 & 1)) {
              j = Rd(i + 1 | 0, 0, 52) | 0;
              l = H() | 0 | c4 & -15728641;
              k = Rd(7, 0, (14 - i | 0) * 3 | 0) | 0;
              l = ac2((j | a2) & ~k, l & ~(H() | 0), d2) | 0;
              T2 = m;
              return l | 0;
            } else {
              f2 = 1;
            }
          } else {
            f2 = 0;
          }
        } while (0);
        e3 = Yb(a2, c4, g2) | 0;
        if (!e3) {
          if (f2) {
            wb(g2, k, l);
            j = 5;
          } else {
            Ab(g2, k, l);
            j = 6;
          }
          b: do {
            if (oa(h) | 0) {
              if (!i) {
                a2 = 5;
              } else {
                e3 = 1;
                while (1) {
                  h = Rd(7, 0, (15 - e3 | 0) * 3 | 0) | 0;
                  if (!((h & a2 | 0) == 0 & ((H() | 0) & c4 | 0) == 0)) {
                    a2 = 2;
                    break b;
                  }
                  if (e3 >>> 0 < i >>> 0) {
                    e3 = e3 + 1 | 0;
                  } else {
                    a2 = 5;
                    break;
                  }
                }
              }
            } else {
              a2 = 2;
            }
          } while (0);
          Xd(d2 | 0, -1, a2 << 2 | 0) | 0;
          c: do {
            if (f2) {
              g2 = 0;
              while (1) {
                h = l + (g2 << 4) | 0;
                yb(h, b[k >> 2] | 0) | 0;
                h = b[h >> 2] | 0;
                i = b[d2 >> 2] | 0;
                if ((i | 0) == -1 | (i | 0) == (h | 0)) {
                  e3 = d2;
                } else {
                  f2 = 0;
                  do {
                    f2 = f2 + 1 | 0;
                    if (f2 >>> 0 >= a2 >>> 0) {
                      e3 = 1;
                      break c;
                    }
                    e3 = d2 + (f2 << 2) | 0;
                    i = b[e3 >> 2] | 0;
                  } while (!((i | 0) == -1 | (i | 0) == (h | 0)));
                }
                b[e3 >> 2] = h;
                g2 = g2 + 1 | 0;
                if (g2 >>> 0 >= j >>> 0) {
                  e3 = 0;
                  break;
                }
              }
            } else {
              g2 = 0;
              while (1) {
                h = l + (g2 << 4) | 0;
                xb(h, b[k >> 2] | 0, 0, 1) | 0;
                h = b[h >> 2] | 0;
                i = b[d2 >> 2] | 0;
                if ((i | 0) == -1 | (i | 0) == (h | 0)) {
                  e3 = d2;
                } else {
                  f2 = 0;
                  do {
                    f2 = f2 + 1 | 0;
                    if (f2 >>> 0 >= a2 >>> 0) {
                      e3 = 1;
                      break c;
                    }
                    e3 = d2 + (f2 << 2) | 0;
                    i = b[e3 >> 2] | 0;
                  } while (!((i | 0) == -1 | (i | 0) == (h | 0)));
                }
                b[e3 >> 2] = h;
                g2 = g2 + 1 | 0;
                if (g2 >>> 0 >= j >>> 0) {
                  e3 = 0;
                  break;
                }
              }
            }
          } while (0);
        }
        l = e3;
        T2 = m;
        return l | 0;
      }
      function bc4() {
        return 12;
      }
      function cc2(a2, c4) {
        a2 = a2 | 0;
        c4 = c4 | 0;
        var d2 = 0, e3 = 0, f2 = 0, g2 = 0, h = 0, i = 0, j = 0;
        if (a2 >>> 0 > 15) {
          i = 4;
          return i | 0;
        }
        Rd(a2 | 0, 0, 52) | 0;
        i = H() | 0 | 134225919;
        if (!a2) {
          d2 = 0;
          e3 = 0;
          do {
            if (oa(e3) | 0) {
              Rd(e3 | 0, 0, 45) | 0;
              h = i | (H() | 0);
              a2 = c4 + (d2 << 3) | 0;
              b[a2 >> 2] = -1;
              b[a2 + 4 >> 2] = h;
              d2 = d2 + 1 | 0;
            }
            e3 = e3 + 1 | 0;
          } while ((e3 | 0) != 122);
          d2 = 0;
          return d2 | 0;
        }
        d2 = 0;
        h = 0;
        do {
          if (oa(h) | 0) {
            Rd(h | 0, 0, 45) | 0;
            e3 = 1;
            f2 = -1;
            g2 = i | (H() | 0);
            while (1) {
              j = Rd(7, 0, (15 - e3 | 0) * 3 | 0) | 0;
              f2 = f2 & ~j;
              g2 = g2 & ~(H() | 0);
              if ((e3 | 0) == (a2 | 0)) {
                break;
              } else {
                e3 = e3 + 1 | 0;
              }
            }
            j = c4 + (d2 << 3) | 0;
            b[j >> 2] = f2;
            b[j + 4 >> 2] = g2;
            d2 = d2 + 1 | 0;
          }
          h = h + 1 | 0;
        } while ((h | 0) != 122);
        d2 = 0;
        return d2 | 0;
      }
      function dc(a2, c4, d2, e3) {
        a2 = a2 | 0;
        c4 = c4 | 0;
        d2 = d2 | 0;
        e3 = e3 | 0;
        var f2 = 0, g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p2 = 0, q2 = 0, r2 = 0, s2 = 0, t4 = 0;
        t4 = T2;
        T2 = T2 + 16 | 0;
        r2 = t4;
        s2 = Qd(a2 | 0, c4 | 0, 52) | 0;
        H() | 0;
        s2 = s2 & 15;
        if (d2 >>> 0 > 15) {
          s2 = 4;
          T2 = t4;
          return s2 | 0;
        }
        if ((s2 | 0) < (d2 | 0)) {
          s2 = 12;
          T2 = t4;
          return s2 | 0;
        }
        if ((s2 | 0) != (d2 | 0)) {
          g2 = Rd(d2 | 0, 0, 52) | 0;
          g2 = g2 | a2;
          i = H() | 0 | c4 & -15728641;
          if ((s2 | 0) > (d2 | 0)) {
            j = d2;
            do {
              q2 = Rd(7, 0, (14 - j | 0) * 3 | 0) | 0;
              j = j + 1 | 0;
              g2 = q2 | g2;
              i = H() | 0 | i;
            } while ((j | 0) < (s2 | 0));
            q2 = g2;
          } else {
            q2 = g2;
          }
        } else {
          q2 = a2;
          i = c4;
        }
        p2 = Qd(q2 | 0, i | 0, 45) | 0;
        H() | 0;
        a: do {
          if (oa(p2 & 127) | 0) {
            j = Qd(q2 | 0, i | 0, 52) | 0;
            H() | 0;
            j = j & 15;
            if (j | 0) {
              g2 = 1;
              while (1) {
                p2 = Rd(7, 0, (15 - g2 | 0) * 3 | 0) | 0;
                if (!((p2 & q2 | 0) == 0 & ((H() | 0) & i | 0) == 0)) {
                  k = 33;
                  break a;
                }
                if (g2 >>> 0 < j >>> 0) {
                  g2 = g2 + 1 | 0;
                } else {
                  break;
                }
              }
            }
            p2 = e3;
            b[p2 >> 2] = 0;
            b[p2 + 4 >> 2] = 0;
            if ((s2 | 0) > (d2 | 0)) {
              p2 = c4 & -15728641;
              o = s2;
              while (1) {
                n = o;
                o = o + -1 | 0;
                if (o >>> 0 > 15 | (s2 | 0) < (o | 0)) {
                  k = 19;
                  break;
                }
                if ((s2 | 0) != (o | 0)) {
                  g2 = Rd(o | 0, 0, 52) | 0;
                  g2 = g2 | a2;
                  j = H() | 0 | p2;
                  if ((s2 | 0) < (n | 0)) {
                    m = g2;
                  } else {
                    k = o;
                    do {
                      m = Rd(7, 0, (14 - k | 0) * 3 | 0) | 0;
                      k = k + 1 | 0;
                      g2 = m | g2;
                      j = H() | 0 | j;
                    } while ((k | 0) < (s2 | 0));
                    m = g2;
                  }
                } else {
                  m = a2;
                  j = c4;
                }
                l = Qd(m | 0, j | 0, 45) | 0;
                H() | 0;
                if (!(oa(l & 127) | 0)) {
                  g2 = 0;
                } else {
                  l = Qd(m | 0, j | 0, 52) | 0;
                  H() | 0;
                  l = l & 15;
                  b: do {
                    if (!l) {
                      g2 = 0;
                    } else {
                      k = 1;
                      while (1) {
                        g2 = Qd(m | 0, j | 0, (15 - k | 0) * 3 | 0) | 0;
                        H() | 0;
                        g2 = g2 & 7;
                        if (g2 | 0) {
                          break b;
                        }
                        if (k >>> 0 < l >>> 0) {
                          k = k + 1 | 0;
                        } else {
                          g2 = 0;
                          break;
                        }
                      }
                    }
                  } while (0);
                  g2 = (g2 | 0) == 0 & 1;
                }
                j = Qd(a2 | 0, c4 | 0, (15 - n | 0) * 3 | 0) | 0;
                H() | 0;
                j = j & 7;
                if ((j | 0) == 7) {
                  f2 = 5;
                  k = 42;
                  break;
                }
                g2 = (g2 | 0) != 0;
                if ((j | 0) == 1 & g2) {
                  f2 = 5;
                  k = 42;
                  break;
                }
                m = j + (((j | 0) != 0 & g2) << 31 >> 31) | 0;
                if (m | 0) {
                  k = s2 - n | 0;
                  k = Oc(7, 0, k, ((k | 0) < 0) << 31 >> 31) | 0;
                  l = H() | 0;
                  if (g2) {
                    g2 = Md(k | 0, l | 0, 5, 0) | 0;
                    g2 = Gd(g2 | 0, H() | 0, -5, -1) | 0;
                    g2 = Kd(g2 | 0, H() | 0, 6, 0) | 0;
                    g2 = Gd(g2 | 0, H() | 0, 1, 0) | 0;
                    j = H() | 0;
                  } else {
                    g2 = k;
                    j = l;
                  }
                  n = m + -1 | 0;
                  n = Md(k | 0, l | 0, n | 0, ((n | 0) < 0) << 31 >> 31 | 0) | 0;
                  n = Gd(g2 | 0, j | 0, n | 0, H() | 0) | 0;
                  m = H() | 0;
                  l = e3;
                  l = Gd(n | 0, m | 0, b[l >> 2] | 0, b[l + 4 >> 2] | 0) | 0;
                  m = H() | 0;
                  n = e3;
                  b[n >> 2] = l;
                  b[n + 4 >> 2] = m;
                }
                if ((o | 0) <= (d2 | 0)) {
                  k = 37;
                  break;
                }
              }
              if ((k | 0) == 19) {
                I(27795, 27122, 1276, 27158);
              } else if ((k | 0) == 37) {
                h = e3;
                f2 = b[h + 4 >> 2] | 0;
                h = b[h >> 2] | 0;
                break;
              } else if ((k | 0) == 42) {
                T2 = t4;
                return f2 | 0;
              }
            } else {
              f2 = 0;
              h = 0;
            }
          } else {
            k = 33;
          }
        } while (0);
        c: do {
          if ((k | 0) == 33) {
            p2 = e3;
            b[p2 >> 2] = 0;
            b[p2 + 4 >> 2] = 0;
            if ((s2 | 0) > (d2 | 0)) {
              g2 = s2;
              while (1) {
                f2 = Qd(a2 | 0, c4 | 0, (15 - g2 | 0) * 3 | 0) | 0;
                H() | 0;
                f2 = f2 & 7;
                if ((f2 | 0) == 7) {
                  f2 = 5;
                  break;
                }
                h = s2 - g2 | 0;
                h = Oc(7, 0, h, ((h | 0) < 0) << 31 >> 31) | 0;
                f2 = Md(h | 0, H() | 0, f2 | 0, 0) | 0;
                h = H() | 0;
                p2 = e3;
                h = Gd(b[p2 >> 2] | 0, b[p2 + 4 >> 2] | 0, f2 | 0, h | 0) | 0;
                f2 = H() | 0;
                p2 = e3;
                b[p2 >> 2] = h;
                b[p2 + 4 >> 2] = f2;
                g2 = g2 + -1 | 0;
                if ((g2 | 0) <= (d2 | 0)) {
                  break c;
                }
              }
              T2 = t4;
              return f2 | 0;
            } else {
              f2 = 0;
              h = 0;
            }
          }
        } while (0);
        if (Gb(q2, i, s2, r2) | 0) {
          I(27795, 27122, 1236, 27173);
        }
        s2 = r2;
        r2 = b[s2 + 4 >> 2] | 0;
        if (((f2 | 0) > -1 | (f2 | 0) == -1 & h >>> 0 > 4294967295) & ((r2 | 0) > (f2 | 0) | ((r2 | 0) == (f2 | 0) ? (b[s2 >> 2] | 0) >>> 0 > h >>> 0 : 0))) {
          s2 = 0;
          T2 = t4;
          return s2 | 0;
        } else {
          I(27795, 27122, 1316, 27158);
        }
        return 0;
      }
      function ec(a2, c4, d2, e3, f2, g2) {
        a2 = a2 | 0;
        c4 = c4 | 0;
        d2 = d2 | 0;
        e3 = e3 | 0;
        f2 = f2 | 0;
        g2 = g2 | 0;
        var h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p2 = 0, q2 = 0;
        m = T2;
        T2 = T2 + 16 | 0;
        h = m;
        if (f2 >>> 0 > 15) {
          g2 = 4;
          T2 = m;
          return g2 | 0;
        }
        i = Qd(d2 | 0, e3 | 0, 52) | 0;
        H() | 0;
        i = i & 15;
        if ((i | 0) > (f2 | 0)) {
          g2 = 12;
          T2 = m;
          return g2 | 0;
        }
        if (Gb(d2, e3, f2, h) | 0) {
          I(27795, 27122, 1236, 27173);
        }
        l = h;
        k = b[l + 4 >> 2] | 0;
        if (!(((c4 | 0) > -1 | (c4 | 0) == -1 & a2 >>> 0 > 4294967295) & ((k | 0) > (c4 | 0) | ((k | 0) == (c4 | 0) ? (b[l >> 2] | 0) >>> 0 > a2 >>> 0 : 0)))) {
          g2 = 2;
          T2 = m;
          return g2 | 0;
        }
        l = f2 - i | 0;
        f2 = Rd(f2 | 0, 0, 52) | 0;
        j = H() | 0 | e3 & -15728641;
        k = g2;
        b[k >> 2] = f2 | d2;
        b[k + 4 >> 2] = j;
        k = Qd(d2 | 0, e3 | 0, 45) | 0;
        H() | 0;
        a: do {
          if (oa(k & 127) | 0) {
            if (i | 0) {
              h = 1;
              while (1) {
                k = Rd(7, 0, (15 - h | 0) * 3 | 0) | 0;
                if (!((k & d2 | 0) == 0 & ((H() | 0) & e3 | 0) == 0)) {
                  break a;
                }
                if (h >>> 0 < i >>> 0) {
                  h = h + 1 | 0;
                } else {
                  break;
                }
              }
            }
            if ((l | 0) < 1) {
              g2 = 0;
              T2 = m;
              return g2 | 0;
            }
            k = i ^ 15;
            e3 = -1;
            j = 1;
            h = 1;
            while (1) {
              i = l - j | 0;
              i = Oc(7, 0, i, ((i | 0) < 0) << 31 >> 31) | 0;
              d2 = H() | 0;
              do {
                if (h) {
                  h = Md(i | 0, d2 | 0, 5, 0) | 0;
                  h = Gd(h | 0, H() | 0, -5, -1) | 0;
                  h = Kd(h | 0, H() | 0, 6, 0) | 0;
                  f2 = H() | 0;
                  if ((c4 | 0) > (f2 | 0) | (c4 | 0) == (f2 | 0) & a2 >>> 0 > h >>> 0) {
                    c4 = Gd(a2 | 0, c4 | 0, -1, -1) | 0;
                    c4 = Hd(c4 | 0, H() | 0, h | 0, f2 | 0) | 0;
                    h = H() | 0;
                    n = g2;
                    p2 = b[n >> 2] | 0;
                    n = b[n + 4 >> 2] | 0;
                    q2 = (k + e3 | 0) * 3 | 0;
                    o = Rd(7, 0, q2 | 0) | 0;
                    n = n & ~(H() | 0);
                    e3 = Kd(c4 | 0, h | 0, i | 0, d2 | 0) | 0;
                    a2 = H() | 0;
                    f2 = Gd(e3 | 0, a2 | 0, 2, 0) | 0;
                    q2 = Rd(f2 | 0, H() | 0, q2 | 0) | 0;
                    n = H() | 0 | n;
                    f2 = g2;
                    b[f2 >> 2] = q2 | p2 & ~o;
                    b[f2 + 4 >> 2] = n;
                    a2 = Md(e3 | 0, a2 | 0, i | 0, d2 | 0) | 0;
                    a2 = Hd(c4 | 0, h | 0, a2 | 0, H() | 0) | 0;
                    h = 0;
                    c4 = H() | 0;
                    break;
                  } else {
                    q2 = g2;
                    o = b[q2 >> 2] | 0;
                    q2 = b[q2 + 4 >> 2] | 0;
                    p2 = Rd(7, 0, (k + e3 | 0) * 3 | 0) | 0;
                    q2 = q2 & ~(H() | 0);
                    h = g2;
                    b[h >> 2] = o & ~p2;
                    b[h + 4 >> 2] = q2;
                    h = 1;
                    break;
                  }
                } else {
                  o = g2;
                  f2 = b[o >> 2] | 0;
                  o = b[o + 4 >> 2] | 0;
                  e3 = (k + e3 | 0) * 3 | 0;
                  n = Rd(7, 0, e3 | 0) | 0;
                  o = o & ~(H() | 0);
                  q2 = Kd(a2 | 0, c4 | 0, i | 0, d2 | 0) | 0;
                  h = H() | 0;
                  e3 = Rd(q2 | 0, h | 0, e3 | 0) | 0;
                  o = H() | 0 | o;
                  p2 = g2;
                  b[p2 >> 2] = e3 | f2 & ~n;
                  b[p2 + 4 >> 2] = o;
                  h = Md(q2 | 0, h | 0, i | 0, d2 | 0) | 0;
                  a2 = Hd(a2 | 0, c4 | 0, h | 0, H() | 0) | 0;
                  h = 0;
                  c4 = H() | 0;
                }
              } while (0);
              if ((l | 0) > (j | 0)) {
                e3 = ~j;
                j = j + 1 | 0;
              } else {
                c4 = 0;
                break;
              }
            }
            T2 = m;
            return c4 | 0;
          }
        } while (0);
        if ((l | 0) < 1) {
          q2 = 0;
          T2 = m;
          return q2 | 0;
        }
        f2 = i ^ 15;
        h = 1;
        while (1) {
          p2 = l - h | 0;
          p2 = Oc(7, 0, p2, ((p2 | 0) < 0) << 31 >> 31) | 0;
          q2 = H() | 0;
          j = g2;
          d2 = b[j >> 2] | 0;
          j = b[j + 4 >> 2] | 0;
          i = (f2 - h | 0) * 3 | 0;
          e3 = Rd(7, 0, i | 0) | 0;
          j = j & ~(H() | 0);
          n = Kd(a2 | 0, c4 | 0, p2 | 0, q2 | 0) | 0;
          o = H() | 0;
          i = Rd(n | 0, o | 0, i | 0) | 0;
          j = H() | 0 | j;
          k = g2;
          b[k >> 2] = i | d2 & ~e3;
          b[k + 4 >> 2] = j;
          q2 = Md(n | 0, o | 0, p2 | 0, q2 | 0) | 0;
          a2 = Hd(a2 | 0, c4 | 0, q2 | 0, H() | 0) | 0;
          c4 = H() | 0;
          if ((l | 0) <= (h | 0)) {
            c4 = 0;
            break;
          } else {
            h = h + 1 | 0;
          }
        }
        T2 = m;
        return c4 | 0;
      }
      function fc(a2, c4, d2, e3) {
        a2 = a2 | 0;
        c4 = c4 | 0;
        d2 = d2 | 0;
        e3 = e3 | 0;
        var f2 = 0, g2 = 0, h = 0;
        f2 = Qd(c4 | 0, d2 | 0, 52) | 0;
        H() | 0;
        f2 = f2 & 15;
        if ((c4 | 0) == 0 & (d2 | 0) == 0 | ((e3 | 0) > 15 | (f2 | 0) > (e3 | 0))) {
          g2 = -1;
          c4 = -1;
          d2 = 0;
          f2 = 0;
        } else {
          c4 = Jb(c4, d2, f2 + 1 | 0, e3) | 0;
          h = (H() | 0) & -15728641;
          d2 = Rd(e3 | 0, 0, 52) | 0;
          d2 = c4 | d2;
          h = h | (H() | 0);
          c4 = (Hb(d2, h) | 0) == 0;
          g2 = f2;
          c4 = c4 ? -1 : e3;
          f2 = h;
        }
        h = a2;
        b[h >> 2] = d2;
        b[h + 4 >> 2] = f2;
        b[a2 + 8 >> 2] = g2;
        b[a2 + 12 >> 2] = c4;
        return;
      }
      function gc(a2, c4, d2, e3) {
        a2 = a2 | 0;
        c4 = c4 | 0;
        d2 = d2 | 0;
        e3 = e3 | 0;
        var f2 = 0, g2 = 0;
        f2 = Qd(a2 | 0, c4 | 0, 52) | 0;
        H() | 0;
        f2 = f2 & 15;
        g2 = e3 + 8 | 0;
        b[g2 >> 2] = f2;
        if ((a2 | 0) == 0 & (c4 | 0) == 0 | ((d2 | 0) > 15 | (f2 | 0) > (d2 | 0))) {
          d2 = e3;
          b[d2 >> 2] = 0;
          b[d2 + 4 >> 2] = 0;
          b[g2 >> 2] = -1;
          b[e3 + 12 >> 2] = -1;
          return;
        }
        a2 = Jb(a2, c4, f2 + 1 | 0, d2) | 0;
        g2 = (H() | 0) & -15728641;
        f2 = Rd(d2 | 0, 0, 52) | 0;
        f2 = a2 | f2;
        g2 = g2 | (H() | 0);
        a2 = e3;
        b[a2 >> 2] = f2;
        b[a2 + 4 >> 2] = g2;
        a2 = e3 + 12 | 0;
        if (!(Hb(f2, g2) | 0)) {
          b[a2 >> 2] = -1;
          return;
        } else {
          b[a2 >> 2] = d2;
          return;
        }
      }
      function hc(a2) {
        a2 = a2 | 0;
        var c4 = 0, d2 = 0, e3 = 0, f2 = 0, g2 = 0, h = 0, i = 0, j = 0, k = 0;
        d2 = a2;
        c4 = b[d2 >> 2] | 0;
        d2 = b[d2 + 4 >> 2] | 0;
        if ((c4 | 0) == 0 & (d2 | 0) == 0) {
          return;
        }
        e3 = Qd(c4 | 0, d2 | 0, 52) | 0;
        H() | 0;
        e3 = e3 & 15;
        i = Rd(1, 0, (e3 ^ 15) * 3 | 0) | 0;
        c4 = Gd(i | 0, H() | 0, c4 | 0, d2 | 0) | 0;
        d2 = H() | 0;
        i = a2;
        b[i >> 2] = c4;
        b[i + 4 >> 2] = d2;
        i = a2 + 8 | 0;
        h = b[i >> 2] | 0;
        if ((e3 | 0) < (h | 0)) {
          return;
        }
        j = a2 + 12 | 0;
        g2 = e3;
        while (1) {
          if ((g2 | 0) == (h | 0)) {
            e3 = 5;
            break;
          }
          k = (g2 | 0) == (b[j >> 2] | 0);
          f2 = (15 - g2 | 0) * 3 | 0;
          e3 = Qd(c4 | 0, d2 | 0, f2 | 0) | 0;
          H() | 0;
          e3 = e3 & 7;
          if (k & ((e3 | 0) == 1 & true)) {
            e3 = 7;
            break;
          }
          if (!((e3 | 0) == 7 & true)) {
            e3 = 10;
            break;
          }
          k = Rd(1, 0, f2 | 0) | 0;
          c4 = Gd(c4 | 0, d2 | 0, k | 0, H() | 0) | 0;
          d2 = H() | 0;
          k = a2;
          b[k >> 2] = c4;
          b[k + 4 >> 2] = d2;
          if ((g2 | 0) > (h | 0)) {
            g2 = g2 + -1 | 0;
          } else {
            e3 = 10;
            break;
          }
        }
        if ((e3 | 0) == 5) {
          k = a2;
          b[k >> 2] = 0;
          b[k + 4 >> 2] = 0;
          b[i >> 2] = -1;
          b[j >> 2] = -1;
          return;
        } else if ((e3 | 0) == 7) {
          h = Rd(1, 0, f2 | 0) | 0;
          h = Gd(c4 | 0, d2 | 0, h | 0, H() | 0) | 0;
          i = H() | 0;
          k = a2;
          b[k >> 2] = h;
          b[k + 4 >> 2] = i;
          b[j >> 2] = g2 + -1;
          return;
        } else if ((e3 | 0) == 10) {
          return;
        }
      }
      function ic(a2) {
        a2 = +a2;
        var b2 = 0;
        b2 = a2 < 0 ? a2 + 6.283185307179586 : a2;
        return +(!(a2 >= 6.283185307179586) ? b2 : b2 + -6.283185307179586);
      }
      function jc(a2, b2) {
        a2 = a2 | 0;
        b2 = b2 | 0;
        if (!(+q(+(+e[a2 >> 3] - +e[b2 >> 3])) < 17453292519943298e-27)) {
          b2 = 0;
          return b2 | 0;
        }
        b2 = +q(+(+e[a2 + 8 >> 3] - +e[b2 + 8 >> 3])) < 17453292519943298e-27;
        return b2 | 0;
      }
      function kc(a2, b2) {
        a2 = +a2;
        b2 = b2 | 0;
        switch (b2 | 0) {
          case 1: {
            a2 = a2 < 0 ? a2 + 6.283185307179586 : a2;
            break;
          }
          case 2: {
            a2 = a2 > 0 ? a2 + -6.283185307179586 : a2;
            break;
          }
          default:
        }
        return +a2;
      }
      function lc(a2, b2) {
        a2 = a2 | 0;
        b2 = b2 | 0;
        var c4 = 0, d2 = 0, f2 = 0, g2 = 0;
        f2 = +e[b2 >> 3];
        d2 = +e[a2 >> 3];
        g2 = +u4(+((f2 - d2) * 0.5));
        c4 = +u4(+((+e[b2 + 8 >> 3] - +e[a2 + 8 >> 3]) * 0.5));
        c4 = g2 * g2 + c4 * (+t(+f2) * +t(+d2) * c4);
        return +(+z(+ +r(+c4), + +r(+(1 - c4))) * 2);
      }
      function mc(a2, b2) {
        a2 = a2 | 0;
        b2 = b2 | 0;
        var c4 = 0, d2 = 0, f2 = 0, g2 = 0;
        f2 = +e[b2 >> 3];
        d2 = +e[a2 >> 3];
        g2 = +u4(+((f2 - d2) * 0.5));
        c4 = +u4(+((+e[b2 + 8 >> 3] - +e[a2 + 8 >> 3]) * 0.5));
        c4 = g2 * g2 + c4 * (+t(+f2) * +t(+d2) * c4);
        return +(+z(+ +r(+c4), + +r(+(1 - c4))) * 2 * 6371.007180918475);
      }
      function nc(a2, b2) {
        a2 = a2 | 0;
        b2 = b2 | 0;
        var c4 = 0, d2 = 0, f2 = 0, g2 = 0;
        f2 = +e[b2 >> 3];
        d2 = +e[a2 >> 3];
        g2 = +u4(+((f2 - d2) * 0.5));
        c4 = +u4(+((+e[b2 + 8 >> 3] - +e[a2 + 8 >> 3]) * 0.5));
        c4 = g2 * g2 + c4 * (+t(+f2) * +t(+d2) * c4);
        return +(+z(+ +r(+c4), + +r(+(1 - c4))) * 2 * 6371.007180918475 * 1e3);
      }
      function oc(a2, b2) {
        a2 = a2 | 0;
        b2 = b2 | 0;
        var c4 = 0, d2 = 0, f2 = 0, g2 = 0, h = 0;
        g2 = +e[b2 >> 3];
        d2 = +t(+g2);
        f2 = +e[b2 + 8 >> 3] - +e[a2 + 8 >> 3];
        h = d2 * +u4(+f2);
        c4 = +e[a2 >> 3];
        return + +z(+h, +(+u4(+g2) * +t(+c4) - +t(+f2) * (d2 * +u4(+c4))));
      }
      function pc(a2, c4, d2, f2) {
        a2 = a2 | 0;
        c4 = +c4;
        d2 = +d2;
        f2 = f2 | 0;
        var g2 = 0, h = 0, i = 0, j = 0;
        if (d2 < 1e-16) {
          b[f2 >> 2] = b[a2 >> 2];
          b[f2 + 4 >> 2] = b[a2 + 4 >> 2];
          b[f2 + 8 >> 2] = b[a2 + 8 >> 2];
          b[f2 + 12 >> 2] = b[a2 + 12 >> 2];
          return;
        }
        h = c4 < 0 ? c4 + 6.283185307179586 : c4;
        h = !(c4 >= 6.283185307179586) ? h : h + -6.283185307179586;
        do {
          if (h < 1e-16) {
            c4 = +e[a2 >> 3] + d2;
            e[f2 >> 3] = c4;
            g2 = f2;
          } else {
            g2 = +q(+(h + -3.141592653589793)) < 1e-16;
            c4 = +e[a2 >> 3];
            if (g2) {
              c4 = c4 - d2;
              e[f2 >> 3] = c4;
              g2 = f2;
              break;
            }
            i = +t(+d2);
            d2 = +u4(+d2);
            c4 = i * +u4(+c4) + +t(+h) * (d2 * +t(+c4));
            c4 = c4 > 1 ? 1 : c4;
            c4 = +x(+(c4 < -1 ? -1 : c4));
            e[f2 >> 3] = c4;
            if (+q(+(c4 + -1.5707963267948966)) < 1e-16) {
              e[f2 >> 3] = 1.5707963267948966;
              e[f2 + 8 >> 3] = 0;
              return;
            }
            if (+q(+(c4 + 1.5707963267948966)) < 1e-16) {
              e[f2 >> 3] = -1.5707963267948966;
              e[f2 + 8 >> 3] = 0;
              return;
            }
            j = 1 / +t(+c4);
            h = d2 * +u4(+h) * j;
            d2 = +e[a2 >> 3];
            c4 = j * ((i - +u4(+c4) * +u4(+d2)) / +t(+d2));
            i = h > 1 ? 1 : h;
            c4 = c4 > 1 ? 1 : c4;
            c4 = +e[a2 + 8 >> 3] + +z(+(i < -1 ? -1 : i), +(c4 < -1 ? -1 : c4));
            if (c4 > 3.141592653589793) {
              do {
                c4 = c4 + -6.283185307179586;
              } while (c4 > 3.141592653589793);
            }
            if (c4 < -3.141592653589793) {
              do {
                c4 = c4 + 6.283185307179586;
              } while (c4 < -3.141592653589793);
            }
            e[f2 + 8 >> 3] = c4;
            return;
          }
        } while (0);
        if (+q(+(c4 + -1.5707963267948966)) < 1e-16) {
          e[g2 >> 3] = 1.5707963267948966;
          e[f2 + 8 >> 3] = 0;
          return;
        }
        if (+q(+(c4 + 1.5707963267948966)) < 1e-16) {
          e[g2 >> 3] = -1.5707963267948966;
          e[f2 + 8 >> 3] = 0;
          return;
        }
        c4 = +e[a2 + 8 >> 3];
        if (c4 > 3.141592653589793) {
          do {
            c4 = c4 + -6.283185307179586;
          } while (c4 > 3.141592653589793);
        }
        if (c4 < -3.141592653589793) {
          do {
            c4 = c4 + 6.283185307179586;
          } while (c4 < -3.141592653589793);
        }
        e[f2 + 8 >> 3] = c4;
        return;
      }
      function qc(a2, b2) {
        a2 = a2 | 0;
        b2 = b2 | 0;
        if (a2 >>> 0 > 15) {
          b2 = 4;
          return b2 | 0;
        }
        e[b2 >> 3] = +e[20656 + (a2 << 3) >> 3];
        b2 = 0;
        return b2 | 0;
      }
      function rc(a2, b2) {
        a2 = a2 | 0;
        b2 = b2 | 0;
        if (a2 >>> 0 > 15) {
          b2 = 4;
          return b2 | 0;
        }
        e[b2 >> 3] = +e[20784 + (a2 << 3) >> 3];
        b2 = 0;
        return b2 | 0;
      }
      function sc(a2, b2) {
        a2 = a2 | 0;
        b2 = b2 | 0;
        if (a2 >>> 0 > 15) {
          b2 = 4;
          return b2 | 0;
        }
        e[b2 >> 3] = +e[20912 + (a2 << 3) >> 3];
        b2 = 0;
        return b2 | 0;
      }
      function tc(a2, b2) {
        a2 = a2 | 0;
        b2 = b2 | 0;
        if (a2 >>> 0 > 15) {
          b2 = 4;
          return b2 | 0;
        }
        e[b2 >> 3] = +e[21040 + (a2 << 3) >> 3];
        b2 = 0;
        return b2 | 0;
      }
      function uc(a2, c4) {
        a2 = a2 | 0;
        c4 = c4 | 0;
        var d2 = 0;
        if (a2 >>> 0 > 15) {
          c4 = 4;
          return c4 | 0;
        }
        d2 = Oc(7, 0, a2, ((a2 | 0) < 0) << 31 >> 31) | 0;
        d2 = Md(d2 | 0, H() | 0, 120, 0) | 0;
        a2 = H() | 0;
        b[c4 >> 2] = d2 | 2;
        b[c4 + 4 >> 2] = a2;
        c4 = 0;
        return c4 | 0;
      }
      function vc(a2, b2, c4) {
        a2 = a2 | 0;
        b2 = b2 | 0;
        c4 = c4 | 0;
        var d2 = 0, f2 = 0, g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0;
        n = +e[b2 >> 3];
        l = +e[a2 >> 3];
        j = +u4(+((n - l) * 0.5));
        g2 = +e[b2 + 8 >> 3];
        k = +e[a2 + 8 >> 3];
        h = +u4(+((g2 - k) * 0.5));
        i = +t(+l);
        m = +t(+n);
        h = j * j + h * (m * i * h);
        h = +z(+ +r(+h), + +r(+(1 - h))) * 2;
        j = +e[c4 >> 3];
        n = +u4(+((j - n) * 0.5));
        d2 = +e[c4 + 8 >> 3];
        g2 = +u4(+((d2 - g2) * 0.5));
        f2 = +t(+j);
        g2 = n * n + g2 * (m * f2 * g2);
        g2 = +z(+ +r(+g2), + +r(+(1 - g2))) * 2;
        j = +u4(+((l - j) * 0.5));
        d2 = +u4(+((k - d2) * 0.5));
        d2 = j * j + d2 * (i * f2 * d2);
        d2 = +z(+ +r(+d2), + +r(+(1 - d2))) * 2;
        f2 = (h + g2 + d2) * 0.5;
        return +(+y(+ +r(+(+v2(+(f2 * 0.5)) * +v2(+((f2 - h) * 0.5)) * +v2(+((f2 - g2) * 0.5)) * +v2(+((f2 - d2) * 0.5))))) * 4);
      }
      function wc(a2, c4, d2) {
        a2 = a2 | 0;
        c4 = c4 | 0;
        d2 = d2 | 0;
        var f2 = 0, g2 = 0, h = 0, i = 0, j = 0;
        j = T2;
        T2 = T2 + 192 | 0;
        h = j + 168 | 0;
        i = j;
        g2 = Zb(a2, c4, h) | 0;
        if (g2 | 0) {
          d2 = g2;
          T2 = j;
          return d2 | 0;
        }
        if (_b2(a2, c4, i) | 0) {
          I(27795, 27190, 415, 27199);
        }
        c4 = b[i >> 2] | 0;
        if ((c4 | 0) > 0) {
          f2 = +vc(i + 8 | 0, i + 8 + (((c4 | 0) != 1 & 1) << 4) | 0, h) + 0;
          if ((c4 | 0) != 1) {
            a2 = 1;
            do {
              g2 = a2;
              a2 = a2 + 1 | 0;
              f2 = f2 + +vc(i + 8 + (g2 << 4) | 0, i + 8 + (((a2 | 0) % (c4 | 0) | 0) << 4) | 0, h);
            } while ((a2 | 0) < (c4 | 0));
          }
        } else {
          f2 = 0;
        }
        e[d2 >> 3] = f2;
        d2 = 0;
        T2 = j;
        return d2 | 0;
      }
      function xc(a2, b2, c4) {
        a2 = a2 | 0;
        b2 = b2 | 0;
        c4 = c4 | 0;
        a2 = wc(a2, b2, c4) | 0;
        if (a2 | 0) {
          return a2 | 0;
        }
        e[c4 >> 3] = +e[c4 >> 3] * 6371.007180918475 * 6371.007180918475;
        return a2 | 0;
      }
      function yc(a2, b2, c4) {
        a2 = a2 | 0;
        b2 = b2 | 0;
        c4 = c4 | 0;
        a2 = wc(a2, b2, c4) | 0;
        if (a2 | 0) {
          return a2 | 0;
        }
        e[c4 >> 3] = +e[c4 >> 3] * 6371.007180918475 * 6371.007180918475 * 1e3 * 1e3;
        return a2 | 0;
      }
      function zc(a2, c4, d2) {
        a2 = a2 | 0;
        c4 = c4 | 0;
        d2 = d2 | 0;
        var f2 = 0, g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0;
        j = T2;
        T2 = T2 + 176 | 0;
        i = j;
        a2 = pb(a2, c4, i) | 0;
        if (a2 | 0) {
          i = a2;
          T2 = j;
          return i | 0;
        }
        e[d2 >> 3] = 0;
        a2 = b[i >> 2] | 0;
        if ((a2 | 0) <= 1) {
          i = 0;
          T2 = j;
          return i | 0;
        }
        c4 = a2 + -1 | 0;
        a2 = 0;
        f2 = +e[i + 8 >> 3];
        g2 = +e[i + 16 >> 3];
        h = 0;
        do {
          a2 = a2 + 1 | 0;
          l = f2;
          f2 = +e[i + 8 + (a2 << 4) >> 3];
          m = +u4(+((f2 - l) * 0.5));
          k = g2;
          g2 = +e[i + 8 + (a2 << 4) + 8 >> 3];
          k = +u4(+((g2 - k) * 0.5));
          k = m * m + k * (+t(+f2) * +t(+l) * k);
          h = h + +z(+ +r(+k), + +r(+(1 - k))) * 2;
        } while ((a2 | 0) < (c4 | 0));
        e[d2 >> 3] = h;
        i = 0;
        T2 = j;
        return i | 0;
      }
      function Ac(a2, c4, d2) {
        a2 = a2 | 0;
        c4 = c4 | 0;
        d2 = d2 | 0;
        var f2 = 0, g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0;
        j = T2;
        T2 = T2 + 176 | 0;
        i = j;
        a2 = pb(a2, c4, i) | 0;
        if (a2 | 0) {
          i = a2;
          h = +e[d2 >> 3];
          h = h * 6371.007180918475;
          e[d2 >> 3] = h;
          T2 = j;
          return i | 0;
        }
        e[d2 >> 3] = 0;
        a2 = b[i >> 2] | 0;
        if ((a2 | 0) <= 1) {
          i = 0;
          h = 0;
          h = h * 6371.007180918475;
          e[d2 >> 3] = h;
          T2 = j;
          return i | 0;
        }
        c4 = a2 + -1 | 0;
        a2 = 0;
        f2 = +e[i + 8 >> 3];
        g2 = +e[i + 16 >> 3];
        h = 0;
        do {
          a2 = a2 + 1 | 0;
          l = f2;
          f2 = +e[i + 8 + (a2 << 4) >> 3];
          m = +u4(+((f2 - l) * 0.5));
          k = g2;
          g2 = +e[i + 8 + (a2 << 4) + 8 >> 3];
          k = +u4(+((g2 - k) * 0.5));
          k = m * m + k * (+t(+l) * +t(+f2) * k);
          h = h + +z(+ +r(+k), + +r(+(1 - k))) * 2;
        } while ((a2 | 0) != (c4 | 0));
        e[d2 >> 3] = h;
        i = 0;
        m = h;
        m = m * 6371.007180918475;
        e[d2 >> 3] = m;
        T2 = j;
        return i | 0;
      }
      function Bc(a2, c4, d2) {
        a2 = a2 | 0;
        c4 = c4 | 0;
        d2 = d2 | 0;
        var f2 = 0, g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0;
        j = T2;
        T2 = T2 + 176 | 0;
        i = j;
        a2 = pb(a2, c4, i) | 0;
        if (a2 | 0) {
          i = a2;
          h = +e[d2 >> 3];
          h = h * 6371.007180918475;
          h = h * 1e3;
          e[d2 >> 3] = h;
          T2 = j;
          return i | 0;
        }
        e[d2 >> 3] = 0;
        a2 = b[i >> 2] | 0;
        if ((a2 | 0) <= 1) {
          i = 0;
          h = 0;
          h = h * 6371.007180918475;
          h = h * 1e3;
          e[d2 >> 3] = h;
          T2 = j;
          return i | 0;
        }
        c4 = a2 + -1 | 0;
        a2 = 0;
        f2 = +e[i + 8 >> 3];
        g2 = +e[i + 16 >> 3];
        h = 0;
        do {
          a2 = a2 + 1 | 0;
          l = f2;
          f2 = +e[i + 8 + (a2 << 4) >> 3];
          m = +u4(+((f2 - l) * 0.5));
          k = g2;
          g2 = +e[i + 8 + (a2 << 4) + 8 >> 3];
          k = +u4(+((g2 - k) * 0.5));
          k = m * m + k * (+t(+l) * +t(+f2) * k);
          h = h + +z(+ +r(+k), + +r(+(1 - k))) * 2;
        } while ((a2 | 0) != (c4 | 0));
        e[d2 >> 3] = h;
        i = 0;
        m = h;
        m = m * 6371.007180918475;
        m = m * 1e3;
        e[d2 >> 3] = m;
        T2 = j;
        return i | 0;
      }
      function Cc(a2) {
        a2 = a2 | 0;
        var c4 = 0, d2 = 0, e3 = 0;
        c4 = Fd(1, 12) | 0;
        if (!c4) {
          I(27280, 27235, 49, 27293);
        }
        d2 = a2 + 4 | 0;
        e3 = b[d2 >> 2] | 0;
        if (e3 | 0) {
          e3 = e3 + 8 | 0;
          b[e3 >> 2] = c4;
          b[d2 >> 2] = c4;
          return c4 | 0;
        }
        if (b[a2 >> 2] | 0) {
          I(27310, 27235, 61, 27333);
        }
        e3 = a2;
        b[e3 >> 2] = c4;
        b[d2 >> 2] = c4;
        return c4 | 0;
      }
      function Dc(a2, c4) {
        a2 = a2 | 0;
        c4 = c4 | 0;
        var d2 = 0, e3 = 0;
        e3 = Dd(24) | 0;
        if (!e3) {
          I(27347, 27235, 78, 27361);
        }
        b[e3 >> 2] = b[c4 >> 2];
        b[e3 + 4 >> 2] = b[c4 + 4 >> 2];
        b[e3 + 8 >> 2] = b[c4 + 8 >> 2];
        b[e3 + 12 >> 2] = b[c4 + 12 >> 2];
        b[e3 + 16 >> 2] = 0;
        c4 = a2 + 4 | 0;
        d2 = b[c4 >> 2] | 0;
        if (d2 | 0) {
          b[d2 + 16 >> 2] = e3;
          b[c4 >> 2] = e3;
          return e3 | 0;
        }
        if (b[a2 >> 2] | 0) {
          I(27376, 27235, 82, 27361);
        }
        b[a2 >> 2] = e3;
        b[c4 >> 2] = e3;
        return e3 | 0;
      }
      function Ec(a2) {
        a2 = a2 | 0;
        var c4 = 0, d2 = 0, e3 = 0, f2 = 0;
        if (!a2) {
          return;
        }
        e3 = 1;
        while (1) {
          c4 = b[a2 >> 2] | 0;
          if (c4 | 0) {
            do {
              d2 = b[c4 >> 2] | 0;
              if (d2 | 0) {
                do {
                  f2 = d2;
                  d2 = b[d2 + 16 >> 2] | 0;
                  Ed(f2);
                } while ((d2 | 0) != 0);
              }
              f2 = c4;
              c4 = b[c4 + 8 >> 2] | 0;
              Ed(f2);
            } while ((c4 | 0) != 0);
          }
          c4 = a2;
          a2 = b[a2 + 8 >> 2] | 0;
          if (!e3) {
            Ed(c4);
          }
          if (!a2) {
            break;
          } else {
            e3 = 0;
          }
        }
        return;
      }
      function Fc(a2) {
        a2 = a2 | 0;
        var c4 = 0, d2 = 0, f2 = 0, g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p2 = 0, r2 = 0, s2 = 0, t4 = 0, u5 = 0, v3 = 0, w4 = 0, x2 = 0, y2 = 0, z2 = 0, A6 = 0, B5 = 0, C4 = 0, D4 = 0, E3 = 0, F = 0, G2 = 0, H2 = 0, J2 = 0, K3 = 0;
        g2 = a2 + 8 | 0;
        if (b[g2 >> 2] | 0) {
          K3 = 1;
          return K3 | 0;
        }
        f2 = b[a2 >> 2] | 0;
        if (!f2) {
          K3 = 0;
          return K3 | 0;
        }
        c4 = f2;
        d2 = 0;
        do {
          d2 = d2 + 1 | 0;
          c4 = b[c4 + 8 >> 2] | 0;
        } while ((c4 | 0) != 0);
        if (d2 >>> 0 < 2) {
          K3 = 0;
          return K3 | 0;
        }
        H2 = Dd(d2 << 2) | 0;
        if (!H2) {
          I(27396, 27235, 317, 27415);
        }
        G2 = Dd(d2 << 5) | 0;
        if (!G2) {
          I(27437, 27235, 321, 27415);
        }
        b[a2 >> 2] = 0;
        z2 = a2 + 4 | 0;
        b[z2 >> 2] = 0;
        b[g2 >> 2] = 0;
        d2 = 0;
        F = 0;
        y2 = 0;
        n = 0;
        a: while (1) {
          m = b[f2 >> 2] | 0;
          if (m) {
            h = 0;
            i = m;
            do {
              k = +e[i + 8 >> 3];
              c4 = i;
              i = b[i + 16 >> 2] | 0;
              l = (i | 0) == 0;
              g2 = l ? m : i;
              j = +e[g2 + 8 >> 3];
              if (+q(+(k - j)) > 3.141592653589793) {
                K3 = 14;
                break;
              }
              h = h + (j - k) * (+e[c4 >> 3] + +e[g2 >> 3]);
            } while (!l);
            if ((K3 | 0) == 14) {
              K3 = 0;
              h = 0;
              c4 = m;
              do {
                x2 = +e[c4 + 8 >> 3];
                E3 = c4 + 16 | 0;
                D4 = b[E3 >> 2] | 0;
                D4 = (D4 | 0) == 0 ? m : D4;
                w4 = +e[D4 + 8 >> 3];
                h = h + (+e[c4 >> 3] + +e[D4 >> 3]) * ((w4 < 0 ? w4 + 6.283185307179586 : w4) - (x2 < 0 ? x2 + 6.283185307179586 : x2));
                c4 = b[((c4 | 0) == 0 ? f2 : E3) >> 2] | 0;
              } while ((c4 | 0) != 0);
            }
            if (h > 0) {
              b[H2 + (F << 2) >> 2] = f2;
              F = F + 1 | 0;
              g2 = y2;
              c4 = n;
            } else {
              K3 = 19;
            }
          } else {
            K3 = 19;
          }
          if ((K3 | 0) == 19) {
            K3 = 0;
            do {
              if (!d2) {
                if (!n) {
                  if (!(b[a2 >> 2] | 0)) {
                    g2 = z2;
                    i = a2;
                    c4 = f2;
                    d2 = a2;
                    break;
                  } else {
                    K3 = 27;
                    break a;
                  }
                } else {
                  g2 = z2;
                  i = n + 8 | 0;
                  c4 = f2;
                  d2 = a2;
                  break;
                }
              } else {
                c4 = d2 + 8 | 0;
                if (b[c4 >> 2] | 0) {
                  K3 = 21;
                  break a;
                }
                d2 = Fd(1, 12) | 0;
                if (!d2) {
                  K3 = 23;
                  break a;
                }
                b[c4 >> 2] = d2;
                g2 = d2 + 4 | 0;
                i = d2;
                c4 = n;
              }
            } while (0);
            b[i >> 2] = f2;
            b[g2 >> 2] = f2;
            i = G2 + (y2 << 5) | 0;
            l = b[f2 >> 2] | 0;
            if (l) {
              m = G2 + (y2 << 5) + 8 | 0;
              e[m >> 3] = 17976931348623157e292;
              n = G2 + (y2 << 5) + 24 | 0;
              e[n >> 3] = 17976931348623157e292;
              e[i >> 3] = -17976931348623157e292;
              o = G2 + (y2 << 5) + 16 | 0;
              e[o >> 3] = -17976931348623157e292;
              u5 = 17976931348623157e292;
              v3 = -17976931348623157e292;
              g2 = 0;
              p2 = l;
              k = 17976931348623157e292;
              s2 = 17976931348623157e292;
              t4 = -17976931348623157e292;
              j = -17976931348623157e292;
              while (1) {
                h = +e[p2 >> 3];
                x2 = +e[p2 + 8 >> 3];
                p2 = b[p2 + 16 >> 2] | 0;
                r2 = (p2 | 0) == 0;
                w4 = +e[(r2 ? l : p2) + 8 >> 3];
                if (h < k) {
                  e[m >> 3] = h;
                  k = h;
                }
                if (x2 < s2) {
                  e[n >> 3] = x2;
                  s2 = x2;
                }
                if (h > t4) {
                  e[i >> 3] = h;
                } else {
                  h = t4;
                }
                if (x2 > j) {
                  e[o >> 3] = x2;
                  j = x2;
                }
                u5 = x2 > 0 & x2 < u5 ? x2 : u5;
                v3 = x2 < 0 & x2 > v3 ? x2 : v3;
                g2 = g2 | +q(+(x2 - w4)) > 3.141592653589793;
                if (r2) {
                  break;
                } else {
                  t4 = h;
                }
              }
              if (g2) {
                e[o >> 3] = v3;
                e[n >> 3] = u5;
              }
            } else {
              b[i >> 2] = 0;
              b[i + 4 >> 2] = 0;
              b[i + 8 >> 2] = 0;
              b[i + 12 >> 2] = 0;
              b[i + 16 >> 2] = 0;
              b[i + 20 >> 2] = 0;
              b[i + 24 >> 2] = 0;
              b[i + 28 >> 2] = 0;
            }
            g2 = y2 + 1 | 0;
          }
          E3 = f2 + 8 | 0;
          f2 = b[E3 >> 2] | 0;
          b[E3 >> 2] = 0;
          if (!f2) {
            K3 = 45;
            break;
          } else {
            y2 = g2;
            n = c4;
          }
        }
        if ((K3 | 0) == 21) {
          I(27213, 27235, 35, 27247);
        } else if ((K3 | 0) == 23) {
          I(27267, 27235, 37, 27247);
        } else if ((K3 | 0) == 27) {
          I(27310, 27235, 61, 27333);
        } else if ((K3 | 0) == 45) {
          b: do {
            if ((F | 0) > 0) {
              E3 = (g2 | 0) == 0;
              C4 = g2 << 2;
              D4 = (a2 | 0) == 0;
              B5 = 0;
              c4 = 0;
              while (1) {
                A6 = b[H2 + (B5 << 2) >> 2] | 0;
                if (!E3) {
                  y2 = Dd(C4) | 0;
                  if (!y2) {
                    K3 = 50;
                    break;
                  }
                  z2 = Dd(C4) | 0;
                  if (!z2) {
                    K3 = 52;
                    break;
                  }
                  c: do {
                    if (!D4) {
                      g2 = 0;
                      d2 = 0;
                      i = a2;
                      while (1) {
                        f2 = G2 + (g2 << 5) | 0;
                        if (Gc(b[i >> 2] | 0, f2, b[A6 >> 2] | 0) | 0) {
                          b[y2 + (d2 << 2) >> 2] = i;
                          b[z2 + (d2 << 2) >> 2] = f2;
                          r2 = d2 + 1 | 0;
                        } else {
                          r2 = d2;
                        }
                        i = b[i + 8 >> 2] | 0;
                        if (!i) {
                          break;
                        } else {
                          g2 = g2 + 1 | 0;
                          d2 = r2;
                        }
                      }
                      if ((r2 | 0) > 0) {
                        f2 = b[y2 >> 2] | 0;
                        if ((r2 | 0) == 1) {
                          d2 = f2;
                        } else {
                          o = 0;
                          p2 = -1;
                          d2 = f2;
                          n = f2;
                          while (1) {
                            l = b[n >> 2] | 0;
                            f2 = 0;
                            i = 0;
                            while (1) {
                              g2 = b[b[y2 + (i << 2) >> 2] >> 2] | 0;
                              if ((g2 | 0) == (l | 0)) {
                                m = f2;
                              } else {
                                m = f2 + ((Gc(g2, b[z2 + (i << 2) >> 2] | 0, b[l >> 2] | 0) | 0) & 1) | 0;
                              }
                              i = i + 1 | 0;
                              if ((i | 0) == (r2 | 0)) {
                                break;
                              } else {
                                f2 = m;
                              }
                            }
                            g2 = (m | 0) > (p2 | 0);
                            d2 = g2 ? n : d2;
                            f2 = o + 1 | 0;
                            if ((f2 | 0) == (r2 | 0)) {
                              break c;
                            }
                            o = f2;
                            p2 = g2 ? m : p2;
                            n = b[y2 + (f2 << 2) >> 2] | 0;
                          }
                        }
                      } else {
                        d2 = 0;
                      }
                    } else {
                      d2 = 0;
                    }
                  } while (0);
                  Ed(y2);
                  Ed(z2);
                  if (d2) {
                    g2 = d2 + 4 | 0;
                    f2 = b[g2 >> 2] | 0;
                    if (!f2) {
                      if (b[d2 >> 2] | 0) {
                        K3 = 70;
                        break;
                      }
                    } else {
                      d2 = f2 + 8 | 0;
                    }
                    b[d2 >> 2] = A6;
                    b[g2 >> 2] = A6;
                  } else {
                    K3 = 73;
                  }
                } else {
                  K3 = 73;
                }
                if ((K3 | 0) == 73) {
                  K3 = 0;
                  c4 = b[A6 >> 2] | 0;
                  if (c4 | 0) {
                    do {
                      z2 = c4;
                      c4 = b[c4 + 16 >> 2] | 0;
                      Ed(z2);
                    } while ((c4 | 0) != 0);
                  }
                  Ed(A6);
                  c4 = 1;
                }
                B5 = B5 + 1 | 0;
                if ((B5 | 0) >= (F | 0)) {
                  J2 = c4;
                  break b;
                }
              }
              if ((K3 | 0) == 50) {
                I(27452, 27235, 249, 27471);
              } else if ((K3 | 0) == 52) {
                I(27490, 27235, 252, 27471);
              } else if ((K3 | 0) == 70) {
                I(27310, 27235, 61, 27333);
              }
            } else {
              J2 = 0;
            }
          } while (0);
          Ed(H2);
          Ed(G2);
          K3 = J2;
          return K3 | 0;
        }
        return 0;
      }
      function Gc(a2, c4, d2) {
        a2 = a2 | 0;
        c4 = c4 | 0;
        d2 = d2 | 0;
        var f2 = 0, g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0;
        if (!(Ca(c4, d2) | 0)) {
          a2 = 0;
          return a2 | 0;
        }
        c4 = Aa(c4) | 0;
        f2 = +e[d2 >> 3];
        g2 = +e[d2 + 8 >> 3];
        g2 = c4 & g2 < 0 ? g2 + 6.283185307179586 : g2;
        a2 = b[a2 >> 2] | 0;
        if (!a2) {
          a2 = 0;
          return a2 | 0;
        }
        if (c4) {
          c4 = 0;
          l = g2;
          d2 = a2;
          a: while (1) {
            while (1) {
              i = +e[d2 >> 3];
              g2 = +e[d2 + 8 >> 3];
              d2 = d2 + 16 | 0;
              m = b[d2 >> 2] | 0;
              m = (m | 0) == 0 ? a2 : m;
              h = +e[m >> 3];
              j = +e[m + 8 >> 3];
              if (i > h) {
                k = i;
                i = j;
              } else {
                k = h;
                h = i;
                i = g2;
                g2 = j;
              }
              f2 = f2 == h | f2 == k ? f2 + 2220446049250313e-31 : f2;
              if (!(f2 < h | f2 > k)) {
                break;
              }
              d2 = b[d2 >> 2] | 0;
              if (!d2) {
                d2 = 22;
                break a;
              }
            }
            j = i < 0 ? i + 6.283185307179586 : i;
            i = g2 < 0 ? g2 + 6.283185307179586 : g2;
            l = j == l | i == l ? l + -2220446049250313e-31 : l;
            k = j + (i - j) * ((f2 - h) / (k - h));
            if ((k < 0 ? k + 6.283185307179586 : k) > l) {
              c4 = c4 ^ 1;
            }
            d2 = b[d2 >> 2] | 0;
            if (!d2) {
              d2 = 22;
              break;
            }
          }
          if ((d2 | 0) == 22) {
            return c4 | 0;
          }
        } else {
          c4 = 0;
          l = g2;
          d2 = a2;
          b: while (1) {
            while (1) {
              i = +e[d2 >> 3];
              g2 = +e[d2 + 8 >> 3];
              d2 = d2 + 16 | 0;
              m = b[d2 >> 2] | 0;
              m = (m | 0) == 0 ? a2 : m;
              h = +e[m >> 3];
              j = +e[m + 8 >> 3];
              if (i > h) {
                k = i;
                i = j;
              } else {
                k = h;
                h = i;
                i = g2;
                g2 = j;
              }
              f2 = f2 == h | f2 == k ? f2 + 2220446049250313e-31 : f2;
              if (!(f2 < h | f2 > k)) {
                break;
              }
              d2 = b[d2 >> 2] | 0;
              if (!d2) {
                d2 = 22;
                break b;
              }
            }
            l = i == l | g2 == l ? l + -2220446049250313e-31 : l;
            if (i + (g2 - i) * ((f2 - h) / (k - h)) > l) {
              c4 = c4 ^ 1;
            }
            d2 = b[d2 >> 2] | 0;
            if (!d2) {
              d2 = 22;
              break;
            }
          }
          if ((d2 | 0) == 22) {
            return c4 | 0;
          }
        }
        return 0;
      }
      function Hc(c4, d2, e3, f2, g2) {
        c4 = c4 | 0;
        d2 = d2 | 0;
        e3 = e3 | 0;
        f2 = f2 | 0;
        g2 = g2 | 0;
        var h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p2 = 0, q2 = 0, r2 = 0, s2 = 0, t4 = 0, u5 = 0;
        u5 = T2;
        T2 = T2 + 32 | 0;
        t4 = u5 + 16 | 0;
        s2 = u5;
        h = Qd(c4 | 0, d2 | 0, 52) | 0;
        H() | 0;
        h = h & 15;
        p2 = Qd(e3 | 0, f2 | 0, 52) | 0;
        H() | 0;
        if ((h | 0) != (p2 & 15 | 0)) {
          t4 = 12;
          T2 = u5;
          return t4 | 0;
        }
        l = Qd(c4 | 0, d2 | 0, 45) | 0;
        H() | 0;
        l = l & 127;
        m = Qd(e3 | 0, f2 | 0, 45) | 0;
        H() | 0;
        m = m & 127;
        if (l >>> 0 > 121 | m >>> 0 > 121) {
          t4 = 5;
          T2 = u5;
          return t4 | 0;
        }
        p2 = (l | 0) != (m | 0);
        if (p2) {
          j = wa(l, m) | 0;
          if ((j | 0) == 7) {
            t4 = 1;
            T2 = u5;
            return t4 | 0;
          }
          k = wa(m, l) | 0;
          if ((k | 0) == 7) {
            I(27514, 27538, 161, 27548);
          } else {
            q2 = j;
            i = k;
          }
        } else {
          q2 = 0;
          i = 0;
        }
        n = oa(l) | 0;
        o = oa(m) | 0;
        b[t4 >> 2] = 0;
        b[t4 + 4 >> 2] = 0;
        b[t4 + 8 >> 2] = 0;
        b[t4 + 12 >> 2] = 0;
        do {
          if (!q2) {
            Xb(e3, f2, t4) | 0;
            if ((n | 0) != 0 & (o | 0) != 0) {
              if ((m | 0) != (l | 0)) {
                I(27621, 27538, 261, 27548);
              }
              i = Pb(c4, d2) | 0;
              h = Pb(e3, f2) | 0;
              if (!((i | 0) == 7 | (h | 0) == 7)) {
                if (!(a[22e3 + (i * 7 | 0) + h >> 0] | 0)) {
                  i = b[21168 + (i * 28 | 0) + (h << 2) >> 2] | 0;
                  if ((i | 0) > 0) {
                    j = t4 + 4 | 0;
                    h = 0;
                    do {
                      _a2(j);
                      h = h + 1 | 0;
                    } while ((h | 0) != (i | 0));
                    r2 = 51;
                  } else {
                    r2 = 51;
                  }
                } else {
                  h = 1;
                }
              } else {
                h = 5;
              }
            } else {
              r2 = 51;
            }
          } else {
            m = b[4272 + (l * 28 | 0) + (q2 << 2) >> 2] | 0;
            j = (m | 0) > 0;
            if (!o) {
              if (j) {
                l = 0;
                k = e3;
                j = f2;
                do {
                  k = Tb(k, j) | 0;
                  j = H() | 0;
                  i = ab4(i) | 0;
                  l = l + 1 | 0;
                } while ((l | 0) != (m | 0));
                m = i;
                l = k;
                k = j;
              } else {
                m = i;
                l = e3;
                k = f2;
              }
            } else if (j) {
              l = 0;
              k = e3;
              j = f2;
              do {
                k = Sb(k, j) | 0;
                j = H() | 0;
                i = ab4(i) | 0;
                if ((i | 0) == 1) {
                  i = ab4(1) | 0;
                }
                l = l + 1 | 0;
              } while ((l | 0) != (m | 0));
              m = i;
              l = k;
              k = j;
            } else {
              m = i;
              l = e3;
              k = f2;
            }
            Xb(l, k, t4) | 0;
            if (!p2) {
              I(27563, 27538, 191, 27548);
            }
            j = (n | 0) != 0;
            i = (o | 0) != 0;
            if (j & i) {
              I(27590, 27538, 192, 27548);
            }
            if (!j) {
              if (i) {
                i = Pb(l, k) | 0;
                if ((i | 0) == 7) {
                  h = 5;
                  break;
                }
                if (a[22e3 + (i * 7 | 0) + m >> 0] | 0) {
                  h = 1;
                  break;
                }
                l = 0;
                k = b[21168 + (m * 28 | 0) + (i << 2) >> 2] | 0;
              } else {
                l = 0;
                k = 0;
              }
            } else {
              i = Pb(c4, d2) | 0;
              if ((i | 0) == 7) {
                h = 5;
                break;
              }
              if (a[22e3 + (i * 7 | 0) + q2 >> 0] | 0) {
                h = 1;
                break;
              }
              k = b[21168 + (i * 28 | 0) + (q2 << 2) >> 2] | 0;
              l = k;
            }
            if ((l | k | 0) < 0) {
              h = 5;
            } else {
              if ((k | 0) > 0) {
                j = t4 + 4 | 0;
                i = 0;
                do {
                  _a2(j);
                  i = i + 1 | 0;
                } while ((i | 0) != (k | 0));
              }
              b[s2 >> 2] = 0;
              b[s2 + 4 >> 2] = 0;
              b[s2 + 8 >> 2] = 0;
              Ya(s2, q2);
              if (h | 0) {
                while (1) {
                  if (!(Vb(h) | 0)) {
                    Xa(s2);
                  } else {
                    Wa(s2);
                  }
                  if ((h | 0) > 1) {
                    h = h + -1 | 0;
                  } else {
                    break;
                  }
                }
              }
              if ((l | 0) > 0) {
                h = 0;
                do {
                  _a2(s2);
                  h = h + 1 | 0;
                } while ((h | 0) != (l | 0));
              }
              r2 = t4 + 4 | 0;
              Oa(r2, s2, r2);
              Ma(r2);
              r2 = 51;
            }
          }
        } while (0);
        if ((r2 | 0) == 51) {
          h = t4 + 4 | 0;
          b[g2 >> 2] = b[h >> 2];
          b[g2 + 4 >> 2] = b[h + 4 >> 2];
          b[g2 + 8 >> 2] = b[h + 8 >> 2];
          h = 0;
        }
        t4 = h;
        T2 = u5;
        return t4 | 0;
      }
      function Ic(a2, c4, d2, e3) {
        a2 = a2 | 0;
        c4 = c4 | 0;
        d2 = d2 | 0;
        e3 = e3 | 0;
        var f2 = 0, g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p2 = 0, q2 = 0, r2 = 0, s2 = 0, t4 = 0, u5 = 0;
        q2 = T2;
        T2 = T2 + 48 | 0;
        k = q2 + 36 | 0;
        h = q2 + 24 | 0;
        i = q2 + 12 | 0;
        j = q2;
        f2 = Qd(a2 | 0, c4 | 0, 52) | 0;
        H() | 0;
        f2 = f2 & 15;
        n = Qd(a2 | 0, c4 | 0, 45) | 0;
        H() | 0;
        n = n & 127;
        if (n >>> 0 > 121) {
          e3 = 5;
          T2 = q2;
          return e3 | 0;
        }
        l = oa(n) | 0;
        Rd(f2 | 0, 0, 52) | 0;
        r2 = H() | 0 | 134225919;
        g2 = e3;
        b[g2 >> 2] = -1;
        b[g2 + 4 >> 2] = r2;
        if (!f2) {
          f2 = Ra(d2) | 0;
          if ((f2 | 0) == 7) {
            r2 = 1;
            T2 = q2;
            return r2 | 0;
          }
          f2 = va(n, f2) | 0;
          if ((f2 | 0) == 127) {
            r2 = 1;
            T2 = q2;
            return r2 | 0;
          }
          o = Rd(f2 | 0, 0, 45) | 0;
          p2 = H() | 0;
          n = e3;
          p2 = b[n + 4 >> 2] & -1040385 | p2;
          r2 = e3;
          b[r2 >> 2] = b[n >> 2] | o;
          b[r2 + 4 >> 2] = p2;
          r2 = 0;
          T2 = q2;
          return r2 | 0;
        }
        b[k >> 2] = b[d2 >> 2];
        b[k + 4 >> 2] = b[d2 + 4 >> 2];
        b[k + 8 >> 2] = b[d2 + 8 >> 2];
        d2 = f2;
        while (1) {
          g2 = d2;
          d2 = d2 + -1 | 0;
          b[h >> 2] = b[k >> 2];
          b[h + 4 >> 2] = b[k + 4 >> 2];
          b[h + 8 >> 2] = b[k + 8 >> 2];
          if (!(Vb(g2) | 0)) {
            f2 = Ta(k) | 0;
            if (f2 | 0) {
              d2 = 13;
              break;
            }
            b[i >> 2] = b[k >> 2];
            b[i + 4 >> 2] = b[k + 4 >> 2];
            b[i + 8 >> 2] = b[k + 8 >> 2];
            Xa(i);
          } else {
            f2 = Sa(k) | 0;
            if (f2 | 0) {
              d2 = 13;
              break;
            }
            b[i >> 2] = b[k >> 2];
            b[i + 4 >> 2] = b[k + 4 >> 2];
            b[i + 8 >> 2] = b[k + 8 >> 2];
            Wa(i);
          }
          Pa(h, i, j);
          Ma(j);
          f2 = e3;
          t4 = b[f2 >> 2] | 0;
          f2 = b[f2 + 4 >> 2] | 0;
          u5 = (15 - g2 | 0) * 3 | 0;
          s2 = Rd(7, 0, u5 | 0) | 0;
          f2 = f2 & ~(H() | 0);
          u5 = Rd(Ra(j) | 0, 0, u5 | 0) | 0;
          f2 = H() | 0 | f2;
          r2 = e3;
          b[r2 >> 2] = u5 | t4 & ~s2;
          b[r2 + 4 >> 2] = f2;
          if ((g2 | 0) <= 1) {
            d2 = 14;
            break;
          }
        }
        a: do {
          if ((d2 | 0) != 13) {
            if ((d2 | 0) == 14) {
              if (((b[k >> 2] | 0) <= 1 ? (b[k + 4 >> 2] | 0) <= 1 : 0) ? (b[k + 8 >> 2] | 0) <= 1 : 0) {
                d2 = Ra(k) | 0;
                f2 = va(n, d2) | 0;
                if ((f2 | 0) == 127) {
                  j = 0;
                } else {
                  j = oa(f2) | 0;
                }
                b: do {
                  if (!d2) {
                    if ((l | 0) != 0 & (j | 0) != 0) {
                      d2 = Pb(a2, c4) | 0;
                      g2 = e3;
                      g2 = Pb(b[g2 >> 2] | 0, b[g2 + 4 >> 2] | 0) | 0;
                      if ((d2 | 0) == 7 | (g2 | 0) == 7) {
                        f2 = 5;
                        break a;
                      }
                      g2 = b[21376 + (d2 * 28 | 0) + (g2 << 2) >> 2] | 0;
                      if ((g2 | 0) < 0) {
                        f2 = 5;
                        break a;
                      }
                      if (!g2) {
                        d2 = 59;
                      } else {
                        i = e3;
                        d2 = 0;
                        h = b[i >> 2] | 0;
                        i = b[i + 4 >> 2] | 0;
                        do {
                          h = Rb(h, i) | 0;
                          i = H() | 0;
                          u5 = e3;
                          b[u5 >> 2] = h;
                          b[u5 + 4 >> 2] = i;
                          d2 = d2 + 1 | 0;
                        } while ((d2 | 0) < (g2 | 0));
                        d2 = 58;
                      }
                    } else {
                      d2 = 58;
                    }
                  } else {
                    if (l) {
                      f2 = Pb(a2, c4) | 0;
                      if ((f2 | 0) == 7) {
                        f2 = 5;
                        break a;
                      }
                      g2 = b[21376 + (f2 * 28 | 0) + (d2 << 2) >> 2] | 0;
                      if ((g2 | 0) > 0) {
                        f2 = d2;
                        d2 = 0;
                        do {
                          f2 = $a(f2) | 0;
                          d2 = d2 + 1 | 0;
                        } while ((d2 | 0) != (g2 | 0));
                      } else {
                        f2 = d2;
                      }
                      if ((f2 | 0) == 1) {
                        f2 = 9;
                        break a;
                      }
                      d2 = va(n, f2) | 0;
                      if ((d2 | 0) == 127) {
                        I(27648, 27538, 411, 27678);
                      }
                      if (!(oa(d2) | 0)) {
                        p2 = d2;
                        o = g2;
                        m = f2;
                      } else {
                        I(27693, 27538, 412, 27678);
                      }
                    } else {
                      p2 = f2;
                      o = 0;
                      m = d2;
                    }
                    i = b[4272 + (n * 28 | 0) + (m << 2) >> 2] | 0;
                    if ((i | 0) <= -1) {
                      I(27724, 27538, 419, 27678);
                    }
                    if (!j) {
                      if ((o | 0) < 0) {
                        f2 = 5;
                        break a;
                      }
                      if (o | 0) {
                        g2 = e3;
                        f2 = 0;
                        d2 = b[g2 >> 2] | 0;
                        g2 = b[g2 + 4 >> 2] | 0;
                        do {
                          d2 = Rb(d2, g2) | 0;
                          g2 = H() | 0;
                          u5 = e3;
                          b[u5 >> 2] = d2;
                          b[u5 + 4 >> 2] = g2;
                          f2 = f2 + 1 | 0;
                        } while ((f2 | 0) < (o | 0));
                      }
                      if ((i | 0) <= 0) {
                        f2 = p2;
                        d2 = 58;
                        break;
                      }
                      g2 = e3;
                      f2 = 0;
                      d2 = b[g2 >> 2] | 0;
                      g2 = b[g2 + 4 >> 2] | 0;
                      while (1) {
                        d2 = Rb(d2, g2) | 0;
                        g2 = H() | 0;
                        u5 = e3;
                        b[u5 >> 2] = d2;
                        b[u5 + 4 >> 2] = g2;
                        f2 = f2 + 1 | 0;
                        if ((f2 | 0) == (i | 0)) {
                          f2 = p2;
                          d2 = 58;
                          break b;
                        }
                      }
                    }
                    h = wa(p2, n) | 0;
                    if ((h | 0) == 7) {
                      I(27514, 27538, 428, 27678);
                    }
                    f2 = e3;
                    d2 = b[f2 >> 2] | 0;
                    f2 = b[f2 + 4 >> 2] | 0;
                    if ((i | 0) > 0) {
                      g2 = 0;
                      do {
                        d2 = Rb(d2, f2) | 0;
                        f2 = H() | 0;
                        u5 = e3;
                        b[u5 >> 2] = d2;
                        b[u5 + 4 >> 2] = f2;
                        g2 = g2 + 1 | 0;
                      } while ((g2 | 0) != (i | 0));
                    }
                    f2 = Pb(d2, f2) | 0;
                    if ((f2 | 0) == 7) {
                      I(27795, 27538, 440, 27678);
                    }
                    d2 = pa(p2) | 0;
                    d2 = b[(d2 ? 21792 : 21584) + (h * 28 | 0) + (f2 << 2) >> 2] | 0;
                    if ((d2 | 0) < 0) {
                      I(27795, 27538, 454, 27678);
                    }
                    if (!d2) {
                      f2 = p2;
                      d2 = 58;
                    } else {
                      h = e3;
                      f2 = 0;
                      g2 = b[h >> 2] | 0;
                      h = b[h + 4 >> 2] | 0;
                      do {
                        g2 = Qb(g2, h) | 0;
                        h = H() | 0;
                        u5 = e3;
                        b[u5 >> 2] = g2;
                        b[u5 + 4 >> 2] = h;
                        f2 = f2 + 1 | 0;
                      } while ((f2 | 0) < (d2 | 0));
                      f2 = p2;
                      d2 = 58;
                    }
                  }
                } while (0);
                if ((d2 | 0) == 58) {
                  if (j) {
                    d2 = 59;
                  }
                }
                if ((d2 | 0) == 59) {
                  u5 = e3;
                  if ((Pb(b[u5 >> 2] | 0, b[u5 + 4 >> 2] | 0) | 0) == 1) {
                    f2 = 9;
                    break;
                  }
                }
                u5 = e3;
                s2 = b[u5 >> 2] | 0;
                u5 = b[u5 + 4 >> 2] & -1040385;
                t4 = Rd(f2 | 0, 0, 45) | 0;
                u5 = u5 | (H() | 0);
                f2 = e3;
                b[f2 >> 2] = s2 | t4;
                b[f2 + 4 >> 2] = u5;
                f2 = 0;
              } else {
                f2 = 1;
              }
            }
          }
        } while (0);
        u5 = f2;
        T2 = q2;
        return u5 | 0;
      }
      function Jc(a2, b2, c4, d2, e3, f2) {
        a2 = a2 | 0;
        b2 = b2 | 0;
        c4 = c4 | 0;
        d2 = d2 | 0;
        e3 = e3 | 0;
        f2 = f2 | 0;
        var g2 = 0, h = 0;
        h = T2;
        T2 = T2 + 16 | 0;
        g2 = h;
        if (!e3) {
          a2 = Hc(a2, b2, c4, d2, g2) | 0;
          if (!a2) {
            eb2(g2, f2);
            a2 = 0;
          }
        } else {
          a2 = 15;
        }
        T2 = h;
        return a2 | 0;
      }
      function Kc(a2, b2, c4, d2, e3) {
        a2 = a2 | 0;
        b2 = b2 | 0;
        c4 = c4 | 0;
        d2 = d2 | 0;
        e3 = e3 | 0;
        var f2 = 0, g2 = 0;
        g2 = T2;
        T2 = T2 + 16 | 0;
        f2 = g2;
        if (!d2) {
          c4 = fb(c4, f2) | 0;
          if (!c4) {
            c4 = Ic(a2, b2, f2, e3) | 0;
          }
        } else {
          c4 = 15;
        }
        T2 = g2;
        return c4 | 0;
      }
      function Lc(a2, c4, d2, e3, f2) {
        a2 = a2 | 0;
        c4 = c4 | 0;
        d2 = d2 | 0;
        e3 = e3 | 0;
        f2 = f2 | 0;
        var g2 = 0, h = 0, i = 0, j = 0;
        j = T2;
        T2 = T2 + 32 | 0;
        h = j + 12 | 0;
        i = j;
        g2 = Hc(a2, c4, a2, c4, h) | 0;
        if (g2 | 0) {
          i = g2;
          T2 = j;
          return i | 0;
        }
        a2 = Hc(a2, c4, d2, e3, i) | 0;
        if (a2 | 0) {
          i = a2;
          T2 = j;
          return i | 0;
        }
        h = db(h, i) | 0;
        i = f2;
        b[i >> 2] = h;
        b[i + 4 >> 2] = ((h | 0) < 0) << 31 >> 31;
        i = 0;
        T2 = j;
        return i | 0;
      }
      function Mc(a2, c4, d2, e3, f2) {
        a2 = a2 | 0;
        c4 = c4 | 0;
        d2 = d2 | 0;
        e3 = e3 | 0;
        f2 = f2 | 0;
        var g2 = 0, h = 0, i = 0, j = 0;
        j = T2;
        T2 = T2 + 32 | 0;
        h = j + 12 | 0;
        i = j;
        g2 = Hc(a2, c4, a2, c4, h) | 0;
        if (!g2) {
          g2 = Hc(a2, c4, d2, e3, i) | 0;
          if (!g2) {
            e3 = db(h, i) | 0;
            e3 = Gd(e3 | 0, ((e3 | 0) < 0) << 31 >> 31 | 0, 1, 0) | 0;
            h = H() | 0;
            i = f2;
            b[i >> 2] = e3;
            b[i + 4 >> 2] = h;
            i = 0;
            T2 = j;
            return i | 0;
          }
        }
        i = g2;
        T2 = j;
        return i | 0;
      }
      function Nc(a2, c4, d2, e3, f2) {
        a2 = a2 | 0;
        c4 = c4 | 0;
        d2 = d2 | 0;
        e3 = e3 | 0;
        f2 = f2 | 0;
        var g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p2 = 0, r2 = 0, s2 = 0, t4 = 0, u5 = 0, v3 = 0, w4 = 0, x2 = 0, y2 = 0, z2 = 0, A6 = 0;
        z2 = T2;
        T2 = T2 + 48 | 0;
        x2 = z2 + 24 | 0;
        h = z2 + 12 | 0;
        y2 = z2;
        g2 = Hc(a2, c4, a2, c4, x2) | 0;
        if (!g2) {
          g2 = Hc(a2, c4, d2, e3, h) | 0;
          if (!g2) {
            v3 = db(x2, h) | 0;
            w4 = ((v3 | 0) < 0) << 31 >> 31;
            b[x2 >> 2] = 0;
            b[x2 + 4 >> 2] = 0;
            b[x2 + 8 >> 2] = 0;
            b[h >> 2] = 0;
            b[h + 4 >> 2] = 0;
            b[h + 8 >> 2] = 0;
            if (Hc(a2, c4, a2, c4, x2) | 0) {
              I(27795, 27538, 692, 27747);
            }
            if (Hc(a2, c4, d2, e3, h) | 0) {
              I(27795, 27538, 697, 27747);
            }
            gb(x2);
            gb(h);
            l = (v3 | 0) == 0 ? 0 : 1 / +(v3 | 0);
            d2 = b[x2 >> 2] | 0;
            r2 = l * +((b[h >> 2] | 0) - d2 | 0);
            s2 = x2 + 4 | 0;
            e3 = b[s2 >> 2] | 0;
            t4 = l * +((b[h + 4 >> 2] | 0) - e3 | 0);
            u5 = x2 + 8 | 0;
            g2 = b[u5 >> 2] | 0;
            l = l * +((b[h + 8 >> 2] | 0) - g2 | 0);
            b[y2 >> 2] = d2;
            m = y2 + 4 | 0;
            b[m >> 2] = e3;
            n = y2 + 8 | 0;
            b[n >> 2] = g2;
            a: do {
              if ((v3 | 0) < 0) {
                g2 = 0;
              } else {
                o = 0;
                p2 = 0;
                while (1) {
                  j = +(p2 >>> 0) + 4294967296 * +(o | 0);
                  A6 = r2 * j + +(d2 | 0);
                  i = t4 * j + +(e3 | 0);
                  j = l * j + +(g2 | 0);
                  d2 = ~~+Vd(+A6);
                  h = ~~+Vd(+i);
                  g2 = ~~+Vd(+j);
                  A6 = +q(+(+(d2 | 0) - A6));
                  i = +q(+(+(h | 0) - i));
                  j = +q(+(+(g2 | 0) - j));
                  do {
                    if (!(A6 > i & A6 > j)) {
                      k = 0 - d2 | 0;
                      if (i > j) {
                        e3 = k - g2 | 0;
                        break;
                      } else {
                        e3 = h;
                        g2 = k - h | 0;
                        break;
                      }
                    } else {
                      d2 = 0 - (h + g2) | 0;
                      e3 = h;
                    }
                  } while (0);
                  b[y2 >> 2] = d2;
                  b[m >> 2] = e3;
                  b[n >> 2] = g2;
                  hb(y2);
                  g2 = Ic(a2, c4, y2, f2 + (p2 << 3) | 0) | 0;
                  if (g2 | 0) {
                    break a;
                  }
                  if (!((o | 0) < (w4 | 0) | (o | 0) == (w4 | 0) & p2 >>> 0 < v3 >>> 0)) {
                    g2 = 0;
                    break a;
                  }
                  d2 = Gd(p2 | 0, o | 0, 1, 0) | 0;
                  e3 = H() | 0;
                  o = e3;
                  p2 = d2;
                  d2 = b[x2 >> 2] | 0;
                  e3 = b[s2 >> 2] | 0;
                  g2 = b[u5 >> 2] | 0;
                }
              }
            } while (0);
            y2 = g2;
            T2 = z2;
            return y2 | 0;
          }
        }
        y2 = g2;
        T2 = z2;
        return y2 | 0;
      }
      function Oc(a2, b2, c4, d2) {
        a2 = a2 | 0;
        b2 = b2 | 0;
        c4 = c4 | 0;
        d2 = d2 | 0;
        var e3 = 0, f2 = 0, g2 = 0;
        if ((c4 | 0) == 0 & (d2 | 0) == 0) {
          e3 = 0;
          f2 = 1;
          G(e3 | 0);
          return f2 | 0;
        }
        f2 = a2;
        e3 = b2;
        a2 = 1;
        b2 = 0;
        do {
          g2 = (c4 & 1 | 0) == 0 & true;
          a2 = Md((g2 ? 1 : f2) | 0, (g2 ? 0 : e3) | 0, a2 | 0, b2 | 0) | 0;
          b2 = H() | 0;
          c4 = Pd(c4 | 0, d2 | 0, 1) | 0;
          d2 = H() | 0;
          f2 = Md(f2 | 0, e3 | 0, f2 | 0, e3 | 0) | 0;
          e3 = H() | 0;
        } while (!((c4 | 0) == 0 & (d2 | 0) == 0));
        G(b2 | 0);
        return a2 | 0;
      }
      function Pc(a2, c4, d2, f2) {
        a2 = a2 | 0;
        c4 = c4 | 0;
        d2 = d2 | 0;
        f2 = f2 | 0;
        var g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0;
        j = T2;
        T2 = T2 + 16 | 0;
        h = j;
        i = Qd(a2 | 0, c4 | 0, 52) | 0;
        H() | 0;
        i = i & 15;
        do {
          if (!i) {
            g2 = Qd(a2 | 0, c4 | 0, 45) | 0;
            H() | 0;
            g2 = g2 & 127;
            if (g2 >>> 0 > 121) {
              i = 5;
              T2 = j;
              return i | 0;
            } else {
              h = 22064 + (g2 << 5) | 0;
              b[d2 >> 2] = b[h >> 2];
              b[d2 + 4 >> 2] = b[h + 4 >> 2];
              b[d2 + 8 >> 2] = b[h + 8 >> 2];
              b[d2 + 12 >> 2] = b[h + 12 >> 2];
              b[d2 + 16 >> 2] = b[h + 16 >> 2];
              b[d2 + 20 >> 2] = b[h + 20 >> 2];
              b[d2 + 24 >> 2] = b[h + 24 >> 2];
              b[d2 + 28 >> 2] = b[h + 28 >> 2];
              break;
            }
          } else {
            g2 = Zb(a2, c4, h) | 0;
            if (!g2) {
              l = +e[h >> 3];
              k = 1 / +t(+l);
              m = +e[25968 + (i << 3) >> 3];
              e[d2 >> 3] = l + m;
              e[d2 + 8 >> 3] = l - m;
              l = +e[h + 8 >> 3];
              k = m * k;
              e[d2 + 16 >> 3] = k + l;
              e[d2 + 24 >> 3] = l - k;
              break;
            }
            i = g2;
            T2 = j;
            return i | 0;
          }
        } while (0);
        Ja(d2, f2 ? 1.4 : 1.1);
        f2 = 26096 + (i << 3) | 0;
        if ((b[f2 >> 2] | 0) == (a2 | 0) ? (b[f2 + 4 >> 2] | 0) == (c4 | 0) : 0) {
          e[d2 >> 3] = 1.5707963267948966;
        }
        i = 26224 + (i << 3) | 0;
        if ((b[i >> 2] | 0) == (a2 | 0) ? (b[i + 4 >> 2] | 0) == (c4 | 0) : 0) {
          e[d2 + 8 >> 3] = -1.5707963267948966;
        }
        if (!(+e[d2 >> 3] == 1.5707963267948966) ? !(+e[d2 + 8 >> 3] == -1.5707963267948966) : 0) {
          i = 0;
          T2 = j;
          return i | 0;
        }
        e[d2 + 16 >> 3] = 3.141592653589793;
        e[d2 + 24 >> 3] = -3.141592653589793;
        i = 0;
        T2 = j;
        return i | 0;
      }
      function Qc(c4, d2, e3, f2) {
        c4 = c4 | 0;
        d2 = d2 | 0;
        e3 = e3 | 0;
        f2 = f2 | 0;
        var g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0;
        l = T2;
        T2 = T2 + 48 | 0;
        i = l + 32 | 0;
        h = l + 40 | 0;
        j = l;
        Eb(i, 0, 0, 0);
        k = b[i >> 2] | 0;
        i = b[i + 4 >> 2] | 0;
        do {
          if (e3 >>> 0 <= 15) {
            g2 = Xc(f2) | 0;
            if (g2 | 0) {
              f2 = j;
              b[f2 >> 2] = 0;
              b[f2 + 4 >> 2] = 0;
              b[j + 8 >> 2] = g2;
              b[j + 12 >> 2] = -1;
              f2 = j + 16 | 0;
              k = j + 29 | 0;
              b[f2 >> 2] = 0;
              b[f2 + 4 >> 2] = 0;
              b[f2 + 8 >> 2] = 0;
              a[f2 + 12 >> 0] = 0;
              a[k >> 0] = a[h >> 0] | 0;
              a[k + 1 >> 0] = a[h + 1 >> 0] | 0;
              a[k + 2 >> 0] = a[h + 2 >> 0] | 0;
              break;
            }
            g2 = Fd((b[d2 + 8 >> 2] | 0) + 1 | 0, 32) | 0;
            if (!g2) {
              f2 = j;
              b[f2 >> 2] = 0;
              b[f2 + 4 >> 2] = 0;
              b[j + 8 >> 2] = 13;
              b[j + 12 >> 2] = -1;
              f2 = j + 16 | 0;
              k = j + 29 | 0;
              b[f2 >> 2] = 0;
              b[f2 + 4 >> 2] = 0;
              b[f2 + 8 >> 2] = 0;
              a[f2 + 12 >> 0] = 0;
              a[k >> 0] = a[h >> 0] | 0;
              a[k + 1 >> 0] = a[h + 1 >> 0] | 0;
              a[k + 2 >> 0] = a[h + 2 >> 0] | 0;
              break;
            } else {
              Yc(d2, g2);
              m = j;
              b[m >> 2] = k;
              b[m + 4 >> 2] = i;
              b[j + 8 >> 2] = 0;
              b[j + 12 >> 2] = e3;
              b[j + 16 >> 2] = f2;
              b[j + 20 >> 2] = d2;
              b[j + 24 >> 2] = g2;
              a[j + 28 >> 0] = 0;
              k = j + 29 | 0;
              a[k >> 0] = a[h >> 0] | 0;
              a[k + 1 >> 0] = a[h + 1 >> 0] | 0;
              a[k + 2 >> 0] = a[h + 2 >> 0] | 0;
              break;
            }
          } else {
            k = j;
            b[k >> 2] = 0;
            b[k + 4 >> 2] = 0;
            b[j + 8 >> 2] = 4;
            b[j + 12 >> 2] = -1;
            k = j + 16 | 0;
            m = j + 29 | 0;
            b[k >> 2] = 0;
            b[k + 4 >> 2] = 0;
            b[k + 8 >> 2] = 0;
            a[k + 12 >> 0] = 0;
            a[m >> 0] = a[h >> 0] | 0;
            a[m + 1 >> 0] = a[h + 1 >> 0] | 0;
            a[m + 2 >> 0] = a[h + 2 >> 0] | 0;
          }
        } while (0);
        Rc(j);
        b[c4 >> 2] = b[j >> 2];
        b[c4 + 4 >> 2] = b[j + 4 >> 2];
        b[c4 + 8 >> 2] = b[j + 8 >> 2];
        b[c4 + 12 >> 2] = b[j + 12 >> 2];
        b[c4 + 16 >> 2] = b[j + 16 >> 2];
        b[c4 + 20 >> 2] = b[j + 20 >> 2];
        b[c4 + 24 >> 2] = b[j + 24 >> 2];
        b[c4 + 28 >> 2] = b[j + 28 >> 2];
        T2 = l;
        return;
      }
      function Rc(c4) {
        c4 = c4 | 0;
        var d2 = 0, e3 = 0, f2 = 0, g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p2 = 0, q2 = 0, r2 = 0, s2 = 0, t4 = 0, u5 = 0, v3 = 0, w4 = 0;
        w4 = T2;
        T2 = T2 + 336 | 0;
        p2 = w4 + 168 | 0;
        q2 = w4;
        f2 = c4;
        e3 = b[f2 >> 2] | 0;
        f2 = b[f2 + 4 >> 2] | 0;
        if ((e3 | 0) == 0 & (f2 | 0) == 0) {
          T2 = w4;
          return;
        }
        d2 = c4 + 28 | 0;
        if (!(a[d2 >> 0] | 0)) {
          a[d2 >> 0] = 1;
        } else {
          e3 = Sc(e3, f2) | 0;
          f2 = H() | 0;
        }
        v3 = c4 + 20 | 0;
        if (!(b[b[v3 >> 2] >> 2] | 0)) {
          d2 = c4 + 24 | 0;
          e3 = b[d2 >> 2] | 0;
          if (e3 | 0) {
            Ed(e3);
          }
          u5 = c4;
          b[u5 >> 2] = 0;
          b[u5 + 4 >> 2] = 0;
          b[c4 + 8 >> 2] = 0;
          b[v3 >> 2] = 0;
          b[c4 + 12 >> 2] = -1;
          b[c4 + 16 >> 2] = 0;
          b[d2 >> 2] = 0;
          T2 = w4;
          return;
        }
        u5 = c4 + 16 | 0;
        d2 = b[u5 >> 2] | 0;
        g2 = d2 & 15;
        a: do {
          if (!((e3 | 0) == 0 & (f2 | 0) == 0)) {
            r2 = c4 + 12 | 0;
            n = (g2 | 0) == 3;
            m = d2 & 255;
            k = (g2 | 1 | 0) == 3;
            o = c4 + 24 | 0;
            l = (g2 + -1 | 0) >>> 0 < 3;
            i = (g2 | 2 | 0) == 3;
            j = q2 + 8 | 0;
            b: while (1) {
              h = Qd(e3 | 0, f2 | 0, 52) | 0;
              H() | 0;
              h = h & 15;
              if ((h | 0) == (b[r2 >> 2] | 0)) {
                switch (m & 15) {
                  case 0:
                  case 2:
                  case 3: {
                    g2 = Zb(e3, f2, p2) | 0;
                    if (g2 | 0) {
                      s2 = 15;
                      break b;
                    }
                    if (Zc(b[v3 >> 2] | 0, b[o >> 2] | 0, p2) | 0) {
                      s2 = 19;
                      break b;
                    }
                    break;
                  }
                  default:
                }
                if (k ? (g2 = b[(b[v3 >> 2] | 0) + 4 >> 2] | 0, b[p2 >> 2] = b[g2 >> 2], b[p2 + 4 >> 2] = b[g2 + 4 >> 2], b[p2 + 8 >> 2] = b[g2 + 8 >> 2], b[p2 + 12 >> 2] = b[g2 + 12 >> 2], Ca(26832, p2) | 0) : 0) {
                  if (Wb(b[(b[v3 >> 2] | 0) + 4 >> 2] | 0, h, q2) | 0) {
                    s2 = 25;
                    break;
                  }
                  g2 = q2;
                  if ((b[g2 >> 2] | 0) == (e3 | 0) ? (b[g2 + 4 >> 2] | 0) == (f2 | 0) : 0) {
                    s2 = 29;
                    break;
                  }
                }
                if (l) {
                  g2 = _b2(e3, f2, p2) | 0;
                  if (g2 | 0) {
                    s2 = 32;
                    break;
                  }
                  if (Pc(e3, f2, q2, 0) | 0) {
                    s2 = 36;
                    break;
                  }
                  if (i ? _c(b[v3 >> 2] | 0, b[o >> 2] | 0, p2, q2) | 0 : 0) {
                    s2 = 42;
                    break;
                  }
                  if (k ? ad(b[v3 >> 2] | 0, b[o >> 2] | 0, p2, q2) | 0 : 0) {
                    s2 = 42;
                    break;
                  }
                }
                if (n) {
                  d2 = Pc(e3, f2, p2, 1) | 0;
                  g2 = b[o >> 2] | 0;
                  if (d2 | 0) {
                    s2 = 45;
                    break;
                  }
                  if (Da(g2, p2) | 0) {
                    Ga(q2, p2);
                    if (Fa(p2, b[o >> 2] | 0) | 0) {
                      s2 = 53;
                      break;
                    }
                    if (Zc(b[v3 >> 2] | 0, b[o >> 2] | 0, j) | 0) {
                      s2 = 53;
                      break;
                    }
                    if (ad(b[v3 >> 2] | 0, b[o >> 2] | 0, q2, p2) | 0) {
                      s2 = 53;
                      break;
                    }
                  }
                }
              }
              do {
                if ((h | 0) < (b[r2 >> 2] | 0)) {
                  d2 = Pc(e3, f2, p2, 1) | 0;
                  g2 = b[o >> 2] | 0;
                  if (d2 | 0) {
                    s2 = 58;
                    break b;
                  }
                  if (!(Da(g2, p2) | 0)) {
                    s2 = 73;
                    break;
                  }
                  if (Fa(b[o >> 2] | 0, p2) | 0 ? (Ga(q2, p2), _c(b[v3 >> 2] | 0, b[o >> 2] | 0, q2, p2) | 0) : 0) {
                    s2 = 65;
                    break b;
                  }
                  e3 = Kb(e3, f2, h + 1 | 0, q2) | 0;
                  if (e3 | 0) {
                    s2 = 67;
                    break b;
                  }
                  f2 = q2;
                  e3 = b[f2 >> 2] | 0;
                  f2 = b[f2 + 4 >> 2] | 0;
                } else {
                  s2 = 73;
                }
              } while (0);
              if ((s2 | 0) == 73) {
                s2 = 0;
                e3 = Sc(e3, f2) | 0;
                f2 = H() | 0;
              }
              if ((e3 | 0) == 0 & (f2 | 0) == 0) {
                t4 = o;
                break a;
              }
            }
            switch (s2 | 0) {
              case 15: {
                d2 = b[o >> 2] | 0;
                if (d2 | 0) {
                  Ed(d2);
                }
                s2 = c4;
                b[s2 >> 2] = 0;
                b[s2 + 4 >> 2] = 0;
                b[v3 >> 2] = 0;
                b[r2 >> 2] = -1;
                b[u5 >> 2] = 0;
                b[o >> 2] = 0;
                b[c4 + 8 >> 2] = g2;
                s2 = 20;
                break;
              }
              case 19: {
                b[c4 >> 2] = e3;
                b[c4 + 4 >> 2] = f2;
                s2 = 20;
                break;
              }
              case 25: {
                I(27795, 27761, 470, 27772);
                break;
              }
              case 29: {
                b[c4 >> 2] = e3;
                b[c4 + 4 >> 2] = f2;
                T2 = w4;
                return;
              }
              case 32: {
                d2 = b[o >> 2] | 0;
                if (d2 | 0) {
                  Ed(d2);
                }
                t4 = c4;
                b[t4 >> 2] = 0;
                b[t4 + 4 >> 2] = 0;
                b[v3 >> 2] = 0;
                b[r2 >> 2] = -1;
                b[u5 >> 2] = 0;
                b[o >> 2] = 0;
                b[c4 + 8 >> 2] = g2;
                T2 = w4;
                return;
              }
              case 36: {
                I(27795, 27761, 493, 27772);
                break;
              }
              case 42: {
                b[c4 >> 2] = e3;
                b[c4 + 4 >> 2] = f2;
                T2 = w4;
                return;
              }
              case 45: {
                if (g2 | 0) {
                  Ed(g2);
                }
                s2 = c4;
                b[s2 >> 2] = 0;
                b[s2 + 4 >> 2] = 0;
                b[v3 >> 2] = 0;
                b[r2 >> 2] = -1;
                b[u5 >> 2] = 0;
                b[o >> 2] = 0;
                b[c4 + 8 >> 2] = d2;
                s2 = 55;
                break;
              }
              case 53: {
                b[c4 >> 2] = e3;
                b[c4 + 4 >> 2] = f2;
                s2 = 55;
                break;
              }
              case 58: {
                if (g2 | 0) {
                  Ed(g2);
                }
                s2 = c4;
                b[s2 >> 2] = 0;
                b[s2 + 4 >> 2] = 0;
                b[v3 >> 2] = 0;
                b[r2 >> 2] = -1;
                b[u5 >> 2] = 0;
                b[o >> 2] = 0;
                b[c4 + 8 >> 2] = d2;
                s2 = 71;
                break;
              }
              case 65: {
                b[c4 >> 2] = e3;
                b[c4 + 4 >> 2] = f2;
                s2 = 71;
                break;
              }
              case 67: {
                d2 = b[o >> 2] | 0;
                if (d2 | 0) {
                  Ed(d2);
                }
                t4 = c4;
                b[t4 >> 2] = 0;
                b[t4 + 4 >> 2] = 0;
                b[v3 >> 2] = 0;
                b[r2 >> 2] = -1;
                b[u5 >> 2] = 0;
                b[o >> 2] = 0;
                b[c4 + 8 >> 2] = e3;
                T2 = w4;
                return;
              }
            }
            if ((s2 | 0) == 20) {
              T2 = w4;
              return;
            } else if ((s2 | 0) == 55) {
              T2 = w4;
              return;
            } else if ((s2 | 0) == 71) {
              T2 = w4;
              return;
            }
          } else {
            t4 = c4 + 24 | 0;
          }
        } while (0);
        d2 = b[t4 >> 2] | 0;
        if (d2 | 0) {
          Ed(d2);
        }
        s2 = c4;
        b[s2 >> 2] = 0;
        b[s2 + 4 >> 2] = 0;
        b[c4 + 8 >> 2] = 0;
        b[v3 >> 2] = 0;
        b[c4 + 12 >> 2] = -1;
        b[u5 >> 2] = 0;
        b[t4 >> 2] = 0;
        T2 = w4;
        return;
      }
      function Sc(a2, c4) {
        a2 = a2 | 0;
        c4 = c4 | 0;
        var d2 = 0, e3 = 0, f2 = 0, g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0;
        m = T2;
        T2 = T2 + 16 | 0;
        l = m;
        e3 = Qd(a2 | 0, c4 | 0, 52) | 0;
        H() | 0;
        e3 = e3 & 15;
        d2 = Qd(a2 | 0, c4 | 0, 45) | 0;
        H() | 0;
        do {
          if (e3) {
            while (1) {
              d2 = Rd(e3 + 4095 | 0, 0, 52) | 0;
              f2 = H() | 0 | c4 & -15728641;
              g2 = (15 - e3 | 0) * 3 | 0;
              h = Rd(7, 0, g2 | 0) | 0;
              i = H() | 0;
              d2 = d2 | a2 | h;
              f2 = f2 | i;
              j = Qd(a2 | 0, c4 | 0, g2 | 0) | 0;
              H() | 0;
              j = j & 7;
              e3 = e3 + -1 | 0;
              if (j >>> 0 < 6) {
                break;
              }
              if (!e3) {
                k = 4;
                break;
              } else {
                c4 = f2;
                a2 = d2;
              }
            }
            if ((k | 0) == 4) {
              d2 = Qd(d2 | 0, f2 | 0, 45) | 0;
              H() | 0;
              break;
            }
            l = (j | 0) == 0 & (Hb(d2, f2) | 0) != 0;
            l = Rd((l ? 2 : 1) + j | 0, 0, g2 | 0) | 0;
            k = H() | 0 | c4 & ~i;
            l = l | a2 & ~h;
            G(k | 0);
            T2 = m;
            return l | 0;
          }
        } while (0);
        d2 = d2 & 127;
        if (d2 >>> 0 > 120) {
          k = 0;
          l = 0;
          G(k | 0);
          T2 = m;
          return l | 0;
        }
        Eb(l, 0, d2 + 1 | 0, 0);
        k = b[l + 4 >> 2] | 0;
        l = b[l >> 2] | 0;
        G(k | 0);
        T2 = m;
        return l | 0;
      }
      function Tc(a2, c4, d2, e3, f2, g2) {
        a2 = a2 | 0;
        c4 = c4 | 0;
        d2 = d2 | 0;
        e3 = e3 | 0;
        f2 = f2 | 0;
        g2 = g2 | 0;
        var h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p2 = 0, q2 = 0, r2 = 0;
        r2 = T2;
        T2 = T2 + 160 | 0;
        m = r2 + 80 | 0;
        i = r2 + 64 | 0;
        n = r2 + 112 | 0;
        q2 = r2;
        Qc(m, a2, c4, d2);
        k = m;
        fc(i, b[k >> 2] | 0, b[k + 4 >> 2] | 0, c4);
        k = i;
        j = b[k >> 2] | 0;
        k = b[k + 4 >> 2] | 0;
        h = b[m + 8 >> 2] | 0;
        o = n + 4 | 0;
        b[o >> 2] = b[m >> 2];
        b[o + 4 >> 2] = b[m + 4 >> 2];
        b[o + 8 >> 2] = b[m + 8 >> 2];
        b[o + 12 >> 2] = b[m + 12 >> 2];
        b[o + 16 >> 2] = b[m + 16 >> 2];
        b[o + 20 >> 2] = b[m + 20 >> 2];
        b[o + 24 >> 2] = b[m + 24 >> 2];
        b[o + 28 >> 2] = b[m + 28 >> 2];
        o = q2;
        b[o >> 2] = j;
        b[o + 4 >> 2] = k;
        o = q2 + 8 | 0;
        b[o >> 2] = h;
        a2 = q2 + 12 | 0;
        c4 = n;
        d2 = a2 + 36 | 0;
        do {
          b[a2 >> 2] = b[c4 >> 2];
          a2 = a2 + 4 | 0;
          c4 = c4 + 4 | 0;
        } while ((a2 | 0) < (d2 | 0));
        n = q2 + 48 | 0;
        b[n >> 2] = b[i >> 2];
        b[n + 4 >> 2] = b[i + 4 >> 2];
        b[n + 8 >> 2] = b[i + 8 >> 2];
        b[n + 12 >> 2] = b[i + 12 >> 2];
        if ((j | 0) == 0 & (k | 0) == 0) {
          q2 = h;
          T2 = r2;
          return q2 | 0;
        }
        d2 = q2 + 16 | 0;
        l = q2 + 24 | 0;
        m = q2 + 28 | 0;
        h = 0;
        i = 0;
        c4 = j;
        a2 = k;
        do {
          if (!((h | 0) < (f2 | 0) | (h | 0) == (f2 | 0) & i >>> 0 < e3 >>> 0)) {
            p2 = 4;
            break;
          }
          k = i;
          i = Gd(i | 0, h | 0, 1, 0) | 0;
          h = H() | 0;
          k = g2 + (k << 3) | 0;
          b[k >> 2] = c4;
          b[k + 4 >> 2] = a2;
          hc(n);
          a2 = n;
          c4 = b[a2 >> 2] | 0;
          a2 = b[a2 + 4 >> 2] | 0;
          if ((c4 | 0) == 0 & (a2 | 0) == 0) {
            Rc(d2);
            c4 = d2;
            a2 = b[c4 >> 2] | 0;
            c4 = b[c4 + 4 >> 2] | 0;
            if ((a2 | 0) == 0 & (c4 | 0) == 0) {
              p2 = 10;
              break;
            }
            gc(a2, c4, b[m >> 2] | 0, n);
            a2 = n;
            c4 = b[a2 >> 2] | 0;
            a2 = b[a2 + 4 >> 2] | 0;
          }
          k = q2;
          b[k >> 2] = c4;
          b[k + 4 >> 2] = a2;
        } while (!((c4 | 0) == 0 & (a2 | 0) == 0));
        if ((p2 | 0) == 4) {
          a2 = q2 + 40 | 0;
          c4 = b[a2 >> 2] | 0;
          if (c4 | 0) {
            Ed(c4);
          }
          p2 = q2 + 16 | 0;
          b[p2 >> 2] = 0;
          b[p2 + 4 >> 2] = 0;
          b[l >> 2] = 0;
          b[q2 + 36 >> 2] = 0;
          b[m >> 2] = -1;
          b[q2 + 32 >> 2] = 0;
          b[a2 >> 2] = 0;
          gc(0, 0, 0, n);
          b[q2 >> 2] = 0;
          b[q2 + 4 >> 2] = 0;
          b[o >> 2] = 0;
          q2 = 14;
          T2 = r2;
          return q2 | 0;
        } else if ((p2 | 0) == 10) {
          b[q2 >> 2] = 0;
          b[q2 + 4 >> 2] = 0;
          b[o >> 2] = b[l >> 2];
        }
        q2 = b[o >> 2] | 0;
        T2 = r2;
        return q2 | 0;
      }
      function Uc(c4, d2, f2, g2) {
        c4 = c4 | 0;
        d2 = d2 | 0;
        f2 = f2 | 0;
        g2 = g2 | 0;
        var h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p2 = 0, r2 = 0;
        o = T2;
        T2 = T2 + 48 | 0;
        l = o + 32 | 0;
        k = o + 40 | 0;
        m = o;
        if (!(b[c4 >> 2] | 0)) {
          n = g2;
          b[n >> 2] = 0;
          b[n + 4 >> 2] = 0;
          n = 0;
          T2 = o;
          return n | 0;
        }
        Eb(l, 0, 0, 0);
        j = l;
        h = b[j >> 2] | 0;
        j = b[j + 4 >> 2] | 0;
        do {
          if (d2 >>> 0 > 15) {
            n = m;
            b[n >> 2] = 0;
            b[n + 4 >> 2] = 0;
            b[m + 8 >> 2] = 4;
            b[m + 12 >> 2] = -1;
            n = m + 16 | 0;
            f2 = m + 29 | 0;
            b[n >> 2] = 0;
            b[n + 4 >> 2] = 0;
            b[n + 8 >> 2] = 0;
            a[n + 12 >> 0] = 0;
            a[f2 >> 0] = a[k >> 0] | 0;
            a[f2 + 1 >> 0] = a[k + 1 >> 0] | 0;
            a[f2 + 2 >> 0] = a[k + 2 >> 0] | 0;
            f2 = 4;
            n = 9;
          } else {
            f2 = Xc(f2) | 0;
            if (f2 | 0) {
              l = m;
              b[l >> 2] = 0;
              b[l + 4 >> 2] = 0;
              b[m + 8 >> 2] = f2;
              b[m + 12 >> 2] = -1;
              l = m + 16 | 0;
              n = m + 29 | 0;
              b[l >> 2] = 0;
              b[l + 4 >> 2] = 0;
              b[l + 8 >> 2] = 0;
              a[l + 12 >> 0] = 0;
              a[n >> 0] = a[k >> 0] | 0;
              a[n + 1 >> 0] = a[k + 1 >> 0] | 0;
              a[n + 2 >> 0] = a[k + 2 >> 0] | 0;
              n = 9;
              break;
            }
            f2 = Fd((b[c4 + 8 >> 2] | 0) + 1 | 0, 32) | 0;
            if (!f2) {
              n = m;
              b[n >> 2] = 0;
              b[n + 4 >> 2] = 0;
              b[m + 8 >> 2] = 13;
              b[m + 12 >> 2] = -1;
              n = m + 16 | 0;
              f2 = m + 29 | 0;
              b[n >> 2] = 0;
              b[n + 4 >> 2] = 0;
              b[n + 8 >> 2] = 0;
              a[n + 12 >> 0] = 0;
              a[f2 >> 0] = a[k >> 0] | 0;
              a[f2 + 1 >> 0] = a[k + 1 >> 0] | 0;
              a[f2 + 2 >> 0] = a[k + 2 >> 0] | 0;
              f2 = 13;
              n = 9;
              break;
            }
            Yc(c4, f2);
            r2 = m;
            b[r2 >> 2] = h;
            b[r2 + 4 >> 2] = j;
            j = m + 8 | 0;
            b[j >> 2] = 0;
            b[m + 12 >> 2] = d2;
            b[m + 20 >> 2] = c4;
            b[m + 24 >> 2] = f2;
            a[m + 28 >> 0] = 0;
            h = m + 29 | 0;
            a[h >> 0] = a[k >> 0] | 0;
            a[h + 1 >> 0] = a[k + 1 >> 0] | 0;
            a[h + 2 >> 0] = a[k + 2 >> 0] | 0;
            b[m + 16 >> 2] = 3;
            p2 = +Ba(f2);
            p2 = p2 * +za(f2);
            i = +q(+ +e[f2 >> 3]);
            i = p2 / +t(+ +Ud(+i, + +q(+ +e[f2 + 8 >> 3]))) * 6371.007180918475 * 6371.007180918475;
            h = m + 12 | 0;
            f2 = b[h >> 2] | 0;
            a: do {
              if ((f2 | 0) > 0) {
                do {
                  qc(f2 + -1 | 0, l) | 0;
                  if (!(i / +e[l >> 3] > 10)) {
                    break a;
                  }
                  r2 = b[h >> 2] | 0;
                  f2 = r2 + -1 | 0;
                  b[h >> 2] = f2;
                } while ((r2 | 0) > 1);
              }
            } while (0);
            Rc(m);
            h = g2;
            b[h >> 2] = 0;
            b[h + 4 >> 2] = 0;
            h = m;
            f2 = b[h >> 2] | 0;
            h = b[h + 4 >> 2] | 0;
            if (!((f2 | 0) == 0 & (h | 0) == 0)) {
              do {
                Gb(f2, h, d2, l) | 0;
                k = l;
                c4 = g2;
                k = Gd(b[c4 >> 2] | 0, b[c4 + 4 >> 2] | 0, b[k >> 2] | 0, b[k + 4 >> 2] | 0) | 0;
                c4 = H() | 0;
                r2 = g2;
                b[r2 >> 2] = k;
                b[r2 + 4 >> 2] = c4;
                Rc(m);
                r2 = m;
                f2 = b[r2 >> 2] | 0;
                h = b[r2 + 4 >> 2] | 0;
              } while (!((f2 | 0) == 0 & (h | 0) == 0));
            }
            f2 = b[j >> 2] | 0;
          }
        } while (0);
        r2 = f2;
        T2 = o;
        return r2 | 0;
      }
      function Vc(a2, c4, d2) {
        a2 = a2 | 0;
        c4 = c4 | 0;
        d2 = d2 | 0;
        var f2 = 0, g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0;
        if (!(Ca(c4, d2) | 0)) {
          o = 0;
          return o | 0;
        }
        c4 = Aa(c4) | 0;
        f2 = +e[d2 >> 3];
        g2 = +e[d2 + 8 >> 3];
        g2 = c4 & g2 < 0 ? g2 + 6.283185307179586 : g2;
        o = b[a2 >> 2] | 0;
        if ((o | 0) <= 0) {
          o = 0;
          return o | 0;
        }
        n = b[a2 + 4 >> 2] | 0;
        if (c4) {
          c4 = 0;
          m = g2;
          d2 = -1;
          a2 = 0;
          a: while (1) {
            l = a2;
            while (1) {
              i = +e[n + (l << 4) >> 3];
              g2 = +e[n + (l << 4) + 8 >> 3];
              a2 = (d2 + 2 | 0) % (o | 0) | 0;
              h = +e[n + (a2 << 4) >> 3];
              j = +e[n + (a2 << 4) + 8 >> 3];
              if (i > h) {
                k = i;
                i = j;
              } else {
                k = h;
                h = i;
                i = g2;
                g2 = j;
              }
              f2 = f2 == h | f2 == k ? f2 + 2220446049250313e-31 : f2;
              if (!(f2 < h | f2 > k)) {
                break;
              }
              d2 = l + 1 | 0;
              if ((d2 | 0) >= (o | 0)) {
                d2 = 22;
                break a;
              } else {
                a2 = l;
                l = d2;
                d2 = a2;
              }
            }
            j = i < 0 ? i + 6.283185307179586 : i;
            i = g2 < 0 ? g2 + 6.283185307179586 : g2;
            m = j == m | i == m ? m + -2220446049250313e-31 : m;
            k = j + (i - j) * ((f2 - h) / (k - h));
            if ((k < 0 ? k + 6.283185307179586 : k) > m) {
              c4 = c4 ^ 1;
            }
            a2 = l + 1 | 0;
            if ((a2 | 0) >= (o | 0)) {
              d2 = 22;
              break;
            } else {
              d2 = l;
            }
          }
          if ((d2 | 0) == 22) {
            return c4 | 0;
          }
        } else {
          c4 = 0;
          m = g2;
          d2 = -1;
          a2 = 0;
          b: while (1) {
            l = a2;
            while (1) {
              i = +e[n + (l << 4) >> 3];
              g2 = +e[n + (l << 4) + 8 >> 3];
              a2 = (d2 + 2 | 0) % (o | 0) | 0;
              h = +e[n + (a2 << 4) >> 3];
              j = +e[n + (a2 << 4) + 8 >> 3];
              if (i > h) {
                k = i;
                i = j;
              } else {
                k = h;
                h = i;
                i = g2;
                g2 = j;
              }
              f2 = f2 == h | f2 == k ? f2 + 2220446049250313e-31 : f2;
              if (!(f2 < h | f2 > k)) {
                break;
              }
              d2 = l + 1 | 0;
              if ((d2 | 0) >= (o | 0)) {
                d2 = 22;
                break b;
              } else {
                a2 = l;
                l = d2;
                d2 = a2;
              }
            }
            m = i == m | g2 == m ? m + -2220446049250313e-31 : m;
            if (i + (g2 - i) * ((f2 - h) / (k - h)) > m) {
              c4 = c4 ^ 1;
            }
            a2 = l + 1 | 0;
            if ((a2 | 0) >= (o | 0)) {
              d2 = 22;
              break;
            } else {
              d2 = l;
            }
          }
          if ((d2 | 0) == 22) {
            return c4 | 0;
          }
        }
        return 0;
      }
      function Wc(a2, c4) {
        a2 = a2 | 0;
        c4 = c4 | 0;
        var d2 = 0, f2 = 0, g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p2 = 0, r2 = 0, s2 = 0, t4 = 0, u5 = 0, v3 = 0;
        r2 = b[a2 >> 2] | 0;
        if (!r2) {
          b[c4 >> 2] = 0;
          b[c4 + 4 >> 2] = 0;
          b[c4 + 8 >> 2] = 0;
          b[c4 + 12 >> 2] = 0;
          b[c4 + 16 >> 2] = 0;
          b[c4 + 20 >> 2] = 0;
          b[c4 + 24 >> 2] = 0;
          b[c4 + 28 >> 2] = 0;
          return;
        }
        s2 = c4 + 8 | 0;
        e[s2 >> 3] = 17976931348623157e292;
        t4 = c4 + 24 | 0;
        e[t4 >> 3] = 17976931348623157e292;
        e[c4 >> 3] = -17976931348623157e292;
        u5 = c4 + 16 | 0;
        e[u5 >> 3] = -17976931348623157e292;
        if ((r2 | 0) <= 0) {
          return;
        }
        o = b[a2 + 4 >> 2] | 0;
        l = 17976931348623157e292;
        m = -17976931348623157e292;
        n = 0;
        a2 = -1;
        h = 17976931348623157e292;
        i = 17976931348623157e292;
        k = -17976931348623157e292;
        f2 = -17976931348623157e292;
        p2 = 0;
        while (1) {
          d2 = +e[o + (p2 << 4) >> 3];
          j = +e[o + (p2 << 4) + 8 >> 3];
          a2 = a2 + 2 | 0;
          g2 = +e[o + (((a2 | 0) == (r2 | 0) ? 0 : a2) << 4) + 8 >> 3];
          if (d2 < h) {
            e[s2 >> 3] = d2;
            h = d2;
          }
          if (j < i) {
            e[t4 >> 3] = j;
            i = j;
          }
          if (d2 > k) {
            e[c4 >> 3] = d2;
          } else {
            d2 = k;
          }
          if (j > f2) {
            e[u5 >> 3] = j;
            f2 = j;
          }
          l = j > 0 & j < l ? j : l;
          m = j < 0 & j > m ? j : m;
          n = n | +q(+(j - g2)) > 3.141592653589793;
          a2 = p2 + 1 | 0;
          if ((a2 | 0) == (r2 | 0)) {
            break;
          } else {
            v3 = p2;
            k = d2;
            p2 = a2;
            a2 = v3;
          }
        }
        if (!n) {
          return;
        }
        e[u5 >> 3] = m;
        e[t4 >> 3] = l;
        return;
      }
      function Xc(a2) {
        a2 = a2 | 0;
        return (a2 >>> 0 < 4 ? 0 : 15) | 0;
      }
      function Yc(a2, c4) {
        a2 = a2 | 0;
        c4 = c4 | 0;
        var d2 = 0, f2 = 0, g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p2 = 0, r2 = 0, s2 = 0, t4 = 0, u5 = 0, v3 = 0, w4 = 0, x2 = 0, y2 = 0, z2 = 0, A6 = 0;
        r2 = b[a2 >> 2] | 0;
        if (r2) {
          s2 = c4 + 8 | 0;
          e[s2 >> 3] = 17976931348623157e292;
          t4 = c4 + 24 | 0;
          e[t4 >> 3] = 17976931348623157e292;
          e[c4 >> 3] = -17976931348623157e292;
          u5 = c4 + 16 | 0;
          e[u5 >> 3] = -17976931348623157e292;
          if ((r2 | 0) > 0) {
            g2 = b[a2 + 4 >> 2] | 0;
            o = 17976931348623157e292;
            p2 = -17976931348623157e292;
            f2 = 0;
            d2 = -1;
            k = 17976931348623157e292;
            l = 17976931348623157e292;
            n = -17976931348623157e292;
            i = -17976931348623157e292;
            v3 = 0;
            while (1) {
              h = +e[g2 + (v3 << 4) >> 3];
              m = +e[g2 + (v3 << 4) + 8 >> 3];
              z2 = d2 + 2 | 0;
              j = +e[g2 + (((z2 | 0) == (r2 | 0) ? 0 : z2) << 4) + 8 >> 3];
              if (h < k) {
                e[s2 >> 3] = h;
                k = h;
              }
              if (m < l) {
                e[t4 >> 3] = m;
                l = m;
              }
              if (h > n) {
                e[c4 >> 3] = h;
              } else {
                h = n;
              }
              if (m > i) {
                e[u5 >> 3] = m;
                i = m;
              }
              o = m > 0 & m < o ? m : o;
              p2 = m < 0 & m > p2 ? m : p2;
              f2 = f2 | +q(+(m - j)) > 3.141592653589793;
              d2 = v3 + 1 | 0;
              if ((d2 | 0) == (r2 | 0)) {
                break;
              } else {
                z2 = v3;
                n = h;
                v3 = d2;
                d2 = z2;
              }
            }
            if (f2) {
              e[u5 >> 3] = p2;
              e[t4 >> 3] = o;
            }
          }
        } else {
          b[c4 >> 2] = 0;
          b[c4 + 4 >> 2] = 0;
          b[c4 + 8 >> 2] = 0;
          b[c4 + 12 >> 2] = 0;
          b[c4 + 16 >> 2] = 0;
          b[c4 + 20 >> 2] = 0;
          b[c4 + 24 >> 2] = 0;
          b[c4 + 28 >> 2] = 0;
        }
        z2 = a2 + 8 | 0;
        d2 = b[z2 >> 2] | 0;
        if ((d2 | 0) <= 0) {
          return;
        }
        y2 = a2 + 12 | 0;
        x2 = 0;
        do {
          g2 = b[y2 >> 2] | 0;
          f2 = x2;
          x2 = x2 + 1 | 0;
          t4 = c4 + (x2 << 5) | 0;
          u5 = b[g2 + (f2 << 3) >> 2] | 0;
          if (u5) {
            v3 = c4 + (x2 << 5) + 8 | 0;
            e[v3 >> 3] = 17976931348623157e292;
            a2 = c4 + (x2 << 5) + 24 | 0;
            e[a2 >> 3] = 17976931348623157e292;
            e[t4 >> 3] = -17976931348623157e292;
            w4 = c4 + (x2 << 5) + 16 | 0;
            e[w4 >> 3] = -17976931348623157e292;
            if ((u5 | 0) > 0) {
              r2 = b[g2 + (f2 << 3) + 4 >> 2] | 0;
              o = 17976931348623157e292;
              p2 = -17976931348623157e292;
              g2 = 0;
              f2 = -1;
              s2 = 0;
              k = 17976931348623157e292;
              l = 17976931348623157e292;
              m = -17976931348623157e292;
              i = -17976931348623157e292;
              while (1) {
                h = +e[r2 + (s2 << 4) >> 3];
                n = +e[r2 + (s2 << 4) + 8 >> 3];
                f2 = f2 + 2 | 0;
                j = +e[r2 + (((f2 | 0) == (u5 | 0) ? 0 : f2) << 4) + 8 >> 3];
                if (h < k) {
                  e[v3 >> 3] = h;
                  k = h;
                }
                if (n < l) {
                  e[a2 >> 3] = n;
                  l = n;
                }
                if (h > m) {
                  e[t4 >> 3] = h;
                } else {
                  h = m;
                }
                if (n > i) {
                  e[w4 >> 3] = n;
                  i = n;
                }
                o = n > 0 & n < o ? n : o;
                p2 = n < 0 & n > p2 ? n : p2;
                g2 = g2 | +q(+(n - j)) > 3.141592653589793;
                f2 = s2 + 1 | 0;
                if ((f2 | 0) == (u5 | 0)) {
                  break;
                } else {
                  A6 = s2;
                  s2 = f2;
                  m = h;
                  f2 = A6;
                }
              }
              if (g2) {
                e[w4 >> 3] = p2;
                e[a2 >> 3] = o;
              }
            }
          } else {
            b[t4 >> 2] = 0;
            b[t4 + 4 >> 2] = 0;
            b[t4 + 8 >> 2] = 0;
            b[t4 + 12 >> 2] = 0;
            b[t4 + 16 >> 2] = 0;
            b[t4 + 20 >> 2] = 0;
            b[t4 + 24 >> 2] = 0;
            b[t4 + 28 >> 2] = 0;
            d2 = b[z2 >> 2] | 0;
          }
        } while ((x2 | 0) < (d2 | 0));
        return;
      }
      function Zc(a2, c4, d2) {
        a2 = a2 | 0;
        c4 = c4 | 0;
        d2 = d2 | 0;
        var e3 = 0, f2 = 0, g2 = 0;
        if (!(Vc(a2, c4, d2) | 0)) {
          f2 = 0;
          return f2 | 0;
        }
        f2 = a2 + 8 | 0;
        if ((b[f2 >> 2] | 0) <= 0) {
          f2 = 1;
          return f2 | 0;
        }
        e3 = a2 + 12 | 0;
        a2 = 0;
        while (1) {
          g2 = a2;
          a2 = a2 + 1 | 0;
          if (Vc((b[e3 >> 2] | 0) + (g2 << 3) | 0, c4 + (a2 << 5) | 0, d2) | 0) {
            a2 = 0;
            e3 = 6;
            break;
          }
          if ((a2 | 0) >= (b[f2 >> 2] | 0)) {
            a2 = 1;
            e3 = 6;
            break;
          }
        }
        if ((e3 | 0) == 6) {
          return a2 | 0;
        }
        return 0;
      }
      function _c(a2, c4, d2, e3) {
        a2 = a2 | 0;
        c4 = c4 | 0;
        d2 = d2 | 0;
        e3 = e3 | 0;
        var f2 = 0, g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0;
        k = T2;
        T2 = T2 + 16 | 0;
        i = k;
        h = d2 + 8 | 0;
        if (!(Vc(a2, c4, h) | 0)) {
          j = 0;
          T2 = k;
          return j | 0;
        }
        j = a2 + 8 | 0;
        a: do {
          if ((b[j >> 2] | 0) > 0) {
            g2 = a2 + 12 | 0;
            f2 = 0;
            while (1) {
              l = f2;
              f2 = f2 + 1 | 0;
              if (Vc((b[g2 >> 2] | 0) + (l << 3) | 0, c4 + (f2 << 5) | 0, h) | 0) {
                f2 = 0;
                break;
              }
              if ((f2 | 0) >= (b[j >> 2] | 0)) {
                break a;
              }
            }
            T2 = k;
            return f2 | 0;
          }
        } while (0);
        if ($c(a2, c4, d2, e3) | 0) {
          l = 0;
          T2 = k;
          return l | 0;
        }
        b[i >> 2] = b[d2 >> 2];
        b[i + 4 >> 2] = h;
        f2 = b[j >> 2] | 0;
        b: do {
          if ((f2 | 0) > 0) {
            a2 = a2 + 12 | 0;
            h = 0;
            g2 = f2;
            while (1) {
              f2 = b[a2 >> 2] | 0;
              if ((b[f2 + (h << 3) >> 2] | 0) > 0) {
                if (Vc(i, e3, b[f2 + (h << 3) + 4 >> 2] | 0) | 0) {
                  f2 = 0;
                  break b;
                }
                f2 = h + 1 | 0;
                if ($c((b[a2 >> 2] | 0) + (h << 3) | 0, c4 + (f2 << 5) | 0, d2, e3) | 0) {
                  f2 = 0;
                  break b;
                }
                g2 = b[j >> 2] | 0;
              } else {
                f2 = h + 1 | 0;
              }
              if ((f2 | 0) < (g2 | 0)) {
                h = f2;
              } else {
                f2 = 1;
                break;
              }
            }
          } else {
            f2 = 1;
          }
        } while (0);
        l = f2;
        T2 = k;
        return l | 0;
      }
      function $c(a2, c4, d2, f2) {
        a2 = a2 | 0;
        c4 = c4 | 0;
        d2 = d2 | 0;
        f2 = f2 | 0;
        var g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p2 = 0, q2 = 0, r2 = 0, s2 = 0, t4 = 0, u5 = 0, v3 = 0, w4 = 0, x2 = 0, y2 = 0, z2 = 0, A6 = 0;
        y2 = T2;
        T2 = T2 + 176 | 0;
        u5 = y2 + 172 | 0;
        g2 = y2 + 168 | 0;
        v3 = y2;
        if (!(Da(c4, f2) | 0)) {
          a2 = 0;
          T2 = y2;
          return a2 | 0;
        }
        Ea(c4, f2, u5, g2);
        Wd(v3 | 0, d2 | 0, 168) | 0;
        if ((b[d2 >> 2] | 0) > 0) {
          c4 = 0;
          do {
            z2 = v3 + 8 + (c4 << 4) + 8 | 0;
            t4 = +kc(+e[z2 >> 3], b[g2 >> 2] | 0);
            e[z2 >> 3] = t4;
            c4 = c4 + 1 | 0;
          } while ((c4 | 0) < (b[d2 >> 2] | 0));
        }
        r2 = +e[f2 >> 3];
        s2 = +e[f2 + 8 >> 3];
        t4 = +kc(+e[f2 + 16 >> 3], b[g2 >> 2] | 0);
        p2 = +kc(+e[f2 + 24 >> 3], b[g2 >> 2] | 0);
        a: do {
          if ((b[a2 >> 2] | 0) > 0) {
            f2 = a2 + 4 | 0;
            g2 = b[v3 >> 2] | 0;
            if ((g2 | 0) <= 0) {
              c4 = 0;
              while (1) {
                c4 = c4 + 1 | 0;
                if ((c4 | 0) >= (b[a2 >> 2] | 0)) {
                  c4 = 0;
                  break a;
                }
              }
            }
            d2 = 0;
            while (1) {
              c4 = b[f2 >> 2] | 0;
              o = +e[c4 + (d2 << 4) >> 3];
              q2 = +kc(+e[c4 + (d2 << 4) + 8 >> 3], b[u5 >> 2] | 0);
              c4 = b[f2 >> 2] | 0;
              d2 = d2 + 1 | 0;
              z2 = (d2 | 0) % (b[a2 >> 2] | 0) | 0;
              h = +e[c4 + (z2 << 4) >> 3];
              i = +kc(+e[c4 + (z2 << 4) + 8 >> 3], b[u5 >> 2] | 0);
              if (((!(o >= r2) | !(h >= r2) ? !(o <= s2) | !(h <= s2) : 0) ? !(q2 <= p2) | !(i <= p2) : 0) ? !(q2 >= t4) | !(i >= t4) : 0) {
                n = h - o;
                l = i - q2;
                c4 = 0;
                do {
                  A6 = c4;
                  c4 = c4 + 1 | 0;
                  z2 = (c4 | 0) == (g2 | 0) ? 0 : c4;
                  h = +e[v3 + 8 + (A6 << 4) + 8 >> 3];
                  i = +e[v3 + 8 + (z2 << 4) + 8 >> 3] - h;
                  j = +e[v3 + 8 + (A6 << 4) >> 3];
                  k = +e[v3 + 8 + (z2 << 4) >> 3] - j;
                  m = n * i - l * k;
                  if ((m != 0 ? (w4 = q2 - h, x2 = o - j, k = (w4 * k - i * x2) / m, !(k < 0 | k > 1)) : 0) ? (m = (n * w4 - l * x2) / m, m >= 0 & m <= 1) : 0) {
                    c4 = 1;
                    break a;
                  }
                } while ((c4 | 0) < (g2 | 0));
              }
              if ((d2 | 0) >= (b[a2 >> 2] | 0)) {
                c4 = 0;
                break;
              }
            }
          } else {
            c4 = 0;
          }
        } while (0);
        A6 = c4;
        T2 = y2;
        return A6 | 0;
      }
      function ad(a2, c4, d2, e3) {
        a2 = a2 | 0;
        c4 = c4 | 0;
        d2 = d2 | 0;
        e3 = e3 | 0;
        var f2 = 0, g2 = 0, h = 0;
        if ($c(a2, c4, d2, e3) | 0) {
          g2 = 1;
          return g2 | 0;
        }
        g2 = a2 + 8 | 0;
        if ((b[g2 >> 2] | 0) <= 0) {
          g2 = 0;
          return g2 | 0;
        }
        f2 = a2 + 12 | 0;
        a2 = 0;
        while (1) {
          h = a2;
          a2 = a2 + 1 | 0;
          if ($c((b[f2 >> 2] | 0) + (h << 3) | 0, c4 + (a2 << 5) | 0, d2, e3) | 0) {
            a2 = 1;
            f2 = 6;
            break;
          }
          if ((a2 | 0) >= (b[g2 >> 2] | 0)) {
            a2 = 0;
            f2 = 6;
            break;
          }
        }
        if ((f2 | 0) == 6) {
          return a2 | 0;
        }
        return 0;
      }
      function bd2() {
        return 8;
      }
      function cd2() {
        return 16;
      }
      function dd() {
        return 168;
      }
      function ed() {
        return 8;
      }
      function fd() {
        return 16;
      }
      function gd() {
        return 12;
      }
      function hd() {
        return 8;
      }
      function id(a2) {
        a2 = a2 | 0;
        return +(+((b[a2 >> 2] | 0) >>> 0) + 4294967296 * +(b[a2 + 4 >> 2] | 0));
      }
      function jd(a2) {
        a2 = a2 | 0;
        var b2 = 0, c4 = 0;
        c4 = +e[a2 >> 3];
        b2 = +e[a2 + 8 >> 3];
        return + +r(+(c4 * c4 + b2 * b2));
      }
      function kd(a2, b2, c4, d2, f2) {
        a2 = a2 | 0;
        b2 = b2 | 0;
        c4 = c4 | 0;
        d2 = d2 | 0;
        f2 = f2 | 0;
        var g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0;
        k = +e[a2 >> 3];
        j = +e[b2 >> 3] - k;
        i = +e[a2 + 8 >> 3];
        h = +e[b2 + 8 >> 3] - i;
        m = +e[c4 >> 3];
        g2 = +e[d2 >> 3] - m;
        n = +e[c4 + 8 >> 3];
        l = +e[d2 + 8 >> 3] - n;
        g2 = (g2 * (i - n) - (k - m) * l) / (j * l - h * g2);
        e[f2 >> 3] = k + j * g2;
        e[f2 + 8 >> 3] = i + h * g2;
        return;
      }
      function ld(a2, b2) {
        a2 = a2 | 0;
        b2 = b2 | 0;
        if (!(+q(+(+e[a2 >> 3] - +e[b2 >> 3])) < 11920928955078125e-23)) {
          b2 = 0;
          return b2 | 0;
        }
        b2 = +q(+(+e[a2 + 8 >> 3] - +e[b2 + 8 >> 3])) < 11920928955078125e-23;
        return b2 | 0;
      }
      function md(a2, b2) {
        a2 = a2 | 0;
        b2 = b2 | 0;
        var c4 = 0, d2 = 0, f2 = 0;
        f2 = +e[a2 >> 3] - +e[b2 >> 3];
        d2 = +e[a2 + 8 >> 3] - +e[b2 + 8 >> 3];
        c4 = +e[a2 + 16 >> 3] - +e[b2 + 16 >> 3];
        return +(f2 * f2 + d2 * d2 + c4 * c4);
      }
      function nd(a2, b2) {
        a2 = a2 | 0;
        b2 = b2 | 0;
        var c4 = 0, d2 = 0, f2 = 0;
        c4 = +e[a2 >> 3];
        d2 = +t(+c4);
        c4 = +u4(+c4);
        e[b2 + 16 >> 3] = c4;
        c4 = +e[a2 + 8 >> 3];
        f2 = d2 * +t(+c4);
        e[b2 >> 3] = f2;
        c4 = d2 * +u4(+c4);
        e[b2 + 8 >> 3] = c4;
        return;
      }
      function od(a2, c4, d2) {
        a2 = a2 | 0;
        c4 = c4 | 0;
        d2 = d2 | 0;
        var e3 = 0, f2 = 0, g2 = 0;
        g2 = T2;
        T2 = T2 + 16 | 0;
        f2 = g2;
        e3 = Hb(a2, c4) | 0;
        if ((d2 + -1 | 0) >>> 0 > 5) {
          f2 = -1;
          T2 = g2;
          return f2 | 0;
        }
        e3 = (e3 | 0) != 0;
        if ((d2 | 0) == 1 & e3) {
          f2 = -1;
          T2 = g2;
          return f2 | 0;
        }
        do {
          if (!(pd(a2, c4, f2) | 0)) {
            if (e3) {
              e3 = ((b[26352 + (d2 << 2) >> 2] | 0) + 5 - (b[f2 >> 2] | 0) | 0) % 5 | 0;
              break;
            } else {
              e3 = ((b[26384 + (d2 << 2) >> 2] | 0) + 6 - (b[f2 >> 2] | 0) | 0) % 6 | 0;
              break;
            }
          } else {
            e3 = -1;
          }
        } while (0);
        f2 = e3;
        T2 = g2;
        return f2 | 0;
      }
      function pd(a2, c4, d2) {
        a2 = a2 | 0;
        c4 = c4 | 0;
        d2 = d2 | 0;
        var e3 = 0, f2 = 0, g2 = 0, h = 0, i = 0, j = 0, k = 0;
        k = T2;
        T2 = T2 + 32 | 0;
        h = k + 16 | 0;
        i = k;
        e3 = Yb(a2, c4, h) | 0;
        if (e3 | 0) {
          d2 = e3;
          T2 = k;
          return d2 | 0;
        }
        g2 = Cb(a2, c4) | 0;
        j = Pb(a2, c4) | 0;
        sa(g2, i);
        e3 = ta(g2, b[h >> 2] | 0) | 0;
        a: do {
          if (oa(g2) | 0) {
            do {
              switch (g2 | 0) {
                case 4: {
                  a2 = 0;
                  break;
                }
                case 14: {
                  a2 = 1;
                  break;
                }
                case 24: {
                  a2 = 2;
                  break;
                }
                case 38: {
                  a2 = 3;
                  break;
                }
                case 49: {
                  a2 = 4;
                  break;
                }
                case 58: {
                  a2 = 5;
                  break;
                }
                case 63: {
                  a2 = 6;
                  break;
                }
                case 72: {
                  a2 = 7;
                  break;
                }
                case 83: {
                  a2 = 8;
                  break;
                }
                case 97: {
                  a2 = 9;
                  break;
                }
                case 107: {
                  a2 = 10;
                  break;
                }
                case 117: {
                  a2 = 11;
                  break;
                }
                default: {
                  e3 = 1;
                  break a;
                }
              }
            } while (0);
            f2 = b[26416 + (a2 * 24 | 0) + 8 >> 2] | 0;
            c4 = b[26416 + (a2 * 24 | 0) + 16 >> 2] | 0;
            a2 = b[h >> 2] | 0;
            if ((a2 | 0) != (b[i >> 2] | 0)) {
              i = pa(g2) | 0;
              a2 = b[h >> 2] | 0;
              if (i | (a2 | 0) == (c4 | 0)) {
                e3 = (e3 + 1 | 0) % 6 | 0;
              }
            }
            if ((j | 0) == 3 & (a2 | 0) == (c4 | 0)) {
              e3 = (e3 + 5 | 0) % 6 | 0;
              f2 = 22;
              break;
            }
            if ((j | 0) == 5 & (a2 | 0) == (f2 | 0)) {
              e3 = (e3 + 1 | 0) % 6 | 0;
              f2 = 22;
            } else {
              f2 = 22;
            }
          } else {
            f2 = 22;
          }
        } while (0);
        if ((f2 | 0) == 22) {
          b[d2 >> 2] = e3;
          e3 = 0;
        }
        d2 = e3;
        T2 = k;
        return d2 | 0;
      }
      function qd(a2, c4, d2, e3) {
        a2 = a2 | 0;
        c4 = c4 | 0;
        d2 = d2 | 0;
        e3 = e3 | 0;
        var f2 = 0, g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p2 = 0, q2 = 0, r2 = 0, s2 = 0, t4 = 0, u5 = 0;
        u5 = T2;
        T2 = T2 + 32 | 0;
        t4 = u5 + 24 | 0;
        r2 = u5 + 20 | 0;
        p2 = u5 + 8 | 0;
        o = u5 + 16 | 0;
        n = u5;
        j = (Hb(a2, c4) | 0) == 0;
        j = j ? 6 : 5;
        l = Qd(a2 | 0, c4 | 0, 52) | 0;
        H() | 0;
        l = l & 15;
        if (j >>> 0 <= d2 >>> 0) {
          e3 = 2;
          T2 = u5;
          return e3 | 0;
        }
        m = (l | 0) == 0;
        if (!m ? (q2 = Rd(7, 0, (l ^ 15) * 3 | 0) | 0, (q2 & a2 | 0) == 0 & ((H() | 0) & c4 | 0) == 0) : 0) {
          f2 = d2;
        } else {
          g2 = 4;
        }
        a: do {
          if ((g2 | 0) == 4) {
            f2 = (Hb(a2, c4) | 0) != 0;
            if (((f2 ? 4 : 5) | 0) < (d2 | 0)) {
              e3 = 1;
              T2 = u5;
              return e3 | 0;
            }
            if (pd(a2, c4, t4) | 0) {
              e3 = 1;
              T2 = u5;
              return e3 | 0;
            }
            g2 = (b[t4 >> 2] | 0) + d2 | 0;
            if (f2) {
              f2 = 26704 + (((g2 | 0) % 5 | 0) << 2) | 0;
            } else {
              f2 = 26736 + (((g2 | 0) % 6 | 0) << 2) | 0;
            }
            q2 = b[f2 >> 2] | 0;
            if ((q2 | 0) == 7) {
              e3 = 1;
              T2 = u5;
              return e3 | 0;
            }
            b[r2 >> 2] = 0;
            f2 = ea2(a2, c4, q2, r2, p2) | 0;
            do {
              if (!f2) {
                i = p2;
                k = b[i >> 2] | 0;
                i = b[i + 4 >> 2] | 0;
                h = i >>> 0 < c4 >>> 0 | (i | 0) == (c4 | 0) & k >>> 0 < a2 >>> 0;
                g2 = h ? k : a2;
                h = h ? i : c4;
                if (!m ? (m = Rd(7, 0, (l ^ 15) * 3 | 0) | 0, (k & m | 0) == 0 & (i & (H() | 0) | 0) == 0) : 0) {
                  f2 = d2;
                } else {
                  i = (d2 + -1 + j | 0) % (j | 0) | 0;
                  f2 = Hb(a2, c4) | 0;
                  if ((i | 0) < 0) {
                    I(27795, 27797, 246, 27806);
                  }
                  j = (f2 | 0) != 0;
                  if (((j ? 4 : 5) | 0) < (i | 0)) {
                    I(27795, 27797, 246, 27806);
                  }
                  if (pd(a2, c4, t4) | 0) {
                    I(27795, 27797, 246, 27806);
                  }
                  f2 = (b[t4 >> 2] | 0) + i | 0;
                  if (j) {
                    f2 = 26704 + (((f2 | 0) % 5 | 0) << 2) | 0;
                  } else {
                    f2 = 26736 + (((f2 | 0) % 6 | 0) << 2) | 0;
                  }
                  i = b[f2 >> 2] | 0;
                  if ((i | 0) == 7) {
                    I(27795, 27797, 246, 27806);
                  }
                  b[o >> 2] = 0;
                  f2 = ea2(a2, c4, i, o, n) | 0;
                  if (f2 | 0) {
                    break;
                  }
                  k = n;
                  j = b[k >> 2] | 0;
                  k = b[k + 4 >> 2] | 0;
                  do {
                    if (k >>> 0 < h >>> 0 | (k | 0) == (h | 0) & j >>> 0 < g2 >>> 0) {
                      if (!(Hb(j, k) | 0)) {
                        g2 = b[26800 + ((((b[o >> 2] | 0) + (b[26768 + (i << 2) >> 2] | 0) | 0) % 6 | 0) << 2) >> 2] | 0;
                      } else {
                        g2 = ia(j, k, a2, c4) | 0;
                      }
                      f2 = Hb(j, k) | 0;
                      if ((g2 + -1 | 0) >>> 0 > 5) {
                        f2 = -1;
                        g2 = j;
                        h = k;
                        break;
                      }
                      f2 = (f2 | 0) != 0;
                      if ((g2 | 0) == 1 & f2) {
                        f2 = -1;
                        g2 = j;
                        h = k;
                        break;
                      }
                      do {
                        if (!(pd(j, k, t4) | 0)) {
                          if (f2) {
                            f2 = ((b[26352 + (g2 << 2) >> 2] | 0) + 5 - (b[t4 >> 2] | 0) | 0) % 5 | 0;
                            break;
                          } else {
                            f2 = ((b[26384 + (g2 << 2) >> 2] | 0) + 6 - (b[t4 >> 2] | 0) | 0) % 6 | 0;
                            break;
                          }
                        } else {
                          f2 = -1;
                        }
                      } while (0);
                      g2 = j;
                      h = k;
                    } else {
                      f2 = d2;
                    }
                  } while (0);
                  i = p2;
                  k = b[i >> 2] | 0;
                  i = b[i + 4 >> 2] | 0;
                }
                if ((g2 | 0) == (k | 0) & (h | 0) == (i | 0)) {
                  j = (Hb(k, i) | 0) != 0;
                  if (j) {
                    a2 = ia(k, i, a2, c4) | 0;
                  } else {
                    a2 = b[26800 + ((((b[r2 >> 2] | 0) + (b[26768 + (q2 << 2) >> 2] | 0) | 0) % 6 | 0) << 2) >> 2] | 0;
                  }
                  f2 = Hb(k, i) | 0;
                  if ((a2 + -1 | 0) >>> 0 <= 5 ? (s2 = (f2 | 0) != 0, !((a2 | 0) == 1 & s2)) : 0) {
                    do {
                      if (!(pd(k, i, t4) | 0)) {
                        if (s2) {
                          f2 = ((b[26352 + (a2 << 2) >> 2] | 0) + 5 - (b[t4 >> 2] | 0) | 0) % 5 | 0;
                          break;
                        } else {
                          f2 = ((b[26384 + (a2 << 2) >> 2] | 0) + 6 - (b[t4 >> 2] | 0) | 0) % 6 | 0;
                          break;
                        }
                      } else {
                        f2 = -1;
                      }
                    } while (0);
                  } else {
                    f2 = -1;
                  }
                  f2 = f2 + 1 | 0;
                  f2 = (f2 | 0) == 6 | j & (f2 | 0) == 5 ? 0 : f2;
                }
                c4 = h;
                a2 = g2;
                break a;
              }
            } while (0);
            e3 = f2;
            T2 = u5;
            return e3 | 0;
          }
        } while (0);
        s2 = Rd(f2 | 0, 0, 56) | 0;
        t4 = H() | 0 | c4 & -2130706433 | 536870912;
        b[e3 >> 2] = s2 | a2;
        b[e3 + 4 >> 2] = t4;
        e3 = 0;
        T2 = u5;
        return e3 | 0;
      }
      function rd(a2, c4, d2) {
        a2 = a2 | 0;
        c4 = c4 | 0;
        d2 = d2 | 0;
        var e3 = 0, f2 = 0, g2 = 0;
        g2 = (Hb(a2, c4) | 0) == 0;
        e3 = qd(a2, c4, 0, d2) | 0;
        f2 = (e3 | 0) == 0;
        if (g2) {
          if (!f2) {
            g2 = e3;
            return g2 | 0;
          }
          e3 = qd(a2, c4, 1, d2 + 8 | 0) | 0;
          if (e3 | 0) {
            g2 = e3;
            return g2 | 0;
          }
          e3 = qd(a2, c4, 2, d2 + 16 | 0) | 0;
          if (e3 | 0) {
            g2 = e3;
            return g2 | 0;
          }
          e3 = qd(a2, c4, 3, d2 + 24 | 0) | 0;
          if (e3 | 0) {
            g2 = e3;
            return g2 | 0;
          }
          e3 = qd(a2, c4, 4, d2 + 32 | 0) | 0;
          if (!e3) {
            return qd(a2, c4, 5, d2 + 40 | 0) | 0;
          } else {
            g2 = e3;
            return g2 | 0;
          }
        }
        if (!f2) {
          g2 = e3;
          return g2 | 0;
        }
        e3 = qd(a2, c4, 1, d2 + 8 | 0) | 0;
        if (e3 | 0) {
          g2 = e3;
          return g2 | 0;
        }
        e3 = qd(a2, c4, 2, d2 + 16 | 0) | 0;
        if (e3 | 0) {
          g2 = e3;
          return g2 | 0;
        }
        e3 = qd(a2, c4, 3, d2 + 24 | 0) | 0;
        if (e3 | 0) {
          g2 = e3;
          return g2 | 0;
        }
        e3 = qd(a2, c4, 4, d2 + 32 | 0) | 0;
        if (e3 | 0) {
          g2 = e3;
          return g2 | 0;
        }
        g2 = d2 + 40 | 0;
        b[g2 >> 2] = 0;
        b[g2 + 4 >> 2] = 0;
        g2 = 0;
        return g2 | 0;
      }
      function sd(a2, c4, d2) {
        a2 = a2 | 0;
        c4 = c4 | 0;
        d2 = d2 | 0;
        var e3 = 0, f2 = 0, g2 = 0, h = 0, i = 0, j = 0;
        j = T2;
        T2 = T2 + 192 | 0;
        f2 = j;
        g2 = j + 168 | 0;
        h = Qd(a2 | 0, c4 | 0, 56) | 0;
        H() | 0;
        h = h & 7;
        i = c4 & -2130706433 | 134217728;
        e3 = Yb(a2, i, g2) | 0;
        if (e3 | 0) {
          i = e3;
          T2 = j;
          return i | 0;
        }
        c4 = Qd(a2 | 0, c4 | 0, 52) | 0;
        H() | 0;
        c4 = c4 & 15;
        if (!(Hb(a2, i) | 0)) {
          zb(g2, c4, h, 1, f2);
        } else {
          vb(g2, c4, h, 1, f2);
        }
        i = f2 + 8 | 0;
        b[d2 >> 2] = b[i >> 2];
        b[d2 + 4 >> 2] = b[i + 4 >> 2];
        b[d2 + 8 >> 2] = b[i + 8 >> 2];
        b[d2 + 12 >> 2] = b[i + 12 >> 2];
        i = 0;
        T2 = j;
        return i | 0;
      }
      function td(a2, c4) {
        a2 = a2 | 0;
        c4 = c4 | 0;
        var d2 = 0, e3 = 0, f2 = 0, g2 = 0;
        f2 = T2;
        T2 = T2 + 16 | 0;
        d2 = f2;
        if (!(true & (c4 & 2013265920 | 0) == 536870912)) {
          e3 = 0;
          T2 = f2;
          return e3 | 0;
        }
        e3 = c4 & -2130706433 | 134217728;
        if (!(Db(a2, e3) | 0)) {
          e3 = 0;
          T2 = f2;
          return e3 | 0;
        }
        g2 = Qd(a2 | 0, c4 | 0, 56) | 0;
        H() | 0;
        g2 = (qd(a2, e3, g2 & 7, d2) | 0) == 0;
        e3 = d2;
        e3 = g2 & ((b[e3 >> 2] | 0) == (a2 | 0) ? (b[e3 + 4 >> 2] | 0) == (c4 | 0) : 0) & 1;
        T2 = f2;
        return e3 | 0;
      }
      function ud(a2, c4, d2) {
        a2 = a2 | 0;
        c4 = c4 | 0;
        d2 = d2 | 0;
        var e3 = 0;
        if ((c4 | 0) > 0) {
          e3 = Fd(c4, 4) | 0;
          b[a2 >> 2] = e3;
          if (!e3) {
            I(27819, 27842, 40, 27856);
          }
        } else {
          b[a2 >> 2] = 0;
        }
        b[a2 + 4 >> 2] = c4;
        b[a2 + 8 >> 2] = 0;
        b[a2 + 12 >> 2] = d2;
        return;
      }
      function vd(a2) {
        a2 = a2 | 0;
        var c4 = 0, d2 = 0, f2 = 0, g2 = 0, h = 0, i = 0, j = 0;
        g2 = a2 + 4 | 0;
        h = a2 + 12 | 0;
        i = a2 + 8 | 0;
        a: while (1) {
          d2 = b[g2 >> 2] | 0;
          c4 = 0;
          while (1) {
            if ((c4 | 0) >= (d2 | 0)) {
              break a;
            }
            f2 = b[a2 >> 2] | 0;
            j = b[f2 + (c4 << 2) >> 2] | 0;
            if (!j) {
              c4 = c4 + 1 | 0;
            } else {
              break;
            }
          }
          c4 = f2 + (~~(+q(+(+s(10, + +(15 - (b[h >> 2] | 0) | 0)) * (+e[j >> 3] + +e[j + 8 >> 3]))) % +(d2 | 0)) >>> 0 << 2) | 0;
          d2 = b[c4 >> 2] | 0;
          b: do {
            if (d2 | 0) {
              f2 = j + 32 | 0;
              if ((d2 | 0) == (j | 0)) {
                b[c4 >> 2] = b[f2 >> 2];
              } else {
                d2 = d2 + 32 | 0;
                c4 = b[d2 >> 2] | 0;
                if (!c4) {
                  break;
                }
                while (1) {
                  if ((c4 | 0) == (j | 0)) {
                    break;
                  }
                  d2 = c4 + 32 | 0;
                  c4 = b[d2 >> 2] | 0;
                  if (!c4) {
                    break b;
                  }
                }
                b[d2 >> 2] = b[f2 >> 2];
              }
              Ed(j);
              b[i >> 2] = (b[i >> 2] | 0) + -1;
            }
          } while (0);
        }
        Ed(b[a2 >> 2] | 0);
        return;
      }
      function wd(a2) {
        a2 = a2 | 0;
        var c4 = 0, d2 = 0, e3 = 0;
        e3 = b[a2 + 4 >> 2] | 0;
        d2 = 0;
        while (1) {
          if ((d2 | 0) >= (e3 | 0)) {
            c4 = 0;
            d2 = 4;
            break;
          }
          c4 = b[(b[a2 >> 2] | 0) + (d2 << 2) >> 2] | 0;
          if (!c4) {
            d2 = d2 + 1 | 0;
          } else {
            d2 = 4;
            break;
          }
        }
        if ((d2 | 0) == 4) {
          return c4 | 0;
        }
        return 0;
      }
      function xd(a2, c4) {
        a2 = a2 | 0;
        c4 = c4 | 0;
        var d2 = 0, f2 = 0, g2 = 0, h = 0;
        d2 = ~~(+q(+(+s(10, + +(15 - (b[a2 + 12 >> 2] | 0) | 0)) * (+e[c4 >> 3] + +e[c4 + 8 >> 3]))) % +(b[a2 + 4 >> 2] | 0)) >>> 0;
        d2 = (b[a2 >> 2] | 0) + (d2 << 2) | 0;
        f2 = b[d2 >> 2] | 0;
        if (!f2) {
          h = 1;
          return h | 0;
        }
        h = c4 + 32 | 0;
        do {
          if ((f2 | 0) != (c4 | 0)) {
            d2 = b[f2 + 32 >> 2] | 0;
            if (!d2) {
              h = 1;
              return h | 0;
            }
            g2 = d2;
            while (1) {
              if ((g2 | 0) == (c4 | 0)) {
                g2 = 8;
                break;
              }
              d2 = b[g2 + 32 >> 2] | 0;
              if (!d2) {
                d2 = 1;
                g2 = 10;
                break;
              } else {
                f2 = g2;
                g2 = d2;
              }
            }
            if ((g2 | 0) == 8) {
              b[f2 + 32 >> 2] = b[h >> 2];
              break;
            } else if ((g2 | 0) == 10) {
              return d2 | 0;
            }
          } else {
            b[d2 >> 2] = b[h >> 2];
          }
        } while (0);
        Ed(c4);
        h = a2 + 8 | 0;
        b[h >> 2] = (b[h >> 2] | 0) + -1;
        h = 0;
        return h | 0;
      }
      function yd(a2, c4, d2) {
        a2 = a2 | 0;
        c4 = c4 | 0;
        d2 = d2 | 0;
        var f2 = 0, g2 = 0, h = 0, i = 0;
        h = Dd(40) | 0;
        if (!h) {
          I(27872, 27842, 98, 27885);
        }
        b[h >> 2] = b[c4 >> 2];
        b[h + 4 >> 2] = b[c4 + 4 >> 2];
        b[h + 8 >> 2] = b[c4 + 8 >> 2];
        b[h + 12 >> 2] = b[c4 + 12 >> 2];
        g2 = h + 16 | 0;
        b[g2 >> 2] = b[d2 >> 2];
        b[g2 + 4 >> 2] = b[d2 + 4 >> 2];
        b[g2 + 8 >> 2] = b[d2 + 8 >> 2];
        b[g2 + 12 >> 2] = b[d2 + 12 >> 2];
        b[h + 32 >> 2] = 0;
        g2 = ~~(+q(+(+s(10, + +(15 - (b[a2 + 12 >> 2] | 0) | 0)) * (+e[c4 >> 3] + +e[c4 + 8 >> 3]))) % +(b[a2 + 4 >> 2] | 0)) >>> 0;
        g2 = (b[a2 >> 2] | 0) + (g2 << 2) | 0;
        f2 = b[g2 >> 2] | 0;
        do {
          if (!f2) {
            b[g2 >> 2] = h;
          } else {
            while (1) {
              if (jc(f2, c4) | 0 ? jc(f2 + 16 | 0, d2) | 0 : 0) {
                break;
              }
              g2 = b[f2 + 32 >> 2] | 0;
              f2 = (g2 | 0) == 0 ? f2 : g2;
              if (!(b[f2 + 32 >> 2] | 0)) {
                i = 10;
                break;
              }
            }
            if ((i | 0) == 10) {
              b[f2 + 32 >> 2] = h;
              break;
            }
            Ed(h);
            i = f2;
            return i | 0;
          }
        } while (0);
        i = a2 + 8 | 0;
        b[i >> 2] = (b[i >> 2] | 0) + 1;
        i = h;
        return i | 0;
      }
      function zd(a2, c4, d2) {
        a2 = a2 | 0;
        c4 = c4 | 0;
        d2 = d2 | 0;
        var f2 = 0, g2 = 0;
        g2 = ~~(+q(+(+s(10, + +(15 - (b[a2 + 12 >> 2] | 0) | 0)) * (+e[c4 >> 3] + +e[c4 + 8 >> 3]))) % +(b[a2 + 4 >> 2] | 0)) >>> 0;
        g2 = b[(b[a2 >> 2] | 0) + (g2 << 2) >> 2] | 0;
        if (!g2) {
          d2 = 0;
          return d2 | 0;
        }
        if (!d2) {
          a2 = g2;
          while (1) {
            if (jc(a2, c4) | 0) {
              f2 = 10;
              break;
            }
            a2 = b[a2 + 32 >> 2] | 0;
            if (!a2) {
              a2 = 0;
              f2 = 10;
              break;
            }
          }
          if ((f2 | 0) == 10) {
            return a2 | 0;
          }
        }
        a2 = g2;
        while (1) {
          if (jc(a2, c4) | 0 ? jc(a2 + 16 | 0, d2) | 0 : 0) {
            f2 = 10;
            break;
          }
          a2 = b[a2 + 32 >> 2] | 0;
          if (!a2) {
            a2 = 0;
            f2 = 10;
            break;
          }
        }
        if ((f2 | 0) == 10) {
          return a2 | 0;
        }
        return 0;
      }
      function Ad(a2, c4) {
        a2 = a2 | 0;
        c4 = c4 | 0;
        var d2 = 0;
        d2 = ~~(+q(+(+s(10, + +(15 - (b[a2 + 12 >> 2] | 0) | 0)) * (+e[c4 >> 3] + +e[c4 + 8 >> 3]))) % +(b[a2 + 4 >> 2] | 0)) >>> 0;
        a2 = b[(b[a2 >> 2] | 0) + (d2 << 2) >> 2] | 0;
        if (!a2) {
          d2 = 0;
          return d2 | 0;
        }
        while (1) {
          if (jc(a2, c4) | 0) {
            c4 = 5;
            break;
          }
          a2 = b[a2 + 32 >> 2] | 0;
          if (!a2) {
            a2 = 0;
            c4 = 5;
            break;
          }
        }
        if ((c4 | 0) == 5) {
          return a2 | 0;
        }
        return 0;
      }
      function Bd() {
        return 27904;
      }
      function Cd(a2) {
        a2 = +a2;
        return ~~+Yd(+a2) | 0;
      }
      function Dd(a2) {
        a2 = a2 | 0;
        var c4 = 0, d2 = 0, e3 = 0, f2 = 0, g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p2 = 0, q2 = 0, r2 = 0, s2 = 0, t4 = 0, u5 = 0, v3 = 0, w4 = 0;
        w4 = T2;
        T2 = T2 + 16 | 0;
        n = w4;
        do {
          if (a2 >>> 0 < 245) {
            k = a2 >>> 0 < 11 ? 16 : a2 + 11 & -8;
            a2 = k >>> 3;
            m = b[6977] | 0;
            d2 = m >>> a2;
            if (d2 & 3 | 0) {
              c4 = (d2 & 1 ^ 1) + a2 | 0;
              a2 = 27948 + (c4 << 1 << 2) | 0;
              d2 = a2 + 8 | 0;
              e3 = b[d2 >> 2] | 0;
              f2 = e3 + 8 | 0;
              g2 = b[f2 >> 2] | 0;
              if ((g2 | 0) == (a2 | 0)) {
                b[6977] = m & ~(1 << c4);
              } else {
                b[g2 + 12 >> 2] = a2;
                b[d2 >> 2] = g2;
              }
              v3 = c4 << 3;
              b[e3 + 4 >> 2] = v3 | 3;
              v3 = e3 + v3 + 4 | 0;
              b[v3 >> 2] = b[v3 >> 2] | 1;
              v3 = f2;
              T2 = w4;
              return v3 | 0;
            }
            l = b[6979] | 0;
            if (k >>> 0 > l >>> 0) {
              if (d2 | 0) {
                c4 = 2 << a2;
                c4 = d2 << a2 & (c4 | 0 - c4);
                c4 = (c4 & 0 - c4) + -1 | 0;
                i = c4 >>> 12 & 16;
                c4 = c4 >>> i;
                d2 = c4 >>> 5 & 8;
                c4 = c4 >>> d2;
                g2 = c4 >>> 2 & 4;
                c4 = c4 >>> g2;
                a2 = c4 >>> 1 & 2;
                c4 = c4 >>> a2;
                e3 = c4 >>> 1 & 1;
                e3 = (d2 | i | g2 | a2 | e3) + (c4 >>> e3) | 0;
                c4 = 27948 + (e3 << 1 << 2) | 0;
                a2 = c4 + 8 | 0;
                g2 = b[a2 >> 2] | 0;
                i = g2 + 8 | 0;
                d2 = b[i >> 2] | 0;
                if ((d2 | 0) == (c4 | 0)) {
                  a2 = m & ~(1 << e3);
                  b[6977] = a2;
                } else {
                  b[d2 + 12 >> 2] = c4;
                  b[a2 >> 2] = d2;
                  a2 = m;
                }
                v3 = e3 << 3;
                h = v3 - k | 0;
                b[g2 + 4 >> 2] = k | 3;
                f2 = g2 + k | 0;
                b[f2 + 4 >> 2] = h | 1;
                b[g2 + v3 >> 2] = h;
                if (l | 0) {
                  e3 = b[6982] | 0;
                  c4 = l >>> 3;
                  d2 = 27948 + (c4 << 1 << 2) | 0;
                  c4 = 1 << c4;
                  if (!(a2 & c4)) {
                    b[6977] = a2 | c4;
                    c4 = d2;
                    a2 = d2 + 8 | 0;
                  } else {
                    a2 = d2 + 8 | 0;
                    c4 = b[a2 >> 2] | 0;
                  }
                  b[a2 >> 2] = e3;
                  b[c4 + 12 >> 2] = e3;
                  b[e3 + 8 >> 2] = c4;
                  b[e3 + 12 >> 2] = d2;
                }
                b[6979] = h;
                b[6982] = f2;
                v3 = i;
                T2 = w4;
                return v3 | 0;
              }
              g2 = b[6978] | 0;
              if (g2) {
                d2 = (g2 & 0 - g2) + -1 | 0;
                f2 = d2 >>> 12 & 16;
                d2 = d2 >>> f2;
                e3 = d2 >>> 5 & 8;
                d2 = d2 >>> e3;
                h = d2 >>> 2 & 4;
                d2 = d2 >>> h;
                i = d2 >>> 1 & 2;
                d2 = d2 >>> i;
                j = d2 >>> 1 & 1;
                j = b[28212 + ((e3 | f2 | h | i | j) + (d2 >>> j) << 2) >> 2] | 0;
                d2 = j;
                i = j;
                j = (b[j + 4 >> 2] & -8) - k | 0;
                while (1) {
                  a2 = b[d2 + 16 >> 2] | 0;
                  if (!a2) {
                    a2 = b[d2 + 20 >> 2] | 0;
                    if (!a2) {
                      break;
                    }
                  }
                  h = (b[a2 + 4 >> 2] & -8) - k | 0;
                  f2 = h >>> 0 < j >>> 0;
                  d2 = a2;
                  i = f2 ? a2 : i;
                  j = f2 ? h : j;
                }
                h = i + k | 0;
                if (h >>> 0 > i >>> 0) {
                  f2 = b[i + 24 >> 2] | 0;
                  c4 = b[i + 12 >> 2] | 0;
                  do {
                    if ((c4 | 0) == (i | 0)) {
                      a2 = i + 20 | 0;
                      c4 = b[a2 >> 2] | 0;
                      if (!c4) {
                        a2 = i + 16 | 0;
                        c4 = b[a2 >> 2] | 0;
                        if (!c4) {
                          d2 = 0;
                          break;
                        }
                      }
                      while (1) {
                        e3 = c4 + 20 | 0;
                        d2 = b[e3 >> 2] | 0;
                        if (!d2) {
                          e3 = c4 + 16 | 0;
                          d2 = b[e3 >> 2] | 0;
                          if (!d2) {
                            break;
                          } else {
                            c4 = d2;
                            a2 = e3;
                          }
                        } else {
                          c4 = d2;
                          a2 = e3;
                        }
                      }
                      b[a2 >> 2] = 0;
                      d2 = c4;
                    } else {
                      d2 = b[i + 8 >> 2] | 0;
                      b[d2 + 12 >> 2] = c4;
                      b[c4 + 8 >> 2] = d2;
                      d2 = c4;
                    }
                  } while (0);
                  do {
                    if (f2 | 0) {
                      c4 = b[i + 28 >> 2] | 0;
                      a2 = 28212 + (c4 << 2) | 0;
                      if ((i | 0) == (b[a2 >> 2] | 0)) {
                        b[a2 >> 2] = d2;
                        if (!d2) {
                          b[6978] = g2 & ~(1 << c4);
                          break;
                        }
                      } else {
                        v3 = f2 + 16 | 0;
                        b[((b[v3 >> 2] | 0) == (i | 0) ? v3 : f2 + 20 | 0) >> 2] = d2;
                        if (!d2) {
                          break;
                        }
                      }
                      b[d2 + 24 >> 2] = f2;
                      c4 = b[i + 16 >> 2] | 0;
                      if (c4 | 0) {
                        b[d2 + 16 >> 2] = c4;
                        b[c4 + 24 >> 2] = d2;
                      }
                      c4 = b[i + 20 >> 2] | 0;
                      if (c4 | 0) {
                        b[d2 + 20 >> 2] = c4;
                        b[c4 + 24 >> 2] = d2;
                      }
                    }
                  } while (0);
                  if (j >>> 0 < 16) {
                    v3 = j + k | 0;
                    b[i + 4 >> 2] = v3 | 3;
                    v3 = i + v3 + 4 | 0;
                    b[v3 >> 2] = b[v3 >> 2] | 1;
                  } else {
                    b[i + 4 >> 2] = k | 3;
                    b[h + 4 >> 2] = j | 1;
                    b[h + j >> 2] = j;
                    if (l | 0) {
                      e3 = b[6982] | 0;
                      c4 = l >>> 3;
                      d2 = 27948 + (c4 << 1 << 2) | 0;
                      c4 = 1 << c4;
                      if (!(c4 & m)) {
                        b[6977] = c4 | m;
                        c4 = d2;
                        a2 = d2 + 8 | 0;
                      } else {
                        a2 = d2 + 8 | 0;
                        c4 = b[a2 >> 2] | 0;
                      }
                      b[a2 >> 2] = e3;
                      b[c4 + 12 >> 2] = e3;
                      b[e3 + 8 >> 2] = c4;
                      b[e3 + 12 >> 2] = d2;
                    }
                    b[6979] = j;
                    b[6982] = h;
                  }
                  v3 = i + 8 | 0;
                  T2 = w4;
                  return v3 | 0;
                } else {
                  m = k;
                }
              } else {
                m = k;
              }
            } else {
              m = k;
            }
          } else if (a2 >>> 0 <= 4294967231) {
            a2 = a2 + 11 | 0;
            k = a2 & -8;
            e3 = b[6978] | 0;
            if (e3) {
              f2 = 0 - k | 0;
              a2 = a2 >>> 8;
              if (a2) {
                if (k >>> 0 > 16777215) {
                  j = 31;
                } else {
                  m = (a2 + 1048320 | 0) >>> 16 & 8;
                  q2 = a2 << m;
                  i = (q2 + 520192 | 0) >>> 16 & 4;
                  q2 = q2 << i;
                  j = (q2 + 245760 | 0) >>> 16 & 2;
                  j = 14 - (i | m | j) + (q2 << j >>> 15) | 0;
                  j = k >>> (j + 7 | 0) & 1 | j << 1;
                }
              } else {
                j = 0;
              }
              d2 = b[28212 + (j << 2) >> 2] | 0;
              a: do {
                if (!d2) {
                  d2 = 0;
                  a2 = 0;
                  q2 = 61;
                } else {
                  a2 = 0;
                  i = k << ((j | 0) == 31 ? 0 : 25 - (j >>> 1) | 0);
                  g2 = 0;
                  while (1) {
                    h = (b[d2 + 4 >> 2] & -8) - k | 0;
                    if (h >>> 0 < f2 >>> 0) {
                      if (!h) {
                        a2 = d2;
                        f2 = 0;
                        q2 = 65;
                        break a;
                      } else {
                        a2 = d2;
                        f2 = h;
                      }
                    }
                    q2 = b[d2 + 20 >> 2] | 0;
                    d2 = b[d2 + 16 + (i >>> 31 << 2) >> 2] | 0;
                    g2 = (q2 | 0) == 0 | (q2 | 0) == (d2 | 0) ? g2 : q2;
                    if (!d2) {
                      d2 = g2;
                      q2 = 61;
                      break;
                    } else {
                      i = i << 1;
                    }
                  }
                }
              } while (0);
              if ((q2 | 0) == 61) {
                if ((d2 | 0) == 0 & (a2 | 0) == 0) {
                  a2 = 2 << j;
                  a2 = (a2 | 0 - a2) & e3;
                  if (!a2) {
                    m = k;
                    break;
                  }
                  m = (a2 & 0 - a2) + -1 | 0;
                  h = m >>> 12 & 16;
                  m = m >>> h;
                  g2 = m >>> 5 & 8;
                  m = m >>> g2;
                  i = m >>> 2 & 4;
                  m = m >>> i;
                  j = m >>> 1 & 2;
                  m = m >>> j;
                  d2 = m >>> 1 & 1;
                  a2 = 0;
                  d2 = b[28212 + ((g2 | h | i | j | d2) + (m >>> d2) << 2) >> 2] | 0;
                }
                if (!d2) {
                  i = a2;
                  h = f2;
                } else {
                  q2 = 65;
                }
              }
              if ((q2 | 0) == 65) {
                g2 = d2;
                while (1) {
                  m = (b[g2 + 4 >> 2] & -8) - k | 0;
                  d2 = m >>> 0 < f2 >>> 0;
                  f2 = d2 ? m : f2;
                  a2 = d2 ? g2 : a2;
                  d2 = b[g2 + 16 >> 2] | 0;
                  if (!d2) {
                    d2 = b[g2 + 20 >> 2] | 0;
                  }
                  if (!d2) {
                    i = a2;
                    h = f2;
                    break;
                  } else {
                    g2 = d2;
                  }
                }
              }
              if (((i | 0) != 0 ? h >>> 0 < ((b[6979] | 0) - k | 0) >>> 0 : 0) ? (l = i + k | 0, l >>> 0 > i >>> 0) : 0) {
                g2 = b[i + 24 >> 2] | 0;
                c4 = b[i + 12 >> 2] | 0;
                do {
                  if ((c4 | 0) == (i | 0)) {
                    a2 = i + 20 | 0;
                    c4 = b[a2 >> 2] | 0;
                    if (!c4) {
                      a2 = i + 16 | 0;
                      c4 = b[a2 >> 2] | 0;
                      if (!c4) {
                        c4 = 0;
                        break;
                      }
                    }
                    while (1) {
                      f2 = c4 + 20 | 0;
                      d2 = b[f2 >> 2] | 0;
                      if (!d2) {
                        f2 = c4 + 16 | 0;
                        d2 = b[f2 >> 2] | 0;
                        if (!d2) {
                          break;
                        } else {
                          c4 = d2;
                          a2 = f2;
                        }
                      } else {
                        c4 = d2;
                        a2 = f2;
                      }
                    }
                    b[a2 >> 2] = 0;
                  } else {
                    v3 = b[i + 8 >> 2] | 0;
                    b[v3 + 12 >> 2] = c4;
                    b[c4 + 8 >> 2] = v3;
                  }
                } while (0);
                do {
                  if (g2) {
                    a2 = b[i + 28 >> 2] | 0;
                    d2 = 28212 + (a2 << 2) | 0;
                    if ((i | 0) == (b[d2 >> 2] | 0)) {
                      b[d2 >> 2] = c4;
                      if (!c4) {
                        e3 = e3 & ~(1 << a2);
                        b[6978] = e3;
                        break;
                      }
                    } else {
                      v3 = g2 + 16 | 0;
                      b[((b[v3 >> 2] | 0) == (i | 0) ? v3 : g2 + 20 | 0) >> 2] = c4;
                      if (!c4) {
                        break;
                      }
                    }
                    b[c4 + 24 >> 2] = g2;
                    a2 = b[i + 16 >> 2] | 0;
                    if (a2 | 0) {
                      b[c4 + 16 >> 2] = a2;
                      b[a2 + 24 >> 2] = c4;
                    }
                    a2 = b[i + 20 >> 2] | 0;
                    if (a2) {
                      b[c4 + 20 >> 2] = a2;
                      b[a2 + 24 >> 2] = c4;
                    }
                  }
                } while (0);
                b: do {
                  if (h >>> 0 < 16) {
                    v3 = h + k | 0;
                    b[i + 4 >> 2] = v3 | 3;
                    v3 = i + v3 + 4 | 0;
                    b[v3 >> 2] = b[v3 >> 2] | 1;
                  } else {
                    b[i + 4 >> 2] = k | 3;
                    b[l + 4 >> 2] = h | 1;
                    b[l + h >> 2] = h;
                    c4 = h >>> 3;
                    if (h >>> 0 < 256) {
                      d2 = 27948 + (c4 << 1 << 2) | 0;
                      a2 = b[6977] | 0;
                      c4 = 1 << c4;
                      if (!(a2 & c4)) {
                        b[6977] = a2 | c4;
                        c4 = d2;
                        a2 = d2 + 8 | 0;
                      } else {
                        a2 = d2 + 8 | 0;
                        c4 = b[a2 >> 2] | 0;
                      }
                      b[a2 >> 2] = l;
                      b[c4 + 12 >> 2] = l;
                      b[l + 8 >> 2] = c4;
                      b[l + 12 >> 2] = d2;
                      break;
                    }
                    c4 = h >>> 8;
                    if (c4) {
                      if (h >>> 0 > 16777215) {
                        d2 = 31;
                      } else {
                        u5 = (c4 + 1048320 | 0) >>> 16 & 8;
                        v3 = c4 << u5;
                        t4 = (v3 + 520192 | 0) >>> 16 & 4;
                        v3 = v3 << t4;
                        d2 = (v3 + 245760 | 0) >>> 16 & 2;
                        d2 = 14 - (t4 | u5 | d2) + (v3 << d2 >>> 15) | 0;
                        d2 = h >>> (d2 + 7 | 0) & 1 | d2 << 1;
                      }
                    } else {
                      d2 = 0;
                    }
                    c4 = 28212 + (d2 << 2) | 0;
                    b[l + 28 >> 2] = d2;
                    a2 = l + 16 | 0;
                    b[a2 + 4 >> 2] = 0;
                    b[a2 >> 2] = 0;
                    a2 = 1 << d2;
                    if (!(e3 & a2)) {
                      b[6978] = e3 | a2;
                      b[c4 >> 2] = l;
                      b[l + 24 >> 2] = c4;
                      b[l + 12 >> 2] = l;
                      b[l + 8 >> 2] = l;
                      break;
                    }
                    c4 = b[c4 >> 2] | 0;
                    c: do {
                      if ((b[c4 + 4 >> 2] & -8 | 0) != (h | 0)) {
                        e3 = h << ((d2 | 0) == 31 ? 0 : 25 - (d2 >>> 1) | 0);
                        while (1) {
                          d2 = c4 + 16 + (e3 >>> 31 << 2) | 0;
                          a2 = b[d2 >> 2] | 0;
                          if (!a2) {
                            break;
                          }
                          if ((b[a2 + 4 >> 2] & -8 | 0) == (h | 0)) {
                            c4 = a2;
                            break c;
                          } else {
                            e3 = e3 << 1;
                            c4 = a2;
                          }
                        }
                        b[d2 >> 2] = l;
                        b[l + 24 >> 2] = c4;
                        b[l + 12 >> 2] = l;
                        b[l + 8 >> 2] = l;
                        break b;
                      }
                    } while (0);
                    u5 = c4 + 8 | 0;
                    v3 = b[u5 >> 2] | 0;
                    b[v3 + 12 >> 2] = l;
                    b[u5 >> 2] = l;
                    b[l + 8 >> 2] = v3;
                    b[l + 12 >> 2] = c4;
                    b[l + 24 >> 2] = 0;
                  }
                } while (0);
                v3 = i + 8 | 0;
                T2 = w4;
                return v3 | 0;
              } else {
                m = k;
              }
            } else {
              m = k;
            }
          } else {
            m = -1;
          }
        } while (0);
        d2 = b[6979] | 0;
        if (d2 >>> 0 >= m >>> 0) {
          c4 = d2 - m | 0;
          a2 = b[6982] | 0;
          if (c4 >>> 0 > 15) {
            v3 = a2 + m | 0;
            b[6982] = v3;
            b[6979] = c4;
            b[v3 + 4 >> 2] = c4 | 1;
            b[a2 + d2 >> 2] = c4;
            b[a2 + 4 >> 2] = m | 3;
          } else {
            b[6979] = 0;
            b[6982] = 0;
            b[a2 + 4 >> 2] = d2 | 3;
            v3 = a2 + d2 + 4 | 0;
            b[v3 >> 2] = b[v3 >> 2] | 1;
          }
          v3 = a2 + 8 | 0;
          T2 = w4;
          return v3 | 0;
        }
        h = b[6980] | 0;
        if (h >>> 0 > m >>> 0) {
          t4 = h - m | 0;
          b[6980] = t4;
          v3 = b[6983] | 0;
          u5 = v3 + m | 0;
          b[6983] = u5;
          b[u5 + 4 >> 2] = t4 | 1;
          b[v3 + 4 >> 2] = m | 3;
          v3 = v3 + 8 | 0;
          T2 = w4;
          return v3 | 0;
        }
        if (!(b[7095] | 0)) {
          b[7097] = 4096;
          b[7096] = 4096;
          b[7098] = -1;
          b[7099] = -1;
          b[7100] = 0;
          b[7088] = 0;
          b[7095] = n & -16 ^ 1431655768;
          a2 = 4096;
        } else {
          a2 = b[7097] | 0;
        }
        i = m + 48 | 0;
        j = m + 47 | 0;
        g2 = a2 + j | 0;
        f2 = 0 - a2 | 0;
        k = g2 & f2;
        if (k >>> 0 <= m >>> 0) {
          v3 = 0;
          T2 = w4;
          return v3 | 0;
        }
        a2 = b[7087] | 0;
        if (a2 | 0 ? (l = b[7085] | 0, n = l + k | 0, n >>> 0 <= l >>> 0 | n >>> 0 > a2 >>> 0) : 0) {
          v3 = 0;
          T2 = w4;
          return v3 | 0;
        }
        d: do {
          if (!(b[7088] & 4)) {
            d2 = b[6983] | 0;
            e: do {
              if (d2) {
                e3 = 28356;
                while (1) {
                  n = b[e3 >> 2] | 0;
                  if (n >>> 0 <= d2 >>> 0 ? (n + (b[e3 + 4 >> 2] | 0) | 0) >>> 0 > d2 >>> 0 : 0) {
                    break;
                  }
                  a2 = b[e3 + 8 >> 2] | 0;
                  if (!a2) {
                    q2 = 128;
                    break e;
                  } else {
                    e3 = a2;
                  }
                }
                c4 = g2 - h & f2;
                if (c4 >>> 0 < 2147483647) {
                  a2 = Zd(c4 | 0) | 0;
                  if ((a2 | 0) == ((b[e3 >> 2] | 0) + (b[e3 + 4 >> 2] | 0) | 0)) {
                    if ((a2 | 0) != (-1 | 0)) {
                      h = c4;
                      g2 = a2;
                      q2 = 145;
                      break d;
                    }
                  } else {
                    e3 = a2;
                    q2 = 136;
                  }
                } else {
                  c4 = 0;
                }
              } else {
                q2 = 128;
              }
            } while (0);
            do {
              if ((q2 | 0) == 128) {
                d2 = Zd(0) | 0;
                if ((d2 | 0) != (-1 | 0) ? (c4 = d2, o = b[7096] | 0, p2 = o + -1 | 0, c4 = ((p2 & c4 | 0) == 0 ? 0 : (p2 + c4 & 0 - o) - c4 | 0) + k | 0, o = b[7085] | 0, p2 = c4 + o | 0, c4 >>> 0 > m >>> 0 & c4 >>> 0 < 2147483647) : 0) {
                  n = b[7087] | 0;
                  if (n | 0 ? p2 >>> 0 <= o >>> 0 | p2 >>> 0 > n >>> 0 : 0) {
                    c4 = 0;
                    break;
                  }
                  a2 = Zd(c4 | 0) | 0;
                  if ((a2 | 0) == (d2 | 0)) {
                    h = c4;
                    g2 = d2;
                    q2 = 145;
                    break d;
                  } else {
                    e3 = a2;
                    q2 = 136;
                  }
                } else {
                  c4 = 0;
                }
              }
            } while (0);
            do {
              if ((q2 | 0) == 136) {
                d2 = 0 - c4 | 0;
                if (!(i >>> 0 > c4 >>> 0 & (c4 >>> 0 < 2147483647 & (e3 | 0) != (-1 | 0)))) {
                  if ((e3 | 0) == (-1 | 0)) {
                    c4 = 0;
                    break;
                  } else {
                    h = c4;
                    g2 = e3;
                    q2 = 145;
                    break d;
                  }
                }
                a2 = b[7097] | 0;
                a2 = j - c4 + a2 & 0 - a2;
                if (a2 >>> 0 >= 2147483647) {
                  h = c4;
                  g2 = e3;
                  q2 = 145;
                  break d;
                }
                if ((Zd(a2 | 0) | 0) == (-1 | 0)) {
                  Zd(d2 | 0) | 0;
                  c4 = 0;
                  break;
                } else {
                  h = a2 + c4 | 0;
                  g2 = e3;
                  q2 = 145;
                  break d;
                }
              }
            } while (0);
            b[7088] = b[7088] | 4;
            q2 = 143;
          } else {
            c4 = 0;
            q2 = 143;
          }
        } while (0);
        if (((q2 | 0) == 143 ? k >>> 0 < 2147483647 : 0) ? (t4 = Zd(k | 0) | 0, p2 = Zd(0) | 0, r2 = p2 - t4 | 0, s2 = r2 >>> 0 > (m + 40 | 0) >>> 0, !((t4 | 0) == (-1 | 0) | s2 ^ 1 | t4 >>> 0 < p2 >>> 0 & ((t4 | 0) != (-1 | 0) & (p2 | 0) != (-1 | 0)) ^ 1)) : 0) {
          h = s2 ? r2 : c4;
          g2 = t4;
          q2 = 145;
        }
        if ((q2 | 0) == 145) {
          c4 = (b[7085] | 0) + h | 0;
          b[7085] = c4;
          if (c4 >>> 0 > (b[7086] | 0) >>> 0) {
            b[7086] = c4;
          }
          j = b[6983] | 0;
          f: do {
            if (j) {
              c4 = 28356;
              while (1) {
                a2 = b[c4 >> 2] | 0;
                d2 = b[c4 + 4 >> 2] | 0;
                if ((g2 | 0) == (a2 + d2 | 0)) {
                  q2 = 154;
                  break;
                }
                e3 = b[c4 + 8 >> 2] | 0;
                if (!e3) {
                  break;
                } else {
                  c4 = e3;
                }
              }
              if (((q2 | 0) == 154 ? (u5 = c4 + 4 | 0, (b[c4 + 12 >> 2] & 8 | 0) == 0) : 0) ? g2 >>> 0 > j >>> 0 & a2 >>> 0 <= j >>> 0 : 0) {
                b[u5 >> 2] = d2 + h;
                v3 = (b[6980] | 0) + h | 0;
                t4 = j + 8 | 0;
                t4 = (t4 & 7 | 0) == 0 ? 0 : 0 - t4 & 7;
                u5 = j + t4 | 0;
                t4 = v3 - t4 | 0;
                b[6983] = u5;
                b[6980] = t4;
                b[u5 + 4 >> 2] = t4 | 1;
                b[j + v3 + 4 >> 2] = 40;
                b[6984] = b[7099];
                break;
              }
              if (g2 >>> 0 < (b[6981] | 0) >>> 0) {
                b[6981] = g2;
              }
              d2 = g2 + h | 0;
              c4 = 28356;
              while (1) {
                if ((b[c4 >> 2] | 0) == (d2 | 0)) {
                  q2 = 162;
                  break;
                }
                a2 = b[c4 + 8 >> 2] | 0;
                if (!a2) {
                  break;
                } else {
                  c4 = a2;
                }
              }
              if ((q2 | 0) == 162 ? (b[c4 + 12 >> 2] & 8 | 0) == 0 : 0) {
                b[c4 >> 2] = g2;
                l = c4 + 4 | 0;
                b[l >> 2] = (b[l >> 2] | 0) + h;
                l = g2 + 8 | 0;
                l = g2 + ((l & 7 | 0) == 0 ? 0 : 0 - l & 7) | 0;
                c4 = d2 + 8 | 0;
                c4 = d2 + ((c4 & 7 | 0) == 0 ? 0 : 0 - c4 & 7) | 0;
                k = l + m | 0;
                i = c4 - l - m | 0;
                b[l + 4 >> 2] = m | 3;
                g: do {
                  if ((j | 0) == (c4 | 0)) {
                    v3 = (b[6980] | 0) + i | 0;
                    b[6980] = v3;
                    b[6983] = k;
                    b[k + 4 >> 2] = v3 | 1;
                  } else {
                    if ((b[6982] | 0) == (c4 | 0)) {
                      v3 = (b[6979] | 0) + i | 0;
                      b[6979] = v3;
                      b[6982] = k;
                      b[k + 4 >> 2] = v3 | 1;
                      b[k + v3 >> 2] = v3;
                      break;
                    }
                    a2 = b[c4 + 4 >> 2] | 0;
                    if ((a2 & 3 | 0) == 1) {
                      h = a2 & -8;
                      e3 = a2 >>> 3;
                      h: do {
                        if (a2 >>> 0 < 256) {
                          a2 = b[c4 + 8 >> 2] | 0;
                          d2 = b[c4 + 12 >> 2] | 0;
                          if ((d2 | 0) == (a2 | 0)) {
                            b[6977] = b[6977] & ~(1 << e3);
                            break;
                          } else {
                            b[a2 + 12 >> 2] = d2;
                            b[d2 + 8 >> 2] = a2;
                            break;
                          }
                        } else {
                          g2 = b[c4 + 24 >> 2] | 0;
                          a2 = b[c4 + 12 >> 2] | 0;
                          do {
                            if ((a2 | 0) == (c4 | 0)) {
                              d2 = c4 + 16 | 0;
                              e3 = d2 + 4 | 0;
                              a2 = b[e3 >> 2] | 0;
                              if (!a2) {
                                a2 = b[d2 >> 2] | 0;
                                if (!a2) {
                                  a2 = 0;
                                  break;
                                }
                              } else {
                                d2 = e3;
                              }
                              while (1) {
                                f2 = a2 + 20 | 0;
                                e3 = b[f2 >> 2] | 0;
                                if (!e3) {
                                  f2 = a2 + 16 | 0;
                                  e3 = b[f2 >> 2] | 0;
                                  if (!e3) {
                                    break;
                                  } else {
                                    a2 = e3;
                                    d2 = f2;
                                  }
                                } else {
                                  a2 = e3;
                                  d2 = f2;
                                }
                              }
                              b[d2 >> 2] = 0;
                            } else {
                              v3 = b[c4 + 8 >> 2] | 0;
                              b[v3 + 12 >> 2] = a2;
                              b[a2 + 8 >> 2] = v3;
                            }
                          } while (0);
                          if (!g2) {
                            break;
                          }
                          d2 = b[c4 + 28 >> 2] | 0;
                          e3 = 28212 + (d2 << 2) | 0;
                          do {
                            if ((b[e3 >> 2] | 0) != (c4 | 0)) {
                              v3 = g2 + 16 | 0;
                              b[((b[v3 >> 2] | 0) == (c4 | 0) ? v3 : g2 + 20 | 0) >> 2] = a2;
                              if (!a2) {
                                break h;
                              }
                            } else {
                              b[e3 >> 2] = a2;
                              if (a2 | 0) {
                                break;
                              }
                              b[6978] = b[6978] & ~(1 << d2);
                              break h;
                            }
                          } while (0);
                          b[a2 + 24 >> 2] = g2;
                          d2 = c4 + 16 | 0;
                          e3 = b[d2 >> 2] | 0;
                          if (e3 | 0) {
                            b[a2 + 16 >> 2] = e3;
                            b[e3 + 24 >> 2] = a2;
                          }
                          d2 = b[d2 + 4 >> 2] | 0;
                          if (!d2) {
                            break;
                          }
                          b[a2 + 20 >> 2] = d2;
                          b[d2 + 24 >> 2] = a2;
                        }
                      } while (0);
                      c4 = c4 + h | 0;
                      f2 = h + i | 0;
                    } else {
                      f2 = i;
                    }
                    c4 = c4 + 4 | 0;
                    b[c4 >> 2] = b[c4 >> 2] & -2;
                    b[k + 4 >> 2] = f2 | 1;
                    b[k + f2 >> 2] = f2;
                    c4 = f2 >>> 3;
                    if (f2 >>> 0 < 256) {
                      d2 = 27948 + (c4 << 1 << 2) | 0;
                      a2 = b[6977] | 0;
                      c4 = 1 << c4;
                      if (!(a2 & c4)) {
                        b[6977] = a2 | c4;
                        c4 = d2;
                        a2 = d2 + 8 | 0;
                      } else {
                        a2 = d2 + 8 | 0;
                        c4 = b[a2 >> 2] | 0;
                      }
                      b[a2 >> 2] = k;
                      b[c4 + 12 >> 2] = k;
                      b[k + 8 >> 2] = c4;
                      b[k + 12 >> 2] = d2;
                      break;
                    }
                    c4 = f2 >>> 8;
                    do {
                      if (!c4) {
                        e3 = 0;
                      } else {
                        if (f2 >>> 0 > 16777215) {
                          e3 = 31;
                          break;
                        }
                        u5 = (c4 + 1048320 | 0) >>> 16 & 8;
                        v3 = c4 << u5;
                        t4 = (v3 + 520192 | 0) >>> 16 & 4;
                        v3 = v3 << t4;
                        e3 = (v3 + 245760 | 0) >>> 16 & 2;
                        e3 = 14 - (t4 | u5 | e3) + (v3 << e3 >>> 15) | 0;
                        e3 = f2 >>> (e3 + 7 | 0) & 1 | e3 << 1;
                      }
                    } while (0);
                    c4 = 28212 + (e3 << 2) | 0;
                    b[k + 28 >> 2] = e3;
                    a2 = k + 16 | 0;
                    b[a2 + 4 >> 2] = 0;
                    b[a2 >> 2] = 0;
                    a2 = b[6978] | 0;
                    d2 = 1 << e3;
                    if (!(a2 & d2)) {
                      b[6978] = a2 | d2;
                      b[c4 >> 2] = k;
                      b[k + 24 >> 2] = c4;
                      b[k + 12 >> 2] = k;
                      b[k + 8 >> 2] = k;
                      break;
                    }
                    c4 = b[c4 >> 2] | 0;
                    i: do {
                      if ((b[c4 + 4 >> 2] & -8 | 0) != (f2 | 0)) {
                        e3 = f2 << ((e3 | 0) == 31 ? 0 : 25 - (e3 >>> 1) | 0);
                        while (1) {
                          d2 = c4 + 16 + (e3 >>> 31 << 2) | 0;
                          a2 = b[d2 >> 2] | 0;
                          if (!a2) {
                            break;
                          }
                          if ((b[a2 + 4 >> 2] & -8 | 0) == (f2 | 0)) {
                            c4 = a2;
                            break i;
                          } else {
                            e3 = e3 << 1;
                            c4 = a2;
                          }
                        }
                        b[d2 >> 2] = k;
                        b[k + 24 >> 2] = c4;
                        b[k + 12 >> 2] = k;
                        b[k + 8 >> 2] = k;
                        break g;
                      }
                    } while (0);
                    u5 = c4 + 8 | 0;
                    v3 = b[u5 >> 2] | 0;
                    b[v3 + 12 >> 2] = k;
                    b[u5 >> 2] = k;
                    b[k + 8 >> 2] = v3;
                    b[k + 12 >> 2] = c4;
                    b[k + 24 >> 2] = 0;
                  }
                } while (0);
                v3 = l + 8 | 0;
                T2 = w4;
                return v3 | 0;
              }
              c4 = 28356;
              while (1) {
                a2 = b[c4 >> 2] | 0;
                if (a2 >>> 0 <= j >>> 0 ? (v3 = a2 + (b[c4 + 4 >> 2] | 0) | 0, v3 >>> 0 > j >>> 0) : 0) {
                  break;
                }
                c4 = b[c4 + 8 >> 2] | 0;
              }
              f2 = v3 + -47 | 0;
              a2 = f2 + 8 | 0;
              a2 = f2 + ((a2 & 7 | 0) == 0 ? 0 : 0 - a2 & 7) | 0;
              f2 = j + 16 | 0;
              a2 = a2 >>> 0 < f2 >>> 0 ? j : a2;
              c4 = a2 + 8 | 0;
              d2 = h + -40 | 0;
              t4 = g2 + 8 | 0;
              t4 = (t4 & 7 | 0) == 0 ? 0 : 0 - t4 & 7;
              u5 = g2 + t4 | 0;
              t4 = d2 - t4 | 0;
              b[6983] = u5;
              b[6980] = t4;
              b[u5 + 4 >> 2] = t4 | 1;
              b[g2 + d2 + 4 >> 2] = 40;
              b[6984] = b[7099];
              d2 = a2 + 4 | 0;
              b[d2 >> 2] = 27;
              b[c4 >> 2] = b[7089];
              b[c4 + 4 >> 2] = b[7090];
              b[c4 + 8 >> 2] = b[7091];
              b[c4 + 12 >> 2] = b[7092];
              b[7089] = g2;
              b[7090] = h;
              b[7092] = 0;
              b[7091] = c4;
              c4 = a2 + 24 | 0;
              do {
                u5 = c4;
                c4 = c4 + 4 | 0;
                b[c4 >> 2] = 7;
              } while ((u5 + 8 | 0) >>> 0 < v3 >>> 0);
              if ((a2 | 0) != (j | 0)) {
                g2 = a2 - j | 0;
                b[d2 >> 2] = b[d2 >> 2] & -2;
                b[j + 4 >> 2] = g2 | 1;
                b[a2 >> 2] = g2;
                c4 = g2 >>> 3;
                if (g2 >>> 0 < 256) {
                  d2 = 27948 + (c4 << 1 << 2) | 0;
                  a2 = b[6977] | 0;
                  c4 = 1 << c4;
                  if (!(a2 & c4)) {
                    b[6977] = a2 | c4;
                    c4 = d2;
                    a2 = d2 + 8 | 0;
                  } else {
                    a2 = d2 + 8 | 0;
                    c4 = b[a2 >> 2] | 0;
                  }
                  b[a2 >> 2] = j;
                  b[c4 + 12 >> 2] = j;
                  b[j + 8 >> 2] = c4;
                  b[j + 12 >> 2] = d2;
                  break;
                }
                c4 = g2 >>> 8;
                if (c4) {
                  if (g2 >>> 0 > 16777215) {
                    e3 = 31;
                  } else {
                    u5 = (c4 + 1048320 | 0) >>> 16 & 8;
                    v3 = c4 << u5;
                    t4 = (v3 + 520192 | 0) >>> 16 & 4;
                    v3 = v3 << t4;
                    e3 = (v3 + 245760 | 0) >>> 16 & 2;
                    e3 = 14 - (t4 | u5 | e3) + (v3 << e3 >>> 15) | 0;
                    e3 = g2 >>> (e3 + 7 | 0) & 1 | e3 << 1;
                  }
                } else {
                  e3 = 0;
                }
                d2 = 28212 + (e3 << 2) | 0;
                b[j + 28 >> 2] = e3;
                b[j + 20 >> 2] = 0;
                b[f2 >> 2] = 0;
                c4 = b[6978] | 0;
                a2 = 1 << e3;
                if (!(c4 & a2)) {
                  b[6978] = c4 | a2;
                  b[d2 >> 2] = j;
                  b[j + 24 >> 2] = d2;
                  b[j + 12 >> 2] = j;
                  b[j + 8 >> 2] = j;
                  break;
                }
                c4 = b[d2 >> 2] | 0;
                j: do {
                  if ((b[c4 + 4 >> 2] & -8 | 0) != (g2 | 0)) {
                    e3 = g2 << ((e3 | 0) == 31 ? 0 : 25 - (e3 >>> 1) | 0);
                    while (1) {
                      d2 = c4 + 16 + (e3 >>> 31 << 2) | 0;
                      a2 = b[d2 >> 2] | 0;
                      if (!a2) {
                        break;
                      }
                      if ((b[a2 + 4 >> 2] & -8 | 0) == (g2 | 0)) {
                        c4 = a2;
                        break j;
                      } else {
                        e3 = e3 << 1;
                        c4 = a2;
                      }
                    }
                    b[d2 >> 2] = j;
                    b[j + 24 >> 2] = c4;
                    b[j + 12 >> 2] = j;
                    b[j + 8 >> 2] = j;
                    break f;
                  }
                } while (0);
                u5 = c4 + 8 | 0;
                v3 = b[u5 >> 2] | 0;
                b[v3 + 12 >> 2] = j;
                b[u5 >> 2] = j;
                b[j + 8 >> 2] = v3;
                b[j + 12 >> 2] = c4;
                b[j + 24 >> 2] = 0;
              }
            } else {
              v3 = b[6981] | 0;
              if ((v3 | 0) == 0 | g2 >>> 0 < v3 >>> 0) {
                b[6981] = g2;
              }
              b[7089] = g2;
              b[7090] = h;
              b[7092] = 0;
              b[6986] = b[7095];
              b[6985] = -1;
              b[6990] = 27948;
              b[6989] = 27948;
              b[6992] = 27956;
              b[6991] = 27956;
              b[6994] = 27964;
              b[6993] = 27964;
              b[6996] = 27972;
              b[6995] = 27972;
              b[6998] = 27980;
              b[6997] = 27980;
              b[7e3] = 27988;
              b[6999] = 27988;
              b[7002] = 27996;
              b[7001] = 27996;
              b[7004] = 28004;
              b[7003] = 28004;
              b[7006] = 28012;
              b[7005] = 28012;
              b[7008] = 28020;
              b[7007] = 28020;
              b[7010] = 28028;
              b[7009] = 28028;
              b[7012] = 28036;
              b[7011] = 28036;
              b[7014] = 28044;
              b[7013] = 28044;
              b[7016] = 28052;
              b[7015] = 28052;
              b[7018] = 28060;
              b[7017] = 28060;
              b[7020] = 28068;
              b[7019] = 28068;
              b[7022] = 28076;
              b[7021] = 28076;
              b[7024] = 28084;
              b[7023] = 28084;
              b[7026] = 28092;
              b[7025] = 28092;
              b[7028] = 28100;
              b[7027] = 28100;
              b[7030] = 28108;
              b[7029] = 28108;
              b[7032] = 28116;
              b[7031] = 28116;
              b[7034] = 28124;
              b[7033] = 28124;
              b[7036] = 28132;
              b[7035] = 28132;
              b[7038] = 28140;
              b[7037] = 28140;
              b[7040] = 28148;
              b[7039] = 28148;
              b[7042] = 28156;
              b[7041] = 28156;
              b[7044] = 28164;
              b[7043] = 28164;
              b[7046] = 28172;
              b[7045] = 28172;
              b[7048] = 28180;
              b[7047] = 28180;
              b[7050] = 28188;
              b[7049] = 28188;
              b[7052] = 28196;
              b[7051] = 28196;
              v3 = h + -40 | 0;
              t4 = g2 + 8 | 0;
              t4 = (t4 & 7 | 0) == 0 ? 0 : 0 - t4 & 7;
              u5 = g2 + t4 | 0;
              t4 = v3 - t4 | 0;
              b[6983] = u5;
              b[6980] = t4;
              b[u5 + 4 >> 2] = t4 | 1;
              b[g2 + v3 + 4 >> 2] = 40;
              b[6984] = b[7099];
            }
          } while (0);
          c4 = b[6980] | 0;
          if (c4 >>> 0 > m >>> 0) {
            t4 = c4 - m | 0;
            b[6980] = t4;
            v3 = b[6983] | 0;
            u5 = v3 + m | 0;
            b[6983] = u5;
            b[u5 + 4 >> 2] = t4 | 1;
            b[v3 + 4 >> 2] = m | 3;
            v3 = v3 + 8 | 0;
            T2 = w4;
            return v3 | 0;
          }
        }
        v3 = Bd() | 0;
        b[v3 >> 2] = 12;
        v3 = 0;
        T2 = w4;
        return v3 | 0;
      }
      function Ed(a2) {
        a2 = a2 | 0;
        var c4 = 0, d2 = 0, e3 = 0, f2 = 0, g2 = 0, h = 0, i = 0, j = 0;
        if (!a2) {
          return;
        }
        d2 = a2 + -8 | 0;
        f2 = b[6981] | 0;
        a2 = b[a2 + -4 >> 2] | 0;
        c4 = a2 & -8;
        j = d2 + c4 | 0;
        do {
          if (!(a2 & 1)) {
            e3 = b[d2 >> 2] | 0;
            if (!(a2 & 3)) {
              return;
            }
            h = d2 + (0 - e3) | 0;
            g2 = e3 + c4 | 0;
            if (h >>> 0 < f2 >>> 0) {
              return;
            }
            if ((b[6982] | 0) == (h | 0)) {
              a2 = j + 4 | 0;
              c4 = b[a2 >> 2] | 0;
              if ((c4 & 3 | 0) != 3) {
                i = h;
                c4 = g2;
                break;
              }
              b[6979] = g2;
              b[a2 >> 2] = c4 & -2;
              b[h + 4 >> 2] = g2 | 1;
              b[h + g2 >> 2] = g2;
              return;
            }
            d2 = e3 >>> 3;
            if (e3 >>> 0 < 256) {
              a2 = b[h + 8 >> 2] | 0;
              c4 = b[h + 12 >> 2] | 0;
              if ((c4 | 0) == (a2 | 0)) {
                b[6977] = b[6977] & ~(1 << d2);
                i = h;
                c4 = g2;
                break;
              } else {
                b[a2 + 12 >> 2] = c4;
                b[c4 + 8 >> 2] = a2;
                i = h;
                c4 = g2;
                break;
              }
            }
            f2 = b[h + 24 >> 2] | 0;
            a2 = b[h + 12 >> 2] | 0;
            do {
              if ((a2 | 0) == (h | 0)) {
                c4 = h + 16 | 0;
                d2 = c4 + 4 | 0;
                a2 = b[d2 >> 2] | 0;
                if (!a2) {
                  a2 = b[c4 >> 2] | 0;
                  if (!a2) {
                    a2 = 0;
                    break;
                  }
                } else {
                  c4 = d2;
                }
                while (1) {
                  e3 = a2 + 20 | 0;
                  d2 = b[e3 >> 2] | 0;
                  if (!d2) {
                    e3 = a2 + 16 | 0;
                    d2 = b[e3 >> 2] | 0;
                    if (!d2) {
                      break;
                    } else {
                      a2 = d2;
                      c4 = e3;
                    }
                  } else {
                    a2 = d2;
                    c4 = e3;
                  }
                }
                b[c4 >> 2] = 0;
              } else {
                i = b[h + 8 >> 2] | 0;
                b[i + 12 >> 2] = a2;
                b[a2 + 8 >> 2] = i;
              }
            } while (0);
            if (f2) {
              c4 = b[h + 28 >> 2] | 0;
              d2 = 28212 + (c4 << 2) | 0;
              if ((b[d2 >> 2] | 0) == (h | 0)) {
                b[d2 >> 2] = a2;
                if (!a2) {
                  b[6978] = b[6978] & ~(1 << c4);
                  i = h;
                  c4 = g2;
                  break;
                }
              } else {
                i = f2 + 16 | 0;
                b[((b[i >> 2] | 0) == (h | 0) ? i : f2 + 20 | 0) >> 2] = a2;
                if (!a2) {
                  i = h;
                  c4 = g2;
                  break;
                }
              }
              b[a2 + 24 >> 2] = f2;
              c4 = h + 16 | 0;
              d2 = b[c4 >> 2] | 0;
              if (d2 | 0) {
                b[a2 + 16 >> 2] = d2;
                b[d2 + 24 >> 2] = a2;
              }
              c4 = b[c4 + 4 >> 2] | 0;
              if (c4) {
                b[a2 + 20 >> 2] = c4;
                b[c4 + 24 >> 2] = a2;
                i = h;
                c4 = g2;
              } else {
                i = h;
                c4 = g2;
              }
            } else {
              i = h;
              c4 = g2;
            }
          } else {
            i = d2;
            h = d2;
          }
        } while (0);
        if (h >>> 0 >= j >>> 0) {
          return;
        }
        a2 = j + 4 | 0;
        e3 = b[a2 >> 2] | 0;
        if (!(e3 & 1)) {
          return;
        }
        if (!(e3 & 2)) {
          if ((b[6983] | 0) == (j | 0)) {
            j = (b[6980] | 0) + c4 | 0;
            b[6980] = j;
            b[6983] = i;
            b[i + 4 >> 2] = j | 1;
            if ((i | 0) != (b[6982] | 0)) {
              return;
            }
            b[6982] = 0;
            b[6979] = 0;
            return;
          }
          if ((b[6982] | 0) == (j | 0)) {
            j = (b[6979] | 0) + c4 | 0;
            b[6979] = j;
            b[6982] = h;
            b[i + 4 >> 2] = j | 1;
            b[h + j >> 2] = j;
            return;
          }
          f2 = (e3 & -8) + c4 | 0;
          d2 = e3 >>> 3;
          do {
            if (e3 >>> 0 < 256) {
              c4 = b[j + 8 >> 2] | 0;
              a2 = b[j + 12 >> 2] | 0;
              if ((a2 | 0) == (c4 | 0)) {
                b[6977] = b[6977] & ~(1 << d2);
                break;
              } else {
                b[c4 + 12 >> 2] = a2;
                b[a2 + 8 >> 2] = c4;
                break;
              }
            } else {
              g2 = b[j + 24 >> 2] | 0;
              a2 = b[j + 12 >> 2] | 0;
              do {
                if ((a2 | 0) == (j | 0)) {
                  c4 = j + 16 | 0;
                  d2 = c4 + 4 | 0;
                  a2 = b[d2 >> 2] | 0;
                  if (!a2) {
                    a2 = b[c4 >> 2] | 0;
                    if (!a2) {
                      d2 = 0;
                      break;
                    }
                  } else {
                    c4 = d2;
                  }
                  while (1) {
                    e3 = a2 + 20 | 0;
                    d2 = b[e3 >> 2] | 0;
                    if (!d2) {
                      e3 = a2 + 16 | 0;
                      d2 = b[e3 >> 2] | 0;
                      if (!d2) {
                        break;
                      } else {
                        a2 = d2;
                        c4 = e3;
                      }
                    } else {
                      a2 = d2;
                      c4 = e3;
                    }
                  }
                  b[c4 >> 2] = 0;
                  d2 = a2;
                } else {
                  d2 = b[j + 8 >> 2] | 0;
                  b[d2 + 12 >> 2] = a2;
                  b[a2 + 8 >> 2] = d2;
                  d2 = a2;
                }
              } while (0);
              if (g2 | 0) {
                a2 = b[j + 28 >> 2] | 0;
                c4 = 28212 + (a2 << 2) | 0;
                if ((b[c4 >> 2] | 0) == (j | 0)) {
                  b[c4 >> 2] = d2;
                  if (!d2) {
                    b[6978] = b[6978] & ~(1 << a2);
                    break;
                  }
                } else {
                  e3 = g2 + 16 | 0;
                  b[((b[e3 >> 2] | 0) == (j | 0) ? e3 : g2 + 20 | 0) >> 2] = d2;
                  if (!d2) {
                    break;
                  }
                }
                b[d2 + 24 >> 2] = g2;
                a2 = j + 16 | 0;
                c4 = b[a2 >> 2] | 0;
                if (c4 | 0) {
                  b[d2 + 16 >> 2] = c4;
                  b[c4 + 24 >> 2] = d2;
                }
                a2 = b[a2 + 4 >> 2] | 0;
                if (a2 | 0) {
                  b[d2 + 20 >> 2] = a2;
                  b[a2 + 24 >> 2] = d2;
                }
              }
            }
          } while (0);
          b[i + 4 >> 2] = f2 | 1;
          b[h + f2 >> 2] = f2;
          if ((i | 0) == (b[6982] | 0)) {
            b[6979] = f2;
            return;
          }
        } else {
          b[a2 >> 2] = e3 & -2;
          b[i + 4 >> 2] = c4 | 1;
          b[h + c4 >> 2] = c4;
          f2 = c4;
        }
        a2 = f2 >>> 3;
        if (f2 >>> 0 < 256) {
          d2 = 27948 + (a2 << 1 << 2) | 0;
          c4 = b[6977] | 0;
          a2 = 1 << a2;
          if (!(c4 & a2)) {
            b[6977] = c4 | a2;
            a2 = d2;
            c4 = d2 + 8 | 0;
          } else {
            c4 = d2 + 8 | 0;
            a2 = b[c4 >> 2] | 0;
          }
          b[c4 >> 2] = i;
          b[a2 + 12 >> 2] = i;
          b[i + 8 >> 2] = a2;
          b[i + 12 >> 2] = d2;
          return;
        }
        a2 = f2 >>> 8;
        if (a2) {
          if (f2 >>> 0 > 16777215) {
            e3 = 31;
          } else {
            h = (a2 + 1048320 | 0) >>> 16 & 8;
            j = a2 << h;
            g2 = (j + 520192 | 0) >>> 16 & 4;
            j = j << g2;
            e3 = (j + 245760 | 0) >>> 16 & 2;
            e3 = 14 - (g2 | h | e3) + (j << e3 >>> 15) | 0;
            e3 = f2 >>> (e3 + 7 | 0) & 1 | e3 << 1;
          }
        } else {
          e3 = 0;
        }
        a2 = 28212 + (e3 << 2) | 0;
        b[i + 28 >> 2] = e3;
        b[i + 20 >> 2] = 0;
        b[i + 16 >> 2] = 0;
        c4 = b[6978] | 0;
        d2 = 1 << e3;
        a: do {
          if (!(c4 & d2)) {
            b[6978] = c4 | d2;
            b[a2 >> 2] = i;
            b[i + 24 >> 2] = a2;
            b[i + 12 >> 2] = i;
            b[i + 8 >> 2] = i;
          } else {
            a2 = b[a2 >> 2] | 0;
            b: do {
              if ((b[a2 + 4 >> 2] & -8 | 0) != (f2 | 0)) {
                e3 = f2 << ((e3 | 0) == 31 ? 0 : 25 - (e3 >>> 1) | 0);
                while (1) {
                  d2 = a2 + 16 + (e3 >>> 31 << 2) | 0;
                  c4 = b[d2 >> 2] | 0;
                  if (!c4) {
                    break;
                  }
                  if ((b[c4 + 4 >> 2] & -8 | 0) == (f2 | 0)) {
                    a2 = c4;
                    break b;
                  } else {
                    e3 = e3 << 1;
                    a2 = c4;
                  }
                }
                b[d2 >> 2] = i;
                b[i + 24 >> 2] = a2;
                b[i + 12 >> 2] = i;
                b[i + 8 >> 2] = i;
                break a;
              }
            } while (0);
            h = a2 + 8 | 0;
            j = b[h >> 2] | 0;
            b[j + 12 >> 2] = i;
            b[h >> 2] = i;
            b[i + 8 >> 2] = j;
            b[i + 12 >> 2] = a2;
            b[i + 24 >> 2] = 0;
          }
        } while (0);
        j = (b[6985] | 0) + -1 | 0;
        b[6985] = j;
        if (j | 0) {
          return;
        }
        a2 = 28364;
        while (1) {
          a2 = b[a2 >> 2] | 0;
          if (!a2) {
            break;
          } else {
            a2 = a2 + 8 | 0;
          }
        }
        b[6985] = -1;
        return;
      }
      function Fd(a2, c4) {
        a2 = a2 | 0;
        c4 = c4 | 0;
        var d2 = 0;
        if (a2) {
          d2 = B4(c4, a2) | 0;
          if ((c4 | a2) >>> 0 > 65535) {
            d2 = ((d2 >>> 0) / (a2 >>> 0) | 0 | 0) == (c4 | 0) ? d2 : -1;
          }
        } else {
          d2 = 0;
        }
        a2 = Dd(d2) | 0;
        if (!a2) {
          return a2 | 0;
        }
        if (!(b[a2 + -4 >> 2] & 3)) {
          return a2 | 0;
        }
        Xd(a2 | 0, 0, d2 | 0) | 0;
        return a2 | 0;
      }
      function Gd(a2, b2, c4, d2) {
        a2 = a2 | 0;
        b2 = b2 | 0;
        c4 = c4 | 0;
        d2 = d2 | 0;
        c4 = a2 + c4 >>> 0;
        return (G(b2 + d2 + (c4 >>> 0 < a2 >>> 0 | 0) >>> 0 | 0), c4 | 0) | 0;
      }
      function Hd(a2, b2, c4, d2) {
        a2 = a2 | 0;
        b2 = b2 | 0;
        c4 = c4 | 0;
        d2 = d2 | 0;
        d2 = b2 - d2 - (c4 >>> 0 > a2 >>> 0 | 0) >>> 0;
        return (G(d2 | 0), a2 - c4 >>> 0 | 0) | 0;
      }
      function Id(a2) {
        a2 = a2 | 0;
        return (a2 ? 31 - (E2(a2 ^ a2 - 1) | 0) | 0 : 32) | 0;
      }
      function Jd(a2, c4, d2, e3, f2) {
        a2 = a2 | 0;
        c4 = c4 | 0;
        d2 = d2 | 0;
        e3 = e3 | 0;
        f2 = f2 | 0;
        var g2 = 0, h = 0, i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, o = 0, p2 = 0;
        l = a2;
        j = c4;
        k = j;
        h = d2;
        n = e3;
        i = n;
        if (!k) {
          g2 = (f2 | 0) != 0;
          if (!i) {
            if (g2) {
              b[f2 >> 2] = (l >>> 0) % (h >>> 0);
              b[f2 + 4 >> 2] = 0;
            }
            n = 0;
            f2 = (l >>> 0) / (h >>> 0) >>> 0;
            return (G(n | 0), f2) | 0;
          } else {
            if (!g2) {
              n = 0;
              f2 = 0;
              return (G(n | 0), f2) | 0;
            }
            b[f2 >> 2] = a2 | 0;
            b[f2 + 4 >> 2] = c4 & 0;
            n = 0;
            f2 = 0;
            return (G(n | 0), f2) | 0;
          }
        }
        g2 = (i | 0) == 0;
        do {
          if (h) {
            if (!g2) {
              g2 = (E2(i | 0) | 0) - (E2(k | 0) | 0) | 0;
              if (g2 >>> 0 <= 31) {
                m = g2 + 1 | 0;
                i = 31 - g2 | 0;
                c4 = g2 - 31 >> 31;
                h = m;
                a2 = l >>> (m >>> 0) & c4 | k << i;
                c4 = k >>> (m >>> 0) & c4;
                g2 = 0;
                i = l << i;
                break;
              }
              if (!f2) {
                n = 0;
                f2 = 0;
                return (G(n | 0), f2) | 0;
              }
              b[f2 >> 2] = a2 | 0;
              b[f2 + 4 >> 2] = j | c4 & 0;
              n = 0;
              f2 = 0;
              return (G(n | 0), f2) | 0;
            }
            g2 = h - 1 | 0;
            if (g2 & h | 0) {
              i = (E2(h | 0) | 0) + 33 - (E2(k | 0) | 0) | 0;
              p2 = 64 - i | 0;
              m = 32 - i | 0;
              j = m >> 31;
              o = i - 32 | 0;
              c4 = o >> 31;
              h = i;
              a2 = m - 1 >> 31 & k >>> (o >>> 0) | (k << m | l >>> (i >>> 0)) & c4;
              c4 = c4 & k >>> (i >>> 0);
              g2 = l << p2 & j;
              i = (k << p2 | l >>> (o >>> 0)) & j | l << m & i - 33 >> 31;
              break;
            }
            if (f2 | 0) {
              b[f2 >> 2] = g2 & l;
              b[f2 + 4 >> 2] = 0;
            }
            if ((h | 0) == 1) {
              o = j | c4 & 0;
              p2 = a2 | 0 | 0;
              return (G(o | 0), p2) | 0;
            } else {
              p2 = Id(h | 0) | 0;
              o = k >>> (p2 >>> 0) | 0;
              p2 = k << 32 - p2 | l >>> (p2 >>> 0) | 0;
              return (G(o | 0), p2) | 0;
            }
          } else {
            if (g2) {
              if (f2 | 0) {
                b[f2 >> 2] = (k >>> 0) % (h >>> 0);
                b[f2 + 4 >> 2] = 0;
              }
              o = 0;
              p2 = (k >>> 0) / (h >>> 0) >>> 0;
              return (G(o | 0), p2) | 0;
            }
            if (!l) {
              if (f2 | 0) {
                b[f2 >> 2] = 0;
                b[f2 + 4 >> 2] = (k >>> 0) % (i >>> 0);
              }
              o = 0;
              p2 = (k >>> 0) / (i >>> 0) >>> 0;
              return (G(o | 0), p2) | 0;
            }
            g2 = i - 1 | 0;
            if (!(g2 & i)) {
              if (f2 | 0) {
                b[f2 >> 2] = a2 | 0;
                b[f2 + 4 >> 2] = g2 & k | c4 & 0;
              }
              o = 0;
              p2 = k >>> ((Id(i | 0) | 0) >>> 0);
              return (G(o | 0), p2) | 0;
            }
            g2 = (E2(i | 0) | 0) - (E2(k | 0) | 0) | 0;
            if (g2 >>> 0 <= 30) {
              c4 = g2 + 1 | 0;
              i = 31 - g2 | 0;
              h = c4;
              a2 = k << i | l >>> (c4 >>> 0);
              c4 = k >>> (c4 >>> 0);
              g2 = 0;
              i = l << i;
              break;
            }
            if (!f2) {
              o = 0;
              p2 = 0;
              return (G(o | 0), p2) | 0;
            }
            b[f2 >> 2] = a2 | 0;
            b[f2 + 4 >> 2] = j | c4 & 0;
            o = 0;
            p2 = 0;
            return (G(o | 0), p2) | 0;
          }
        } while (0);
        if (!h) {
          k = i;
          j = 0;
          i = 0;
        } else {
          m = d2 | 0 | 0;
          l = n | e3 & 0;
          k = Gd(m | 0, l | 0, -1, -1) | 0;
          d2 = H() | 0;
          j = i;
          i = 0;
          do {
            e3 = j;
            j = g2 >>> 31 | j << 1;
            g2 = i | g2 << 1;
            e3 = a2 << 1 | e3 >>> 31 | 0;
            n = a2 >>> 31 | c4 << 1 | 0;
            Hd(k | 0, d2 | 0, e3 | 0, n | 0) | 0;
            p2 = H() | 0;
            o = p2 >> 31 | ((p2 | 0) < 0 ? -1 : 0) << 1;
            i = o & 1;
            a2 = Hd(e3 | 0, n | 0, o & m | 0, (((p2 | 0) < 0 ? -1 : 0) >> 31 | ((p2 | 0) < 0 ? -1 : 0) << 1) & l | 0) | 0;
            c4 = H() | 0;
            h = h - 1 | 0;
          } while ((h | 0) != 0);
          k = j;
          j = 0;
        }
        h = 0;
        if (f2 | 0) {
          b[f2 >> 2] = a2;
          b[f2 + 4 >> 2] = c4;
        }
        o = (g2 | 0) >>> 31 | (k | h) << 1 | (h << 1 | g2 >>> 31) & 0 | j;
        p2 = (g2 << 1 | 0 >>> 31) & -2 | i;
        return (G(o | 0), p2) | 0;
      }
      function Kd(a2, b2, c4, d2) {
        a2 = a2 | 0;
        b2 = b2 | 0;
        c4 = c4 | 0;
        d2 = d2 | 0;
        var e3 = 0, f2 = 0, g2 = 0, h = 0, i = 0, j = 0;
        j = b2 >> 31 | ((b2 | 0) < 0 ? -1 : 0) << 1;
        i = ((b2 | 0) < 0 ? -1 : 0) >> 31 | ((b2 | 0) < 0 ? -1 : 0) << 1;
        f2 = d2 >> 31 | ((d2 | 0) < 0 ? -1 : 0) << 1;
        e3 = ((d2 | 0) < 0 ? -1 : 0) >> 31 | ((d2 | 0) < 0 ? -1 : 0) << 1;
        h = Hd(j ^ a2 | 0, i ^ b2 | 0, j | 0, i | 0) | 0;
        g2 = H() | 0;
        a2 = f2 ^ j;
        b2 = e3 ^ i;
        return Hd((Jd(h, g2, Hd(f2 ^ c4 | 0, e3 ^ d2 | 0, f2 | 0, e3 | 0) | 0, H() | 0, 0) | 0) ^ a2 | 0, (H() | 0) ^ b2 | 0, a2 | 0, b2 | 0) | 0;
      }
      function Ld(a2, b2) {
        a2 = a2 | 0;
        b2 = b2 | 0;
        var c4 = 0, d2 = 0, e3 = 0, f2 = 0;
        f2 = a2 & 65535;
        e3 = b2 & 65535;
        c4 = B4(e3, f2) | 0;
        d2 = a2 >>> 16;
        a2 = (c4 >>> 16) + (B4(e3, d2) | 0) | 0;
        e3 = b2 >>> 16;
        b2 = B4(e3, f2) | 0;
        return (G((a2 >>> 16) + (B4(e3, d2) | 0) + (((a2 & 65535) + b2 | 0) >>> 16) | 0), a2 + b2 << 16 | c4 & 65535 | 0) | 0;
      }
      function Md(a2, b2, c4, d2) {
        a2 = a2 | 0;
        b2 = b2 | 0;
        c4 = c4 | 0;
        d2 = d2 | 0;
        var e3 = 0, f2 = 0;
        e3 = a2;
        f2 = c4;
        c4 = Ld(e3, f2) | 0;
        a2 = H() | 0;
        return (G((B4(b2, f2) | 0) + (B4(d2, e3) | 0) + a2 | a2 & 0 | 0), c4 | 0 | 0) | 0;
      }
      function Nd(a2, c4, d2, e3) {
        a2 = a2 | 0;
        c4 = c4 | 0;
        d2 = d2 | 0;
        e3 = e3 | 0;
        var f2 = 0, g2 = 0, h = 0, i = 0, j = 0, k = 0;
        f2 = T2;
        T2 = T2 + 16 | 0;
        i = f2 | 0;
        h = c4 >> 31 | ((c4 | 0) < 0 ? -1 : 0) << 1;
        g2 = ((c4 | 0) < 0 ? -1 : 0) >> 31 | ((c4 | 0) < 0 ? -1 : 0) << 1;
        k = e3 >> 31 | ((e3 | 0) < 0 ? -1 : 0) << 1;
        j = ((e3 | 0) < 0 ? -1 : 0) >> 31 | ((e3 | 0) < 0 ? -1 : 0) << 1;
        a2 = Hd(h ^ a2 | 0, g2 ^ c4 | 0, h | 0, g2 | 0) | 0;
        c4 = H() | 0;
        Jd(a2, c4, Hd(k ^ d2 | 0, j ^ e3 | 0, k | 0, j | 0) | 0, H() | 0, i) | 0;
        e3 = Hd(b[i >> 2] ^ h | 0, b[i + 4 >> 2] ^ g2 | 0, h | 0, g2 | 0) | 0;
        d2 = H() | 0;
        T2 = f2;
        return (G(d2 | 0), e3) | 0;
      }
      function Od(a2, c4, d2, e3) {
        a2 = a2 | 0;
        c4 = c4 | 0;
        d2 = d2 | 0;
        e3 = e3 | 0;
        var f2 = 0, g2 = 0;
        g2 = T2;
        T2 = T2 + 16 | 0;
        f2 = g2 | 0;
        Jd(a2, c4, d2, e3, f2) | 0;
        T2 = g2;
        return (G(b[f2 + 4 >> 2] | 0), b[f2 >> 2] | 0) | 0;
      }
      function Pd(a2, b2, c4) {
        a2 = a2 | 0;
        b2 = b2 | 0;
        c4 = c4 | 0;
        if ((c4 | 0) < 32) {
          G(b2 >> c4 | 0);
          return a2 >>> c4 | (b2 & (1 << c4) - 1) << 32 - c4;
        }
        G(((b2 | 0) < 0 ? -1 : 0) | 0);
        return b2 >> c4 - 32 | 0;
      }
      function Qd(a2, b2, c4) {
        a2 = a2 | 0;
        b2 = b2 | 0;
        c4 = c4 | 0;
        if ((c4 | 0) < 32) {
          G(b2 >>> c4 | 0);
          return a2 >>> c4 | (b2 & (1 << c4) - 1) << 32 - c4;
        }
        G(0);
        return b2 >>> c4 - 32 | 0;
      }
      function Rd(a2, b2, c4) {
        a2 = a2 | 0;
        b2 = b2 | 0;
        c4 = c4 | 0;
        if ((c4 | 0) < 32) {
          G(b2 << c4 | (a2 & (1 << c4) - 1 << 32 - c4) >>> 32 - c4 | 0);
          return a2 << c4;
        }
        G(a2 << c4 - 32 | 0);
        return 0;
      }
      function Sd(a2, b2, c4) {
        a2 = a2 | 0;
        b2 = b2 | 0;
        c4 = c4 | 0;
        b2 = E2(b2) | 0;
        if ((b2 | 0) == 32) {
          b2 = b2 + (E2(a2) | 0) | 0;
        }
        G(0);
        return b2 | 0;
      }
      function Td(a2, b2) {
        a2 = +a2;
        b2 = +b2;
        if (a2 != a2) {
          return +b2;
        }
        if (b2 != b2) {
          return +a2;
        }
        return +D3(+a2, +b2);
      }
      function Ud(a2, b2) {
        a2 = +a2;
        b2 = +b2;
        if (a2 != a2) {
          return +b2;
        }
        if (b2 != b2) {
          return +a2;
        }
        return +C3(+a2, +b2);
      }
      function Vd(a2) {
        a2 = +a2;
        return a2 >= 0 ? +p(a2 + 0.5) : +A5(a2 - 0.5);
      }
      function Wd(c4, d2, e3) {
        c4 = c4 | 0;
        d2 = d2 | 0;
        e3 = e3 | 0;
        var f2 = 0, g2 = 0, h = 0;
        if ((e3 | 0) >= 8192) {
          L(c4 | 0, d2 | 0, e3 | 0) | 0;
          return c4 | 0;
        }
        h = c4 | 0;
        g2 = c4 + e3 | 0;
        if ((c4 & 3) == (d2 & 3)) {
          while (c4 & 3) {
            if (!e3) {
              return h | 0;
            }
            a[c4 >> 0] = a[d2 >> 0] | 0;
            c4 = c4 + 1 | 0;
            d2 = d2 + 1 | 0;
            e3 = e3 - 1 | 0;
          }
          e3 = g2 & -4 | 0;
          f2 = e3 - 64 | 0;
          while ((c4 | 0) <= (f2 | 0)) {
            b[c4 >> 2] = b[d2 >> 2];
            b[c4 + 4 >> 2] = b[d2 + 4 >> 2];
            b[c4 + 8 >> 2] = b[d2 + 8 >> 2];
            b[c4 + 12 >> 2] = b[d2 + 12 >> 2];
            b[c4 + 16 >> 2] = b[d2 + 16 >> 2];
            b[c4 + 20 >> 2] = b[d2 + 20 >> 2];
            b[c4 + 24 >> 2] = b[d2 + 24 >> 2];
            b[c4 + 28 >> 2] = b[d2 + 28 >> 2];
            b[c4 + 32 >> 2] = b[d2 + 32 >> 2];
            b[c4 + 36 >> 2] = b[d2 + 36 >> 2];
            b[c4 + 40 >> 2] = b[d2 + 40 >> 2];
            b[c4 + 44 >> 2] = b[d2 + 44 >> 2];
            b[c4 + 48 >> 2] = b[d2 + 48 >> 2];
            b[c4 + 52 >> 2] = b[d2 + 52 >> 2];
            b[c4 + 56 >> 2] = b[d2 + 56 >> 2];
            b[c4 + 60 >> 2] = b[d2 + 60 >> 2];
            c4 = c4 + 64 | 0;
            d2 = d2 + 64 | 0;
          }
          while ((c4 | 0) < (e3 | 0)) {
            b[c4 >> 2] = b[d2 >> 2];
            c4 = c4 + 4 | 0;
            d2 = d2 + 4 | 0;
          }
        } else {
          e3 = g2 - 4 | 0;
          while ((c4 | 0) < (e3 | 0)) {
            a[c4 >> 0] = a[d2 >> 0] | 0;
            a[c4 + 1 >> 0] = a[d2 + 1 >> 0] | 0;
            a[c4 + 2 >> 0] = a[d2 + 2 >> 0] | 0;
            a[c4 + 3 >> 0] = a[d2 + 3 >> 0] | 0;
            c4 = c4 + 4 | 0;
            d2 = d2 + 4 | 0;
          }
        }
        while ((c4 | 0) < (g2 | 0)) {
          a[c4 >> 0] = a[d2 >> 0] | 0;
          c4 = c4 + 1 | 0;
          d2 = d2 + 1 | 0;
        }
        return h | 0;
      }
      function Xd(c4, d2, e3) {
        c4 = c4 | 0;
        d2 = d2 | 0;
        e3 = e3 | 0;
        var f2 = 0, g2 = 0, h = 0, i = 0;
        h = c4 + e3 | 0;
        d2 = d2 & 255;
        if ((e3 | 0) >= 67) {
          while (c4 & 3) {
            a[c4 >> 0] = d2;
            c4 = c4 + 1 | 0;
          }
          f2 = h & -4 | 0;
          i = d2 | d2 << 8 | d2 << 16 | d2 << 24;
          g2 = f2 - 64 | 0;
          while ((c4 | 0) <= (g2 | 0)) {
            b[c4 >> 2] = i;
            b[c4 + 4 >> 2] = i;
            b[c4 + 8 >> 2] = i;
            b[c4 + 12 >> 2] = i;
            b[c4 + 16 >> 2] = i;
            b[c4 + 20 >> 2] = i;
            b[c4 + 24 >> 2] = i;
            b[c4 + 28 >> 2] = i;
            b[c4 + 32 >> 2] = i;
            b[c4 + 36 >> 2] = i;
            b[c4 + 40 >> 2] = i;
            b[c4 + 44 >> 2] = i;
            b[c4 + 48 >> 2] = i;
            b[c4 + 52 >> 2] = i;
            b[c4 + 56 >> 2] = i;
            b[c4 + 60 >> 2] = i;
            c4 = c4 + 64 | 0;
          }
          while ((c4 | 0) < (f2 | 0)) {
            b[c4 >> 2] = i;
            c4 = c4 + 4 | 0;
          }
        }
        while ((c4 | 0) < (h | 0)) {
          a[c4 >> 0] = d2;
          c4 = c4 + 1 | 0;
        }
        return h - e3 | 0;
      }
      function Yd(a2) {
        a2 = +a2;
        return a2 >= 0 ? +p(a2 + 0.5) : +A5(a2 - 0.5);
      }
      function Zd(a2) {
        a2 = a2 | 0;
        var c4 = 0, d2 = 0, e3 = 0;
        e3 = K2() | 0;
        d2 = b[g >> 2] | 0;
        c4 = d2 + a2 | 0;
        if ((a2 | 0) > 0 & (c4 | 0) < (d2 | 0) | (c4 | 0) < 0) {
          N2(c4 | 0) | 0;
          J(12);
          return -1;
        }
        if ((c4 | 0) > (e3 | 0)) {
          if (!(M2(c4 | 0) | 0)) {
            J(12);
            return -1;
          }
        }
        b[g >> 2] = c4;
        return d2 | 0;
      }
      return {
        ___divdi3: Kd,
        ___muldi3: Md,
        ___remdi3: Nd,
        ___uremdi3: Od,
        _areNeighborCells: ib,
        _bitshift64Ashr: Pd,
        _bitshift64Lshr: Qd,
        _bitshift64Shl: Rd,
        _calloc: Fd,
        _cellAreaKm2: xc,
        _cellAreaM2: yc,
        _cellAreaRads2: wc,
        _cellToBoundary: _b2,
        _cellToCenterChild: Kb,
        _cellToChildPos: dc,
        _cellToChildren: Ib,
        _cellToChildrenSize: Gb,
        _cellToLatLng: Zb,
        _cellToLocalIj: Jc,
        _cellToParent: Fb,
        _cellToVertex: qd,
        _cellToVertexes: rd,
        _cellsToDirectedEdge: jb,
        _cellsToLinkedMultiPolygon: na,
        _childPosToCell: ec,
        _compactCells: Lb,
        _destroyLinkedMultiPolygon: Ec,
        _directedEdgeToBoundary: pb,
        _directedEdgeToCells: nb,
        _edgeLengthKm: Ac,
        _edgeLengthM: Bc,
        _edgeLengthRads: zc,
        _emscripten_replace_memory: W,
        _free: Ed,
        _getBaseCellNumber: Cb,
        _getDirectedEdgeDestination: lb,
        _getDirectedEdgeOrigin: kb,
        _getHexagonAreaAvgKm2: qc,
        _getHexagonAreaAvgM2: rc,
        _getHexagonEdgeLengthAvgKm: sc,
        _getHexagonEdgeLengthAvgM: tc,
        _getIcosahedronFaces: ac2,
        _getNumCells: uc,
        _getPentagons: cc2,
        _getRes0Cells: ya,
        _getResolution: Bb,
        _greatCircleDistanceKm: mc,
        _greatCircleDistanceM: nc,
        _greatCircleDistanceRads: lc,
        _gridDisk: aa2,
        _gridDiskDistances: ba,
        _gridDistance: Lc,
        _gridPathCells: Nc,
        _gridPathCellsSize: Mc,
        _gridRing: fa,
        _gridRingUnsafe: ga,
        _i64Add: Gd,
        _i64Subtract: Hd,
        _isPentagon: Hb,
        _isResClassIII: Ob,
        _isValidCell: Db,
        _isValidDirectedEdge: mb,
        _isValidVertex: td,
        _latLngToCell: Wb,
        _llvm_ctlz_i64: Sd,
        _llvm_maxnum_f64: Td,
        _llvm_minnum_f64: Ud,
        _llvm_round_f64: Vd,
        _localIjToCell: Kc,
        _malloc: Dd,
        _maxFaceCount: $b,
        _maxGridDiskSize: $,
        _maxPolygonToCellsSize: ja,
        _maxPolygonToCellsSizeExperimental: Uc,
        _memcpy: Wd,
        _memset: Xd,
        _originToDirectedEdges: ob,
        _pentagonCount: bc4,
        _polygonToCells: la,
        _polygonToCellsExperimental: Tc,
        _readInt64AsDoubleFromPointer: id,
        _res0CellCount: xa,
        _round: Yd,
        _sbrk: Zd,
        _sizeOfCellBoundary: dd,
        _sizeOfCoordIJ: hd,
        _sizeOfGeoLoop: ed,
        _sizeOfGeoPolygon: fd,
        _sizeOfH3Index: bd2,
        _sizeOfLatLng: cd2,
        _sizeOfLinkedGeoPolygon: gd,
        _uncompactCells: Mb,
        _uncompactCellsSize: Nb,
        _vertexToLatLng: sd,
        establishStackSpace: _,
        stackAlloc: X,
        stackRestore: Z,
        stackSave: Y
      };
    }(asmGlobalArg, asmLibraryArg, buffer3)
  );
  var ___divdi3 = Module["___divdi3"] = asm["___divdi3"];
  var ___muldi3 = Module["___muldi3"] = asm["___muldi3"];
  var ___remdi3 = Module["___remdi3"] = asm["___remdi3"];
  var ___uremdi3 = Module["___uremdi3"] = asm["___uremdi3"];
  var _areNeighborCells = Module["_areNeighborCells"] = asm["_areNeighborCells"];
  var _bitshift64Ashr = Module["_bitshift64Ashr"] = asm["_bitshift64Ashr"];
  var _bitshift64Lshr = Module["_bitshift64Lshr"] = asm["_bitshift64Lshr"];
  var _bitshift64Shl = Module["_bitshift64Shl"] = asm["_bitshift64Shl"];
  var _calloc = Module["_calloc"] = asm["_calloc"];
  var _cellAreaKm2 = Module["_cellAreaKm2"] = asm["_cellAreaKm2"];
  var _cellAreaM2 = Module["_cellAreaM2"] = asm["_cellAreaM2"];
  var _cellAreaRads2 = Module["_cellAreaRads2"] = asm["_cellAreaRads2"];
  var _cellToBoundary = Module["_cellToBoundary"] = asm["_cellToBoundary"];
  var _cellToCenterChild = Module["_cellToCenterChild"] = asm["_cellToCenterChild"];
  var _cellToChildPos = Module["_cellToChildPos"] = asm["_cellToChildPos"];
  var _cellToChildren = Module["_cellToChildren"] = asm["_cellToChildren"];
  var _cellToChildrenSize = Module["_cellToChildrenSize"] = asm["_cellToChildrenSize"];
  var _cellToLatLng = Module["_cellToLatLng"] = asm["_cellToLatLng"];
  var _cellToLocalIj = Module["_cellToLocalIj"] = asm["_cellToLocalIj"];
  var _cellToParent = Module["_cellToParent"] = asm["_cellToParent"];
  var _cellToVertex = Module["_cellToVertex"] = asm["_cellToVertex"];
  var _cellToVertexes = Module["_cellToVertexes"] = asm["_cellToVertexes"];
  var _cellsToDirectedEdge = Module["_cellsToDirectedEdge"] = asm["_cellsToDirectedEdge"];
  var _cellsToLinkedMultiPolygon = Module["_cellsToLinkedMultiPolygon"] = asm["_cellsToLinkedMultiPolygon"];
  var _childPosToCell = Module["_childPosToCell"] = asm["_childPosToCell"];
  var _compactCells = Module["_compactCells"] = asm["_compactCells"];
  var _destroyLinkedMultiPolygon = Module["_destroyLinkedMultiPolygon"] = asm["_destroyLinkedMultiPolygon"];
  var _directedEdgeToBoundary = Module["_directedEdgeToBoundary"] = asm["_directedEdgeToBoundary"];
  var _directedEdgeToCells = Module["_directedEdgeToCells"] = asm["_directedEdgeToCells"];
  var _edgeLengthKm = Module["_edgeLengthKm"] = asm["_edgeLengthKm"];
  var _edgeLengthM = Module["_edgeLengthM"] = asm["_edgeLengthM"];
  var _edgeLengthRads = Module["_edgeLengthRads"] = asm["_edgeLengthRads"];
  var _emscripten_replace_memory = Module["_emscripten_replace_memory"] = asm["_emscripten_replace_memory"];
  var _free = Module["_free"] = asm["_free"];
  var _getBaseCellNumber = Module["_getBaseCellNumber"] = asm["_getBaseCellNumber"];
  var _getDirectedEdgeDestination = Module["_getDirectedEdgeDestination"] = asm["_getDirectedEdgeDestination"];
  var _getDirectedEdgeOrigin = Module["_getDirectedEdgeOrigin"] = asm["_getDirectedEdgeOrigin"];
  var _getHexagonAreaAvgKm2 = Module["_getHexagonAreaAvgKm2"] = asm["_getHexagonAreaAvgKm2"];
  var _getHexagonAreaAvgM2 = Module["_getHexagonAreaAvgM2"] = asm["_getHexagonAreaAvgM2"];
  var _getHexagonEdgeLengthAvgKm = Module["_getHexagonEdgeLengthAvgKm"] = asm["_getHexagonEdgeLengthAvgKm"];
  var _getHexagonEdgeLengthAvgM = Module["_getHexagonEdgeLengthAvgM"] = asm["_getHexagonEdgeLengthAvgM"];
  var _getIcosahedronFaces = Module["_getIcosahedronFaces"] = asm["_getIcosahedronFaces"];
  var _getNumCells = Module["_getNumCells"] = asm["_getNumCells"];
  var _getPentagons = Module["_getPentagons"] = asm["_getPentagons"];
  var _getRes0Cells = Module["_getRes0Cells"] = asm["_getRes0Cells"];
  var _getResolution = Module["_getResolution"] = asm["_getResolution"];
  var _greatCircleDistanceKm = Module["_greatCircleDistanceKm"] = asm["_greatCircleDistanceKm"];
  var _greatCircleDistanceM = Module["_greatCircleDistanceM"] = asm["_greatCircleDistanceM"];
  var _greatCircleDistanceRads = Module["_greatCircleDistanceRads"] = asm["_greatCircleDistanceRads"];
  var _gridDisk = Module["_gridDisk"] = asm["_gridDisk"];
  var _gridDiskDistances = Module["_gridDiskDistances"] = asm["_gridDiskDistances"];
  var _gridDistance = Module["_gridDistance"] = asm["_gridDistance"];
  var _gridPathCells = Module["_gridPathCells"] = asm["_gridPathCells"];
  var _gridPathCellsSize = Module["_gridPathCellsSize"] = asm["_gridPathCellsSize"];
  var _gridRing = Module["_gridRing"] = asm["_gridRing"];
  var _gridRingUnsafe = Module["_gridRingUnsafe"] = asm["_gridRingUnsafe"];
  var _i64Add = Module["_i64Add"] = asm["_i64Add"];
  var _i64Subtract = Module["_i64Subtract"] = asm["_i64Subtract"];
  var _isPentagon = Module["_isPentagon"] = asm["_isPentagon"];
  var _isResClassIII = Module["_isResClassIII"] = asm["_isResClassIII"];
  var _isValidCell = Module["_isValidCell"] = asm["_isValidCell"];
  var _isValidDirectedEdge = Module["_isValidDirectedEdge"] = asm["_isValidDirectedEdge"];
  var _isValidVertex = Module["_isValidVertex"] = asm["_isValidVertex"];
  var _latLngToCell = Module["_latLngToCell"] = asm["_latLngToCell"];
  var _llvm_ctlz_i64 = Module["_llvm_ctlz_i64"] = asm["_llvm_ctlz_i64"];
  var _llvm_maxnum_f64 = Module["_llvm_maxnum_f64"] = asm["_llvm_maxnum_f64"];
  var _llvm_minnum_f64 = Module["_llvm_minnum_f64"] = asm["_llvm_minnum_f64"];
  var _llvm_round_f64 = Module["_llvm_round_f64"] = asm["_llvm_round_f64"];
  var _localIjToCell = Module["_localIjToCell"] = asm["_localIjToCell"];
  var _malloc = Module["_malloc"] = asm["_malloc"];
  var _maxFaceCount = Module["_maxFaceCount"] = asm["_maxFaceCount"];
  var _maxGridDiskSize = Module["_maxGridDiskSize"] = asm["_maxGridDiskSize"];
  var _maxPolygonToCellsSize = Module["_maxPolygonToCellsSize"] = asm["_maxPolygonToCellsSize"];
  var _maxPolygonToCellsSizeExperimental = Module["_maxPolygonToCellsSizeExperimental"] = asm["_maxPolygonToCellsSizeExperimental"];
  var _memcpy = Module["_memcpy"] = asm["_memcpy"];
  var _memset = Module["_memset"] = asm["_memset"];
  var _originToDirectedEdges = Module["_originToDirectedEdges"] = asm["_originToDirectedEdges"];
  var _pentagonCount = Module["_pentagonCount"] = asm["_pentagonCount"];
  var _polygonToCells = Module["_polygonToCells"] = asm["_polygonToCells"];
  var _polygonToCellsExperimental = Module["_polygonToCellsExperimental"] = asm["_polygonToCellsExperimental"];
  var _readInt64AsDoubleFromPointer = Module["_readInt64AsDoubleFromPointer"] = asm["_readInt64AsDoubleFromPointer"];
  var _res0CellCount = Module["_res0CellCount"] = asm["_res0CellCount"];
  var _round = Module["_round"] = asm["_round"];
  var _sbrk = Module["_sbrk"] = asm["_sbrk"];
  var _sizeOfCellBoundary = Module["_sizeOfCellBoundary"] = asm["_sizeOfCellBoundary"];
  var _sizeOfCoordIJ = Module["_sizeOfCoordIJ"] = asm["_sizeOfCoordIJ"];
  var _sizeOfGeoLoop = Module["_sizeOfGeoLoop"] = asm["_sizeOfGeoLoop"];
  var _sizeOfGeoPolygon = Module["_sizeOfGeoPolygon"] = asm["_sizeOfGeoPolygon"];
  var _sizeOfH3Index = Module["_sizeOfH3Index"] = asm["_sizeOfH3Index"];
  var _sizeOfLatLng = Module["_sizeOfLatLng"] = asm["_sizeOfLatLng"];
  var _sizeOfLinkedGeoPolygon = Module["_sizeOfLinkedGeoPolygon"] = asm["_sizeOfLinkedGeoPolygon"];
  var _uncompactCells = Module["_uncompactCells"] = asm["_uncompactCells"];
  var _uncompactCellsSize = Module["_uncompactCellsSize"] = asm["_uncompactCellsSize"];
  var _vertexToLatLng = Module["_vertexToLatLng"] = asm["_vertexToLatLng"];
  var establishStackSpace = Module["establishStackSpace"] = asm["establishStackSpace"];
  var stackAlloc = Module["stackAlloc"] = asm["stackAlloc"];
  var stackRestore = Module["stackRestore"] = asm["stackRestore"];
  var stackSave = Module["stackSave"] = asm["stackSave"];
  Module["asm"] = asm;
  Module["cwrap"] = cwrap;
  Module["setValue"] = setValue;
  Module["getValue"] = getValue;
  if (memoryInitializer) {
    if (!isDataURI(memoryInitializer)) {
      memoryInitializer = locateFile(memoryInitializer);
    }
    {
      addRunDependency("memory initializer");
      var applyMemoryInitializer = function(data) {
        if (data.byteLength) {
          data = new Uint8Array(data);
        }
        HEAPU8.set(data, GLOBAL_BASE);
        if (Module["memoryInitializerRequest"]) {
          delete Module["memoryInitializerRequest"].response;
        }
        removeRunDependency("memory initializer");
      };
      var doBrowserLoad = function() {
        readAsync(memoryInitializer, applyMemoryInitializer, function() {
          throw "could not load memory initializer " + memoryInitializer;
        });
      };
      var memoryInitializerBytes = tryParseAsDataURI(memoryInitializer);
      if (memoryInitializerBytes) {
        applyMemoryInitializer(memoryInitializerBytes.buffer);
      } else if (Module["memoryInitializerRequest"]) {
        var useRequest = function() {
          var request = Module["memoryInitializerRequest"];
          var response = request.response;
          if (request.status !== 200 && request.status !== 0) {
            var data = tryParseAsDataURI(Module["memoryInitializerRequestURL"]);
            if (data) {
              response = data.buffer;
            } else {
              console.warn("a problem seems to have happened with Module.memoryInitializerRequest, status: " + request.status + ", retrying " + memoryInitializer);
              doBrowserLoad();
              return;
            }
          }
          applyMemoryInitializer(response);
        };
        if (Module["memoryInitializerRequest"].response) {
          setTimeout(useRequest, 0);
        } else {
          Module["memoryInitializerRequest"].addEventListener("load", useRequest);
        }
      } else {
        doBrowserLoad();
      }
    }
  }
  var calledRun;
  dependenciesFulfilled = function runCaller() {
    if (!calledRun) {
      run();
    }
    if (!calledRun) {
      dependenciesFulfilled = runCaller;
    }
  };
  function run(args) {
    args = args || arguments_;
    if (runDependencies > 0) {
      return;
    }
    preRun();
    if (runDependencies > 0) {
      return;
    }
    function doRun() {
      if (calledRun) {
        return;
      }
      calledRun = true;
      if (ABORT) {
        return;
      }
      initRuntime();
      preMain();
      if (Module["onRuntimeInitialized"]) {
        Module["onRuntimeInitialized"]();
      }
      postRun();
    }
    if (Module["setStatus"]) {
      Module["setStatus"]("Running...");
      setTimeout(function() {
        setTimeout(function() {
          Module["setStatus"]("");
        }, 1);
        doRun();
      }, 1);
    } else {
      doRun();
    }
  }
  Module["run"] = run;
  function abort(what) {
    if (Module["onAbort"]) {
      Module["onAbort"](what);
    }
    what += "";
    out(what);
    err(what);
    ABORT = true;
    throw "abort(" + what + "). Build with -s ASSERTIONS=1 for more info.";
  }
  Module["abort"] = abort;
  if (Module["preInit"]) {
    if (typeof Module["preInit"] == "function") {
      Module["preInit"] = [Module["preInit"]];
    }
    while (Module["preInit"].length > 0) {
      Module["preInit"].pop()();
    }
  }
  run();
  return libh32;
}(typeof libh3 === "object" ? libh3 : {});
var NUMBER = "number";
var H3_ERROR = NUMBER;
var BOOLEAN = NUMBER;
var H3_LOWER = NUMBER;
var H3_UPPER = NUMBER;
var RESOLUTION = NUMBER;
var POINTER = NUMBER;
var BINDINGS = [
  // The size functions are inserted via build/sizes.h
  ["sizeOfH3Index", NUMBER],
  ["sizeOfLatLng", NUMBER],
  ["sizeOfCellBoundary", NUMBER],
  ["sizeOfGeoLoop", NUMBER],
  ["sizeOfGeoPolygon", NUMBER],
  ["sizeOfLinkedGeoPolygon", NUMBER],
  ["sizeOfCoordIJ", NUMBER],
  ["readInt64AsDoubleFromPointer", NUMBER],
  // The remaining functions are defined in the core lib in h3Api.h
  ["isValidCell", BOOLEAN, [H3_LOWER, H3_UPPER]],
  ["latLngToCell", H3_ERROR, [NUMBER, NUMBER, RESOLUTION, POINTER]],
  ["cellToLatLng", H3_ERROR, [H3_LOWER, H3_UPPER, POINTER]],
  ["cellToBoundary", H3_ERROR, [H3_LOWER, H3_UPPER, POINTER]],
  ["maxGridDiskSize", H3_ERROR, [NUMBER, POINTER]],
  ["gridDisk", H3_ERROR, [H3_LOWER, H3_UPPER, NUMBER, POINTER]],
  ["gridDiskDistances", H3_ERROR, [H3_LOWER, H3_UPPER, NUMBER, POINTER, POINTER]],
  ["gridRing", H3_ERROR, [H3_LOWER, H3_UPPER, NUMBER, POINTER]],
  ["gridRingUnsafe", H3_ERROR, [H3_LOWER, H3_UPPER, NUMBER, POINTER]],
  ["maxPolygonToCellsSize", H3_ERROR, [POINTER, RESOLUTION, NUMBER, POINTER]],
  ["polygonToCells", H3_ERROR, [POINTER, RESOLUTION, NUMBER, POINTER]],
  ["maxPolygonToCellsSizeExperimental", H3_ERROR, [POINTER, RESOLUTION, NUMBER, POINTER]],
  ["polygonToCellsExperimental", H3_ERROR, [POINTER, RESOLUTION, NUMBER, NUMBER, NUMBER, POINTER]],
  ["cellsToLinkedMultiPolygon", H3_ERROR, [POINTER, NUMBER, POINTER]],
  ["destroyLinkedMultiPolygon", null, [POINTER]],
  ["compactCells", H3_ERROR, [POINTER, POINTER, NUMBER, NUMBER]],
  ["uncompactCells", H3_ERROR, [POINTER, NUMBER, NUMBER, POINTER, NUMBER, RESOLUTION]],
  ["uncompactCellsSize", H3_ERROR, [POINTER, NUMBER, NUMBER, RESOLUTION, POINTER]],
  ["isPentagon", BOOLEAN, [H3_LOWER, H3_UPPER]],
  ["isResClassIII", BOOLEAN, [H3_LOWER, H3_UPPER]],
  ["getBaseCellNumber", NUMBER, [H3_LOWER, H3_UPPER]],
  ["getResolution", NUMBER, [H3_LOWER, H3_UPPER]],
  ["maxFaceCount", H3_ERROR, [H3_LOWER, H3_UPPER, POINTER]],
  ["getIcosahedronFaces", H3_ERROR, [H3_LOWER, H3_UPPER, POINTER]],
  ["cellToParent", H3_ERROR, [H3_LOWER, H3_UPPER, RESOLUTION, POINTER]],
  ["cellToChildren", H3_ERROR, [H3_LOWER, H3_UPPER, RESOLUTION, POINTER]],
  ["cellToCenterChild", H3_ERROR, [H3_LOWER, H3_UPPER, RESOLUTION, POINTER]],
  ["cellToChildrenSize", H3_ERROR, [H3_LOWER, H3_UPPER, RESOLUTION, POINTER]],
  ["cellToChildPos", H3_ERROR, [H3_LOWER, H3_UPPER, RESOLUTION, POINTER]],
  ["childPosToCell", H3_ERROR, [NUMBER, NUMBER, H3_LOWER, H3_UPPER, RESOLUTION, POINTER]],
  ["areNeighborCells", H3_ERROR, [H3_LOWER, H3_UPPER, H3_LOWER, H3_UPPER, POINTER]],
  ["cellsToDirectedEdge", H3_ERROR, [H3_LOWER, H3_UPPER, H3_LOWER, H3_UPPER, POINTER]],
  ["getDirectedEdgeOrigin", H3_ERROR, [H3_LOWER, H3_UPPER, POINTER]],
  ["getDirectedEdgeDestination", H3_ERROR, [H3_LOWER, H3_UPPER, POINTER]],
  ["isValidDirectedEdge", BOOLEAN, [H3_LOWER, H3_UPPER]],
  ["directedEdgeToCells", H3_ERROR, [H3_LOWER, H3_UPPER, POINTER]],
  ["originToDirectedEdges", H3_ERROR, [H3_LOWER, H3_UPPER, POINTER]],
  ["directedEdgeToBoundary", H3_ERROR, [H3_LOWER, H3_UPPER, POINTER]],
  ["gridDistance", H3_ERROR, [H3_LOWER, H3_UPPER, H3_LOWER, H3_UPPER, POINTER]],
  ["gridPathCells", H3_ERROR, [H3_LOWER, H3_UPPER, H3_LOWER, H3_UPPER, POINTER]],
  ["gridPathCellsSize", H3_ERROR, [H3_LOWER, H3_UPPER, H3_LOWER, H3_UPPER, POINTER]],
  ["cellToLocalIj", H3_ERROR, [H3_LOWER, H3_UPPER, H3_LOWER, H3_UPPER, NUMBER, POINTER]],
  ["localIjToCell", H3_ERROR, [H3_LOWER, H3_UPPER, POINTER, NUMBER, POINTER]],
  ["getHexagonAreaAvgM2", H3_ERROR, [RESOLUTION, POINTER]],
  ["getHexagonAreaAvgKm2", H3_ERROR, [RESOLUTION, POINTER]],
  ["getHexagonEdgeLengthAvgM", H3_ERROR, [RESOLUTION, POINTER]],
  ["getHexagonEdgeLengthAvgKm", H3_ERROR, [RESOLUTION, POINTER]],
  ["greatCircleDistanceM", NUMBER, [POINTER, POINTER]],
  ["greatCircleDistanceKm", NUMBER, [POINTER, POINTER]],
  ["greatCircleDistanceRads", NUMBER, [POINTER, POINTER]],
  ["cellAreaM2", H3_ERROR, [H3_LOWER, H3_UPPER, POINTER]],
  ["cellAreaKm2", H3_ERROR, [H3_LOWER, H3_UPPER, POINTER]],
  ["cellAreaRads2", H3_ERROR, [H3_LOWER, H3_UPPER, POINTER]],
  ["edgeLengthM", H3_ERROR, [H3_LOWER, H3_UPPER, POINTER]],
  ["edgeLengthKm", H3_ERROR, [H3_LOWER, H3_UPPER, POINTER]],
  ["edgeLengthRads", H3_ERROR, [H3_LOWER, H3_UPPER, POINTER]],
  ["getNumCells", H3_ERROR, [RESOLUTION, POINTER]],
  ["getRes0Cells", H3_ERROR, [POINTER]],
  ["res0CellCount", NUMBER],
  ["getPentagons", H3_ERROR, [NUMBER, POINTER]],
  ["pentagonCount", NUMBER],
  ["cellToVertex", H3_ERROR, [H3_LOWER, H3_UPPER, NUMBER, POINTER]],
  ["cellToVertexes", H3_ERROR, [H3_LOWER, H3_UPPER, POINTER]],
  ["vertexToLatLng", H3_ERROR, [H3_LOWER, H3_UPPER, POINTER]],
  ["isValidVertex", BOOLEAN, [H3_LOWER, H3_UPPER]]
];
var E_SUCCESS = 0;
var E_FAILED = 1;
var E_DOMAIN = 2;
var E_LATLNG_DOMAIN = 3;
var E_RES_DOMAIN = 4;
var E_CELL_INVALID = 5;
var E_DIR_EDGE_INVALID = 6;
var E_UNDIR_EDGE_INVALID = 7;
var E_VERTEX_INVALID = 8;
var E_PENTAGON = 9;
var E_DUPLICATE_INPUT = 10;
var E_NOT_NEIGHBORS = 11;
var E_RES_MISMATCH = 12;
var E_MEMORY_ALLOC = 13;
var E_MEMORY_BOUNDS = 14;
var E_OPTION_INVALID = 15;
var H3_ERROR_MSGS = {};
H3_ERROR_MSGS[E_SUCCESS] = "Success";
H3_ERROR_MSGS[E_FAILED] = "The operation failed but a more specific error is not available";
H3_ERROR_MSGS[E_DOMAIN] = "Argument was outside of acceptable range";
H3_ERROR_MSGS[E_LATLNG_DOMAIN] = "Latitude or longitude arguments were outside of acceptable range";
H3_ERROR_MSGS[E_RES_DOMAIN] = "Resolution argument was outside of acceptable range";
H3_ERROR_MSGS[E_CELL_INVALID] = "Cell argument was not valid";
H3_ERROR_MSGS[E_DIR_EDGE_INVALID] = "Directed edge argument was not valid";
H3_ERROR_MSGS[E_UNDIR_EDGE_INVALID] = "Undirected edge argument was not valid";
H3_ERROR_MSGS[E_VERTEX_INVALID] = "Vertex argument was not valid";
H3_ERROR_MSGS[E_PENTAGON] = "Pentagon distortion was encountered";
H3_ERROR_MSGS[E_DUPLICATE_INPUT] = "Duplicate input";
H3_ERROR_MSGS[E_NOT_NEIGHBORS] = "Cell arguments were not neighbors";
H3_ERROR_MSGS[E_RES_MISMATCH] = "Cell arguments had incompatible resolutions";
H3_ERROR_MSGS[E_MEMORY_ALLOC] = "Memory allocation failed";
H3_ERROR_MSGS[E_MEMORY_BOUNDS] = "Bounds of provided memory were insufficient";
H3_ERROR_MSGS[E_OPTION_INVALID] = "Mode or flags argument was not valid";
var E_UNKNOWN_UNIT = 1e3;
var E_ARRAY_LENGTH = 1001;
var E_NULL_INDEX = 1002;
var JS_ERROR_MESSAGES = {};
JS_ERROR_MESSAGES[E_UNKNOWN_UNIT] = "Unknown unit";
JS_ERROR_MESSAGES[E_ARRAY_LENGTH] = "Array length out of bounds";
JS_ERROR_MESSAGES[E_NULL_INDEX] = "Got unexpected null value for H3 index";
var UNKNOWN_ERROR_MSG = "Unknown error";
function createError(messages, errCode, meta) {
  var hasValue = meta && "value" in meta;
  var err = new Error((messages[errCode] || UNKNOWN_ERROR_MSG) + " (code: " + errCode + (hasValue ? ", value: " + meta.value : "") + ")");
  err.code = errCode;
  return err;
}
function H3LibraryError(errCode, value) {
  var meta = arguments.length === 2 ? {
    value
  } : {};
  return createError(H3_ERROR_MSGS, errCode, meta);
}
function JSBindingError(errCode, value) {
  var meta = arguments.length === 2 ? {
    value
  } : {};
  return createError(JS_ERROR_MESSAGES, errCode, meta);
}
function throwIfError(errCode) {
  if (errCode !== 0) {
    throw H3LibraryError(errCode);
  }
}
var H3 = {};
BINDINGS.forEach(function bind(def) {
  H3[def[0]] = libh3.cwrap.apply(libh3, def);
});
var BASE_16 = 16;
var SZ_INT = 4;
var SZ_DBL = 8;
var SZ_INT64 = 8;
var SZ_H3INDEX = H3.sizeOfH3Index();
var SZ_LATLNG = H3.sizeOfLatLng();
var SZ_CELLBOUNDARY = H3.sizeOfCellBoundary();
var SZ_GEOPOLYGON = H3.sizeOfGeoPolygon();
var SZ_GEOLOOP = H3.sizeOfGeoLoop();
var SZ_LINKED_GEOPOLYGON = H3.sizeOfLinkedGeoPolygon();
var SZ_COORDIJ = H3.sizeOfCoordIJ();
function validateRes(res) {
  if (typeof res !== "number" || res < 0 || res > 15 || Math.floor(res) !== res) {
    throw H3LibraryError(E_RES_DOMAIN, res);
  }
  return res;
}
function validateH3Index(h3Index) {
  if (!h3Index) {
    throw JSBindingError(E_NULL_INDEX);
  }
  return h3Index;
}
var MAX_JS_ARRAY_LENGTH = Math.pow(2, 32) - 1;
function validateArrayLength(length3) {
  if (length3 > MAX_JS_ARRAY_LENGTH) {
    throw JSBindingError(E_ARRAY_LENGTH, length3);
  }
  return length3;
}
var INVALID_HEXIDECIMAL_CHAR = /[^0-9a-fA-F]/;
function h3IndexToSplitLong(h3Index) {
  if (Array.isArray(h3Index) && h3Index.length === 2 && Number.isInteger(h3Index[0]) && Number.isInteger(h3Index[1])) {
    return h3Index;
  }
  if (typeof h3Index !== "string" || INVALID_HEXIDECIMAL_CHAR.test(h3Index)) {
    return [0, 0];
  }
  var upper = parseInt(h3Index.substring(0, h3Index.length - 8), BASE_16);
  var lower = parseInt(h3Index.substring(h3Index.length - 8), BASE_16);
  return [lower, upper];
}
function hexFrom32Bit(num) {
  if (num >= 0) {
    return num.toString(BASE_16);
  }
  num = num & 2147483647;
  var tempStr = zeroPad(8, num.toString(BASE_16));
  var topNum = (parseInt(tempStr[0], BASE_16) + 8).toString(BASE_16);
  tempStr = topNum + tempStr.substring(1);
  return tempStr;
}
function splitLongToH3Index(lower, upper) {
  return hexFrom32Bit(upper) + zeroPad(8, hexFrom32Bit(lower));
}
function zeroPad(fullLen, numStr) {
  var numZeroes = fullLen - numStr.length;
  var outStr = "";
  for (var i = 0; i < numZeroes; i++) {
    outStr += "0";
  }
  outStr = outStr + numStr;
  return outStr;
}
var UPPER_BIT_DIVISOR = Math.pow(2, 32);
function polygonArrayToGeoLoop(polygonArray, geoLoop, isGeoJson) {
  var numVerts = polygonArray.length;
  var geoCoordArray = libh3._calloc(numVerts, SZ_LATLNG);
  var latIndex = isGeoJson ? 1 : 0;
  var lngIndex = isGeoJson ? 0 : 1;
  for (var i = 0; i < numVerts * 2; i += 2) {
    libh3.HEAPF64.set([polygonArray[i / 2][latIndex], polygonArray[i / 2][lngIndex]].map(degsToRads), geoCoordArray / SZ_DBL + i);
  }
  libh3.HEAPU32.set([numVerts, geoCoordArray], geoLoop / SZ_INT);
  return geoLoop;
}
function coordinatesToGeoPolygon(coordinates2, isGeoJson) {
  var numHoles = coordinates2.length - 1;
  var geoPolygon = libh3._calloc(SZ_GEOPOLYGON);
  var geoLoopOffset = 0;
  var numHolesOffset = geoLoopOffset + SZ_GEOLOOP;
  var holesOffset = numHolesOffset + SZ_INT;
  polygonArrayToGeoLoop(coordinates2[0], geoPolygon + geoLoopOffset, isGeoJson);
  var holes;
  if (numHoles > 0) {
    holes = libh3._calloc(numHoles, SZ_GEOLOOP);
    for (var i = 0; i < numHoles; i++) {
      polygonArrayToGeoLoop(coordinates2[i + 1], holes + SZ_GEOLOOP * i, isGeoJson);
    }
  }
  libh3.setValue(geoPolygon + numHolesOffset, numHoles, "i32");
  libh3.setValue(geoPolygon + holesOffset, holes, "i32");
  return geoPolygon;
}
function destroyGeoPolygon(geoPolygon) {
  var geoLoopOffset = 0;
  var numHolesOffset = geoLoopOffset + SZ_GEOLOOP;
  var holesOffset = numHolesOffset + SZ_INT;
  var geoLoopArrayOffset = SZ_INT;
  libh3._free(libh3.getValue(geoPolygon + geoLoopOffset + geoLoopArrayOffset, "i8*"));
  var numHoles = libh3.getValue(geoPolygon + numHolesOffset, "i32");
  if (numHoles > 0) {
    var holes = libh3.getValue(geoPolygon + holesOffset, "i32");
    for (var i = 0; i < numHoles; i++) {
      libh3._free(libh3.getValue(holes + SZ_GEOLOOP * i + geoLoopArrayOffset, "i8*"));
    }
    libh3._free(holes);
  }
  libh3._free(geoPolygon);
}
function readH3IndexFromPointer(cAddress, offset) {
  if (offset === void 0) offset = 0;
  var lower = libh3.getValue(cAddress + SZ_H3INDEX * offset, "i32");
  var upper = libh3.getValue(cAddress + SZ_H3INDEX * offset + SZ_INT, "i32");
  return upper ? splitLongToH3Index(lower, upper) : null;
}
function readInt64AsDoubleFromPointer(cAddress) {
  return H3.readInt64AsDoubleFromPointer(cAddress);
}
function readArrayOfH3Indexes(cAddress, maxCount) {
  var out = [];
  for (var i = 0; i < maxCount; i++) {
    var h3Index = readH3IndexFromPointer(cAddress, i);
    if (h3Index !== null) {
      out.push(h3Index);
    }
  }
  return out;
}
function readSingleCoord(cAddress) {
  return radsToDegs(libh3.getValue(cAddress, "double"));
}
function readLatLng(cAddress) {
  return [readSingleCoord(cAddress), readSingleCoord(cAddress + SZ_DBL)];
}
function readLatLngGeoJson(cAddress) {
  return [readSingleCoord(cAddress + SZ_DBL), readSingleCoord(cAddress)];
}
function readCellBoundary(cellBoundary, geoJsonCoords, closedLoop) {
  var numVerts = libh3.getValue(cellBoundary, "i32");
  var vertsPos = cellBoundary + SZ_DBL;
  var out = [];
  var readCoord = geoJsonCoords ? readLatLngGeoJson : readLatLng;
  for (var i = 0; i < numVerts * 2; i += 2) {
    out.push(readCoord(vertsPos + SZ_DBL * i));
  }
  if (closedLoop) {
    out.push(out[0]);
  }
  return out;
}
function latLngToCell(lat, lng, res) {
  var latLng = libh3._malloc(SZ_LATLNG);
  libh3.HEAPF64.set([lat, lng].map(degsToRads), latLng / SZ_DBL);
  var h3Index = libh3._malloc(SZ_H3INDEX);
  try {
    throwIfError(H3.latLngToCell(latLng, res, h3Index));
    return validateH3Index(readH3IndexFromPointer(h3Index));
  } finally {
    libh3._free(h3Index);
    libh3._free(latLng);
  }
}
function cellToLatLng(h3Index) {
  var latLng = libh3._malloc(SZ_LATLNG);
  var ref = h3IndexToSplitLong(h3Index);
  var lower = ref[0];
  var upper = ref[1];
  try {
    throwIfError(H3.cellToLatLng(lower, upper, latLng));
    return readLatLng(latLng);
  } finally {
    libh3._free(latLng);
  }
}
function cellToBoundary(h3Index, formatAsGeoJson) {
  var cellBoundary = libh3._malloc(SZ_CELLBOUNDARY);
  var ref = h3IndexToSplitLong(h3Index);
  var lower = ref[0];
  var upper = ref[1];
  try {
    throwIfError(H3.cellToBoundary(lower, upper, cellBoundary));
    return readCellBoundary(cellBoundary, formatAsGeoJson, formatAsGeoJson);
  } finally {
    libh3._free(cellBoundary);
  }
}
function polygonToCells(coordinates2, res, isGeoJson) {
  validateRes(res);
  isGeoJson = Boolean(isGeoJson);
  if (coordinates2.length === 0 || coordinates2[0].length === 0) {
    return [];
  }
  var polygon = typeof coordinates2[0][0] === "number" ? [coordinates2] : coordinates2;
  var geoPolygon = coordinatesToGeoPolygon(
    // @ts-expect-error - There's no way to convince TS that polygon is now number[][][]
    polygon,
    isGeoJson
  );
  var countPtr = libh3._malloc(SZ_INT64);
  try {
    throwIfError(H3.maxPolygonToCellsSize(geoPolygon, res, 0, countPtr));
    var count2 = validateArrayLength(readInt64AsDoubleFromPointer(countPtr));
    var hexagons = libh3._calloc(count2, SZ_H3INDEX);
    try {
      throwIfError(H3.polygonToCells(geoPolygon, res, 0, hexagons));
      return readArrayOfH3Indexes(hexagons, count2);
    } finally {
      libh3._free(hexagons);
    }
  } finally {
    libh3._free(countPtr);
    destroyGeoPolygon(geoPolygon);
  }
}
function degsToRads(deg) {
  return deg * Math.PI / 180;
}
function radsToDegs(rad) {
  return rad * 180 / Math.PI;
}

// node_modules/d3-scale-chromatic/src/colors.js
function colors_default(specifier) {
  var n = specifier.length / 6 | 0, colors = new Array(n), i = 0;
  while (i < n) colors[i] = "#" + specifier.slice(i * 6, ++i * 6);
  return colors;
}

// node_modules/d3-scale-chromatic/src/categorical/category10.js
var category10_default = colors_default("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf");

// node_modules/d3-scale-chromatic/src/categorical/Accent.js
var Accent_default = colors_default("7fc97fbeaed4fdc086ffff99386cb0f0027fbf5b17666666");

// node_modules/d3-scale-chromatic/src/categorical/Dark2.js
var Dark2_default = colors_default("1b9e77d95f027570b3e7298a66a61ee6ab02a6761d666666");

// node_modules/d3-scale-chromatic/src/categorical/observable10.js
var observable10_default = colors_default("4269d0efb118ff725c6cc5b03ca951ff8ab7a463f297bbf59c6b4e9498a0");

// node_modules/d3-scale-chromatic/src/categorical/Paired.js
var Paired_default = colors_default("a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928");

// node_modules/d3-scale-chromatic/src/categorical/Pastel1.js
var Pastel1_default = colors_default("fbb4aeb3cde3ccebc5decbe4fed9a6ffffcce5d8bdfddaecf2f2f2");

// node_modules/d3-scale-chromatic/src/categorical/Pastel2.js
var Pastel2_default = colors_default("b3e2cdfdcdaccbd5e8f4cae4e6f5c9fff2aef1e2cccccccc");

// node_modules/d3-scale-chromatic/src/categorical/Set1.js
var Set1_default = colors_default("e41a1c377eb84daf4a984ea3ff7f00ffff33a65628f781bf999999");

// node_modules/d3-scale-chromatic/src/categorical/Set2.js
var Set2_default = colors_default("66c2a5fc8d628da0cbe78ac3a6d854ffd92fe5c494b3b3b3");

// node_modules/d3-scale-chromatic/src/categorical/Set3.js
var Set3_default = colors_default("8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f");

// node_modules/d3-scale-chromatic/src/categorical/Tableau10.js
var Tableau10_default = colors_default("4e79a7f28e2ce1575976b7b259a14fedc949af7aa1ff9da79c755fbab0ab");

// node_modules/d3-scale-chromatic/src/ramp.js
var ramp_default = (scheme28) => rgbBasis(scheme28[scheme28.length - 1]);

// node_modules/d3-scale-chromatic/src/diverging/BrBG.js
var scheme = new Array(3).concat(
  "d8b365f5f5f55ab4ac",
  "a6611adfc27d80cdc1018571",
  "a6611adfc27df5f5f580cdc1018571",
  "8c510ad8b365f6e8c3c7eae55ab4ac01665e",
  "8c510ad8b365f6e8c3f5f5f5c7eae55ab4ac01665e",
  "8c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e",
  "8c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e",
  "5430058c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e003c30",
  "5430058c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e003c30"
).map(colors_default);
var BrBG_default = ramp_default(scheme);

// node_modules/d3-scale-chromatic/src/diverging/PRGn.js
var scheme2 = new Array(3).concat(
  "af8dc3f7f7f77fbf7b",
  "7b3294c2a5cfa6dba0008837",
  "7b3294c2a5cff7f7f7a6dba0008837",
  "762a83af8dc3e7d4e8d9f0d37fbf7b1b7837",
  "762a83af8dc3e7d4e8f7f7f7d9f0d37fbf7b1b7837",
  "762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b7837",
  "762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b7837",
  "40004b762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b783700441b",
  "40004b762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b783700441b"
).map(colors_default);
var PRGn_default = ramp_default(scheme2);

// node_modules/d3-scale-chromatic/src/diverging/PiYG.js
var scheme3 = new Array(3).concat(
  "e9a3c9f7f7f7a1d76a",
  "d01c8bf1b6dab8e1864dac26",
  "d01c8bf1b6daf7f7f7b8e1864dac26",
  "c51b7de9a3c9fde0efe6f5d0a1d76a4d9221",
  "c51b7de9a3c9fde0eff7f7f7e6f5d0a1d76a4d9221",
  "c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221",
  "c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221",
  "8e0152c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221276419",
  "8e0152c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221276419"
).map(colors_default);
var PiYG_default = ramp_default(scheme3);

// node_modules/d3-scale-chromatic/src/diverging/PuOr.js
var scheme4 = new Array(3).concat(
  "998ec3f7f7f7f1a340",
  "5e3c99b2abd2fdb863e66101",
  "5e3c99b2abd2f7f7f7fdb863e66101",
  "542788998ec3d8daebfee0b6f1a340b35806",
  "542788998ec3d8daebf7f7f7fee0b6f1a340b35806",
  "5427888073acb2abd2d8daebfee0b6fdb863e08214b35806",
  "5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b35806",
  "2d004b5427888073acb2abd2d8daebfee0b6fdb863e08214b358067f3b08",
  "2d004b5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b358067f3b08"
).map(colors_default);
var PuOr_default = ramp_default(scheme4);

// node_modules/d3-scale-chromatic/src/diverging/RdBu.js
var scheme5 = new Array(3).concat(
  "ef8a62f7f7f767a9cf",
  "ca0020f4a58292c5de0571b0",
  "ca0020f4a582f7f7f792c5de0571b0",
  "b2182bef8a62fddbc7d1e5f067a9cf2166ac",
  "b2182bef8a62fddbc7f7f7f7d1e5f067a9cf2166ac",
  "b2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac",
  "b2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac",
  "67001fb2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac053061",
  "67001fb2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac053061"
).map(colors_default);
var RdBu_default = ramp_default(scheme5);

// node_modules/d3-scale-chromatic/src/diverging/RdGy.js
var scheme6 = new Array(3).concat(
  "ef8a62ffffff999999",
  "ca0020f4a582bababa404040",
  "ca0020f4a582ffffffbababa404040",
  "b2182bef8a62fddbc7e0e0e09999994d4d4d",
  "b2182bef8a62fddbc7ffffffe0e0e09999994d4d4d",
  "b2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d",
  "b2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d",
  "67001fb2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d1a1a1a",
  "67001fb2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d1a1a1a"
).map(colors_default);
var RdGy_default = ramp_default(scheme6);

// node_modules/d3-scale-chromatic/src/diverging/RdYlBu.js
var scheme7 = new Array(3).concat(
  "fc8d59ffffbf91bfdb",
  "d7191cfdae61abd9e92c7bb6",
  "d7191cfdae61ffffbfabd9e92c7bb6",
  "d73027fc8d59fee090e0f3f891bfdb4575b4",
  "d73027fc8d59fee090ffffbfe0f3f891bfdb4575b4",
  "d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4",
  "d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4",
  "a50026d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4313695",
  "a50026d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4313695"
).map(colors_default);
var RdYlBu_default = ramp_default(scheme7);

// node_modules/d3-scale-chromatic/src/diverging/RdYlGn.js
var scheme8 = new Array(3).concat(
  "fc8d59ffffbf91cf60",
  "d7191cfdae61a6d96a1a9641",
  "d7191cfdae61ffffbfa6d96a1a9641",
  "d73027fc8d59fee08bd9ef8b91cf601a9850",
  "d73027fc8d59fee08bffffbfd9ef8b91cf601a9850",
  "d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850",
  "d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850",
  "a50026d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850006837",
  "a50026d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850006837"
).map(colors_default);
var RdYlGn_default = ramp_default(scheme8);

// node_modules/d3-scale-chromatic/src/diverging/Spectral.js
var scheme9 = new Array(3).concat(
  "fc8d59ffffbf99d594",
  "d7191cfdae61abdda42b83ba",
  "d7191cfdae61ffffbfabdda42b83ba",
  "d53e4ffc8d59fee08be6f59899d5943288bd",
  "d53e4ffc8d59fee08bffffbfe6f59899d5943288bd",
  "d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd",
  "d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd",
  "9e0142d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd5e4fa2",
  "9e0142d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd5e4fa2"
).map(colors_default);
var Spectral_default = ramp_default(scheme9);

// node_modules/d3-scale-chromatic/src/sequential-multi/BuGn.js
var scheme10 = new Array(3).concat(
  "e5f5f999d8c92ca25f",
  "edf8fbb2e2e266c2a4238b45",
  "edf8fbb2e2e266c2a42ca25f006d2c",
  "edf8fbccece699d8c966c2a42ca25f006d2c",
  "edf8fbccece699d8c966c2a441ae76238b45005824",
  "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45005824",
  "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45006d2c00441b"
).map(colors_default);
var BuGn_default = ramp_default(scheme10);

// node_modules/d3-scale-chromatic/src/sequential-multi/BuPu.js
var scheme11 = new Array(3).concat(
  "e0ecf49ebcda8856a7",
  "edf8fbb3cde38c96c688419d",
  "edf8fbb3cde38c96c68856a7810f7c",
  "edf8fbbfd3e69ebcda8c96c68856a7810f7c",
  "edf8fbbfd3e69ebcda8c96c68c6bb188419d6e016b",
  "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d6e016b",
  "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d810f7c4d004b"
).map(colors_default);
var BuPu_default = ramp_default(scheme11);

// node_modules/d3-scale-chromatic/src/sequential-multi/GnBu.js
var scheme12 = new Array(3).concat(
  "e0f3dba8ddb543a2ca",
  "f0f9e8bae4bc7bccc42b8cbe",
  "f0f9e8bae4bc7bccc443a2ca0868ac",
  "f0f9e8ccebc5a8ddb57bccc443a2ca0868ac",
  "f0f9e8ccebc5a8ddb57bccc44eb3d32b8cbe08589e",
  "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe08589e",
  "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe0868ac084081"
).map(colors_default);
var GnBu_default = ramp_default(scheme12);

// node_modules/d3-scale-chromatic/src/sequential-multi/OrRd.js
var scheme13 = new Array(3).concat(
  "fee8c8fdbb84e34a33",
  "fef0d9fdcc8afc8d59d7301f",
  "fef0d9fdcc8afc8d59e34a33b30000",
  "fef0d9fdd49efdbb84fc8d59e34a33b30000",
  "fef0d9fdd49efdbb84fc8d59ef6548d7301f990000",
  "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301f990000",
  "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301fb300007f0000"
).map(colors_default);
var OrRd_default = ramp_default(scheme13);

// node_modules/d3-scale-chromatic/src/sequential-multi/PuBuGn.js
var scheme14 = new Array(3).concat(
  "ece2f0a6bddb1c9099",
  "f6eff7bdc9e167a9cf02818a",
  "f6eff7bdc9e167a9cf1c9099016c59",
  "f6eff7d0d1e6a6bddb67a9cf1c9099016c59",
  "f6eff7d0d1e6a6bddb67a9cf3690c002818a016450",
  "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016450",
  "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016c59014636"
).map(colors_default);
var PuBuGn_default = ramp_default(scheme14);

// node_modules/d3-scale-chromatic/src/sequential-multi/PuBu.js
var scheme15 = new Array(3).concat(
  "ece7f2a6bddb2b8cbe",
  "f1eef6bdc9e174a9cf0570b0",
  "f1eef6bdc9e174a9cf2b8cbe045a8d",
  "f1eef6d0d1e6a6bddb74a9cf2b8cbe045a8d",
  "f1eef6d0d1e6a6bddb74a9cf3690c00570b0034e7b",
  "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0034e7b",
  "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0045a8d023858"
).map(colors_default);
var PuBu_default = ramp_default(scheme15);

// node_modules/d3-scale-chromatic/src/sequential-multi/PuRd.js
var scheme16 = new Array(3).concat(
  "e7e1efc994c7dd1c77",
  "f1eef6d7b5d8df65b0ce1256",
  "f1eef6d7b5d8df65b0dd1c77980043",
  "f1eef6d4b9dac994c7df65b0dd1c77980043",
  "f1eef6d4b9dac994c7df65b0e7298ace125691003f",
  "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125691003f",
  "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125698004367001f"
).map(colors_default);
var PuRd_default = ramp_default(scheme16);

// node_modules/d3-scale-chromatic/src/sequential-multi/RdPu.js
var scheme17 = new Array(3).concat(
  "fde0ddfa9fb5c51b8a",
  "feebe2fbb4b9f768a1ae017e",
  "feebe2fbb4b9f768a1c51b8a7a0177",
  "feebe2fcc5c0fa9fb5f768a1c51b8a7a0177",
  "feebe2fcc5c0fa9fb5f768a1dd3497ae017e7a0177",
  "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a0177",
  "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a017749006a"
).map(colors_default);
var RdPu_default = ramp_default(scheme17);

// node_modules/d3-scale-chromatic/src/sequential-multi/YlGnBu.js
var scheme18 = new Array(3).concat(
  "edf8b17fcdbb2c7fb8",
  "ffffcca1dab441b6c4225ea8",
  "ffffcca1dab441b6c42c7fb8253494",
  "ffffccc7e9b47fcdbb41b6c42c7fb8253494",
  "ffffccc7e9b47fcdbb41b6c41d91c0225ea80c2c84",
  "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea80c2c84",
  "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea8253494081d58"
).map(colors_default);
var YlGnBu_default = ramp_default(scheme18);

// node_modules/d3-scale-chromatic/src/sequential-multi/YlGn.js
var scheme19 = new Array(3).concat(
  "f7fcb9addd8e31a354",
  "ffffccc2e69978c679238443",
  "ffffccc2e69978c67931a354006837",
  "ffffccd9f0a3addd8e78c67931a354006837",
  "ffffccd9f0a3addd8e78c67941ab5d238443005a32",
  "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443005a32",
  "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443006837004529"
).map(colors_default);
var YlGn_default = ramp_default(scheme19);

// node_modules/d3-scale-chromatic/src/sequential-multi/YlOrBr.js
var scheme20 = new Array(3).concat(
  "fff7bcfec44fd95f0e",
  "ffffd4fed98efe9929cc4c02",
  "ffffd4fed98efe9929d95f0e993404",
  "ffffd4fee391fec44ffe9929d95f0e993404",
  "ffffd4fee391fec44ffe9929ec7014cc4c028c2d04",
  "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c028c2d04",
  "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c02993404662506"
).map(colors_default);
var YlOrBr_default = ramp_default(scheme20);

// node_modules/d3-scale-chromatic/src/sequential-multi/YlOrRd.js
var scheme21 = new Array(3).concat(
  "ffeda0feb24cf03b20",
  "ffffb2fecc5cfd8d3ce31a1c",
  "ffffb2fecc5cfd8d3cf03b20bd0026",
  "ffffb2fed976feb24cfd8d3cf03b20bd0026",
  "ffffb2fed976feb24cfd8d3cfc4e2ae31a1cb10026",
  "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cb10026",
  "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cbd0026800026"
).map(colors_default);
var YlOrRd_default = ramp_default(scheme21);

// node_modules/d3-scale-chromatic/src/sequential-single/Blues.js
var scheme22 = new Array(3).concat(
  "deebf79ecae13182bd",
  "eff3ffbdd7e76baed62171b5",
  "eff3ffbdd7e76baed63182bd08519c",
  "eff3ffc6dbef9ecae16baed63182bd08519c",
  "eff3ffc6dbef9ecae16baed64292c62171b5084594",
  "f7fbffdeebf7c6dbef9ecae16baed64292c62171b5084594",
  "f7fbffdeebf7c6dbef9ecae16baed64292c62171b508519c08306b"
).map(colors_default);
var Blues_default = ramp_default(scheme22);

// node_modules/d3-scale-chromatic/src/sequential-single/Greens.js
var scheme23 = new Array(3).concat(
  "e5f5e0a1d99b31a354",
  "edf8e9bae4b374c476238b45",
  "edf8e9bae4b374c47631a354006d2c",
  "edf8e9c7e9c0a1d99b74c47631a354006d2c",
  "edf8e9c7e9c0a1d99b74c47641ab5d238b45005a32",
  "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45005a32",
  "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45006d2c00441b"
).map(colors_default);
var Greens_default = ramp_default(scheme23);

// node_modules/d3-scale-chromatic/src/sequential-single/Greys.js
var scheme24 = new Array(3).concat(
  "f0f0f0bdbdbd636363",
  "f7f7f7cccccc969696525252",
  "f7f7f7cccccc969696636363252525",
  "f7f7f7d9d9d9bdbdbd969696636363252525",
  "f7f7f7d9d9d9bdbdbd969696737373525252252525",
  "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525",
  "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525000000"
).map(colors_default);
var Greys_default = ramp_default(scheme24);

// node_modules/d3-scale-chromatic/src/sequential-single/Purples.js
var scheme25 = new Array(3).concat(
  "efedf5bcbddc756bb1",
  "f2f0f7cbc9e29e9ac86a51a3",
  "f2f0f7cbc9e29e9ac8756bb154278f",
  "f2f0f7dadaebbcbddc9e9ac8756bb154278f",
  "f2f0f7dadaebbcbddc9e9ac8807dba6a51a34a1486",
  "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a34a1486",
  "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a354278f3f007d"
).map(colors_default);
var Purples_default = ramp_default(scheme25);

// node_modules/d3-scale-chromatic/src/sequential-single/Reds.js
var scheme26 = new Array(3).concat(
  "fee0d2fc9272de2d26",
  "fee5d9fcae91fb6a4acb181d",
  "fee5d9fcae91fb6a4ade2d26a50f15",
  "fee5d9fcbba1fc9272fb6a4ade2d26a50f15",
  "fee5d9fcbba1fc9272fb6a4aef3b2ccb181d99000d",
  "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181d99000d",
  "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181da50f1567000d"
).map(colors_default);
var Reds_default = ramp_default(scheme26);

// node_modules/d3-scale-chromatic/src/sequential-single/Oranges.js
var scheme27 = new Array(3).concat(
  "fee6cefdae6be6550d",
  "feeddefdbe85fd8d3cd94701",
  "feeddefdbe85fd8d3ce6550da63603",
  "feeddefdd0a2fdae6bfd8d3ce6550da63603",
  "feeddefdd0a2fdae6bfd8d3cf16913d948018c2d04",
  "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d948018c2d04",
  "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d94801a636037f2704"
).map(colors_default);
var Oranges_default = ramp_default(scheme27);

// node_modules/d3-scale-chromatic/src/sequential-multi/cubehelix.js
var cubehelix_default2 = cubehelixLong(cubehelix(300, 0.5, 0), cubehelix(-240, 0.5, 1));

// node_modules/d3-scale-chromatic/src/sequential-multi/rainbow.js
var warm = cubehelixLong(cubehelix(-100, 0.75, 0.35), cubehelix(80, 1.5, 0.8));
var cool = cubehelixLong(cubehelix(260, 0.75, 0.35), cubehelix(80, 1.5, 0.8));
var c = cubehelix();

// node_modules/d3-scale-chromatic/src/sequential-multi/sinebow.js
var c2 = rgb();
var pi_1_3 = Math.PI / 3;
var pi_2_3 = Math.PI * 2 / 3;

// node_modules/d3-scale-chromatic/src/sequential-multi/turbo.js
function turbo_default(t) {
  t = Math.max(0, Math.min(1, t));
  return "rgb(" + Math.max(0, Math.min(255, Math.round(34.61 + t * (1172.33 - t * (10793.56 - t * (33300.12 - t * (38394.49 - t * 14825.05))))))) + ", " + Math.max(0, Math.min(255, Math.round(23.31 + t * (557.33 + t * (1225.33 - t * (3574.96 - t * (1073.77 + t * 707.56))))))) + ", " + Math.max(0, Math.min(255, Math.round(27.2 + t * (3211.1 - t * (15327.97 - t * (27814 - t * (22569.18 - t * 6838.66))))))) + ")";
}

// node_modules/d3-scale-chromatic/src/sequential-multi/viridis.js
function ramp(range5) {
  var n = range5.length;
  return function(t) {
    return range5[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
  };
}
var viridis_default = ramp(colors_default("44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725"));
var magma = ramp(colors_default("00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf"));
var inferno = ramp(colors_default("00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4"));
var plasma = ramp(colors_default("0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921"));

// node_modules/three/build/three.webgpu.js
var refreshUniforms = [
  "alphaMap",
  "alphaTest",
  "anisotropy",
  "anisotropyMap",
  "anisotropyRotation",
  "aoMap",
  "aoMapIntensity",
  "attenuationColor",
  "attenuationDistance",
  "bumpMap",
  "clearcoat",
  "clearcoatMap",
  "clearcoatNormalMap",
  "clearcoatNormalScale",
  "clearcoatRoughness",
  "color",
  "dispersion",
  "displacementMap",
  "emissive",
  "emissiveIntensity",
  "emissiveMap",
  "envMap",
  "envMapIntensity",
  "gradientMap",
  "ior",
  "iridescence",
  "iridescenceIOR",
  "iridescenceMap",
  "iridescenceThicknessMap",
  "lightMap",
  "lightMapIntensity",
  "map",
  "matcap",
  "metalness",
  "metalnessMap",
  "normalMap",
  "normalScale",
  "opacity",
  "roughness",
  "roughnessMap",
  "sheen",
  "sheenColor",
  "sheenColorMap",
  "sheenRoughnessMap",
  "shininess",
  "specular",
  "specularColor",
  "specularColorMap",
  "specularIntensity",
  "specularIntensityMap",
  "specularMap",
  "thickness",
  "transmission",
  "transmissionMap"
];
var _lightsCache = /* @__PURE__ */ new WeakMap();
var NodeMaterialObserver = class {
  /**
   * Constructs a new node material observer.
   *
   * @param {NodeBuilder} builder - The node builder.
   */
  constructor(builder) {
    this.renderObjects = /* @__PURE__ */ new WeakMap();
    this.hasNode = this.containsNode(builder);
    this.hasAnimation = builder.object.isSkinnedMesh === true;
    this.refreshUniforms = refreshUniforms;
    this.renderId = 0;
  }
  /**
   * Returns `true` if the given render object is verified for the first time of this observer.
   *
   * @param {RenderObject} renderObject - The render object.
   * @return {boolean} Whether the given render object is verified for the first time of this observer.
   */
  firstInitialization(renderObject) {
    const hasInitialized = this.renderObjects.has(renderObject);
    if (hasInitialized === false) {
      this.getRenderObjectData(renderObject);
      return true;
    }
    return false;
  }
  /**
   * Returns `true` if the current rendering produces motion vectors.
   *
   * @param {Renderer} renderer - The renderer.
   * @return {boolean} Whether the current rendering produces motion vectors or not.
   */
  needsVelocity(renderer) {
    const mrt3 = renderer.getMRT();
    return mrt3 !== null && mrt3.has("velocity");
  }
  /**
   * Returns monitoring data for the given render object.
   *
   * @param {RenderObject} renderObject - The render object.
   * @return {Object} The monitoring data.
   */
  getRenderObjectData(renderObject) {
    let data = this.renderObjects.get(renderObject);
    if (data === void 0) {
      const { geometry, material, object: object2 } = renderObject;
      data = {
        material: this.getMaterialData(material),
        geometry: {
          id: geometry.id,
          attributes: this.getAttributesData(geometry.attributes),
          indexVersion: geometry.index ? geometry.index.version : null,
          drawRange: { start: geometry.drawRange.start, count: geometry.drawRange.count }
        },
        worldMatrix: object2.matrixWorld.clone()
      };
      if (object2.center) {
        data.center = object2.center.clone();
      }
      if (object2.morphTargetInfluences) {
        data.morphTargetInfluences = object2.morphTargetInfluences.slice();
      }
      if (renderObject.bundle !== null) {
        data.version = renderObject.bundle.version;
      }
      if (data.material.transmission > 0) {
        const { width, height } = renderObject.context;
        data.bufferWidth = width;
        data.bufferHeight = height;
      }
      data.lights = this.getLightsData(renderObject.lightsNode.getLights());
      this.renderObjects.set(renderObject, data);
    }
    return data;
  }
  /**
   * Returns an attribute data structure holding the attributes versions for
   * monitoring.
   *
   * @param {Object} attributes - The geometry attributes.
   * @return {Object} An object for monitoring the versions of attributes.
   */
  getAttributesData(attributes) {
    const attributesData = {};
    for (const name in attributes) {
      const attribute3 = attributes[name];
      attributesData[name] = {
        version: attribute3.version
      };
    }
    return attributesData;
  }
  /**
   * Returns `true` if the node builder's material uses
   * node properties.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {boolean} Whether the node builder's material uses node properties or not.
   */
  containsNode(builder) {
    const material = builder.material;
    for (const property3 in material) {
      if (material[property3] && material[property3].isNode)
        return true;
    }
    if (builder.renderer.overrideNodes.modelViewMatrix !== null || builder.renderer.overrideNodes.modelNormalViewMatrix !== null)
      return true;
    return false;
  }
  /**
   * Returns a material data structure holding the material property values for
   * monitoring.
   *
   * @param {Material} material - The material.
   * @return {Object} An object for monitoring material properties.
   */
  getMaterialData(material) {
    const data = {};
    for (const property3 of this.refreshUniforms) {
      const value = material[property3];
      if (value === null || value === void 0) continue;
      if (typeof value === "object" && value.clone !== void 0) {
        if (value.isTexture === true) {
          data[property3] = { id: value.id, version: value.version };
        } else {
          data[property3] = value.clone();
        }
      } else {
        data[property3] = value;
      }
    }
    return data;
  }
  /**
   * Returns `true` if the given render object has not changed its state.
   *
   * @param {RenderObject} renderObject - The render object.
   * @param {Array<Light>} lightsData - The current material lights.
   * @return {boolean} Whether the given render object has changed its state or not.
   */
  equals(renderObject, lightsData) {
    const { object: object2, material, geometry } = renderObject;
    const renderObjectData = this.getRenderObjectData(renderObject);
    if (renderObjectData.worldMatrix.equals(object2.matrixWorld) !== true) {
      renderObjectData.worldMatrix.copy(object2.matrixWorld);
      return false;
    }
    const materialData = renderObjectData.material;
    for (const property3 in materialData) {
      const value = materialData[property3];
      const mtlValue = material[property3];
      if (value.equals !== void 0) {
        if (value.equals(mtlValue) === false) {
          value.copy(mtlValue);
          return false;
        }
      } else if (mtlValue.isTexture === true) {
        if (value.id !== mtlValue.id || value.version !== mtlValue.version) {
          value.id = mtlValue.id;
          value.version = mtlValue.version;
          return false;
        }
      } else if (value !== mtlValue) {
        materialData[property3] = mtlValue;
        return false;
      }
    }
    if (materialData.transmission > 0) {
      const { width, height } = renderObject.context;
      if (renderObjectData.bufferWidth !== width || renderObjectData.bufferHeight !== height) {
        renderObjectData.bufferWidth = width;
        renderObjectData.bufferHeight = height;
        return false;
      }
    }
    const storedGeometryData = renderObjectData.geometry;
    const attributes = geometry.attributes;
    const storedAttributes = storedGeometryData.attributes;
    const storedAttributeNames = Object.keys(storedAttributes);
    const currentAttributeNames = Object.keys(attributes);
    if (storedGeometryData.id !== geometry.id) {
      storedGeometryData.id = geometry.id;
      return false;
    }
    if (storedAttributeNames.length !== currentAttributeNames.length) {
      renderObjectData.geometry.attributes = this.getAttributesData(attributes);
      return false;
    }
    for (const name of storedAttributeNames) {
      const storedAttributeData = storedAttributes[name];
      const attribute3 = attributes[name];
      if (attribute3 === void 0) {
        delete storedAttributes[name];
        return false;
      }
      if (storedAttributeData.version !== attribute3.version) {
        storedAttributeData.version = attribute3.version;
        return false;
      }
    }
    const index5 = geometry.index;
    const storedIndexVersion = storedGeometryData.indexVersion;
    const currentIndexVersion = index5 ? index5.version : null;
    if (storedIndexVersion !== currentIndexVersion) {
      storedGeometryData.indexVersion = currentIndexVersion;
      return false;
    }
    if (storedGeometryData.drawRange.start !== geometry.drawRange.start || storedGeometryData.drawRange.count !== geometry.drawRange.count) {
      storedGeometryData.drawRange.start = geometry.drawRange.start;
      storedGeometryData.drawRange.count = geometry.drawRange.count;
      return false;
    }
    if (renderObjectData.morphTargetInfluences) {
      let morphChanged = false;
      for (let i = 0; i < renderObjectData.morphTargetInfluences.length; i++) {
        if (renderObjectData.morphTargetInfluences[i] !== object2.morphTargetInfluences[i]) {
          morphChanged = true;
        }
      }
      if (morphChanged) return true;
    }
    if (renderObjectData.lights) {
      for (let i = 0; i < lightsData.length; i++) {
        if (renderObjectData.lights[i].map !== lightsData[i].map) {
          return false;
        }
      }
    }
    if (renderObjectData.center) {
      if (renderObjectData.center.equals(object2.center) === false) {
        renderObjectData.center.copy(object2.center);
        return true;
      }
    }
    if (renderObject.bundle !== null) {
      renderObjectData.version = renderObject.bundle.version;
    }
    return true;
  }
  /**
   * Returns the lights data for the given material lights.
   *
   * @param {Array<Light>} materialLights - The material lights.
   * @return {Array<Object>} The lights data for the given material lights.
   */
  getLightsData(materialLights) {
    const lights3 = [];
    for (const light of materialLights) {
      if (light.isSpotLight === true && light.map !== null) {
        lights3.push({ map: light.map.version });
      }
    }
    return lights3;
  }
  /**
   * Returns the lights for the given lights node and render ID.
   *
   * @param {LightsNode} lightsNode - The lights node.
   * @param {number} renderId - The render ID.
   * @return {Array<Object>} The lights for the given lights node and render ID.
   */
  getLights(lightsNode, renderId) {
    if (_lightsCache.has(lightsNode)) {
      const cached = _lightsCache.get(lightsNode);
      if (cached.renderId === renderId) {
        return cached.lightsData;
      }
    }
    const lightsData = this.getLightsData(lightsNode.getLights());
    _lightsCache.set(lightsNode, { renderId, lightsData });
    return lightsData;
  }
  /**
   * Checks if the given render object requires a refresh.
   *
   * @param {RenderObject} renderObject - The render object.
   * @param {NodeFrame} nodeFrame - The current node frame.
   * @return {boolean} Whether the given render object requires a refresh or not.
   */
  needsRefresh(renderObject, nodeFrame) {
    if (this.hasNode || this.hasAnimation || this.firstInitialization(renderObject) || this.needsVelocity(nodeFrame.renderer))
      return true;
    const { renderId } = nodeFrame;
    if (this.renderId !== renderId) {
      this.renderId = renderId;
      return true;
    }
    const isStatic = renderObject.object.static === true;
    const isBundle = renderObject.bundle !== null && renderObject.bundle.static === true && this.getRenderObjectData(renderObject).version === renderObject.bundle.version;
    if (isStatic || isBundle)
      return false;
    const lightsData = this.getLights(renderObject.lightsNode, renderId);
    const notEqual3 = this.equals(renderObject, lightsData) !== true;
    return notEqual3;
  }
};
function cyrb53(value, seed = 0) {
  let h12 = 3735928559 ^ seed, h2 = 1103547991 ^ seed;
  if (value instanceof Array) {
    for (let i = 0, val; i < value.length; i++) {
      val = value[i];
      h12 = Math.imul(h12 ^ val, 2654435761);
      h2 = Math.imul(h2 ^ val, 1597334677);
    }
  } else {
    for (let i = 0, ch; i < value.length; i++) {
      ch = value.charCodeAt(i);
      h12 = Math.imul(h12 ^ ch, 2654435761);
      h2 = Math.imul(h2 ^ ch, 1597334677);
    }
  }
  h12 = Math.imul(h12 ^ h12 >>> 16, 2246822507);
  h12 ^= Math.imul(h2 ^ h2 >>> 13, 3266489909);
  h2 = Math.imul(h2 ^ h2 >>> 16, 2246822507);
  h2 ^= Math.imul(h12 ^ h12 >>> 13, 3266489909);
  return 4294967296 * (2097151 & h2) + (h12 >>> 0);
}
var hashString = (str) => cyrb53(str);
var hashArray = (array4) => cyrb53(array4);
var hash$1 = (...params) => cyrb53(params);
function getCacheKey$1(object2, force = false) {
  const values = [];
  if (object2.isNode === true) {
    values.push(object2.id);
  }
  for (const { property: property3, childNode } of getNodeChildren(object2)) {
    values.push(cyrb53(property3.slice(0, -4)), childNode.getCacheKey(force));
  }
  return cyrb53(values);
}
function* getNodeChildren(node, toJSON = false) {
  for (const property3 of Object.getOwnPropertyNames(node)) {
    if (property3.startsWith("_") === true) continue;
    const object2 = node[property3];
    if (Array.isArray(object2) === true) {
      for (let i = 0; i < object2.length; i++) {
        const child = object2[i];
        if (child && (child.isNode === true || toJSON && typeof child.toJSON === "function")) {
          yield { property: property3, index: i, childNode: child };
        }
      }
    } else if (object2 && object2.isNode === true) {
      yield { property: property3, childNode: object2 };
    } else if (object2 && Object.getPrototypeOf(object2) === Object.prototype) {
      for (const subProperty in object2) {
        if (subProperty.startsWith("_") === true) continue;
        const child = object2[subProperty];
        if (child && (child.isNode === true || toJSON && typeof child.toJSON === "function")) {
          yield { property: property3, index: subProperty, childNode: child };
        }
      }
    }
  }
}
var typeFromLength = /* @__PURE__ */ new Map([
  [1, "float"],
  [2, "vec2"],
  [3, "vec3"],
  [4, "vec4"],
  [9, "mat3"],
  [16, "mat4"]
]);
var dataFromObject = /* @__PURE__ */ new WeakMap();
function getTypeFromLength(length3) {
  return typeFromLength.get(length3);
}
function getTypedArrayFromType(type) {
  if (/[iu]?vec\d/.test(type)) {
    if (type.startsWith("ivec")) return Int32Array;
    if (type.startsWith("uvec")) return Uint32Array;
    return Float32Array;
  }
  if (/mat\d/.test(type)) return Float32Array;
  if (/float/.test(type)) return Float32Array;
  if (/uint/.test(type)) return Uint32Array;
  if (/int/.test(type)) return Int32Array;
  throw new Error(`THREE.NodeUtils: Unsupported type: ${type}`);
}
function getLengthFromType(type) {
  if (/float|int|uint/.test(type)) return 1;
  if (/vec2/.test(type)) return 2;
  if (/vec3/.test(type)) return 3;
  if (/vec4/.test(type)) return 4;
  if (/mat2/.test(type)) return 4;
  if (/mat3/.test(type)) return 9;
  if (/mat4/.test(type)) return 16;
  console.error("THREE.TSL: Unsupported type:", type);
}
function getMemoryLengthFromType(type) {
  if (/float|int|uint/.test(type)) return 1;
  if (/vec2/.test(type)) return 2;
  if (/vec3/.test(type)) return 3;
  if (/vec4/.test(type)) return 4;
  if (/mat2/.test(type)) return 4;
  if (/mat3/.test(type)) return 12;
  if (/mat4/.test(type)) return 16;
  console.error("THREE.TSL: Unsupported type:", type);
}
function getByteBoundaryFromType(type) {
  if (/float|int|uint/.test(type)) return 4;
  if (/vec2/.test(type)) return 8;
  if (/vec3/.test(type)) return 16;
  if (/vec4/.test(type)) return 16;
  if (/mat2/.test(type)) return 8;
  if (/mat3/.test(type)) return 48;
  if (/mat4/.test(type)) return 64;
  console.error("THREE.TSL: Unsupported type:", type);
}
function getValueType(value) {
  if (value === void 0 || value === null) return null;
  const typeOf = typeof value;
  if (value.isNode === true) {
    return "node";
  } else if (typeOf === "number") {
    return "float";
  } else if (typeOf === "boolean") {
    return "bool";
  } else if (typeOf === "string") {
    return "string";
  } else if (typeOf === "function") {
    return "shader";
  } else if (value.isVector2 === true) {
    return "vec2";
  } else if (value.isVector3 === true) {
    return "vec3";
  } else if (value.isVector4 === true) {
    return "vec4";
  } else if (value.isMatrix2 === true) {
    return "mat2";
  } else if (value.isMatrix3 === true) {
    return "mat3";
  } else if (value.isMatrix4 === true) {
    return "mat4";
  } else if (value.isColor === true) {
    return "color";
  } else if (value instanceof ArrayBuffer) {
    return "ArrayBuffer";
  }
  return null;
}
function getValueFromType(type, ...params) {
  const last4 = type ? type.slice(-4) : void 0;
  if (params.length === 1) {
    if (last4 === "vec2") params = [params[0], params[0]];
    else if (last4 === "vec3") params = [params[0], params[0], params[0]];
    else if (last4 === "vec4") params = [params[0], params[0], params[0], params[0]];
  }
  if (type === "color") {
    return new Color(...params);
  } else if (last4 === "vec2") {
    return new Vector2(...params);
  } else if (last4 === "vec3") {
    return new Vector3(...params);
  } else if (last4 === "vec4") {
    return new Vector4(...params);
  } else if (last4 === "mat2") {
    return new Matrix2(...params);
  } else if (last4 === "mat3") {
    return new Matrix3(...params);
  } else if (last4 === "mat4") {
    return new Matrix4(...params);
  } else if (type === "bool") {
    return params[0] || false;
  } else if (type === "float" || type === "int" || type === "uint") {
    return params[0] || 0;
  } else if (type === "string") {
    return params[0] || "";
  } else if (type === "ArrayBuffer") {
    return base64ToArrayBuffer(params[0]);
  }
  return null;
}
function getDataFromObject(object2) {
  let data = dataFromObject.get(object2);
  if (data === void 0) {
    data = {};
    dataFromObject.set(object2, data);
  }
  return data;
}
function arrayBufferToBase64(arrayBuffer3) {
  let chars = "";
  const array4 = new Uint8Array(arrayBuffer3);
  for (let i = 0; i < array4.length; i++) {
    chars += String.fromCharCode(array4[i]);
  }
  return btoa(chars);
}
function base64ToArrayBuffer(base64) {
  return Uint8Array.from(atob(base64), (c3) => c3.charCodeAt(0)).buffer;
}
var NodeUtils = Object.freeze({
  __proto__: null,
  arrayBufferToBase64,
  base64ToArrayBuffer,
  getByteBoundaryFromType,
  getCacheKey: getCacheKey$1,
  getDataFromObject,
  getLengthFromType,
  getMemoryLengthFromType,
  getNodeChildren,
  getTypeFromLength,
  getTypedArrayFromType,
  getValueFromType,
  getValueType,
  hash: hash$1,
  hashArray,
  hashString
});
var NodeShaderStage = {
  VERTEX: "vertex",
  FRAGMENT: "fragment"
};
var NodeUpdateType = {
  NONE: "none",
  FRAME: "frame",
  RENDER: "render",
  OBJECT: "object"
};
var NodeType = {
  BOOLEAN: "bool",
  INTEGER: "int",
  FLOAT: "float",
  VECTOR2: "vec2",
  VECTOR3: "vec3",
  VECTOR4: "vec4",
  MATRIX2: "mat2",
  MATRIX3: "mat3",
  MATRIX4: "mat4"
};
var NodeAccess = {
  READ_ONLY: "readOnly",
  WRITE_ONLY: "writeOnly",
  READ_WRITE: "readWrite"
};
var defaultShaderStages = ["fragment", "vertex"];
var defaultBuildStages = ["setup", "analyze", "generate"];
var shaderStages = [...defaultShaderStages, "compute"];
var vectorComponents = ["x", "y", "z", "w"];
var _parentBuildStage = {
  analyze: "setup",
  generate: "analyze"
};
var _nodeId = 0;
var Node = class extends EventDispatcher {
  static get type() {
    return "Node";
  }
  /**
   * Constructs a new node.
   *
   * @param {?string} nodeType - The node type.
   */
  constructor(nodeType = null) {
    super();
    this.nodeType = nodeType;
    this.updateType = NodeUpdateType.NONE;
    this.updateBeforeType = NodeUpdateType.NONE;
    this.updateAfterType = NodeUpdateType.NONE;
    this.uuid = MathUtils.generateUUID();
    this.version = 0;
    this.global = false;
    this.parents = false;
    this.isNode = true;
    this._cacheKey = null;
    this._cacheKeyVersion = 0;
    Object.defineProperty(this, "id", { value: _nodeId++ });
  }
  /**
   * Set this property to `true` when the node should be regenerated.
   *
   * @type {boolean}
   * @default false
   * @param {boolean} value
   */
  set needsUpdate(value) {
    if (value === true) {
      this.version++;
    }
  }
  /**
   * The type of the class. The value is usually the constructor name.
   *
   * @type {string}
  	 * @readonly
   */
  get type() {
    return this.constructor.type;
  }
  /**
   * Convenient method for defining {@link Node#update}.
   *
   * @param {Function} callback - The update method.
   * @param {string} updateType - The update type.
   * @return {Node} A reference to this node.
   */
  onUpdate(callback, updateType) {
    this.updateType = updateType;
    this.update = callback.bind(this);
    return this;
  }
  /**
   * Convenient method for defining {@link Node#update}. Similar to {@link Node#onUpdate}, but
   * this method automatically sets the update type to `FRAME`.
   *
   * @param {Function} callback - The update method.
   * @return {Node} A reference to this node.
   */
  onFrameUpdate(callback) {
    return this.onUpdate(callback, NodeUpdateType.FRAME);
  }
  /**
   * Convenient method for defining {@link Node#update}. Similar to {@link Node#onUpdate}, but
   * this method automatically sets the update type to `RENDER`.
   *
   * @param {Function} callback - The update method.
   * @return {Node} A reference to this node.
   */
  onRenderUpdate(callback) {
    return this.onUpdate(callback, NodeUpdateType.RENDER);
  }
  /**
   * Convenient method for defining {@link Node#update}. Similar to {@link Node#onUpdate}, but
   * this method automatically sets the update type to `OBJECT`.
   *
   * @param {Function} callback - The update method.
   * @return {Node} A reference to this node.
   */
  onObjectUpdate(callback) {
    return this.onUpdate(callback, NodeUpdateType.OBJECT);
  }
  /**
   * Convenient method for defining {@link Node#updateReference}.
   *
   * @param {Function} callback - The update method.
   * @return {Node} A reference to this node.
   */
  onReference(callback) {
    this.updateReference = callback.bind(this);
    return this;
  }
  /**
   * Nodes might refer to other objects like materials. This method allows to dynamically update the reference
   * to such objects based on a given state (e.g. the current node frame or builder).
   *
   * @param {any} state - This method can be invocated in different contexts so `state` can refer to any object type.
   * @return {any} The updated reference.
   */
  updateReference() {
    return this;
  }
  /**
   * By default this method returns the value of the {@link Node#global} flag. This method
   * can be overwritten in derived classes if an analytical way is required to determine the
   * global cache referring to the current shader-stage.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {boolean} Whether this node is global or not.
   */
  isGlobal() {
    return this.global;
  }
  /**
   * Generator function that can be used to iterate over the child nodes.
   *
   * @generator
   * @yields {Node} A child node.
   */
  *getChildren() {
    for (const { childNode } of getNodeChildren(this)) {
      yield childNode;
    }
  }
  /**
   * Calling this method dispatches the `dispose` event. This event can be used
   * to register event listeners for clean up tasks.
   */
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  /**
   * Callback for {@link Node#traverse}.
   *
   * @callback traverseCallback
   * @param {Node} node - The current node.
   */
  /**
   * Can be used to traverse through the node's hierarchy.
   *
   * @param {traverseCallback} callback - A callback that is executed per node.
   */
  traverse(callback) {
    callback(this);
    for (const childNode of this.getChildren()) {
      childNode.traverse(callback);
    }
  }
  /**
   * Returns the cache key for this node.
   *
   * @param {boolean} [force=false] - When set to `true`, a recomputation of the cache key is forced.
   * @return {number} The cache key of the node.
   */
  getCacheKey(force = false) {
    force = force || this.version !== this._cacheKeyVersion;
    if (force === true || this._cacheKey === null) {
      this._cacheKey = hash$1(getCacheKey$1(this, force), this.customCacheKey());
      this._cacheKeyVersion = this.version;
    }
    return this._cacheKey;
  }
  /**
   * Generate a custom cache key for this node.
   *
   * @return {number} The cache key of the node.
   */
  customCacheKey() {
    return 0;
  }
  /**
   * Returns the references to this node which is by default `this`.
   *
   * @return {Node} A reference to this node.
   */
  getScope() {
    return this;
  }
  /**
   * Returns the hash of the node which is used to identify the node. By default it's
   * the {@link Node#uuid} however derived node classes might have to overwrite this method
   * depending on their implementation.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The hash.
   */
  getHash() {
    return this.uuid;
  }
  /**
   * Returns the update type of {@link Node#update}.
   *
   * @return {NodeUpdateType} The update type.
   */
  getUpdateType() {
    return this.updateType;
  }
  /**
   * Returns the update type of {@link Node#updateBefore}.
   *
   * @return {NodeUpdateType} The update type.
   */
  getUpdateBeforeType() {
    return this.updateBeforeType;
  }
  /**
   * Returns the update type of {@link Node#updateAfter}.
   *
   * @return {NodeUpdateType} The update type.
   */
  getUpdateAfterType() {
    return this.updateAfterType;
  }
  /**
   * Certain types are composed of multiple elements. For example a `vec3`
   * is composed of three `float` values. This method returns the type of
   * these elements.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The type of the node.
   */
  getElementType(builder) {
    const type = this.getNodeType(builder);
    const elementType = builder.getElementType(type);
    return elementType;
  }
  /**
   * Returns the node member type for the given name.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {string} name - The name of the member.
   * @return {string} The type of the node.
   */
  getMemberType() {
    return "void";
  }
  /**
   * Returns the node's type.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The type of the node.
   */
  getNodeType(builder) {
    const nodeProperties = builder.getNodeProperties(this);
    if (nodeProperties.outputNode) {
      return nodeProperties.outputNode.getNodeType(builder);
    }
    return this.nodeType;
  }
  /**
   * This method is used during the build process of a node and ensures
   * equal nodes are not built multiple times but just once. For example if
   * `attribute( 'uv' )` is used multiple times by the user, the build
   * process makes sure to process just the first node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {Node} The shared node if possible. Otherwise `this` is returned.
   */
  getShared(builder) {
    const hash3 = this.getHash(builder);
    const nodeFromHash = builder.getNodeFromHash(hash3);
    return nodeFromHash || this;
  }
  /**
   * Returns the number of elements in the node array.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {?number} The number of elements in the node array.
   */
  getArrayCount() {
    return null;
  }
  /**
   * Represents the setup stage which is the first step of the build process, see {@link Node#build} method.
   * This method is often overwritten in derived modules to prepare the node which is used as a node's output/result.
   * If an output node is prepared, then it must be returned in the `return` statement of the derived module's setup function.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {?Node} The output node.
   */
  setup(builder) {
    const nodeProperties = builder.getNodeProperties(this);
    let index5 = 0;
    for (const childNode of this.getChildren()) {
      nodeProperties["node" + index5++] = childNode;
    }
    return nodeProperties.outputNode || null;
  }
  /**
   * Represents the analyze stage which is the second step of the build process, see {@link Node#build} method.
   * This stage analyzes the node hierarchy and ensures descendent nodes are built.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {?Node} output - The target output node.
   */
  analyze(builder, output3 = null) {
    const usageCount = builder.increaseUsage(this);
    if (this.parents === true) {
      const nodeData = builder.getDataFromNode(this, "any");
      nodeData.stages = nodeData.stages || {};
      nodeData.stages[builder.shaderStage] = nodeData.stages[builder.shaderStage] || [];
      nodeData.stages[builder.shaderStage].push(output3);
    }
    if (usageCount === 1) {
      const nodeProperties = builder.getNodeProperties(this);
      for (const childNode of Object.values(nodeProperties)) {
        if (childNode && childNode.isNode === true) {
          childNode.build(builder, this);
        }
      }
    }
  }
  /**
   * Represents the generate stage which is the third step of the build process, see {@link Node#build} method.
   * This state builds the output node and returns the resulting shader string.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {?string} [output] - Can be used to define the output type.
   * @return {?string} The generated shader string.
   */
  generate(builder, output3) {
    const { outputNode } = builder.getNodeProperties(this);
    if (outputNode && outputNode.isNode === true) {
      return outputNode.build(builder, output3);
    }
  }
  /**
   * The method can be implemented to update the node's internal state before it is used to render an object.
   * The {@link Node#updateBeforeType} property defines how often the update is executed.
   *
   * @abstract
   * @param {NodeFrame} frame - A reference to the current node frame.
   * @return {?boolean} An optional bool that indicates whether the implementation actually performed an update or not (e.g. due to caching).
   */
  updateBefore() {
    console.warn("Abstract function.");
  }
  /**
   * The method can be implemented to update the node's internal state after it was used to render an object.
   * The {@link Node#updateAfterType} property defines how often the update is executed.
   *
   * @abstract
   * @param {NodeFrame} frame - A reference to the current node frame.
   * @return {?boolean} An optional bool that indicates whether the implementation actually performed an update or not (e.g. due to caching).
   */
  updateAfter() {
    console.warn("Abstract function.");
  }
  /**
   * The method can be implemented to update the node's internal state when it is used to render an object.
   * The {@link Node#updateType} property defines how often the update is executed.
   *
   * @abstract
   * @param {NodeFrame} frame - A reference to the current node frame.
   * @return {?boolean} An optional bool that indicates whether the implementation actually performed an update or not (e.g. due to caching).
   */
  update() {
    console.warn("Abstract function.");
  }
  /**
   * This method performs the build of a node. The behavior and return value depend on the current build stage:
   * - **setup**: Prepares the node and its children for the build process. This process can also create new nodes. Returns the node itself or a variant.
   * - **analyze**: Analyzes the node hierarchy for optimizations in the code generation stage. Returns `null`.
   * - **generate**: Generates the shader code for the node. Returns the generated shader string.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {?(string|Node)} [output=null] - Can be used to define the output type.
   * @return {?(Node|string)} The result of the build process, depending on the build stage.
   */
  build(builder, output3 = null) {
    const refNode = this.getShared(builder);
    if (this !== refNode) {
      return refNode.build(builder, output3);
    }
    const nodeData = builder.getDataFromNode(this);
    nodeData.buildStages = nodeData.buildStages || {};
    nodeData.buildStages[builder.buildStage] = true;
    const parentBuildStage = _parentBuildStage[builder.buildStage];
    if (parentBuildStage && nodeData.buildStages[parentBuildStage] !== true) {
      const previousBuildStage = builder.getBuildStage();
      builder.setBuildStage(parentBuildStage);
      this.build(builder);
      builder.setBuildStage(previousBuildStage);
    }
    builder.addNode(this);
    builder.addChain(this);
    let result = null;
    const buildStage = builder.getBuildStage();
    if (buildStage === "setup") {
      this.updateReference(builder);
      const properties = builder.getNodeProperties(this);
      if (properties.initialized !== true) {
        properties.initialized = true;
        properties.outputNode = this.setup(builder) || properties.outputNode || null;
        for (const childNode of Object.values(properties)) {
          if (childNode && childNode.isNode === true) {
            if (childNode.parents === true) {
              const childProperties = builder.getNodeProperties(childNode);
              childProperties.parents = childProperties.parents || [];
              childProperties.parents.push(this);
            }
            childNode.build(builder);
          }
        }
      }
      result = properties.outputNode;
    } else if (buildStage === "analyze") {
      this.analyze(builder, output3);
    } else if (buildStage === "generate") {
      const isGenerateOnce = this.generate.length === 1;
      if (isGenerateOnce) {
        const type = this.getNodeType(builder);
        const nodeData2 = builder.getDataFromNode(this);
        result = nodeData2.snippet;
        if (result === void 0) {
          if (nodeData2.generated === void 0) {
            nodeData2.generated = true;
            result = this.generate(builder) || "";
            nodeData2.snippet = result;
          } else {
            console.warn("THREE.Node: Recursion detected.", this);
            result = "/* Recursion detected. */";
          }
        } else if (nodeData2.flowCodes !== void 0 && builder.context.nodeBlock !== void 0) {
          builder.addFlowCodeHierarchy(this, builder.context.nodeBlock);
        }
        result = builder.format(result, type, output3);
      } else {
        result = this.generate(builder, output3) || "";
      }
      if (result === "" && output3 !== null && output3 !== "void" && output3 !== "OutputType") {
        console.error(`THREE.TSL: Invalid generated code, expected a "${output3}".`);
        result = builder.generateConst(output3);
      }
    }
    builder.removeChain(this);
    builder.addSequentialNode(this);
    return result;
  }
  /**
   * Returns the child nodes as a JSON object.
   *
   * @return {Generator<Object>} An iterable list of serialized child objects as JSON.
   */
  getSerializeChildren() {
    return getNodeChildren(this);
  }
  /**
   * Serializes the node to JSON.
   *
   * @param {Object} json - The output JSON object.
   */
  serialize(json) {
    const nodeChildren = this.getSerializeChildren();
    const inputNodes = {};
    for (const { property: property3, index: index5, childNode } of nodeChildren) {
      if (index5 !== void 0) {
        if (inputNodes[property3] === void 0) {
          inputNodes[property3] = Number.isInteger(index5) ? [] : {};
        }
        inputNodes[property3][index5] = childNode.toJSON(json.meta).uuid;
      } else {
        inputNodes[property3] = childNode.toJSON(json.meta).uuid;
      }
    }
    if (Object.keys(inputNodes).length > 0) {
      json.inputNodes = inputNodes;
    }
  }
  /**
   * Deserializes the node from the given JSON.
   *
   * @param {Object} json - The JSON object.
   */
  deserialize(json) {
    if (json.inputNodes !== void 0) {
      const nodes = json.meta.nodes;
      for (const property3 in json.inputNodes) {
        if (Array.isArray(json.inputNodes[property3])) {
          const inputArray = [];
          for (const uuid of json.inputNodes[property3]) {
            inputArray.push(nodes[uuid]);
          }
          this[property3] = inputArray;
        } else if (typeof json.inputNodes[property3] === "object") {
          const inputObject = {};
          for (const subProperty in json.inputNodes[property3]) {
            const uuid = json.inputNodes[property3][subProperty];
            inputObject[subProperty] = nodes[uuid];
          }
          this[property3] = inputObject;
        } else {
          const uuid = json.inputNodes[property3];
          this[property3] = nodes[uuid];
        }
      }
    }
  }
  /**
   * Serializes the node into the three.js JSON Object/Scene format.
   *
   * @param {?Object} meta - An optional JSON object that already holds serialized data from other scene objects.
   * @return {Object} The serialized node.
   */
  toJSON(meta) {
    const { uuid, type } = this;
    const isRoot = meta === void 0 || typeof meta === "string";
    if (isRoot) {
      meta = {
        textures: {},
        images: {},
        nodes: {}
      };
    }
    let data = meta.nodes[uuid];
    if (data === void 0) {
      data = {
        uuid,
        type,
        meta,
        metadata: {
          version: 4.7,
          type: "Node",
          generator: "Node.toJSON"
        }
      };
      if (isRoot !== true) meta.nodes[data.uuid] = data;
      this.serialize(data);
      delete data.meta;
    }
    function extractFromCache(cache3) {
      const values = [];
      for (const key in cache3) {
        const data2 = cache3[key];
        delete data2.metadata;
        values.push(data2);
      }
      return values;
    }
    if (isRoot) {
      const textures = extractFromCache(meta.textures);
      const images = extractFromCache(meta.images);
      const nodes = extractFromCache(meta.nodes);
      if (textures.length > 0) data.textures = textures;
      if (images.length > 0) data.images = images;
      if (nodes.length > 0) data.nodes = nodes;
    }
    return data;
  }
};
var ArrayElementNode = class extends Node {
  // @TODO: If extending from TempNode it breaks webgpu_compute
  static get type() {
    return "ArrayElementNode";
  }
  /**
   * Constructs an array element node.
   *
   * @param {Node} node - The array-like node.
   * @param {Node} indexNode - The index node that defines the element access.
   */
  constructor(node, indexNode) {
    super();
    this.node = node;
    this.indexNode = indexNode;
    this.isArrayElementNode = true;
  }
  /**
   * This method is overwritten since the node type is inferred from the array-like node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node type.
   */
  getNodeType(builder) {
    return this.node.getElementType(builder);
  }
  generate(builder) {
    const indexType = this.indexNode.getNodeType(builder);
    const nodeSnippet = this.node.build(builder);
    const indexSnippet = this.indexNode.build(builder, !builder.isVector(indexType) && builder.isInteger(indexType) ? indexType : "uint");
    return `${nodeSnippet}[ ${indexSnippet} ]`;
  }
};
var ConvertNode = class extends Node {
  static get type() {
    return "ConvertNode";
  }
  /**
   * Constructs a new convert node.
   *
   * @param {Node} node - The node which type should be converted.
   * @param {string} convertTo - The target node type. Multiple types can be defined by separating them with a `|` sign.
   */
  constructor(node, convertTo) {
    super();
    this.node = node;
    this.convertTo = convertTo;
  }
  /**
   * This method is overwritten since the implementation tries to infer the best
   * matching type from the {@link ConvertNode#convertTo} property.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node type.
   */
  getNodeType(builder) {
    const requestType = this.node.getNodeType(builder);
    let convertTo = null;
    for (const overloadingType of this.convertTo.split("|")) {
      if (convertTo === null || builder.getTypeLength(requestType) === builder.getTypeLength(overloadingType)) {
        convertTo = overloadingType;
      }
    }
    return convertTo;
  }
  serialize(data) {
    super.serialize(data);
    data.convertTo = this.convertTo;
  }
  deserialize(data) {
    super.deserialize(data);
    this.convertTo = data.convertTo;
  }
  generate(builder, output3) {
    const node = this.node;
    const type = this.getNodeType(builder);
    const snippet = node.build(builder, type);
    return builder.format(snippet, type, output3);
  }
};
var TempNode = class extends Node {
  static get type() {
    return "TempNode";
  }
  /**
   * Constructs a temp node.
   *
   * @param {?string} nodeType - The node type.
   */
  constructor(nodeType = null) {
    super(nodeType);
    this.isTempNode = true;
  }
  /**
   * Whether this node is used more than once in context of other nodes.
   *
   * @param {NodeBuilder} builder - The node builder.
   * @return {boolean} A flag that indicates if there is more than one dependency to other nodes.
   */
  hasDependencies(builder) {
    return builder.getDataFromNode(this).usageCount > 1;
  }
  build(builder, output3) {
    const buildStage = builder.getBuildStage();
    if (buildStage === "generate") {
      const type = builder.getVectorType(this.getNodeType(builder, output3));
      const nodeData = builder.getDataFromNode(this);
      if (nodeData.propertyName !== void 0) {
        return builder.format(nodeData.propertyName, type, output3);
      } else if (type !== "void" && output3 !== "void" && this.hasDependencies(builder)) {
        const snippet = super.build(builder, type);
        const nodeVar = builder.getVarFromNode(this, null, type);
        const propertyName = builder.getPropertyName(nodeVar);
        builder.addLineFlowCode(`${propertyName} = ${snippet}`, this);
        nodeData.snippet = snippet;
        nodeData.propertyName = propertyName;
        return builder.format(nodeData.propertyName, type, output3);
      }
    }
    return super.build(builder, output3);
  }
};
var JoinNode = class extends TempNode {
  static get type() {
    return "JoinNode";
  }
  /**
   * Constructs a new join node.
   *
   * @param {Array<Node>} nodes - An array of nodes that should be joined.
   * @param {?string} [nodeType=null] - The node type.
   */
  constructor(nodes = [], nodeType = null) {
    super(nodeType);
    this.nodes = nodes;
  }
  /**
   * This method is overwritten since the node type must be inferred from the
   * joined data length if not explicitly defined.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node type.
   */
  getNodeType(builder) {
    if (this.nodeType !== null) {
      return builder.getVectorType(this.nodeType);
    }
    return builder.getTypeFromLength(this.nodes.reduce((count2, cur) => count2 + builder.getTypeLength(cur.getNodeType(builder)), 0));
  }
  generate(builder, output3) {
    const type = this.getNodeType(builder);
    const maxLength = builder.getTypeLength(type);
    const nodes = this.nodes;
    const primitiveType = builder.getComponentType(type);
    const snippetValues = [];
    let length3 = 0;
    for (const input of nodes) {
      if (length3 >= maxLength) {
        console.error(`THREE.TSL: Length of parameters exceeds maximum length of function '${type}()' type.`);
        break;
      }
      let inputType = input.getNodeType(builder);
      let inputTypeLength = builder.getTypeLength(inputType);
      let inputSnippet;
      if (length3 + inputTypeLength > maxLength) {
        console.error(`THREE.TSL: Length of '${type}()' data exceeds maximum length of output type.`);
        inputTypeLength = maxLength - length3;
        inputType = builder.getTypeFromLength(inputTypeLength);
      }
      length3 += inputTypeLength;
      inputSnippet = input.build(builder, inputType);
      const inputPrimitiveType = builder.getComponentType(inputType);
      if (inputPrimitiveType !== primitiveType) {
        const targetType = builder.getTypeFromLength(inputTypeLength, primitiveType);
        inputSnippet = builder.format(inputSnippet, inputType, targetType);
      }
      snippetValues.push(inputSnippet);
    }
    const snippet = `${builder.getType(type)}( ${snippetValues.join(", ")} )`;
    return builder.format(snippet, type, output3);
  }
};
var _stringVectorComponents = vectorComponents.join("");
var SplitNode = class extends Node {
  static get type() {
    return "SplitNode";
  }
  /**
   * Constructs a new split node.
   *
   * @param {Node} node - The node that should be accessed.
   * @param {string} [components='x'] - The components that should be accessed.
   */
  constructor(node, components = "x") {
    super();
    this.node = node;
    this.components = components;
    this.isSplitNode = true;
  }
  /**
   * Returns the vector length which is computed based on the requested components.
   *
   * @return {number} The vector length.
   */
  getVectorLength() {
    let vectorLength = this.components.length;
    for (const c3 of this.components) {
      vectorLength = Math.max(vectorComponents.indexOf(c3) + 1, vectorLength);
    }
    return vectorLength;
  }
  /**
   * Returns the component type of the node's type.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The component type.
   */
  getComponentType(builder) {
    return builder.getComponentType(this.node.getNodeType(builder));
  }
  /**
   * This method is overwritten since the node type is inferred from requested components.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node type.
   */
  getNodeType(builder) {
    return builder.getTypeFromLength(this.components.length, this.getComponentType(builder));
  }
  /**
   * Returns the scope of the node.
   *
   * @return {Node} The scope of the node.
   */
  getScope() {
    return this.node.getScope();
  }
  generate(builder, output3) {
    const node = this.node;
    const nodeTypeLength = builder.getTypeLength(node.getNodeType(builder));
    let snippet = null;
    if (nodeTypeLength > 1) {
      let type = null;
      const componentsLength = this.getVectorLength();
      if (componentsLength >= nodeTypeLength) {
        type = builder.getTypeFromLength(this.getVectorLength(), this.getComponentType(builder));
      }
      const nodeSnippet = node.build(builder, type);
      if (this.components.length === nodeTypeLength && this.components === _stringVectorComponents.slice(0, this.components.length)) {
        snippet = builder.format(nodeSnippet, type, output3);
      } else {
        snippet = builder.format(`${nodeSnippet}.${this.components}`, this.getNodeType(builder), output3);
      }
    } else {
      snippet = node.build(builder, output3);
    }
    return snippet;
  }
  serialize(data) {
    super.serialize(data);
    data.components = this.components;
  }
  deserialize(data) {
    super.deserialize(data);
    this.components = data.components;
  }
};
var SetNode = class extends TempNode {
  static get type() {
    return "SetNode";
  }
  /**
   * Constructs a new set node.
   *
   * @param {Node} sourceNode - The node that should be updated.
   * @param {string} components - The components that should be updated.
   * @param {Node} targetNode - The value node.
   */
  constructor(sourceNode, components, targetNode) {
    super();
    this.sourceNode = sourceNode;
    this.components = components;
    this.targetNode = targetNode;
  }
  /**
   * This method is overwritten since the node type is inferred from {@link SetNode#sourceNode}.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node type.
   */
  getNodeType(builder) {
    return this.sourceNode.getNodeType(builder);
  }
  generate(builder) {
    const { sourceNode, components, targetNode } = this;
    const sourceType = this.getNodeType(builder);
    const componentType = builder.getComponentType(targetNode.getNodeType(builder));
    const targetType = builder.getTypeFromLength(components.length, componentType);
    const targetSnippet = targetNode.build(builder, targetType);
    const sourceSnippet = sourceNode.build(builder, sourceType);
    const length3 = builder.getTypeLength(sourceType);
    const snippetValues = [];
    for (let i = 0; i < length3; i++) {
      const component = vectorComponents[i];
      if (component === components[0]) {
        snippetValues.push(targetSnippet);
        i += components.length - 1;
      } else {
        snippetValues.push(sourceSnippet + "." + component);
      }
    }
    return `${builder.getType(sourceType)}( ${snippetValues.join(", ")} )`;
  }
};
var FlipNode = class extends TempNode {
  static get type() {
    return "FlipNode";
  }
  /**
   * Constructs a new flip node.
   *
   * @param {Node} sourceNode - The node which component(s) should be flipped.
   * @param {string} components - The components that should be flipped e.g. `'x'` or `'xy'`.
   */
  constructor(sourceNode, components) {
    super();
    this.sourceNode = sourceNode;
    this.components = components;
  }
  /**
   * This method is overwritten since the node type is inferred from the source node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node type.
   */
  getNodeType(builder) {
    return this.sourceNode.getNodeType(builder);
  }
  generate(builder) {
    const { components, sourceNode } = this;
    const sourceType = this.getNodeType(builder);
    const sourceSnippet = sourceNode.build(builder);
    const sourceCache = builder.getVarFromNode(this);
    const sourceProperty = builder.getPropertyName(sourceCache);
    builder.addLineFlowCode(sourceProperty + " = " + sourceSnippet, this);
    const length3 = builder.getTypeLength(sourceType);
    const snippetValues = [];
    let componentIndex = 0;
    for (let i = 0; i < length3; i++) {
      const component = vectorComponents[i];
      if (component === components[componentIndex]) {
        snippetValues.push("1.0 - " + (sourceProperty + "." + component));
        componentIndex++;
      } else {
        snippetValues.push(sourceProperty + "." + component);
      }
    }
    return `${builder.getType(sourceType)}( ${snippetValues.join(", ")} )`;
  }
};
var InputNode = class extends Node {
  static get type() {
    return "InputNode";
  }
  /**
   * Constructs a new input node.
   *
   * @param {any} value - The value of this node. This can be any JS primitive, functions, array buffers or even three.js objects (vector, matrices, colors).
   * @param {?string} nodeType - The node type. If no explicit type is defined, the node tries to derive the type from its value.
   */
  constructor(value, nodeType = null) {
    super(nodeType);
    this.isInputNode = true;
    this.value = value;
    this.precision = null;
  }
  getNodeType() {
    if (this.nodeType === null) {
      return getValueType(this.value);
    }
    return this.nodeType;
  }
  /**
   * Returns the input type of the node which is by default the node type. Derived modules
   * might overwrite this method and use a fixed type or compute one analytically.
   *
   * A typical example for different input and node types are textures. The input type of a
   * normal RGBA texture is `texture` whereas its node type is `vec4`.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The input type.
   */
  getInputType(builder) {
    return this.getNodeType(builder);
  }
  /**
   * Sets the precision to the given value. The method can be
   * overwritten in derived classes if the final precision must be computed
   * analytically.
   *
   * @param {('low'|'medium'|'high')} precision - The precision of the input value in the shader.
   * @return {InputNode} A reference to this node.
   */
  setPrecision(precision) {
    this.precision = precision;
    return this;
  }
  serialize(data) {
    super.serialize(data);
    data.value = this.value;
    if (this.value && this.value.toArray) data.value = this.value.toArray();
    data.valueType = getValueType(this.value);
    data.nodeType = this.nodeType;
    if (data.valueType === "ArrayBuffer") data.value = arrayBufferToBase64(data.value);
    data.precision = this.precision;
  }
  deserialize(data) {
    super.deserialize(data);
    this.nodeType = data.nodeType;
    this.value = Array.isArray(data.value) ? getValueFromType(data.valueType, ...data.value) : data.value;
    this.precision = data.precision || null;
    if (this.value && this.value.fromArray) this.value = this.value.fromArray(data.value);
  }
  generate() {
    console.warn("Abstract function.");
  }
};
var _regNum = /float|u?int/;
var ConstNode = class extends InputNode {
  static get type() {
    return "ConstNode";
  }
  /**
   * Constructs a new input node.
   *
   * @param {any} value - The value of this node. Usually a JS primitive or three.js object (vector, matrix, color).
   * @param {?string} nodeType - The node type. If no explicit type is defined, the node tries to derive the type from its value.
   */
  constructor(value, nodeType = null) {
    super(value, nodeType);
    this.isConstNode = true;
  }
  /**
   * Generates the shader string of the value with the current node builder.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The generated value as a shader string.
   */
  generateConst(builder) {
    return builder.generateConst(this.getNodeType(builder), this.value);
  }
  generate(builder, output3) {
    const type = this.getNodeType(builder);
    if (_regNum.test(type) && _regNum.test(output3)) {
      return builder.generateConst(output3, this.value);
    }
    return builder.format(this.generateConst(builder), type, output3);
  }
};
var MemberNode = class extends Node {
  static get type() {
    return "MemberNode";
  }
  /**
   * Constructs a member node.
   *
   * @param {Node} structNode - The struct node.
   * @param {string} property - The property name.
   */
  constructor(structNode, property3) {
    super();
    this.structNode = structNode;
    this.property = property3;
    this.isMemberNode = true;
  }
  hasMember(builder) {
    if (this.structNode.isMemberNode) {
      if (this.structNode.hasMember(builder) === false) {
        return false;
      }
    }
    return this.structNode.getMemberType(builder, this.property) !== "void";
  }
  getNodeType(builder) {
    if (this.hasMember(builder) === false) {
      return "float";
    }
    return this.structNode.getMemberType(builder, this.property);
  }
  getMemberType(builder, name) {
    if (this.hasMember(builder) === false) {
      return "float";
    }
    const type = this.getNodeType(builder);
    const struct3 = builder.getStructTypeNode(type);
    return struct3.getMemberType(builder, name);
  }
  generate(builder) {
    if (this.hasMember(builder) === false) {
      console.warn(`THREE.TSL: Member "${this.property}" does not exist in struct.`);
      const type = this.getNodeType(builder);
      return builder.generateConst(type);
    }
    const propertyName = this.structNode.build(builder);
    return propertyName + "." + this.property;
  }
};
var currentStack = null;
var NodeElements = /* @__PURE__ */ new Map();
function addMethodChaining(name, nodeElement) {
  if (NodeElements.has(name)) {
    console.warn(`THREE.TSL: Redefinition of method chaining '${name}'.`);
    return;
  }
  if (typeof nodeElement !== "function") throw new Error(`THREE.TSL: Node element ${name} is not a function`);
  NodeElements.set(name, nodeElement);
  if (name !== "assign") {
    Node.prototype[name] = function(...params) {
      return this.isStackNode ? this.add(nodeElement(...params)) : nodeElement(this, ...params);
    };
    Node.prototype[name + "Assign"] = function(...params) {
      return this.isStackNode ? this.assign(params[0], nodeElement(...params)) : this.assign(nodeElement(this, ...params));
    };
  }
}
var parseSwizzle = (props) => props.replace(/r|s/g, "x").replace(/g|t/g, "y").replace(/b|p/g, "z").replace(/a|q/g, "w");
var parseSwizzleAndSort = (props) => parseSwizzle(props).split("").sort().join("");
Node.prototype.assign = function(...params) {
  if (this.isStackNode !== true) {
    if (currentStack !== null) {
      currentStack.assign(this, ...params);
    } else {
      console.error("THREE.TSL: No stack defined for assign operation. Make sure the assign is inside a Fn().");
    }
    return this;
  } else {
    const nodeElement = NodeElements.get("assign");
    return this.add(nodeElement(...params));
  }
};
Node.prototype.toVarIntent = function() {
  return this;
};
Node.prototype.get = function(value) {
  return new MemberNode(this, value);
};
var proto = {};
function setProtoSwizzle(property3, altA, altB) {
  proto[property3] = proto[altA] = proto[altB] = {
    get() {
      this._cache = this._cache || {};
      let split3 = this._cache[property3];
      if (split3 === void 0) {
        split3 = new SplitNode(this, property3);
        this._cache[property3] = split3;
      }
      return split3;
    },
    set(value) {
      this[property3].assign(nodeObject(value));
    }
  };
  const propUpper = property3.toUpperCase();
  const altAUpper = altA.toUpperCase();
  const altBUpper = altB.toUpperCase();
  Node.prototype["set" + propUpper] = Node.prototype["set" + altAUpper] = Node.prototype["set" + altBUpper] = function(value) {
    const swizzle = parseSwizzleAndSort(property3);
    return new SetNode(this, swizzle, nodeObject(value));
  };
  Node.prototype["flip" + propUpper] = Node.prototype["flip" + altAUpper] = Node.prototype["flip" + altBUpper] = function() {
    const swizzle = parseSwizzleAndSort(property3);
    return new FlipNode(this, swizzle);
  };
}
var swizzleA = ["x", "y", "z", "w"];
var swizzleB = ["r", "g", "b", "a"];
var swizzleC = ["s", "t", "p", "q"];
for (let a = 0; a < 4; a++) {
  let prop = swizzleA[a];
  let altA = swizzleB[a];
  let altB = swizzleC[a];
  setProtoSwizzle(prop, altA, altB);
  for (let b = 0; b < 4; b++) {
    prop = swizzleA[a] + swizzleA[b];
    altA = swizzleB[a] + swizzleB[b];
    altB = swizzleC[a] + swizzleC[b];
    setProtoSwizzle(prop, altA, altB);
    for (let c3 = 0; c3 < 4; c3++) {
      prop = swizzleA[a] + swizzleA[b] + swizzleA[c3];
      altA = swizzleB[a] + swizzleB[b] + swizzleB[c3];
      altB = swizzleC[a] + swizzleC[b] + swizzleC[c3];
      setProtoSwizzle(prop, altA, altB);
      for (let d = 0; d < 4; d++) {
        prop = swizzleA[a] + swizzleA[b] + swizzleA[c3] + swizzleA[d];
        altA = swizzleB[a] + swizzleB[b] + swizzleB[c3] + swizzleB[d];
        altB = swizzleC[a] + swizzleC[b] + swizzleC[c3] + swizzleC[d];
        setProtoSwizzle(prop, altA, altB);
      }
    }
  }
}
for (let i = 0; i < 32; i++) {
  proto[i] = {
    get() {
      this._cache = this._cache || {};
      let element3 = this._cache[i];
      if (element3 === void 0) {
        element3 = new ArrayElementNode(this, new ConstNode(i, "uint"));
        this._cache[i] = element3;
      }
      return element3;
    },
    set(value) {
      this[i].assign(nodeObject(value));
    }
  };
}
Object.defineProperties(Node.prototype, proto);
var nodeBuilderFunctionsCacheMap = /* @__PURE__ */ new WeakMap();
var ShaderNodeObject = function(obj, altType = null) {
  const type = getValueType(obj);
  if (type === "node") {
    return obj;
  } else if (altType === null && (type === "float" || type === "boolean") || type && type !== "shader" && type !== "string") {
    return nodeObject(getConstNode(obj, altType));
  } else if (type === "shader") {
    return obj.isFn ? obj : Fn(obj);
  }
  return obj;
};
var ShaderNodeObjects = function(objects, altType = null) {
  for (const name in objects) {
    objects[name] = nodeObject(objects[name], altType);
  }
  return objects;
};
var ShaderNodeArray = function(array4, altType = null) {
  const len = array4.length;
  for (let i = 0; i < len; i++) {
    array4[i] = nodeObject(array4[i], altType);
  }
  return array4;
};
var ShaderNodeProxy = function(NodeClass, scope = null, factor = null, settings = null) {
  function assignNode(node) {
    if (settings !== null) {
      node = nodeObject(Object.assign(node, settings));
      if (settings.intent === true) {
        node = node.toVarIntent();
      }
    } else {
      node = nodeObject(node);
    }
    return node;
  }
  let fn, name = scope, minParams, maxParams;
  function verifyParamsLimit(params) {
    let tslName;
    if (name) tslName = /[a-z]/i.test(name) ? name + "()" : name;
    else tslName = NodeClass.type;
    if (minParams !== void 0 && params.length < minParams) {
      console.error(`THREE.TSL: "${tslName}" parameter length is less than minimum required.`);
      return params.concat(new Array(minParams - params.length).fill(0));
    } else if (maxParams !== void 0 && params.length > maxParams) {
      console.error(`THREE.TSL: "${tslName}" parameter length exceeds limit.`);
      return params.slice(0, maxParams);
    }
    return params;
  }
  if (scope === null) {
    fn = (...params) => {
      return assignNode(new NodeClass(...nodeArray(verifyParamsLimit(params))));
    };
  } else if (factor !== null) {
    factor = nodeObject(factor);
    fn = (...params) => {
      return assignNode(new NodeClass(scope, ...nodeArray(verifyParamsLimit(params)), factor));
    };
  } else {
    fn = (...params) => {
      return assignNode(new NodeClass(scope, ...nodeArray(verifyParamsLimit(params))));
    };
  }
  fn.setParameterLength = (...params) => {
    if (params.length === 1) minParams = maxParams = params[0];
    else if (params.length === 2) [minParams, maxParams] = params;
    return fn;
  };
  fn.setName = (value) => {
    name = value;
    return fn;
  };
  return fn;
};
var ShaderNodeImmutable = function(NodeClass, ...params) {
  return nodeObject(new NodeClass(...nodeArray(params)));
};
var ShaderCallNodeInternal = class extends Node {
  constructor(shaderNode, rawInputs) {
    super();
    this.shaderNode = shaderNode;
    this.rawInputs = rawInputs;
    this.isShaderCallNodeInternal = true;
  }
  getNodeType(builder) {
    return this.shaderNode.nodeType || this.getOutputNode(builder).getNodeType(builder);
  }
  getMemberType(builder, name) {
    return this.getOutputNode(builder).getMemberType(builder, name);
  }
  call(builder) {
    const { shaderNode, rawInputs } = this;
    const properties = builder.getNodeProperties(shaderNode);
    const subBuild3 = builder.getClosestSubBuild(shaderNode.subBuilds) || "";
    const subBuildProperty = subBuild3 || "default";
    if (properties[subBuildProperty]) {
      return properties[subBuildProperty];
    }
    const previousSubBuildFn = builder.subBuildFn;
    builder.subBuildFn = subBuild3;
    let result = null;
    if (shaderNode.layout) {
      let functionNodesCacheMap = nodeBuilderFunctionsCacheMap.get(builder.constructor);
      if (functionNodesCacheMap === void 0) {
        functionNodesCacheMap = /* @__PURE__ */ new WeakMap();
        nodeBuilderFunctionsCacheMap.set(builder.constructor, functionNodesCacheMap);
      }
      let functionNode = functionNodesCacheMap.get(shaderNode);
      if (functionNode === void 0) {
        functionNode = nodeObject(builder.buildFunctionNode(shaderNode));
        functionNodesCacheMap.set(shaderNode, functionNode);
      }
      builder.addInclude(functionNode);
      const inputs = rawInputs ? getLayoutParameters(rawInputs) : null;
      result = nodeObject(functionNode.call(inputs));
    } else {
      const secureNodeBuilder = new Proxy(builder, {
        get: (target, property3, receiver) => {
          let value;
          if (Symbol.iterator === property3) {
            value = function* () {
              yield void 0;
            };
          } else {
            value = Reflect.get(target, property3, receiver);
          }
          return value;
        }
      });
      const inputs = rawInputs ? getProxyParameters(rawInputs) : null;
      const hasParameters = Array.isArray(rawInputs) ? rawInputs.length > 0 : rawInputs !== null;
      const jsFunc = shaderNode.jsFunc;
      const outputNode = hasParameters || jsFunc.length > 1 ? jsFunc(inputs, secureNodeBuilder) : jsFunc(secureNodeBuilder);
      result = nodeObject(outputNode);
    }
    builder.subBuildFn = previousSubBuildFn;
    if (shaderNode.once) {
      properties[subBuildProperty] = result;
    }
    return result;
  }
  setupOutput(builder) {
    builder.addStack();
    builder.stack.outputNode = this.call(builder);
    return builder.removeStack();
  }
  getOutputNode(builder) {
    const properties = builder.getNodeProperties(this);
    const subBuildOutput = builder.getSubBuildOutput(this);
    properties[subBuildOutput] = properties[subBuildOutput] || this.setupOutput(builder);
    properties[subBuildOutput].subBuild = builder.getClosestSubBuild(this);
    return properties[subBuildOutput];
  }
  build(builder, output3 = null) {
    let result = null;
    const buildStage = builder.getBuildStage();
    const properties = builder.getNodeProperties(this);
    const subBuildOutput = builder.getSubBuildOutput(this);
    const outputNode = this.getOutputNode(builder);
    if (buildStage === "setup") {
      const subBuildInitialized = builder.getSubBuildProperty("initialized", this);
      if (properties[subBuildInitialized] !== true) {
        properties[subBuildInitialized] = true;
        properties[subBuildOutput] = this.getOutputNode(builder);
        properties[subBuildOutput].build(builder);
        if (this.shaderNode.subBuilds) {
          for (const node of builder.chaining) {
            const nodeData = builder.getDataFromNode(node, "any");
            nodeData.subBuilds = nodeData.subBuilds || /* @__PURE__ */ new Set();
            for (const subBuild3 of this.shaderNode.subBuilds) {
              nodeData.subBuilds.add(subBuild3);
            }
          }
        }
      }
      result = properties[subBuildOutput];
    } else if (buildStage === "analyze") {
      outputNode.build(builder, output3);
    } else if (buildStage === "generate") {
      result = outputNode.build(builder, output3) || "";
    }
    return result;
  }
};
function getLayoutParameters(params) {
  let output3;
  nodeObjects(params);
  const isArrayAsParameter = params[0] && (params[0].isNode || Object.getPrototypeOf(params[0]) !== Object.prototype);
  if (isArrayAsParameter) {
    output3 = [...params];
  } else {
    output3 = params[0];
  }
  return output3;
}
function getProxyParameters(params) {
  let index5 = 0;
  nodeObjects(params);
  return new Proxy(params, {
    get: (target, property3, receiver) => {
      let value;
      if (property3 === "length") {
        value = params.length;
        return value;
      }
      if (Symbol.iterator === property3) {
        value = function* () {
          for (const inputNode of params) {
            yield nodeObject(inputNode);
          }
        };
      } else {
        if (params.length > 0) {
          if (Object.getPrototypeOf(params[0]) === Object.prototype) {
            const objectTarget = params[0];
            if (objectTarget[property3] === void 0) {
              value = objectTarget[index5++];
            } else {
              value = Reflect.get(objectTarget, property3, receiver);
            }
          } else if (params[0] instanceof Node) {
            if (params[property3] === void 0) {
              value = params[index5++];
            } else {
              value = Reflect.get(params, property3, receiver);
            }
          }
        } else {
          value = Reflect.get(target, property3, receiver);
        }
        value = nodeObject(value);
      }
      return value;
    }
  });
}
var ShaderNodeInternal = class extends Node {
  constructor(jsFunc, nodeType) {
    super(nodeType);
    this.jsFunc = jsFunc;
    this.layout = null;
    this.global = true;
    this.once = false;
  }
  setLayout(layout) {
    this.layout = layout;
    return this;
  }
  call(rawInputs = null) {
    return nodeObject(new ShaderCallNodeInternal(this, rawInputs));
  }
  setup() {
    return this.call();
  }
};
var bools = [false, true];
var uints = [0, 1, 2, 3];
var ints = [-1, -2];
var floats = [0.5, 1.5, 1 / 3, 1e-6, 1e6, Math.PI, Math.PI * 2, 1 / Math.PI, 2 / Math.PI, 1 / (Math.PI * 2), Math.PI / 2];
var boolsCacheMap = /* @__PURE__ */ new Map();
for (const bool3 of bools) boolsCacheMap.set(bool3, new ConstNode(bool3));
var uintsCacheMap = /* @__PURE__ */ new Map();
for (const uint3 of uints) uintsCacheMap.set(uint3, new ConstNode(uint3, "uint"));
var intsCacheMap = new Map([...uintsCacheMap].map((el) => new ConstNode(el.value, "int")));
for (const int3 of ints) intsCacheMap.set(int3, new ConstNode(int3, "int"));
var floatsCacheMap = new Map([...intsCacheMap].map((el) => new ConstNode(el.value)));
for (const float3 of floats) floatsCacheMap.set(float3, new ConstNode(float3));
for (const float3 of floats) floatsCacheMap.set(-float3, new ConstNode(-float3));
var cacheMaps = { bool: boolsCacheMap, uint: uintsCacheMap, ints: intsCacheMap, float: floatsCacheMap };
var constNodesCacheMap = new Map([...boolsCacheMap, ...floatsCacheMap]);
var getConstNode = (value, type) => {
  if (constNodesCacheMap.has(value)) {
    return constNodesCacheMap.get(value);
  } else if (value.isNode === true) {
    return value;
  } else {
    return new ConstNode(value, type);
  }
};
var ConvertType = function(type, cacheMap = null) {
  return (...params) => {
    for (const param of params) {
      if (param === void 0) {
        console.error(`THREE.TSL: Invalid parameter for the type "${type}".`);
        return nodeObject(new ConstNode(0, type));
      }
    }
    if (params.length === 0 || !["bool", "float", "int", "uint"].includes(type) && params.every((param) => {
      const paramType = typeof param;
      return paramType !== "object" && paramType !== "function";
    })) {
      params = [getValueFromType(type, ...params)];
    }
    if (params.length === 1 && cacheMap !== null && cacheMap.has(params[0])) {
      return nodeObjectIntent(cacheMap.get(params[0]));
    }
    if (params.length === 1) {
      const node = getConstNode(params[0], type);
      if (node.nodeType === type) return nodeObjectIntent(node);
      return nodeObjectIntent(new ConvertNode(node, type));
    }
    const nodes = params.map((param) => getConstNode(param));
    return nodeObjectIntent(new JoinNode(nodes, type));
  };
};
var defined = (v2) => typeof v2 === "object" && v2 !== null ? v2.value : v2;
var getConstNodeType = (value) => value !== void 0 && value !== null ? value.nodeType || value.convertTo || (typeof value === "string" ? value : null) : null;
function ShaderNode(jsFunc, nodeType) {
  return new ShaderNodeInternal(jsFunc, nodeType);
}
var nodeObject = (val, altType = null) => (
  /* new */
  ShaderNodeObject(val, altType)
);
var nodeObjectIntent = (val, altType = null) => (
  /* new */
  nodeObject(val, altType).toVarIntent()
);
var nodeObjects = (val, altType = null) => new ShaderNodeObjects(val, altType);
var nodeArray = (val, altType = null) => new ShaderNodeArray(val, altType);
var nodeProxy = (NodeClass, scope = null, factor = null, settings = null) => new ShaderNodeProxy(NodeClass, scope, factor, settings);
var nodeImmutable = (NodeClass, ...params) => new ShaderNodeImmutable(NodeClass, ...params);
var nodeProxyIntent = (NodeClass, scope = null, factor = null, settings = {}) => new ShaderNodeProxy(NodeClass, scope, factor, { intent: true, ...settings });
var fnId = 0;
var FnNode = class extends Node {
  constructor(jsFunc, layout = null) {
    super();
    let nodeType = null;
    if (layout !== null) {
      if (typeof layout === "object") {
        nodeType = layout.return;
      } else {
        if (typeof layout === "string") {
          nodeType = layout;
        } else {
          console.error("THREE.TSL: Invalid layout type.");
        }
        layout = null;
      }
    }
    this.shaderNode = new ShaderNode(jsFunc, nodeType);
    if (layout !== null) {
      this.setLayout(layout);
    }
    this.isFn = true;
  }
  setLayout(layout) {
    const nodeType = this.shaderNode.nodeType;
    if (typeof layout.inputs !== "object") {
      const fullLayout = {
        name: "fn" + fnId++,
        type: nodeType,
        inputs: []
      };
      for (const name in layout) {
        if (name === "return") continue;
        fullLayout.inputs.push({
          name,
          type: layout[name]
        });
      }
      layout = fullLayout;
    }
    this.shaderNode.setLayout(layout);
    return this;
  }
  getNodeType(builder) {
    return this.shaderNode.getNodeType(builder) || "float";
  }
  call(...params) {
    const fnCall = this.shaderNode.call(params);
    if (this.shaderNode.nodeType === "void") fnCall.toStack();
    return fnCall.toVarIntent();
  }
  once(subBuilds = null) {
    this.shaderNode.once = true;
    this.shaderNode.subBuilds = subBuilds;
    return this;
  }
  generate(builder) {
    const type = this.getNodeType(builder);
    console.error('THREE.TSL: "Fn()" was declared but not invoked. Try calling it like "Fn()( ...params )".');
    return builder.generateConst(type);
  }
};
function Fn(jsFunc, layout = null) {
  const instance3 = new FnNode(jsFunc, layout);
  return new Proxy(() => {
  }, {
    apply(target, thisArg, params) {
      return instance3.call(...params);
    },
    get(target, prop, receiver) {
      return Reflect.get(instance3, prop, receiver);
    },
    set(target, prop, value, receiver) {
      return Reflect.set(instance3, prop, value, receiver);
    }
  });
}
var setCurrentStack = (stack3) => {
  currentStack = stack3;
};
var getCurrentStack = () => currentStack;
var If = (...params) => currentStack.If(...params);
var Switch = (...params) => currentStack.Switch(...params);
function Stack(node) {
  if (currentStack) currentStack.add(node);
  return node;
}
addMethodChaining("toStack", Stack);
var color2 = new ConvertType("color");
var float = new ConvertType("float", cacheMaps.float);
var int = new ConvertType("int", cacheMaps.ints);
var uint = new ConvertType("uint", cacheMaps.uint);
var bool = new ConvertType("bool", cacheMaps.bool);
var vec2 = new ConvertType("vec2");
var ivec2 = new ConvertType("ivec2");
var uvec2 = new ConvertType("uvec2");
var bvec2 = new ConvertType("bvec2");
var vec3 = new ConvertType("vec3");
var ivec3 = new ConvertType("ivec3");
var uvec3 = new ConvertType("uvec3");
var bvec3 = new ConvertType("bvec3");
var vec4 = new ConvertType("vec4");
var ivec4 = new ConvertType("ivec4");
var uvec4 = new ConvertType("uvec4");
var bvec4 = new ConvertType("bvec4");
var mat2 = new ConvertType("mat2");
var mat3 = new ConvertType("mat3");
var mat4 = new ConvertType("mat4");
var string = (value = "") => nodeObject(new ConstNode(value, "string"));
var arrayBuffer = (value) => nodeObject(new ConstNode(value, "ArrayBuffer"));
addMethodChaining("toColor", color2);
addMethodChaining("toFloat", float);
addMethodChaining("toInt", int);
addMethodChaining("toUint", uint);
addMethodChaining("toBool", bool);
addMethodChaining("toVec2", vec2);
addMethodChaining("toIVec2", ivec2);
addMethodChaining("toUVec2", uvec2);
addMethodChaining("toBVec2", bvec2);
addMethodChaining("toVec3", vec3);
addMethodChaining("toIVec3", ivec3);
addMethodChaining("toUVec3", uvec3);
addMethodChaining("toBVec3", bvec3);
addMethodChaining("toVec4", vec4);
addMethodChaining("toIVec4", ivec4);
addMethodChaining("toUVec4", uvec4);
addMethodChaining("toBVec4", bvec4);
addMethodChaining("toMat2", mat2);
addMethodChaining("toMat3", mat3);
addMethodChaining("toMat4", mat4);
var element = nodeProxy(ArrayElementNode).setParameterLength(2);
var convert = (node, types) => nodeObject(new ConvertNode(nodeObject(node), types));
var split = (node, channels) => nodeObject(new SplitNode(nodeObject(node), channels));
addMethodChaining("element", element);
addMethodChaining("convert", convert);
var append = (node) => {
  console.warn("THREE.TSL: append() has been renamed to Stack().");
  return Stack(node);
};
addMethodChaining("append", (node) => {
  console.warn("THREE.TSL: .append() has been renamed to .toStack().");
  return Stack(node);
});
var PropertyNode = class extends Node {
  static get type() {
    return "PropertyNode";
  }
  /**
   * Constructs a new property node.
   *
   * @param {string} nodeType - The type of the node.
   * @param {?string} [name=null] - The name of the property in the shader.
   * @param {boolean} [varying=false] - Whether this property is a varying or not.
   */
  constructor(nodeType, name = null, varying3 = false) {
    super(nodeType);
    this.name = name;
    this.varying = varying3;
    this.isPropertyNode = true;
    this.global = true;
  }
  getHash(builder) {
    return this.name || super.getHash(builder);
  }
  generate(builder) {
    let nodeVar;
    if (this.varying === true) {
      nodeVar = builder.getVaryingFromNode(this, this.name);
      nodeVar.needsInterpolation = true;
    } else {
      nodeVar = builder.getVarFromNode(this, this.name);
    }
    return builder.getPropertyName(nodeVar);
  }
};
var property = (type, name) => nodeObject(new PropertyNode(type, name));
var varyingProperty = (type, name) => nodeObject(new PropertyNode(type, name, true));
var diffuseColor = nodeImmutable(PropertyNode, "vec4", "DiffuseColor");
var emissive = nodeImmutable(PropertyNode, "vec3", "EmissiveColor");
var roughness = nodeImmutable(PropertyNode, "float", "Roughness");
var metalness = nodeImmutable(PropertyNode, "float", "Metalness");
var clearcoat = nodeImmutable(PropertyNode, "float", "Clearcoat");
var clearcoatRoughness = nodeImmutable(PropertyNode, "float", "ClearcoatRoughness");
var sheen = nodeImmutable(PropertyNode, "vec3", "Sheen");
var sheenRoughness = nodeImmutable(PropertyNode, "float", "SheenRoughness");
var iridescence = nodeImmutable(PropertyNode, "float", "Iridescence");
var iridescenceIOR = nodeImmutable(PropertyNode, "float", "IridescenceIOR");
var iridescenceThickness = nodeImmutable(PropertyNode, "float", "IridescenceThickness");
var alphaT = nodeImmutable(PropertyNode, "float", "AlphaT");
var anisotropy = nodeImmutable(PropertyNode, "float", "Anisotropy");
var anisotropyT = nodeImmutable(PropertyNode, "vec3", "AnisotropyT");
var anisotropyB = nodeImmutable(PropertyNode, "vec3", "AnisotropyB");
var specularColor = nodeImmutable(PropertyNode, "color", "SpecularColor");
var specularF90 = nodeImmutable(PropertyNode, "float", "SpecularF90");
var shininess = nodeImmutable(PropertyNode, "float", "Shininess");
var output = nodeImmutable(PropertyNode, "vec4", "Output");
var dashSize = nodeImmutable(PropertyNode, "float", "dashSize");
var gapSize = nodeImmutable(PropertyNode, "float", "gapSize");
var pointWidth = nodeImmutable(PropertyNode, "float", "pointWidth");
var ior = nodeImmutable(PropertyNode, "float", "IOR");
var transmission = nodeImmutable(PropertyNode, "float", "Transmission");
var thickness = nodeImmutable(PropertyNode, "float", "Thickness");
var attenuationDistance = nodeImmutable(PropertyNode, "float", "AttenuationDistance");
var attenuationColor = nodeImmutable(PropertyNode, "color", "AttenuationColor");
var dispersion = nodeImmutable(PropertyNode, "float", "Dispersion");
var UniformGroupNode = class extends Node {
  static get type() {
    return "UniformGroupNode";
  }
  /**
   * Constructs a new uniform group node.
   *
   * @param {string} name - The name of the uniform group node.
   * @param {boolean} [shared=false] - Whether this uniform group node is shared or not.
   * @param {number} [order=1] - Influences the internal sorting.
   */
  constructor(name, shared = false, order = 1) {
    super("string");
    this.name = name;
    this.shared = shared;
    this.order = order;
    this.isUniformGroup = true;
  }
  serialize(data) {
    super.serialize(data);
    data.name = this.name;
    data.version = this.version;
    data.shared = this.shared;
  }
  deserialize(data) {
    super.deserialize(data);
    this.name = data.name;
    this.version = data.version;
    this.shared = data.shared;
  }
};
var uniformGroup = (name) => new UniformGroupNode(name);
var sharedUniformGroup = (name, order = 0) => new UniformGroupNode(name, true, order);
var frameGroup = sharedUniformGroup("frame");
var renderGroup = sharedUniformGroup("render");
var objectGroup = uniformGroup("object");
var UniformNode = class extends InputNode {
  static get type() {
    return "UniformNode";
  }
  /**
   * Constructs a new uniform node.
   *
   * @param {any} value - The value of this node. Usually a JS primitive or three.js object (vector, matrix, color, texture).
   * @param {?string} nodeType - The node type. If no explicit type is defined, the node tries to derive the type from its value.
   */
  constructor(value, nodeType = null) {
    super(value, nodeType);
    this.isUniformNode = true;
    this.name = "";
    this.groupNode = objectGroup;
  }
  /**
   * Sets the {@link UniformNode#name} property.
   *
   * @param {string} name - The name of the uniform.
   * @return {UniformNode} A reference to this node.
   */
  setName(name) {
    this.name = name;
    return this;
  }
  /**
   * Sets the {@link UniformNode#name} property.
   *
   * @deprecated
   * @param {string} name - The name of the uniform.
   * @return {UniformNode} A reference to this node.
   */
  label(name) {
    console.warn('THREE.TSL: "label()" has been deprecated. Use "setName()" instead.');
    return this.setName(name);
  }
  /**
   * Sets the {@link UniformNode#groupNode} property.
   *
   * @param {UniformGroupNode} group - The uniform group.
   * @return {UniformNode} A reference to this node.
   */
  setGroup(group2) {
    this.groupNode = group2;
    return this;
  }
  /**
   * Returns the {@link UniformNode#groupNode}.
   *
   * @return {UniformGroupNode} The uniform group.
   */
  getGroup() {
    return this.groupNode;
  }
  /**
   * By default, this method returns the result of {@link Node#getHash} but derived
   * classes might overwrite this method with a different implementation.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The uniform hash.
   */
  getUniformHash(builder) {
    return this.getHash(builder);
  }
  onUpdate(callback, updateType) {
    callback = callback.bind(this);
    return super.onUpdate((frame) => {
      const value = callback(frame, this);
      if (value !== void 0) {
        this.value = value;
      }
    }, updateType);
  }
  getInputType(builder) {
    let type = super.getInputType(builder);
    if (type === "bool") {
      type = "uint";
    }
    return type;
  }
  generate(builder, output3) {
    const type = this.getNodeType(builder);
    const hash3 = this.getUniformHash(builder);
    let sharedNode = builder.getNodeFromHash(hash3);
    if (sharedNode === void 0) {
      builder.setHashNode(this, hash3);
      sharedNode = this;
    }
    const sharedNodeType = sharedNode.getInputType(builder);
    const nodeUniform = builder.getUniformFromNode(sharedNode, sharedNodeType, builder.shaderStage, this.name || builder.context.nodeName);
    const uniformName = builder.getPropertyName(nodeUniform);
    if (builder.context.nodeName !== void 0) delete builder.context.nodeName;
    let snippet = uniformName;
    if (type === "bool") {
      const nodeData = builder.getDataFromNode(this);
      let propertyName = nodeData.propertyName;
      if (propertyName === void 0) {
        const nodeVar = builder.getVarFromNode(this, null, "bool");
        propertyName = builder.getPropertyName(nodeVar);
        nodeData.propertyName = propertyName;
        snippet = builder.format(uniformName, sharedNodeType, type);
        builder.addLineFlowCode(`${propertyName} = ${snippet}`, this);
      }
      snippet = propertyName;
    }
    return builder.format(snippet, type, output3);
  }
};
var uniform = (value, type) => {
  const nodeType = getConstNodeType(type || value);
  if (nodeType === value) {
    value = getValueFromType(nodeType);
  }
  value = value && value.isNode === true ? value.node && value.node.value || value.value : value;
  return nodeObject(new UniformNode(value, nodeType));
};
var ArrayNode = class extends TempNode {
  static get type() {
    return "ArrayNode";
  }
  /**
   * Constructs a new array node.
   *
   * @param {?string} nodeType - The data type of the elements.
   * @param {number} count - Size of the array.
   * @param {?Array<Node>} [values=null] - Array default values.
   */
  constructor(nodeType, count2, values = null) {
    super(nodeType);
    this.count = count2;
    this.values = values;
    this.isArrayNode = true;
  }
  /**
   * Returns the number of elements in the node array.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {number} The number of elements in the node array.
   */
  getArrayCount() {
    return this.count;
  }
  /**
   * Returns the node's type.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The type of the node.
   */
  getNodeType(builder) {
    if (this.nodeType === null) {
      this.nodeType = this.values[0].getNodeType(builder);
    }
    return this.nodeType;
  }
  /**
   * Returns the node's type.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The type of the node.
   */
  getElementType(builder) {
    return this.getNodeType(builder);
  }
  /**
   * This method builds the output node and returns the resulting array as a shader string.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The generated shader string.
   */
  generate(builder) {
    const type = this.getNodeType(builder);
    return builder.generateArray(type, this.count, this.values);
  }
};
var array2 = (...params) => {
  let node;
  if (params.length === 1) {
    const values = params[0];
    node = new ArrayNode(null, values.length, values);
  } else {
    const nodeType = params[0];
    const count2 = params[1];
    node = new ArrayNode(nodeType, count2);
  }
  return nodeObject(node);
};
addMethodChaining("toArray", (node, count2) => array2(Array(count2).fill(node)));
var AssignNode = class extends TempNode {
  static get type() {
    return "AssignNode";
  }
  /**
   * Constructs a new assign node.
   *
   * @param {Node} targetNode - The target node.
   * @param {Node} sourceNode - The source type.
   */
  constructor(targetNode, sourceNode) {
    super();
    this.targetNode = targetNode;
    this.sourceNode = sourceNode;
    this.isAssignNode = true;
  }
  /**
   * Whether this node is used more than once in context of other nodes. This method
   * is overwritten since it always returns `false` (assigns are unique).
   *
   * @return {boolean} A flag that indicates if there is more than one dependency to other nodes. Always `false`.
   */
  hasDependencies() {
    return false;
  }
  getNodeType(builder, output3) {
    return output3 !== "void" ? this.targetNode.getNodeType(builder) : "void";
  }
  /**
   * Whether a split is required when assigning source to target. This can happen when the component length of
   * target and source data type does not match.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {boolean} Whether a split is required when assigning source to target.
   */
  needsSplitAssign(builder) {
    const { targetNode } = this;
    if (builder.isAvailable("swizzleAssign") === false && targetNode.isSplitNode && targetNode.components.length > 1) {
      const targetLength = builder.getTypeLength(targetNode.node.getNodeType(builder));
      const assignDifferentVector = vectorComponents.join("").slice(0, targetLength) !== targetNode.components;
      return assignDifferentVector;
    }
    return false;
  }
  setup(builder) {
    const { targetNode, sourceNode } = this;
    const scope = targetNode.getScope();
    const targetProperties = builder.getNodeProperties(scope);
    targetProperties.assign = true;
    const properties = builder.getNodeProperties(this);
    properties.sourceNode = sourceNode;
    properties.targetNode = targetNode.context({ assign: true });
  }
  generate(builder, output3) {
    const { targetNode, sourceNode } = builder.getNodeProperties(this);
    const needsSplitAssign = this.needsSplitAssign(builder);
    const target = targetNode.build(builder);
    const targetType = targetNode.getNodeType(builder);
    const source = sourceNode.build(builder, targetType);
    const sourceType = sourceNode.getNodeType(builder);
    const nodeData = builder.getDataFromNode(this);
    let snippet;
    if (nodeData.initialized === true) {
      if (output3 !== "void") {
        snippet = target;
      }
    } else if (needsSplitAssign) {
      const sourceVar = builder.getVarFromNode(this, null, targetType);
      const sourceProperty = builder.getPropertyName(sourceVar);
      builder.addLineFlowCode(`${sourceProperty} = ${source}`, this);
      const splitNode = targetNode.node;
      const splitTargetNode = splitNode.node.context({ assign: true });
      const targetRoot = splitTargetNode.build(builder);
      for (let i = 0; i < splitNode.components.length; i++) {
        const component = splitNode.components[i];
        builder.addLineFlowCode(`${targetRoot}.${component} = ${sourceProperty}[ ${i} ]`, this);
      }
      if (output3 !== "void") {
        snippet = target;
      }
    } else {
      snippet = `${target} = ${source}`;
      if (output3 === "void" || sourceType === "void") {
        builder.addLineFlowCode(snippet, this);
        if (output3 !== "void") {
          snippet = target;
        }
      }
    }
    nodeData.initialized = true;
    return builder.format(snippet, targetType, output3);
  }
};
var assign = nodeProxy(AssignNode).setParameterLength(2);
addMethodChaining("assign", assign);
var FunctionCallNode = class extends TempNode {
  static get type() {
    return "FunctionCallNode";
  }
  /**
   * Constructs a new function call node.
   *
   * @param {?FunctionNode} functionNode - The function node.
   * @param {Object<string, Node>} [parameters={}] - The parameters for the function call.
   */
  constructor(functionNode = null, parameters = {}) {
    super();
    this.functionNode = functionNode;
    this.parameters = parameters;
  }
  /**
   * Sets the parameters of the function call node.
   *
   * @param {Object<string, Node>} parameters - The parameters to set.
   * @return {FunctionCallNode} A reference to this node.
   */
  setParameters(parameters) {
    this.parameters = parameters;
    return this;
  }
  /**
   * Returns the parameters of the function call node.
   *
   * @return {Object<string, Node>} The parameters of this node.
   */
  getParameters() {
    return this.parameters;
  }
  /**
   * Returns the type of this function call node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @returns {string} The type of this node.
   */
  getNodeType(builder) {
    return this.functionNode.getNodeType(builder);
  }
  /**
   * Returns the function node of this function call node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {string} [name] - The name of the member.
   * @returns {string} The type of the member.
   */
  getMemberType(builder, name) {
    return this.functionNode.getMemberType(builder, name);
  }
  generate(builder) {
    const params = [];
    const functionNode = this.functionNode;
    const inputs = functionNode.getInputs(builder);
    const parameters = this.parameters;
    const generateInput = (node, inputNode) => {
      const type = inputNode.type;
      const pointer = type === "pointer";
      let output3;
      if (pointer) output3 = "&" + node.build(builder);
      else output3 = node.build(builder, type);
      return output3;
    };
    if (Array.isArray(parameters)) {
      if (parameters.length > inputs.length) {
        console.error("THREE.TSL: The number of provided parameters exceeds the expected number of inputs in 'Fn()'.");
        parameters.length = inputs.length;
      } else if (parameters.length < inputs.length) {
        console.error("THREE.TSL: The number of provided parameters is less than the expected number of inputs in 'Fn()'.");
        while (parameters.length < inputs.length) {
          parameters.push(float(0));
        }
      }
      for (let i = 0; i < parameters.length; i++) {
        params.push(generateInput(parameters[i], inputs[i]));
      }
    } else {
      for (const inputNode of inputs) {
        const node = parameters[inputNode.name];
        if (node !== void 0) {
          params.push(generateInput(node, inputNode));
        } else {
          console.error(`THREE.TSL: Input '${inputNode.name}' not found in 'Fn()'.`);
          params.push(generateInput(float(0), inputNode));
        }
      }
    }
    const functionName = functionNode.build(builder, "property");
    return `${functionName}( ${params.join(", ")} )`;
  }
};
var call = (func, ...params) => {
  params = params.length > 1 || params[0] && params[0].isNode === true ? nodeArray(params) : nodeObjects(params[0]);
  return nodeObject(new FunctionCallNode(nodeObject(func), params));
};
addMethodChaining("call", call);
var _vectorOperators = {
  "==": "equal",
  "!=": "notEqual",
  "<": "lessThan",
  ">": "greaterThan",
  "<=": "lessThanEqual",
  ">=": "greaterThanEqual",
  "%": "mod"
};
var OperatorNode = class _OperatorNode extends TempNode {
  static get type() {
    return "OperatorNode";
  }
  /**
   * Constructs a new operator node.
   *
   * @param {string} op - The operator.
   * @param {Node} aNode - The first input.
   * @param {Node} bNode - The second input.
   * @param {...Node} params - Additional input parameters.
   */
  constructor(op, aNode, bNode, ...params) {
    super();
    if (params.length > 0) {
      let finalOp = new _OperatorNode(op, aNode, bNode);
      for (let i = 0; i < params.length - 1; i++) {
        finalOp = new _OperatorNode(op, finalOp, params[i]);
      }
      aNode = finalOp;
      bNode = params[params.length - 1];
    }
    this.op = op;
    this.aNode = aNode;
    this.bNode = bNode;
    this.isOperatorNode = true;
  }
  /**
   * Returns the operator method name.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {string} output - The output type.
   * @returns {string} The operator method name.
   */
  getOperatorMethod(builder, output3) {
    return builder.getMethod(_vectorOperators[this.op], output3);
  }
  /**
   * This method is overwritten since the node type is inferred from the operator
   * and the input node types.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {?string} [output=null] - The output type.
   * @return {string} The node type.
   */
  getNodeType(builder, output3 = null) {
    const op = this.op;
    const aNode = this.aNode;
    const bNode = this.bNode;
    const typeA = aNode.getNodeType(builder);
    const typeB = bNode ? bNode.getNodeType(builder) : null;
    if (typeA === "void" || typeB === "void") {
      return output3 || "void";
    } else if (op === "%") {
      return typeA;
    } else if (op === "~" || op === "&" || op === "|" || op === "^" || op === ">>" || op === "<<") {
      return builder.getIntegerType(typeA);
    } else if (op === "!" || op === "&&" || op === "||" || op === "^^") {
      return "bool";
    } else if (op === "==" || op === "!=" || op === "<" || op === ">" || op === "<=" || op === ">=") {
      const typeLength = Math.max(builder.getTypeLength(typeA), builder.getTypeLength(typeB));
      return typeLength > 1 ? `bvec${typeLength}` : "bool";
    } else {
      if (builder.isMatrix(typeA)) {
        if (typeB === "float") {
          return typeA;
        } else if (builder.isVector(typeB)) {
          return builder.getVectorFromMatrix(typeA);
        } else if (builder.isMatrix(typeB)) {
          return typeA;
        }
      } else if (builder.isMatrix(typeB)) {
        if (typeA === "float") {
          return typeB;
        } else if (builder.isVector(typeA)) {
          return builder.getVectorFromMatrix(typeB);
        }
      }
      if (builder.getTypeLength(typeB) > builder.getTypeLength(typeA)) {
        return typeB;
      }
      return typeA;
    }
  }
  generate(builder, output3) {
    const op = this.op;
    const { aNode, bNode } = this;
    const type = this.getNodeType(builder, output3);
    let typeA = null;
    let typeB = null;
    if (type !== "void") {
      typeA = aNode.getNodeType(builder);
      typeB = bNode ? bNode.getNodeType(builder) : null;
      if (op === "<" || op === ">" || op === "<=" || op === ">=" || op === "==" || op === "!=") {
        if (builder.isVector(typeA)) {
          typeB = typeA;
        } else if (builder.isVector(typeB)) {
          typeA = typeB;
        } else if (typeA !== typeB) {
          typeA = typeB = "float";
        }
      } else if (op === ">>" || op === "<<") {
        typeA = type;
        typeB = builder.changeComponentType(typeB, "uint");
      } else if (op === "%") {
        typeA = type;
        typeB = builder.isInteger(typeA) && builder.isInteger(typeB) ? typeB : typeA;
      } else if (builder.isMatrix(typeA)) {
        if (typeB === "float") {
          typeB = "float";
        } else if (builder.isVector(typeB)) {
          typeB = builder.getVectorFromMatrix(typeA);
        } else if (builder.isMatrix(typeB)) ;
        else {
          typeA = typeB = type;
        }
      } else if (builder.isMatrix(typeB)) {
        if (typeA === "float") {
          typeA = "float";
        } else if (builder.isVector(typeA)) {
          typeA = builder.getVectorFromMatrix(typeB);
        } else {
          typeA = typeB = type;
        }
      } else {
        typeA = typeB = type;
      }
    } else {
      typeA = typeB = type;
    }
    const a = aNode.build(builder, typeA);
    const b = bNode ? bNode.build(builder, typeB) : null;
    const fnOpSnippet = builder.getFunctionOperator(op);
    if (output3 !== "void") {
      const isGLSL = builder.renderer.coordinateSystem === WebGLCoordinateSystem;
      if (op === "==" || op === "!=" || op === "<" || op === ">" || op === "<=" || op === ">=") {
        if (isGLSL) {
          if (builder.isVector(typeA)) {
            return builder.format(`${this.getOperatorMethod(builder, output3)}( ${a}, ${b} )`, type, output3);
          } else {
            return builder.format(`( ${a} ${op} ${b} )`, type, output3);
          }
        } else {
          return builder.format(`( ${a} ${op} ${b} )`, type, output3);
        }
      } else if (op === "%") {
        if (builder.isInteger(typeB)) {
          return builder.format(`( ${a} % ${b} )`, type, output3);
        } else {
          return builder.format(`${this.getOperatorMethod(builder, type)}( ${a}, ${b} )`, type, output3);
        }
      } else if (op === "!" || op === "~") {
        return builder.format(`(${op}${a})`, typeA, output3);
      } else if (fnOpSnippet) {
        return builder.format(`${fnOpSnippet}( ${a}, ${b} )`, type, output3);
      } else {
        if (builder.isMatrix(typeA) && typeB === "float") {
          return builder.format(`( ${b} ${op} ${a} )`, type, output3);
        } else if (typeA === "float" && builder.isMatrix(typeB)) {
          return builder.format(`${a} ${op} ${b}`, type, output3);
        } else {
          let snippet = `( ${a} ${op} ${b} )`;
          if (!isGLSL && type === "bool" && builder.isVector(typeA) && builder.isVector(typeB)) {
            snippet = `all${snippet}`;
          }
          return builder.format(snippet, type, output3);
        }
      }
    } else if (typeA !== "void") {
      if (fnOpSnippet) {
        return builder.format(`${fnOpSnippet}( ${a}, ${b} )`, type, output3);
      } else {
        if (builder.isMatrix(typeA) && typeB === "float") {
          return builder.format(`${b} ${op} ${a}`, type, output3);
        } else {
          return builder.format(`${a} ${op} ${b}`, type, output3);
        }
      }
    }
  }
  serialize(data) {
    super.serialize(data);
    data.op = this.op;
  }
  deserialize(data) {
    super.deserialize(data);
    this.op = data.op;
  }
};
var add3 = nodeProxyIntent(OperatorNode, "+").setParameterLength(2, Infinity).setName("add");
var sub = nodeProxyIntent(OperatorNode, "-").setParameterLength(2, Infinity).setName("sub");
var mul = nodeProxyIntent(OperatorNode, "*").setParameterLength(2, Infinity).setName("mul");
var div = nodeProxyIntent(OperatorNode, "/").setParameterLength(2, Infinity).setName("div");
var mod = nodeProxyIntent(OperatorNode, "%").setParameterLength(2).setName("mod");
var equal = nodeProxyIntent(OperatorNode, "==").setParameterLength(2).setName("equal");
var notEqual = nodeProxyIntent(OperatorNode, "!=").setParameterLength(2).setName("notEqual");
var lessThan = nodeProxyIntent(OperatorNode, "<").setParameterLength(2).setName("lessThan");
var greaterThan = nodeProxyIntent(OperatorNode, ">").setParameterLength(2).setName("greaterThan");
var lessThanEqual = nodeProxyIntent(OperatorNode, "<=").setParameterLength(2).setName("lessThanEqual");
var greaterThanEqual = nodeProxyIntent(OperatorNode, ">=").setParameterLength(2).setName("greaterThanEqual");
var and = nodeProxyIntent(OperatorNode, "&&").setParameterLength(2, Infinity).setName("and");
var or = nodeProxyIntent(OperatorNode, "||").setParameterLength(2, Infinity).setName("or");
var not = nodeProxyIntent(OperatorNode, "!").setParameterLength(1).setName("not");
var xor = nodeProxyIntent(OperatorNode, "^^").setParameterLength(2).setName("xor");
var bitAnd = nodeProxyIntent(OperatorNode, "&").setParameterLength(2).setName("bitAnd");
var bitNot = nodeProxyIntent(OperatorNode, "~").setParameterLength(2).setName("bitNot");
var bitOr = nodeProxyIntent(OperatorNode, "|").setParameterLength(2).setName("bitOr");
var bitXor = nodeProxyIntent(OperatorNode, "^").setParameterLength(2).setName("bitXor");
var shiftLeft = nodeProxyIntent(OperatorNode, "<<").setParameterLength(2).setName("shiftLeft");
var shiftRight = nodeProxyIntent(OperatorNode, ">>").setParameterLength(2).setName("shiftRight");
var incrementBefore = Fn(([a]) => {
  a.addAssign(1);
  return a;
});
var decrementBefore = Fn(([a]) => {
  a.subAssign(1);
  return a;
});
var increment = Fn(([a]) => {
  const temp = int(a).toConst();
  a.addAssign(1);
  return temp;
});
var decrement = Fn(([a]) => {
  const temp = int(a).toConst();
  a.subAssign(1);
  return temp;
});
addMethodChaining("add", add3);
addMethodChaining("sub", sub);
addMethodChaining("mul", mul);
addMethodChaining("div", div);
addMethodChaining("mod", mod);
addMethodChaining("equal", equal);
addMethodChaining("notEqual", notEqual);
addMethodChaining("lessThan", lessThan);
addMethodChaining("greaterThan", greaterThan);
addMethodChaining("lessThanEqual", lessThanEqual);
addMethodChaining("greaterThanEqual", greaterThanEqual);
addMethodChaining("and", and);
addMethodChaining("or", or);
addMethodChaining("not", not);
addMethodChaining("xor", xor);
addMethodChaining("bitAnd", bitAnd);
addMethodChaining("bitNot", bitNot);
addMethodChaining("bitOr", bitOr);
addMethodChaining("bitXor", bitXor);
addMethodChaining("shiftLeft", shiftLeft);
addMethodChaining("shiftRight", shiftRight);
addMethodChaining("incrementBefore", incrementBefore);
addMethodChaining("decrementBefore", decrementBefore);
addMethodChaining("increment", increment);
addMethodChaining("decrement", decrement);
var modInt = (a, b) => {
  console.warn('THREE.TSL: "modInt()" is deprecated. Use "mod( int( ... ) )" instead.');
  return mod(int(a), int(b));
};
addMethodChaining("modInt", modInt);
var MathNode = class _MathNode extends TempNode {
  static get type() {
    return "MathNode";
  }
  /**
   * Constructs a new math node.
   *
   * @param {string} method - The method name.
   * @param {Node} aNode - The first input.
   * @param {?Node} [bNode=null] - The second input.
   * @param {?Node} [cNode=null] - The third input.
   */
  constructor(method, aNode, bNode = null, cNode = null) {
    super();
    if ((method === _MathNode.MAX || method === _MathNode.MIN) && arguments.length > 3) {
      let finalOp = new _MathNode(method, aNode, bNode);
      for (let i = 2; i < arguments.length - 1; i++) {
        finalOp = new _MathNode(method, finalOp, arguments[i]);
      }
      aNode = finalOp;
      bNode = arguments[arguments.length - 1];
      cNode = null;
    }
    this.method = method;
    this.aNode = aNode;
    this.bNode = bNode;
    this.cNode = cNode;
    this.isMathNode = true;
  }
  /**
   * The input type is inferred from the node types of the input nodes.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The input type.
   */
  getInputType(builder) {
    const aType = this.aNode.getNodeType(builder);
    const bType = this.bNode ? this.bNode.getNodeType(builder) : null;
    const cType = this.cNode ? this.cNode.getNodeType(builder) : null;
    const aLen = builder.isMatrix(aType) ? 0 : builder.getTypeLength(aType);
    const bLen = builder.isMatrix(bType) ? 0 : builder.getTypeLength(bType);
    const cLen = builder.isMatrix(cType) ? 0 : builder.getTypeLength(cType);
    if (aLen > bLen && aLen > cLen) {
      return aType;
    } else if (bLen > cLen) {
      return bType;
    } else if (cLen > aLen) {
      return cType;
    }
    return aType;
  }
  /**
   * The selected method as well as the input type determine the node type of this node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node type.
   */
  getNodeType(builder) {
    const method = this.method;
    if (method === _MathNode.LENGTH || method === _MathNode.DISTANCE || method === _MathNode.DOT) {
      return "float";
    } else if (method === _MathNode.CROSS) {
      return "vec3";
    } else if (method === _MathNode.ALL || method === _MathNode.ANY) {
      return "bool";
    } else if (method === _MathNode.EQUALS) {
      return builder.changeComponentType(this.aNode.getNodeType(builder), "bool");
    } else {
      return this.getInputType(builder);
    }
  }
  setup(builder) {
    const { aNode, bNode, method } = this;
    let outputNode = null;
    if (method === _MathNode.ONE_MINUS) {
      outputNode = sub(1, aNode);
    } else if (method === _MathNode.RECIPROCAL) {
      outputNode = div(1, aNode);
    } else if (method === _MathNode.DIFFERENCE) {
      outputNode = abs2(sub(aNode, bNode));
    } else if (method === _MathNode.TRANSFORM_DIRECTION) {
      let tA = aNode;
      let tB = bNode;
      if (builder.isMatrix(tA.getNodeType(builder))) {
        tB = vec4(vec3(tB), 0);
      } else {
        tA = vec4(vec3(tA), 0);
      }
      const mulNode = mul(tA, tB).xyz;
      outputNode = normalize2(mulNode);
    }
    if (outputNode !== null) {
      return outputNode;
    } else {
      return super.setup(builder);
    }
  }
  generate(builder, output3) {
    const properties = builder.getNodeProperties(this);
    if (properties.outputNode) {
      return super.generate(builder, output3);
    }
    let method = this.method;
    const type = this.getNodeType(builder);
    const inputType = this.getInputType(builder);
    const a = this.aNode;
    const b = this.bNode;
    const c3 = this.cNode;
    const coordinateSystem = builder.renderer.coordinateSystem;
    if (method === _MathNode.NEGATE) {
      return builder.format("( - " + a.build(builder, inputType) + " )", type, output3);
    } else {
      const params = [];
      if (method === _MathNode.CROSS) {
        params.push(
          a.build(builder, type),
          b.build(builder, type)
        );
      } else if (coordinateSystem === WebGLCoordinateSystem && method === _MathNode.STEP) {
        params.push(
          a.build(builder, builder.getTypeLength(a.getNodeType(builder)) === 1 ? "float" : inputType),
          b.build(builder, inputType)
        );
      } else if (coordinateSystem === WebGLCoordinateSystem && (method === _MathNode.MIN || method === _MathNode.MAX)) {
        params.push(
          a.build(builder, inputType),
          b.build(builder, builder.getTypeLength(b.getNodeType(builder)) === 1 ? "float" : inputType)
        );
      } else if (method === _MathNode.REFRACT) {
        params.push(
          a.build(builder, inputType),
          b.build(builder, inputType),
          c3.build(builder, "float")
        );
      } else if (method === _MathNode.MIX) {
        params.push(
          a.build(builder, inputType),
          b.build(builder, inputType),
          c3.build(builder, builder.getTypeLength(c3.getNodeType(builder)) === 1 ? "float" : inputType)
        );
      } else {
        if (coordinateSystem === WebGPUCoordinateSystem && method === _MathNode.ATAN && b !== null) {
          method = "atan2";
        }
        if (builder.shaderStage !== "fragment" && (method === _MathNode.DFDX || method === _MathNode.DFDY)) {
          console.warn(`THREE.TSL: '${method}' is not supported in the ${builder.shaderStage} stage.`);
          method = "/*" + method + "*/";
        }
        params.push(a.build(builder, inputType));
        if (b !== null) params.push(b.build(builder, inputType));
        if (c3 !== null) params.push(c3.build(builder, inputType));
      }
      return builder.format(`${builder.getMethod(method, type)}( ${params.join(", ")} )`, type, output3);
    }
  }
  serialize(data) {
    super.serialize(data);
    data.method = this.method;
  }
  deserialize(data) {
    super.deserialize(data);
    this.method = data.method;
  }
};
MathNode.ALL = "all";
MathNode.ANY = "any";
MathNode.RADIANS = "radians";
MathNode.DEGREES = "degrees";
MathNode.EXP = "exp";
MathNode.EXP2 = "exp2";
MathNode.LOG = "log";
MathNode.LOG2 = "log2";
MathNode.SQRT = "sqrt";
MathNode.INVERSE_SQRT = "inversesqrt";
MathNode.FLOOR = "floor";
MathNode.CEIL = "ceil";
MathNode.NORMALIZE = "normalize";
MathNode.FRACT = "fract";
MathNode.SIN = "sin";
MathNode.COS = "cos";
MathNode.TAN = "tan";
MathNode.ASIN = "asin";
MathNode.ACOS = "acos";
MathNode.ATAN = "atan";
MathNode.ABS = "abs";
MathNode.SIGN = "sign";
MathNode.LENGTH = "length";
MathNode.NEGATE = "negate";
MathNode.ONE_MINUS = "oneMinus";
MathNode.DFDX = "dFdx";
MathNode.DFDY = "dFdy";
MathNode.ROUND = "round";
MathNode.RECIPROCAL = "reciprocal";
MathNode.TRUNC = "trunc";
MathNode.FWIDTH = "fwidth";
MathNode.TRANSPOSE = "transpose";
MathNode.DETERMINANT = "determinant";
MathNode.INVERSE = "inverse";
MathNode.EQUALS = "equals";
MathNode.MIN = "min";
MathNode.MAX = "max";
MathNode.STEP = "step";
MathNode.REFLECT = "reflect";
MathNode.DISTANCE = "distance";
MathNode.DIFFERENCE = "difference";
MathNode.DOT = "dot";
MathNode.CROSS = "cross";
MathNode.POW = "pow";
MathNode.TRANSFORM_DIRECTION = "transformDirection";
MathNode.MIX = "mix";
MathNode.CLAMP = "clamp";
MathNode.REFRACT = "refract";
MathNode.SMOOTHSTEP = "smoothstep";
MathNode.FACEFORWARD = "faceforward";
var EPSILON2 = float(1e-6);
var INFINITY = float(1e6);
var PI = float(Math.PI);
var PI2 = float(Math.PI * 2);
var all = nodeProxyIntent(MathNode, MathNode.ALL).setParameterLength(1);
var any = nodeProxyIntent(MathNode, MathNode.ANY).setParameterLength(1);
var radians4 = nodeProxyIntent(MathNode, MathNode.RADIANS).setParameterLength(1);
var degrees5 = nodeProxyIntent(MathNode, MathNode.DEGREES).setParameterLength(1);
var exp2 = nodeProxyIntent(MathNode, MathNode.EXP).setParameterLength(1);
var exp22 = nodeProxyIntent(MathNode, MathNode.EXP2).setParameterLength(1);
var log3 = nodeProxyIntent(MathNode, MathNode.LOG).setParameterLength(1);
var log22 = nodeProxyIntent(MathNode, MathNode.LOG2).setParameterLength(1);
var sqrt4 = nodeProxyIntent(MathNode, MathNode.SQRT).setParameterLength(1);
var inverseSqrt = nodeProxyIntent(MathNode, MathNode.INVERSE_SQRT).setParameterLength(1);
var floor = nodeProxyIntent(MathNode, MathNode.FLOOR).setParameterLength(1);
var ceil2 = nodeProxyIntent(MathNode, MathNode.CEIL).setParameterLength(1);
var normalize2 = nodeProxyIntent(MathNode, MathNode.NORMALIZE).setParameterLength(1);
var fract = nodeProxyIntent(MathNode, MathNode.FRACT).setParameterLength(1);
var sin3 = nodeProxyIntent(MathNode, MathNode.SIN).setParameterLength(1);
var cos3 = nodeProxyIntent(MathNode, MathNode.COS).setParameterLength(1);
var tan2 = nodeProxyIntent(MathNode, MathNode.TAN).setParameterLength(1);
var asin3 = nodeProxyIntent(MathNode, MathNode.ASIN).setParameterLength(1);
var acos2 = nodeProxyIntent(MathNode, MathNode.ACOS).setParameterLength(1);
var atan3 = nodeProxyIntent(MathNode, MathNode.ATAN).setParameterLength(1, 2);
var abs2 = nodeProxyIntent(MathNode, MathNode.ABS).setParameterLength(1);
var sign4 = nodeProxyIntent(MathNode, MathNode.SIGN).setParameterLength(1);
var length = nodeProxyIntent(MathNode, MathNode.LENGTH).setParameterLength(1);
var negate2 = nodeProxyIntent(MathNode, MathNode.NEGATE).setParameterLength(1);
var oneMinus = nodeProxyIntent(MathNode, MathNode.ONE_MINUS).setParameterLength(1);
var dFdx = nodeProxyIntent(MathNode, MathNode.DFDX).setParameterLength(1);
var dFdy = nodeProxyIntent(MathNode, MathNode.DFDY).setParameterLength(1);
var round = nodeProxyIntent(MathNode, MathNode.ROUND).setParameterLength(1);
var reciprocal = nodeProxyIntent(MathNode, MathNode.RECIPROCAL).setParameterLength(1);
var trunc = nodeProxyIntent(MathNode, MathNode.TRUNC).setParameterLength(1);
var fwidth = nodeProxyIntent(MathNode, MathNode.FWIDTH).setParameterLength(1);
var transpose2 = nodeProxyIntent(MathNode, MathNode.TRANSPOSE).setParameterLength(1);
var determinant = nodeProxyIntent(MathNode, MathNode.DETERMINANT).setParameterLength(1);
var inverse = nodeProxyIntent(MathNode, MathNode.INVERSE).setParameterLength(1);
var equals2 = (x, y) => {
  console.warn('THREE.TSL: "equals" is deprecated. Use "equal" inside a vector instead, like: "bvec*( equal( ... ) )"');
  return equal(x, y);
};
var min$1 = nodeProxyIntent(MathNode, MathNode.MIN).setParameterLength(2, Infinity);
var max$1 = nodeProxyIntent(MathNode, MathNode.MAX).setParameterLength(2, Infinity);
var step = nodeProxyIntent(MathNode, MathNode.STEP).setParameterLength(2);
var reflect = nodeProxyIntent(MathNode, MathNode.REFLECT).setParameterLength(2);
var distance2 = nodeProxyIntent(MathNode, MathNode.DISTANCE).setParameterLength(2);
var difference2 = nodeProxyIntent(MathNode, MathNode.DIFFERENCE).setParameterLength(2);
var dot = nodeProxyIntent(MathNode, MathNode.DOT).setParameterLength(2);
var cross2 = nodeProxyIntent(MathNode, MathNode.CROSS).setParameterLength(2);
var pow4 = nodeProxyIntent(MathNode, MathNode.POW).setParameterLength(2);
var pow22 = (x) => mul(x, x);
var pow32 = (x) => mul(x, x, x);
var pow42 = (x) => mul(x, x, x, x);
var transformDirection = nodeProxyIntent(MathNode, MathNode.TRANSFORM_DIRECTION).setParameterLength(2);
var cbrt = (a) => mul(sign4(a), pow4(abs2(a), 1 / 3));
var lengthSq = (a) => dot(a, a);
var mix = nodeProxyIntent(MathNode, MathNode.MIX).setParameterLength(3);
var clamp = (value, low = 0, high = 1) => nodeObject(new MathNode(MathNode.CLAMP, nodeObject(value), nodeObject(low), nodeObject(high)));
var saturate2 = (value) => clamp(value);
var refract = nodeProxyIntent(MathNode, MathNode.REFRACT).setParameterLength(3);
var smoothstep = nodeProxyIntent(MathNode, MathNode.SMOOTHSTEP).setParameterLength(3);
var faceForward = nodeProxyIntent(MathNode, MathNode.FACEFORWARD).setParameterLength(3);
var rand = Fn(([uv3]) => {
  const a = 12.9898, b = 78.233, c3 = 43758.5453;
  const dt = dot(uv3.xy, vec2(a, b)), sn = mod(dt, PI);
  return fract(sin3(sn).mul(c3));
});
var mixElement = (t, e1, e22) => mix(e1, e22, t);
var smoothstepElement = (x, low, high) => smoothstep(low, high, x);
var stepElement = (x, edge) => step(edge, x);
var atan23 = (y, x) => {
  console.warn('THREE.TSL: "atan2" is overloaded. Use "atan" instead.');
  return atan3(y, x);
};
var faceforward = faceForward;
var inversesqrt = inverseSqrt;
addMethodChaining("all", all);
addMethodChaining("any", any);
addMethodChaining("equals", equals2);
addMethodChaining("radians", radians4);
addMethodChaining("degrees", degrees5);
addMethodChaining("exp", exp2);
addMethodChaining("exp2", exp22);
addMethodChaining("log", log3);
addMethodChaining("log2", log22);
addMethodChaining("sqrt", sqrt4);
addMethodChaining("inverseSqrt", inverseSqrt);
addMethodChaining("floor", floor);
addMethodChaining("ceil", ceil2);
addMethodChaining("normalize", normalize2);
addMethodChaining("fract", fract);
addMethodChaining("sin", sin3);
addMethodChaining("cos", cos3);
addMethodChaining("tan", tan2);
addMethodChaining("asin", asin3);
addMethodChaining("acos", acos2);
addMethodChaining("atan", atan3);
addMethodChaining("abs", abs2);
addMethodChaining("sign", sign4);
addMethodChaining("length", length);
addMethodChaining("lengthSq", lengthSq);
addMethodChaining("negate", negate2);
addMethodChaining("oneMinus", oneMinus);
addMethodChaining("dFdx", dFdx);
addMethodChaining("dFdy", dFdy);
addMethodChaining("round", round);
addMethodChaining("reciprocal", reciprocal);
addMethodChaining("trunc", trunc);
addMethodChaining("fwidth", fwidth);
addMethodChaining("atan2", atan23);
addMethodChaining("min", min$1);
addMethodChaining("max", max$1);
addMethodChaining("step", stepElement);
addMethodChaining("reflect", reflect);
addMethodChaining("distance", distance2);
addMethodChaining("dot", dot);
addMethodChaining("cross", cross2);
addMethodChaining("pow", pow4);
addMethodChaining("pow2", pow22);
addMethodChaining("pow3", pow32);
addMethodChaining("pow4", pow42);
addMethodChaining("transformDirection", transformDirection);
addMethodChaining("mix", mixElement);
addMethodChaining("clamp", clamp);
addMethodChaining("refract", refract);
addMethodChaining("smoothstep", smoothstepElement);
addMethodChaining("faceForward", faceForward);
addMethodChaining("difference", difference2);
addMethodChaining("saturate", saturate2);
addMethodChaining("cbrt", cbrt);
addMethodChaining("transpose", transpose2);
addMethodChaining("determinant", determinant);
addMethodChaining("inverse", inverse);
addMethodChaining("rand", rand);
var ConditionalNode = class extends Node {
  static get type() {
    return "ConditionalNode";
  }
  /**
   * Constructs a new conditional node.
   *
   * @param {Node} condNode - The node that defines the condition.
   * @param {Node} ifNode - The node that is evaluate when the condition ends up `true`.
   * @param {?Node} [elseNode=null] - The node that is evaluate when the condition ends up `false`.
   */
  constructor(condNode, ifNode, elseNode = null) {
    super();
    this.condNode = condNode;
    this.ifNode = ifNode;
    this.elseNode = elseNode;
  }
  /**
   * This method is overwritten since the node type is inferred from the if/else
   * nodes.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node type.
   */
  getNodeType(builder) {
    const { ifNode, elseNode } = builder.getNodeProperties(this);
    if (ifNode === void 0) {
      builder.flowBuildStage(this, "setup");
      return this.getNodeType(builder);
    }
    const ifType = ifNode.getNodeType(builder);
    if (elseNode !== null) {
      const elseType = elseNode.getNodeType(builder);
      if (builder.getTypeLength(elseType) > builder.getTypeLength(ifType)) {
        return elseType;
      }
    }
    return ifType;
  }
  setup(builder) {
    const condNode = this.condNode.cache();
    const ifNode = this.ifNode.cache();
    const elseNode = this.elseNode ? this.elseNode.cache() : null;
    const currentNodeBlock = builder.context.nodeBlock;
    builder.getDataFromNode(ifNode).parentNodeBlock = currentNodeBlock;
    if (elseNode !== null) builder.getDataFromNode(elseNode).parentNodeBlock = currentNodeBlock;
    const isUniformFlow = builder.context.uniformFlow;
    const properties = builder.getNodeProperties(this);
    properties.condNode = condNode;
    properties.ifNode = isUniformFlow ? ifNode : ifNode.context({ nodeBlock: ifNode });
    properties.elseNode = elseNode ? isUniformFlow ? elseNode : elseNode.context({ nodeBlock: elseNode }) : null;
  }
  generate(builder, output3) {
    const type = this.getNodeType(builder);
    const nodeData = builder.getDataFromNode(this);
    if (nodeData.nodeProperty !== void 0) {
      return nodeData.nodeProperty;
    }
    const { condNode, ifNode, elseNode } = builder.getNodeProperties(this);
    const functionNode = builder.currentFunctionNode;
    const needsOutput = output3 !== "void";
    const nodeProperty = needsOutput ? property(type).build(builder) : "";
    nodeData.nodeProperty = nodeProperty;
    const nodeSnippet = condNode.build(builder, "bool");
    const isUniformFlow = builder.context.uniformFlow;
    if (isUniformFlow && elseNode !== null) {
      const ifSnippet2 = ifNode.build(builder, type);
      const elseSnippet = elseNode.build(builder, type);
      const mathSnippet = builder.getTernary(nodeSnippet, ifSnippet2, elseSnippet);
      return builder.format(mathSnippet, type, output3);
    }
    builder.addFlowCode(`
${builder.tab}if ( ${nodeSnippet} ) {

`).addFlowTab();
    let ifSnippet = ifNode.build(builder, type);
    if (ifSnippet) {
      if (needsOutput) {
        ifSnippet = nodeProperty + " = " + ifSnippet + ";";
      } else {
        ifSnippet = "return " + ifSnippet + ";";
        if (functionNode === null) {
          console.warn("THREE.TSL: Return statement used in an inline 'Fn()'. Define a layout struct to allow return values.");
          ifSnippet = "// " + ifSnippet;
        }
      }
    }
    builder.removeFlowTab().addFlowCode(builder.tab + "	" + ifSnippet + "\n\n" + builder.tab + "}");
    if (elseNode !== null) {
      builder.addFlowCode(" else {\n\n").addFlowTab();
      let elseSnippet = elseNode.build(builder, type);
      if (elseSnippet) {
        if (needsOutput) {
          elseSnippet = nodeProperty + " = " + elseSnippet + ";";
        } else {
          elseSnippet = "return " + elseSnippet + ";";
          if (functionNode === null) {
            console.warn("THREE.TSL: Return statement used in an inline 'Fn()'. Define a layout struct to allow return values.");
            elseSnippet = "// " + elseSnippet;
          }
        }
      }
      builder.removeFlowTab().addFlowCode(builder.tab + "	" + elseSnippet + "\n\n" + builder.tab + "}\n\n");
    } else {
      builder.addFlowCode("\n\n");
    }
    return builder.format(nodeProperty, type, output3);
  }
};
var select = nodeProxy(ConditionalNode).setParameterLength(2, 3);
addMethodChaining("select", select);
var ContextNode = class extends Node {
  static get type() {
    return "ContextNode";
  }
  /**
   * Constructs a new context node.
   *
   * @param {Node} node - The node whose context should be modified.
   * @param {Object} [value={}] - The modified context data.
   */
  constructor(node, value = {}) {
    super();
    this.isContextNode = true;
    this.node = node;
    this.value = value;
  }
  /**
   * This method is overwritten to ensure it returns the reference to {@link ContextNode#node}.
   *
   * @return {Node} A reference to {@link ContextNode#node}.
   */
  getScope() {
    return this.node.getScope();
  }
  /**
   * This method is overwritten to ensure it returns the type of {@link ContextNode#node}.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node type.
   */
  getNodeType(builder) {
    return this.node.getNodeType(builder);
  }
  /**
   * This method is overwritten to ensure it returns the member type of {@link ContextNode#node}.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {string} name - The member name.
   * @returns {string} The member type.
   */
  getMemberType(builder, name) {
    return this.node.getMemberType(builder, name);
  }
  analyze(builder) {
    const previousContext = builder.getContext();
    builder.setContext({ ...builder.context, ...this.value });
    this.node.build(builder);
    builder.setContext(previousContext);
  }
  setup(builder) {
    const previousContext = builder.getContext();
    builder.setContext({ ...builder.context, ...this.value });
    this.node.build(builder);
    builder.setContext(previousContext);
  }
  generate(builder, output3) {
    const previousContext = builder.getContext();
    builder.setContext({ ...builder.context, ...this.value });
    const snippet = this.node.build(builder, output3);
    builder.setContext(previousContext);
    return snippet;
  }
};
var context = nodeProxy(ContextNode).setParameterLength(1, 2);
var uniformFlow = (node) => context(node, { uniformFlow: true });
var setName = (node, name) => context(node, { nodeName: name });
function label(node, name) {
  console.warn('THREE.TSL: "label()" has been deprecated. Use "setName()" instead.');
  return setName(node, name);
}
addMethodChaining("context", context);
addMethodChaining("label", label);
addMethodChaining("uniformFlow", uniformFlow);
addMethodChaining("setName", setName);
var VarNode = class extends Node {
  static get type() {
    return "VarNode";
  }
  /**
   * Constructs a new variable node.
   *
   * @param {Node} node - The node for which a variable should be created.
   * @param {?string} [name=null] - The name of the variable in the shader.
   * @param {boolean} [readOnly=false] - The read-only flag.
   */
  constructor(node, name = null, readOnly = false) {
    super();
    this.node = node;
    this.name = name;
    this.global = true;
    this.isVarNode = true;
    this.readOnly = readOnly;
    this.parents = true;
    this.intent = false;
  }
  /**
   * Sets the intent flag for this node.
   *
   * This flag is used to indicate that this node is used for intent
   * and should not be built directly. Instead, it is used to indicate that
   * the node should be treated as a variable intent.
   *
   * It's useful for assigning variables without needing creating a new variable node.
   *
   * @param {boolean} value - The value to set for the intent flag.
   * @returns {VarNode} This node.
   */
  setIntent(value) {
    this.intent = value;
    return this;
  }
  /**
   * Returns the intent flag of this node.
   *
   * @return {boolean} The intent flag.
   */
  getIntent() {
    return this.intent;
  }
  getMemberType(builder, name) {
    return this.node.getMemberType(builder, name);
  }
  getElementType(builder) {
    return this.node.getElementType(builder);
  }
  getNodeType(builder) {
    return this.node.getNodeType(builder);
  }
  getArrayCount(builder) {
    return this.node.getArrayCount(builder);
  }
  build(...params) {
    if (this.intent === true) {
      const builder = params[0];
      const properties = builder.getNodeProperties(this);
      if (properties.assign !== true) {
        return this.node.build(...params);
      }
    }
    return super.build(...params);
  }
  generate(builder) {
    const { node, name, readOnly } = this;
    const { renderer } = builder;
    const isWebGPUBackend = renderer.backend.isWebGPUBackend === true;
    let isDeterministic = false;
    let shouldTreatAsReadOnly = false;
    if (readOnly) {
      isDeterministic = builder.isDeterministic(node);
      shouldTreatAsReadOnly = isWebGPUBackend ? readOnly : isDeterministic;
    }
    const vectorType = builder.getVectorType(this.getNodeType(builder));
    const snippet = node.build(builder, vectorType);
    const nodeVar = builder.getVarFromNode(this, name, vectorType, void 0, shouldTreatAsReadOnly);
    const propertyName = builder.getPropertyName(nodeVar);
    let declarationPrefix = propertyName;
    if (shouldTreatAsReadOnly) {
      if (isWebGPUBackend) {
        declarationPrefix = isDeterministic ? `const ${propertyName}` : `let ${propertyName}`;
      } else {
        const count2 = node.getArrayCount(builder);
        declarationPrefix = `const ${builder.getVar(nodeVar.type, propertyName, count2)}`;
      }
    }
    builder.addLineFlowCode(`${declarationPrefix} = ${snippet}`, this);
    return propertyName;
  }
};
var createVar = nodeProxy(VarNode);
var Var = (node, name = null) => createVar(node, name).toStack();
var Const = (node, name = null) => createVar(node, name, true).toStack();
var VarIntent = (node) => {
  if (getCurrentStack() === null) {
    return node;
  }
  return createVar(node).setIntent(true).toStack();
};
addMethodChaining("toVar", Var);
addMethodChaining("toConst", Const);
addMethodChaining("toVarIntent", VarIntent);
var SubBuildNode = class extends Node {
  static get type() {
    return "SubBuild";
  }
  constructor(node, name, nodeType = null) {
    super(nodeType);
    this.node = node;
    this.name = name;
    this.isSubBuildNode = true;
  }
  getNodeType(builder) {
    if (this.nodeType !== null) return this.nodeType;
    builder.addSubBuild(this.name);
    const nodeType = this.node.getNodeType(builder);
    builder.removeSubBuild();
    return nodeType;
  }
  build(builder, ...params) {
    builder.addSubBuild(this.name);
    const data = this.node.build(builder, ...params);
    builder.removeSubBuild();
    return data;
  }
};
var subBuild = (node, name, type = null) => nodeObject(new SubBuildNode(nodeObject(node), name, type));
var VaryingNode = class extends Node {
  static get type() {
    return "VaryingNode";
  }
  /**
   * Constructs a new varying node.
   *
   * @param {Node} node - The node for which a varying should be created.
   * @param {?string} name - The name of the varying in the shader.
   */
  constructor(node, name = null) {
    super();
    this.node = node;
    this.name = name;
    this.isVaryingNode = true;
    this.interpolationType = null;
    this.interpolationSampling = null;
    this.global = true;
  }
  /**
   * Defines the interpolation type of the varying.
   *
   * @param {string} type - The interpolation type.
   * @param {?string} sampling - The interpolation sampling type
   * @return {VaryingNode} A reference to this node.
   */
  setInterpolation(type, sampling = null) {
    this.interpolationType = type;
    this.interpolationSampling = sampling;
    return this;
  }
  getHash(builder) {
    return this.name || super.getHash(builder);
  }
  getNodeType(builder) {
    return this.node.getNodeType(builder);
  }
  /**
   * This method performs the setup of a varying node with the current node builder.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {NodeVarying} The node varying from the node builder.
   */
  setupVarying(builder) {
    const properties = builder.getNodeProperties(this);
    let varying3 = properties.varying;
    if (varying3 === void 0) {
      const name = this.name;
      const type = this.getNodeType(builder);
      const interpolationType = this.interpolationType;
      const interpolationSampling = this.interpolationSampling;
      properties.varying = varying3 = builder.getVaryingFromNode(this, name, type, interpolationType, interpolationSampling);
      properties.node = subBuild(this.node, "VERTEX");
    }
    varying3.needsInterpolation || (varying3.needsInterpolation = builder.shaderStage === "fragment");
    return varying3;
  }
  setup(builder) {
    this.setupVarying(builder);
    builder.flowNodeFromShaderStage(NodeShaderStage.VERTEX, this.node);
  }
  analyze(builder) {
    this.setupVarying(builder);
    builder.flowNodeFromShaderStage(NodeShaderStage.VERTEX, this.node);
  }
  generate(builder) {
    const propertyKey = builder.getSubBuildProperty("property", builder.currentStack);
    const properties = builder.getNodeProperties(this);
    const varying3 = this.setupVarying(builder);
    if (properties[propertyKey] === void 0) {
      const type = this.getNodeType(builder);
      const propertyName = builder.getPropertyName(varying3, NodeShaderStage.VERTEX);
      builder.flowNodeFromShaderStage(NodeShaderStage.VERTEX, properties.node, type, propertyName);
      properties[propertyKey] = propertyName;
    }
    return builder.getPropertyName(varying3);
  }
};
var varying = nodeProxy(VaryingNode).setParameterLength(1, 2);
var vertexStage = (node) => varying(node);
addMethodChaining("toVarying", varying);
addMethodChaining("toVertexStage", vertexStage);
addMethodChaining("varying", (...params) => {
  console.warn("THREE.TSL: .varying() has been renamed to .toVarying().");
  return varying(...params);
});
addMethodChaining("vertexStage", (...params) => {
  console.warn("THREE.TSL: .vertexStage() has been renamed to .toVertexStage().");
  return varying(...params);
});
var sRGBTransferEOTF = Fn(([color4]) => {
  const a = color4.mul(0.9478672986).add(0.0521327014).pow(2.4);
  const b = color4.mul(0.0773993808);
  const factor = color4.lessThanEqual(0.04045);
  const rgbResult = mix(a, b, factor);
  return rgbResult;
}).setLayout({
  name: "sRGBTransferEOTF",
  type: "vec3",
  inputs: [
    { name: "color", type: "vec3" }
  ]
});
var sRGBTransferOETF = Fn(([color4]) => {
  const a = color4.pow(0.41666).mul(1.055).sub(0.055);
  const b = color4.mul(12.92);
  const factor = color4.lessThanEqual(31308e-7);
  const rgbResult = mix(a, b, factor);
  return rgbResult;
}).setLayout({
  name: "sRGBTransferOETF",
  type: "vec3",
  inputs: [
    { name: "color", type: "vec3" }
  ]
});
var WORKING_COLOR_SPACE = "WorkingColorSpace";
var OUTPUT_COLOR_SPACE = "OutputColorSpace";
var ColorSpaceNode = class extends TempNode {
  static get type() {
    return "ColorSpaceNode";
  }
  /**
   * Constructs a new color space node.
   *
   * @param {Node} colorNode - Represents the color to convert.
   * @param {string} source - The source color space.
   * @param {string} target - The target color space.
   */
  constructor(colorNode, source, target) {
    super("vec4");
    this.colorNode = colorNode;
    this.source = source;
    this.target = target;
  }
  /**
   * This method resolves the constants `WORKING_COLOR_SPACE` and
   * `OUTPUT_COLOR_SPACE` based on the current configuration of the
   * color management and renderer.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {string} colorSpace - The color space to resolve.
   * @return {string} The resolved color space.
   */
  resolveColorSpace(builder, colorSpace) {
    if (colorSpace === WORKING_COLOR_SPACE) {
      return ColorManagement.workingColorSpace;
    } else if (colorSpace === OUTPUT_COLOR_SPACE) {
      return builder.context.outputColorSpace || builder.renderer.outputColorSpace;
    }
    return colorSpace;
  }
  setup(builder) {
    const { colorNode } = this;
    const source = this.resolveColorSpace(builder, this.source);
    const target = this.resolveColorSpace(builder, this.target);
    let outputNode = colorNode;
    if (ColorManagement.enabled === false || source === target || !source || !target) {
      return outputNode;
    }
    if (ColorManagement.getTransfer(source) === SRGBTransfer) {
      outputNode = vec4(sRGBTransferEOTF(outputNode.rgb), outputNode.a);
    }
    if (ColorManagement.getPrimaries(source) !== ColorManagement.getPrimaries(target)) {
      outputNode = vec4(
        mat3(ColorManagement._getMatrix(new Matrix3(), source, target)).mul(outputNode.rgb),
        outputNode.a
      );
    }
    if (ColorManagement.getTransfer(target) === SRGBTransfer) {
      outputNode = vec4(sRGBTransferOETF(outputNode.rgb), outputNode.a);
    }
    return outputNode;
  }
};
var workingToColorSpace = (node, targetColorSpace) => nodeObject(new ColorSpaceNode(nodeObject(node), WORKING_COLOR_SPACE, targetColorSpace));
var colorSpaceToWorking = (node, sourceColorSpace) => nodeObject(new ColorSpaceNode(nodeObject(node), sourceColorSpace, WORKING_COLOR_SPACE));
var convertColorSpace = (node, sourceColorSpace, targetColorSpace) => nodeObject(new ColorSpaceNode(nodeObject(node), sourceColorSpace, targetColorSpace));
addMethodChaining("workingToColorSpace", workingToColorSpace);
addMethodChaining("colorSpaceToWorking", colorSpaceToWorking);
var ReferenceElementNode$1 = class ReferenceElementNode extends ArrayElementNode {
  static get type() {
    return "ReferenceElementNode";
  }
  /**
   * Constructs a new reference element node.
   *
   * @param {ReferenceBaseNode} referenceNode - The reference node.
   * @param {Node} indexNode - The index node that defines the element access.
   */
  constructor(referenceNode, indexNode) {
    super(referenceNode, indexNode);
    this.referenceNode = referenceNode;
    this.isReferenceElementNode = true;
  }
  /**
   * This method is overwritten since the node type is inferred from
   * the uniform type of the reference node.
   *
   * @return {string} The node type.
   */
  getNodeType() {
    return this.referenceNode.uniformType;
  }
  generate(builder) {
    const snippet = super.generate(builder);
    const arrayType = this.referenceNode.getNodeType();
    const elementType = this.getNodeType();
    return builder.format(snippet, arrayType, elementType);
  }
};
var ReferenceBaseNode = class extends Node {
  static get type() {
    return "ReferenceBaseNode";
  }
  /**
   * Constructs a new reference base node.
   *
   * @param {string} property - The name of the property the node refers to.
   * @param {string} uniformType - The uniform type that should be used to represent the property value.
   * @param {?Object} [object=null] - The object the property belongs to.
   * @param {?number} [count=null] - When the linked property is an array-like, this parameter defines its length.
   */
  constructor(property3, uniformType, object2 = null, count2 = null) {
    super();
    this.property = property3;
    this.uniformType = uniformType;
    this.object = object2;
    this.count = count2;
    this.properties = property3.split(".");
    this.reference = object2;
    this.node = null;
    this.group = null;
    this.updateType = NodeUpdateType.OBJECT;
  }
  /**
   * Sets the uniform group for this reference node.
   *
   * @param {UniformGroupNode} group - The uniform group to set.
   * @return {ReferenceBaseNode} A reference to this node.
   */
  setGroup(group2) {
    this.group = group2;
    return this;
  }
  /**
   * When the referred property is array-like, this method can be used
   * to access elements via an index node.
   *
   * @param {IndexNode} indexNode - indexNode.
   * @return {ReferenceElementNode} A reference to an element.
   */
  element(indexNode) {
    return nodeObject(new ReferenceElementNode$1(this, nodeObject(indexNode)));
  }
  /**
   * Sets the node type which automatically defines the internal
   * uniform type.
   *
   * @param {string} uniformType - The type to set.
   */
  setNodeType(uniformType) {
    const node = uniform(null, uniformType);
    if (this.group !== null) {
      node.setGroup(this.group);
    }
    this.node = node;
  }
  /**
   * This method is overwritten since the node type is inferred from
   * the type of the reference node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node type.
   */
  getNodeType(builder) {
    if (this.node === null) {
      this.updateReference(builder);
      this.updateValue();
    }
    return this.node.getNodeType(builder);
  }
  /**
   * Returns the property value from the given referred object.
   *
   * @param {Object} [object=this.reference] - The object to retrieve the property value from.
   * @return {any} The value.
   */
  getValueFromReference(object2 = this.reference) {
    const { properties } = this;
    let value = object2[properties[0]];
    for (let i = 1; i < properties.length; i++) {
      value = value[properties[i]];
    }
    return value;
  }
  /**
   * Allows to update the reference based on the given state. The state is only
   * evaluated {@link ReferenceBaseNode#object} is not set.
   *
   * @param {(NodeFrame|NodeBuilder)} state - The current state.
   * @return {Object} The updated reference.
   */
  updateReference(state) {
    this.reference = this.object !== null ? this.object : state.object;
    return this.reference;
  }
  /**
   * The output of the reference node is the internal uniform node.
   *
   * @return {UniformNode} The output node.
   */
  setup() {
    this.updateValue();
    return this.node;
  }
  /**
   * Overwritten to update the internal uniform value.
   *
   * @param {NodeFrame} frame - A reference to the current node frame.
   */
  update() {
    this.updateValue();
  }
  /**
   * Retrieves the value from the referred object property and uses it
   * to updated the internal uniform.
   */
  updateValue() {
    if (this.node === null) this.setNodeType(this.uniformType);
    const value = this.getValueFromReference();
    if (Array.isArray(value)) {
      this.node.array = value;
    } else {
      this.node.value = value;
    }
  }
};
var reference$1 = (name, type, object2) => nodeObject(new ReferenceBaseNode(name, type, object2));
var RendererReferenceNode = class extends ReferenceBaseNode {
  static get type() {
    return "RendererReferenceNode";
  }
  /**
   * Constructs a new renderer reference node.
   *
   * @param {string} property - The name of the property the node refers to.
   * @param {string} inputType - The uniform type that should be used to represent the property value.
   * @param {?Renderer} [renderer=null] - The renderer the property belongs to. When no renderer is set,
   * the node refers to the renderer of the current state.
   */
  constructor(property3, inputType, renderer = null) {
    super(property3, inputType, renderer);
    this.renderer = renderer;
    this.setGroup(renderGroup);
  }
  /**
   * Updates the reference based on the given state. The state is only evaluated
   * {@link RendererReferenceNode#renderer} is not set.
   *
   * @param {(NodeFrame|NodeBuilder)} state - The current state.
   * @return {Object} The updated reference.
   */
  updateReference(state) {
    this.reference = this.renderer !== null ? this.renderer : state.renderer;
    return this.reference;
  }
};
var rendererReference = (name, type, renderer = null) => nodeObject(new RendererReferenceNode(name, type, renderer));
var ToneMappingNode = class extends TempNode {
  static get type() {
    return "ToneMappingNode";
  }
  /**
   * Constructs a new tone mapping node.
   *
   * @param {number} toneMapping - The tone mapping type.
   * @param {Node} exposureNode - The tone mapping exposure.
   * @param {Node} [colorNode=null] - The color node to process.
   */
  constructor(toneMapping3, exposureNode = toneMappingExposure, colorNode = null) {
    super("vec3");
    this.toneMapping = toneMapping3;
    this.exposureNode = exposureNode;
    this.colorNode = colorNode;
  }
  /**
   * Overwrites the default `customCacheKey()` implementation by including the tone
   * mapping type into the cache key.
   *
   * @return {number} The hash.
   */
  customCacheKey() {
    return hash$1(this.toneMapping);
  }
  setup(builder) {
    const colorNode = this.colorNode || builder.context.color;
    const toneMapping3 = this.toneMapping;
    if (toneMapping3 === NoToneMapping) return colorNode;
    let outputNode = null;
    const toneMappingFn = builder.renderer.library.getToneMappingFunction(toneMapping3);
    if (toneMappingFn !== null) {
      outputNode = vec4(toneMappingFn(colorNode.rgb, this.exposureNode), colorNode.a);
    } else {
      console.error("ToneMappingNode: Unsupported Tone Mapping configuration.", toneMapping3);
      outputNode = colorNode;
    }
    return outputNode;
  }
};
var toneMapping = (mapping, exposure, color4) => nodeObject(new ToneMappingNode(mapping, nodeObject(exposure), nodeObject(color4)));
var toneMappingExposure = rendererReference("toneMappingExposure", "float");
addMethodChaining("toneMapping", (color4, mapping, exposure) => toneMapping(mapping, exposure, color4));
var BufferAttributeNode = class extends InputNode {
  static get type() {
    return "BufferAttributeNode";
  }
  /**
   * Constructs a new buffer attribute node.
   *
   * @param {BufferAttribute|InterleavedBuffer|TypedArray} value - The attribute data.
   * @param {?string} [bufferType=null] - The buffer type (e.g. `'vec3'`).
   * @param {number} [bufferStride=0] - The buffer stride.
   * @param {number} [bufferOffset=0] - The buffer offset.
   */
  constructor(value, bufferType = null, bufferStride = 0, bufferOffset = 0) {
    super(value, bufferType);
    this.isBufferNode = true;
    this.bufferType = bufferType;
    this.bufferStride = bufferStride;
    this.bufferOffset = bufferOffset;
    this.usage = StaticDrawUsage;
    this.instanced = false;
    this.attribute = null;
    this.global = true;
    if (value && value.isBufferAttribute === true) {
      this.attribute = value;
      this.usage = value.usage;
      this.instanced = value.isInstancedBufferAttribute;
    }
  }
  /**
   * This method is overwritten since the attribute data might be shared
   * and thus the hash should be shared as well.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The hash.
   */
  getHash(builder) {
    if (this.bufferStride === 0 && this.bufferOffset === 0) {
      let bufferData = builder.globalCache.getData(this.value);
      if (bufferData === void 0) {
        bufferData = {
          node: this
        };
        builder.globalCache.setData(this.value, bufferData);
      }
      return bufferData.node.uuid;
    }
    return this.uuid;
  }
  /**
   * This method is overwritten since the node type is inferred from
   * the buffer attribute.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node type.
   */
  getNodeType(builder) {
    if (this.bufferType === null) {
      this.bufferType = builder.getTypeFromAttribute(this.attribute);
    }
    return this.bufferType;
  }
  /**
   * Depending on which value was passed to the node, `setup()` behaves
   * differently. If no instance of `BufferAttribute` was passed, the method
   * creates an internal attribute and configures it respectively.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  setup(builder) {
    if (this.attribute !== null) return;
    const type = this.getNodeType(builder);
    const array4 = this.value;
    const itemSize = builder.getTypeLength(type);
    const stride = this.bufferStride || itemSize;
    const offset = this.bufferOffset;
    const buffer3 = array4.isInterleavedBuffer === true ? array4 : new InterleavedBuffer(array4, stride);
    const bufferAttribute3 = new InterleavedBufferAttribute(buffer3, itemSize, offset);
    buffer3.setUsage(this.usage);
    this.attribute = bufferAttribute3;
    this.attribute.isInstancedBufferAttribute = this.instanced;
  }
  /**
   * Generates the code snippet of the buffer attribute node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The generated code snippet.
   */
  generate(builder) {
    const nodeType = this.getNodeType(builder);
    const nodeAttribute = builder.getBufferAttributeFromNode(this, nodeType);
    const propertyName = builder.getPropertyName(nodeAttribute);
    let output3 = null;
    if (builder.shaderStage === "vertex" || builder.shaderStage === "compute") {
      this.name = propertyName;
      output3 = propertyName;
    } else {
      const nodeVarying = varying(this);
      output3 = nodeVarying.build(builder, nodeType);
    }
    return output3;
  }
  /**
   * Overwrites the default implementation to return a fixed value `'bufferAttribute'`.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The input type.
   */
  getInputType() {
    return "bufferAttribute";
  }
  /**
   * Sets the `usage` property to the given value.
   *
   * @param {number} value - The usage to set.
   * @return {BufferAttributeNode} A reference to this node.
   */
  setUsage(value) {
    this.usage = value;
    if (this.attribute && this.attribute.isBufferAttribute === true) {
      this.attribute.usage = value;
    }
    return this;
  }
  /**
   * Sets the `instanced` property to the given value.
   *
   * @param {boolean} value - The value to set.
   * @return {BufferAttributeNode} A reference to this node.
   */
  setInstanced(value) {
    this.instanced = value;
    return this;
  }
};
var bufferAttribute = (array4, type = null, stride = 0, offset = 0) => nodeObject(new BufferAttributeNode(array4, type, stride, offset));
var dynamicBufferAttribute = (array4, type = null, stride = 0, offset = 0) => bufferAttribute(array4, type, stride, offset).setUsage(DynamicDrawUsage);
var instancedBufferAttribute = (array4, type = null, stride = 0, offset = 0) => bufferAttribute(array4, type, stride, offset).setInstanced(true);
var instancedDynamicBufferAttribute = (array4, type = null, stride = 0, offset = 0) => dynamicBufferAttribute(array4, type, stride, offset).setInstanced(true);
addMethodChaining("toAttribute", (bufferNode) => bufferAttribute(bufferNode.value));
var ComputeNode = class extends Node {
  static get type() {
    return "ComputeNode";
  }
  /**
   * Constructs a new compute node.
   *
   * @param {Node} computeNode - TODO
   * @param {Array<number>} workgroupSize - TODO.
   */
  constructor(computeNode, workgroupSize) {
    super("void");
    this.isComputeNode = true;
    this.computeNode = computeNode;
    this.workgroupSize = workgroupSize;
    this.count = null;
    this.version = 1;
    this.name = "";
    this.updateBeforeType = NodeUpdateType.OBJECT;
    this.onInitFunction = null;
  }
  setCount(count2) {
    this.count = count2;
    return this;
  }
  getCount() {
    return this.count;
  }
  /**
   * Executes the `dispose` event for this node.
   */
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  /**
   * Sets the {@link ComputeNode#name} property.
   *
   * @param {string} name - The name of the uniform.
   * @return {ComputeNode} A reference to this node.
   */
  setName(name) {
    this.name = name;
    return this;
  }
  /**
   * Sets the {@link ComputeNode#name} property.
   *
   * @deprecated
   * @param {string} name - The name of the uniform.
   * @return {ComputeNode} A reference to this node.
   */
  label(name) {
    console.warn('THREE.TSL: "label()" has been deprecated. Use "setName()" instead.');
    return this.setName(name);
  }
  /**
   * TODO
   *
   * @param {Function} callback - TODO.
   * @return {ComputeNode} A reference to this node.
   */
  onInit(callback) {
    this.onInitFunction = callback;
    return this;
  }
  /**
   * The method execute the compute for this node.
   *
   * @param {NodeFrame} frame - A reference to the current node frame.
   */
  updateBefore({ renderer }) {
    renderer.compute(this);
  }
  setup(builder) {
    const result = this.computeNode.build(builder);
    if (result) {
      const properties = builder.getNodeProperties(this);
      properties.outputComputeNode = result.outputNode;
      result.outputNode = null;
    }
    return result;
  }
  generate(builder, output3) {
    const { shaderStage } = builder;
    if (shaderStage === "compute") {
      const snippet = this.computeNode.build(builder, "void");
      if (snippet !== "") {
        builder.addLineFlowCode(snippet, this);
      }
    } else {
      const properties = builder.getNodeProperties(this);
      const outputComputeNode = properties.outputComputeNode;
      if (outputComputeNode) {
        return outputComputeNode.build(builder, output3);
      }
    }
  }
};
var computeKernel = (node, workgroupSize = [64]) => {
  if (workgroupSize.length === 0 || workgroupSize.length > 3) {
    console.error("THREE.TSL: compute() workgroupSize must have 1, 2, or 3 elements");
  }
  for (let i = 0; i < workgroupSize.length; i++) {
    const val = workgroupSize[i];
    if (typeof val !== "number" || val <= 0 || !Number.isInteger(val)) {
      console.error(`THREE.TSL: compute() workgroupSize element at index [ ${i} ] must be a positive integer`);
    }
  }
  while (workgroupSize.length < 3) workgroupSize.push(1);
  return nodeObject(new ComputeNode(nodeObject(node), workgroupSize));
};
var compute = (node, count2, workgroupSize) => computeKernel(node, workgroupSize).setCount(count2);
addMethodChaining("compute", compute);
addMethodChaining("computeKernel", computeKernel);
var CacheNode = class extends Node {
  static get type() {
    return "CacheNode";
  }
  /**
   * Constructs a new cache node.
   *
   * @param {Node} node - The node that should be cached.
   * @param {boolean} [parent=true] - Whether this node refers to a shared parent cache or not.
   */
  constructor(node, parent = true) {
    super();
    this.node = node;
    this.parent = parent;
    this.isCacheNode = true;
  }
  getNodeType(builder) {
    const previousCache = builder.getCache();
    const cache3 = builder.getCacheFromNode(this, this.parent);
    builder.setCache(cache3);
    const nodeType = this.node.getNodeType(builder);
    builder.setCache(previousCache);
    return nodeType;
  }
  build(builder, ...params) {
    const previousCache = builder.getCache();
    const cache3 = builder.getCacheFromNode(this, this.parent);
    builder.setCache(cache3);
    const data = this.node.build(builder, ...params);
    builder.setCache(previousCache);
    return data;
  }
};
var cache = (node, parent) => nodeObject(new CacheNode(nodeObject(node), parent));
addMethodChaining("cache", cache);
var BypassNode = class extends Node {
  static get type() {
    return "BypassNode";
  }
  /**
   * Constructs a new bypass node.
   *
   * @param {Node} outputNode - The output node.
   * @param {Node} callNode - The call node.
   */
  constructor(outputNode, callNode) {
    super();
    this.isBypassNode = true;
    this.outputNode = outputNode;
    this.callNode = callNode;
  }
  getNodeType(builder) {
    return this.outputNode.getNodeType(builder);
  }
  generate(builder) {
    const snippet = this.callNode.build(builder, "void");
    if (snippet !== "") {
      builder.addLineFlowCode(snippet, this);
    }
    return this.outputNode.build(builder);
  }
};
var bypass = nodeProxy(BypassNode).setParameterLength(2);
addMethodChaining("bypass", bypass);
var RemapNode = class extends Node {
  static get type() {
    return "RemapNode";
  }
  /**
   * Constructs a new remap node.
   *
   * @param {Node} node - The node that should be remapped.
   * @param {Node} inLowNode - The source or current lower bound of the range.
   * @param {Node} inHighNode - The source or current upper bound of the range.
   * @param {Node} [outLowNode=float(0)] - The target lower bound of the range.
   * @param {Node} [outHighNode=float(1)] - The target upper bound of the range.
   */
  constructor(node, inLowNode, inHighNode, outLowNode = float(0), outHighNode = float(1)) {
    super();
    this.node = node;
    this.inLowNode = inLowNode;
    this.inHighNode = inHighNode;
    this.outLowNode = outLowNode;
    this.outHighNode = outHighNode;
    this.doClamp = true;
  }
  setup() {
    const { node, inLowNode, inHighNode, outLowNode, outHighNode, doClamp } = this;
    let t = node.sub(inLowNode).div(inHighNode.sub(inLowNode));
    if (doClamp === true) t = t.clamp();
    return t.mul(outHighNode.sub(outLowNode)).add(outLowNode);
  }
};
var remap = nodeProxy(RemapNode, null, null, { doClamp: false }).setParameterLength(3, 5);
var remapClamp = nodeProxy(RemapNode).setParameterLength(3, 5);
addMethodChaining("remap", remap);
addMethodChaining("remapClamp", remapClamp);
var ExpressionNode = class extends Node {
  static get type() {
    return "ExpressionNode";
  }
  /**
   * Constructs a new expression node.
   *
   * @param {string} [snippet=''] - The native code snippet.
   * @param {string} [nodeType='void'] - The node type.
   */
  constructor(snippet = "", nodeType = "void") {
    super(nodeType);
    this.snippet = snippet;
  }
  generate(builder, output3) {
    const type = this.getNodeType(builder);
    const snippet = this.snippet;
    if (type === "void") {
      builder.addLineFlowCode(snippet, this);
    } else {
      return builder.format(snippet, type, output3);
    }
  }
};
var expression = nodeProxy(ExpressionNode).setParameterLength(1, 2);
var Discard = (conditional) => (conditional ? select(conditional, expression("discard")) : expression("discard")).toStack();
var Return = () => expression("return").toStack();
addMethodChaining("discard", Discard);
var RenderOutputNode = class extends TempNode {
  static get type() {
    return "RenderOutputNode";
  }
  /**
   * Constructs a new render output node.
   *
   * @param {Node} colorNode - The color node to process.
   * @param {?number} toneMapping - The tone mapping type.
   * @param {?string} outputColorSpace - The output color space.
   */
  constructor(colorNode, toneMapping3, outputColorSpace) {
    super("vec4");
    this.colorNode = colorNode;
    this.toneMapping = toneMapping3;
    this.outputColorSpace = outputColorSpace;
    this.isRenderOutputNode = true;
  }
  setup({ context: context3 }) {
    let outputNode = this.colorNode || context3.color;
    const toneMapping3 = (this.toneMapping !== null ? this.toneMapping : context3.toneMapping) || NoToneMapping;
    const outputColorSpace = (this.outputColorSpace !== null ? this.outputColorSpace : context3.outputColorSpace) || NoColorSpace;
    if (toneMapping3 !== NoToneMapping) {
      outputNode = outputNode.toneMapping(toneMapping3);
    }
    if (outputColorSpace !== NoColorSpace && outputColorSpace !== ColorManagement.workingColorSpace) {
      outputNode = outputNode.workingToColorSpace(outputColorSpace);
    }
    return outputNode;
  }
};
var renderOutput = (color4, toneMapping3 = null, outputColorSpace = null) => nodeObject(new RenderOutputNode(nodeObject(color4), toneMapping3, outputColorSpace));
addMethodChaining("renderOutput", renderOutput);
var DebugNode = class extends TempNode {
  static get type() {
    return "DebugNode";
  }
  constructor(node, callback = null) {
    super();
    this.node = node;
    this.callback = callback;
  }
  getNodeType(builder) {
    return this.node.getNodeType(builder);
  }
  setup(builder) {
    return this.node.build(builder);
  }
  analyze(builder) {
    return this.node.build(builder);
  }
  generate(builder) {
    const callback = this.callback;
    const snippet = this.node.build(builder);
    const title = "--- TSL debug - " + builder.shaderStage + " shader ---";
    const border = "-".repeat(title.length);
    let code3 = "";
    code3 += "// #" + title + "#\n";
    code3 += builder.flow.code.replace(/^\t/mg, "") + "\n";
    code3 += "/* ... */ " + snippet + " /* ... */\n";
    code3 += "// #" + border + "#\n";
    if (callback !== null) {
      callback(builder, code3);
    } else {
      console.log(code3);
    }
    return snippet;
  }
};
var debug = (node, callback = null) => nodeObject(new DebugNode(nodeObject(node), callback)).toStack();
addMethodChaining("debug", debug);
function addNodeElement(name) {
  console.warn("THREE.TSL: AddNodeElement has been removed in favor of tree-shaking. Trying add", name);
}
var AttributeNode = class extends Node {
  static get type() {
    return "AttributeNode";
  }
  /**
   * Constructs a new attribute node.
   *
   * @param {string} attributeName - The name of the attribute.
   * @param {?string} nodeType - The node type.
   */
  constructor(attributeName, nodeType = null) {
    super(nodeType);
    this.global = true;
    this._attributeName = attributeName;
  }
  getHash(builder) {
    return this.getAttributeName(builder);
  }
  getNodeType(builder) {
    let nodeType = this.nodeType;
    if (nodeType === null) {
      const attributeName = this.getAttributeName(builder);
      if (builder.hasGeometryAttribute(attributeName)) {
        const attribute3 = builder.geometry.getAttribute(attributeName);
        nodeType = builder.getTypeFromAttribute(attribute3);
      } else {
        nodeType = "float";
      }
    }
    return nodeType;
  }
  /**
   * Sets the attribute name to the given value. The method can be
   * overwritten in derived classes if the final name must be computed
   * analytically.
   *
   * @param {string} attributeName - The name of the attribute.
   * @return {AttributeNode} A reference to this node.
   */
  setAttributeName(attributeName) {
    this._attributeName = attributeName;
    return this;
  }
  /**
   * Returns the attribute name of this node. The method can be
   * overwritten in derived classes if the final name must be computed
   * analytically.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The attribute name.
   */
  getAttributeName() {
    return this._attributeName;
  }
  generate(builder) {
    const attributeName = this.getAttributeName(builder);
    const nodeType = this.getNodeType(builder);
    const geometryAttribute = builder.hasGeometryAttribute(attributeName);
    if (geometryAttribute === true) {
      const attribute3 = builder.geometry.getAttribute(attributeName);
      const attributeType = builder.getTypeFromAttribute(attribute3);
      const nodeAttribute = builder.getAttribute(attributeName, attributeType);
      if (builder.shaderStage === "vertex") {
        return builder.format(nodeAttribute.name, attributeType, nodeType);
      } else {
        const nodeVarying = varying(this);
        return nodeVarying.build(builder, nodeType);
      }
    } else {
      console.warn(`AttributeNode: Vertex attribute "${attributeName}" not found on geometry.`);
      return builder.generateConst(nodeType);
    }
  }
  serialize(data) {
    super.serialize(data);
    data.global = this.global;
    data._attributeName = this._attributeName;
  }
  deserialize(data) {
    super.deserialize(data);
    this.global = data.global;
    this._attributeName = data._attributeName;
  }
};
var attribute = (name, nodeType = null) => nodeObject(new AttributeNode(name, nodeType));
var uv$1 = (index5 = 0) => attribute("uv" + (index5 > 0 ? index5 : ""), "vec2");
var TextureSizeNode = class extends Node {
  static get type() {
    return "TextureSizeNode";
  }
  /**
   * Constructs a new texture size node.
   *
   * @param {TextureNode} textureNode - A texture node which size should be retrieved.
   * @param {?Node<int>} [levelNode=null] - A level node which defines the requested mip.
   */
  constructor(textureNode, levelNode = null) {
    super("uvec2");
    this.isTextureSizeNode = true;
    this.textureNode = textureNode;
    this.levelNode = levelNode;
  }
  generate(builder, output3) {
    const textureProperty = this.textureNode.build(builder, "property");
    const level = this.levelNode === null ? "0" : this.levelNode.build(builder, "int");
    return builder.format(`${builder.getMethod("textureDimensions")}( ${textureProperty}, ${level} )`, this.getNodeType(builder), output3);
  }
};
var textureSize = nodeProxy(TextureSizeNode).setParameterLength(1, 2);
var MaxMipLevelNode = class extends UniformNode {
  static get type() {
    return "MaxMipLevelNode";
  }
  /**
   * Constructs a new max mip level node.
   *
   * @param {TextureNode} textureNode - The texture node to compute the max mip level for.
   */
  constructor(textureNode) {
    super(0);
    this._textureNode = textureNode;
    this.updateType = NodeUpdateType.FRAME;
  }
  /**
   * The texture node to compute the max mip level for.
   *
   * @readonly
   * @type {TextureNode}
   */
  get textureNode() {
    return this._textureNode;
  }
  /**
   * The texture.
   *
   * @readonly
   * @type {Texture}
   */
  get texture() {
    return this._textureNode.value;
  }
  update() {
    const texture3 = this.texture;
    const images = texture3.images;
    const image = images && images.length > 0 ? images[0] && images[0].image || images[0] : texture3.image;
    if (image && image.width !== void 0) {
      const { width, height } = image;
      this.value = Math.log2(Math.max(width, height));
    }
  }
};
var maxMipLevel = nodeProxy(MaxMipLevelNode).setParameterLength(1);
var EmptyTexture$1 = new Texture();
var TextureNode = class extends UniformNode {
  static get type() {
    return "TextureNode";
  }
  /**
   * Constructs a new texture node.
   *
   * @param {Texture} [value=EmptyTexture] - The texture.
   * @param {?Node<vec2|vec3>} [uvNode=null] - The uv node.
   * @param {?Node<int>} [levelNode=null] - The level node.
   * @param {?Node<float>} [biasNode=null] - The bias node.
   */
  constructor(value = EmptyTexture$1, uvNode = null, levelNode = null, biasNode = null) {
    super(value);
    this.isTextureNode = true;
    this.uvNode = uvNode;
    this.levelNode = levelNode;
    this.biasNode = biasNode;
    this.compareNode = null;
    this.depthNode = null;
    this.gradNode = null;
    this.offsetNode = null;
    this.sampler = true;
    this.updateMatrix = false;
    this.updateType = NodeUpdateType.NONE;
    this.referenceNode = null;
    this._value = value;
    this._matrixUniform = null;
    this.setUpdateMatrix(uvNode === null);
  }
  set value(value) {
    if (this.referenceNode) {
      this.referenceNode.value = value;
    } else {
      this._value = value;
    }
  }
  /**
   * The texture value.
   *
   * @type {Texture}
   */
  get value() {
    return this.referenceNode ? this.referenceNode.value : this._value;
  }
  /**
   * Overwritten since the uniform hash is defined by the texture's UUID.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The uniform hash.
   */
  getUniformHash() {
    return this.value.uuid;
  }
  /**
   * Overwritten since the node type is inferred from the texture type.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node type.
   */
  getNodeType() {
    if (this.value.isDepthTexture === true) return "float";
    if (this.value.type === UnsignedIntType) {
      return "uvec4";
    } else if (this.value.type === IntType) {
      return "ivec4";
    }
    return "vec4";
  }
  /**
   * Overwrites the default implementation to return a fixed value `'texture'`.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The input type.
   */
  getInputType() {
    return "texture";
  }
  /**
   * Returns a default uvs based on the current texture's channel.
   *
   * @return {AttributeNode<vec2>} The default uvs.
   */
  getDefaultUV() {
    return uv$1(this.value.channel);
  }
  /**
   * Overwritten to always return the texture reference of the node.
   *
   * @param {any} state - This method can be invocated in different contexts so `state` can refer to any object type.
   * @return {Texture} The texture reference.
   */
  updateReference() {
    return this.value;
  }
  /**
   * Transforms the given uv node with the texture transformation matrix.
   *
   * @param {Node} uvNode - The uv node to transform.
   * @return {Node} The transformed uv node.
   */
  getTransformedUV(uvNode) {
    if (this._matrixUniform === null) this._matrixUniform = uniform(this.value.matrix);
    return this._matrixUniform.mul(vec3(uvNode, 1)).xy;
  }
  /**
   * Defines whether the uv transformation matrix should automatically be updated or not.
   *
   * @param {boolean} value - The update toggle.
   * @return {TextureNode} A reference to this node.
   */
  setUpdateMatrix(value) {
    this.updateMatrix = value;
    this.updateType = value ? NodeUpdateType.OBJECT : NodeUpdateType.NONE;
    return this;
  }
  /**
   * Setups the uv node. Depending on the backend as well as texture's image and type, it might be necessary
   * to modify the uv node for correct sampling.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {Node} uvNode - The uv node to setup.
   * @return {Node} The updated uv node.
   */
  setupUV(builder, uvNode) {
    const texture3 = this.value;
    if (builder.isFlipY() && (texture3.image instanceof ImageBitmap && texture3.flipY === true || texture3.isRenderTargetTexture === true || texture3.isFramebufferTexture === true || texture3.isDepthTexture === true)) {
      if (this.sampler) {
        uvNode = uvNode.flipY();
      } else {
        uvNode = uvNode.setY(int(textureSize(this, this.levelNode).y).sub(uvNode.y).sub(1));
      }
    }
    return uvNode;
  }
  /**
   * Setups texture node by preparing the internal nodes for code generation.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  setup(builder) {
    const properties = builder.getNodeProperties(this);
    properties.referenceNode = this.referenceNode;
    const texture3 = this.value;
    if (!texture3 || texture3.isTexture !== true) {
      throw new Error("THREE.TSL: `texture( value )` function expects a valid instance of THREE.Texture().");
    }
    let uvNode = this.uvNode;
    if ((uvNode === null || builder.context.forceUVContext === true) && builder.context.getUV) {
      uvNode = builder.context.getUV(this, builder);
    }
    if (!uvNode) uvNode = this.getDefaultUV();
    if (this.updateMatrix === true) {
      uvNode = this.getTransformedUV(uvNode);
    }
    uvNode = this.setupUV(builder, uvNode);
    let levelNode = this.levelNode;
    if (levelNode === null && builder.context.getTextureLevel) {
      levelNode = builder.context.getTextureLevel(this);
    }
    properties.uvNode = uvNode;
    properties.levelNode = levelNode;
    properties.biasNode = this.biasNode;
    properties.compareNode = this.compareNode;
    properties.gradNode = this.gradNode;
    properties.depthNode = this.depthNode;
    properties.offsetNode = this.offsetNode;
  }
  /**
   * Generates the uv code snippet.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {Node} uvNode - The uv node to generate code for.
   * @return {string} The generated code snippet.
   */
  generateUV(builder, uvNode) {
    return uvNode.build(builder, this.sampler === true ? "vec2" : "ivec2");
  }
  /**
   * Generates the offset code snippet.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {Node} offsetNode - The offset node to generate code for.
   * @return {string} The generated code snippet.
   */
  generateOffset(builder, offsetNode) {
    return offsetNode.build(builder, "ivec2");
  }
  /**
   * Generates the snippet for the texture sampling.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {string} textureProperty - The texture property.
   * @param {string} uvSnippet - The uv snippet.
   * @param {?string} levelSnippet - The level snippet.
   * @param {?string} biasSnippet - The bias snippet.
   * @param {?string} depthSnippet - The depth snippet.
   * @param {?string} compareSnippet - The compare snippet.
   * @param {?Array<string>} gradSnippet - The grad snippet.
   * @param {?string} offsetSnippet - The offset snippet.
   * @return {string} The generated code snippet.
   */
  generateSnippet(builder, textureProperty, uvSnippet, levelSnippet, biasSnippet, depthSnippet, compareSnippet, gradSnippet, offsetSnippet) {
    const texture3 = this.value;
    let snippet;
    if (levelSnippet) {
      snippet = builder.generateTextureLevel(texture3, textureProperty, uvSnippet, levelSnippet, depthSnippet, offsetSnippet);
    } else if (biasSnippet) {
      snippet = builder.generateTextureBias(texture3, textureProperty, uvSnippet, biasSnippet, depthSnippet, offsetSnippet);
    } else if (gradSnippet) {
      snippet = builder.generateTextureGrad(texture3, textureProperty, uvSnippet, gradSnippet, depthSnippet, offsetSnippet);
    } else if (compareSnippet) {
      snippet = builder.generateTextureCompare(texture3, textureProperty, uvSnippet, compareSnippet, depthSnippet, offsetSnippet);
    } else if (this.sampler === false) {
      snippet = builder.generateTextureLoad(texture3, textureProperty, uvSnippet, depthSnippet, offsetSnippet);
    } else {
      snippet = builder.generateTexture(texture3, textureProperty, uvSnippet, depthSnippet, offsetSnippet);
    }
    return snippet;
  }
  /**
   * Generates the code snippet of the texture node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {string} output - The current output.
   * @return {string} The generated code snippet.
   */
  generate(builder, output3) {
    const texture3 = this.value;
    const properties = builder.getNodeProperties(this);
    const textureProperty = super.generate(builder, "property");
    if (/^sampler/.test(output3)) {
      return textureProperty + "_sampler";
    } else if (builder.isReference(output3)) {
      return textureProperty;
    } else {
      const nodeData = builder.getDataFromNode(this);
      let propertyName = nodeData.propertyName;
      if (propertyName === void 0) {
        const { uvNode, levelNode, biasNode, compareNode, depthNode, gradNode, offsetNode } = properties;
        const uvSnippet = this.generateUV(builder, uvNode);
        const levelSnippet = levelNode ? levelNode.build(builder, "float") : null;
        const biasSnippet = biasNode ? biasNode.build(builder, "float") : null;
        const depthSnippet = depthNode ? depthNode.build(builder, "int") : null;
        const compareSnippet = compareNode ? compareNode.build(builder, "float") : null;
        const gradSnippet = gradNode ? [gradNode[0].build(builder, "vec2"), gradNode[1].build(builder, "vec2")] : null;
        const offsetSnippet = offsetNode ? this.generateOffset(builder, offsetNode) : null;
        const nodeVar = builder.getVarFromNode(this);
        propertyName = builder.getPropertyName(nodeVar);
        const snippet2 = this.generateSnippet(builder, textureProperty, uvSnippet, levelSnippet, biasSnippet, depthSnippet, compareSnippet, gradSnippet, offsetSnippet);
        builder.addLineFlowCode(`${propertyName} = ${snippet2}`, this);
        nodeData.snippet = snippet2;
        nodeData.propertyName = propertyName;
      }
      let snippet = propertyName;
      const nodeType = this.getNodeType(builder);
      if (builder.needsToWorkingColorSpace(texture3)) {
        snippet = colorSpaceToWorking(expression(snippet, nodeType), texture3.colorSpace).setup(builder).build(builder, nodeType);
      }
      return builder.format(snippet, nodeType, output3);
    }
  }
  /**
   * Sets the sampler value.
   *
   * @param {boolean} value - The sampler value to set.
   * @return {TextureNode} A reference to this texture node.
   */
  setSampler(value) {
    this.sampler = value;
    return this;
  }
  /**
   * Returns the sampler value.
   *
   * @return {boolean} The sampler value.
   */
  getSampler() {
    return this.sampler;
  }
  // @TODO: Move to TSL
  /**
   * @function
   * @deprecated since r172. Use {@link TextureNode#sample} instead.
   *
   * @param {Node} uvNode - The uv node.
   * @return {TextureNode} A texture node representing the texture sample.
   */
  uv(uvNode) {
    console.warn("THREE.TextureNode: .uv() has been renamed. Use .sample() instead.");
    return this.sample(uvNode);
  }
  /**
   * Samples the texture with the given uv node.
   *
   * @param {Node} uvNode - The uv node.
   * @return {TextureNode} A texture node representing the texture sample.
   */
  sample(uvNode) {
    const textureNode = this.clone();
    textureNode.uvNode = nodeObject(uvNode);
    textureNode.referenceNode = this.getBase();
    return nodeObject(textureNode);
  }
  /**
   * TSL function for creating a texture node that fetches/loads texels without interpolation.
   *
   * @param {Node<uvec2>} uvNode - The uv node.
   * @returns {TextureNode} A texture node representing the texture load.
   */
  load(uvNode) {
    return this.sample(uvNode).setSampler(false);
  }
  /**
   * Samples a blurred version of the texture by defining an internal bias.
   *
   * @param {Node<float>} amountNode - How blurred the texture should be.
   * @return {TextureNode} A texture node representing the texture sample.
   */
  blur(amountNode) {
    const textureNode = this.clone();
    textureNode.biasNode = nodeObject(amountNode).mul(maxMipLevel(textureNode));
    textureNode.referenceNode = this.getBase();
    const map4 = textureNode.value;
    if (textureNode.generateMipmaps === false && (map4 && map4.generateMipmaps === false || map4.minFilter === NearestFilter || map4.magFilter === NearestFilter)) {
      console.warn("THREE.TSL: texture().blur() requires mipmaps and sampling. Use .generateMipmaps=true and .minFilter/.magFilter=THREE.LinearFilter in the Texture.");
      textureNode.biasNode = null;
    }
    return nodeObject(textureNode);
  }
  /**
   * Samples a specific mip of the texture.
   *
   * @param {Node<int>} levelNode - The mip level to sample.
   * @return {TextureNode} A texture node representing the texture sample.
   */
  level(levelNode) {
    const textureNode = this.clone();
    textureNode.levelNode = nodeObject(levelNode);
    textureNode.referenceNode = this.getBase();
    return nodeObject(textureNode);
  }
  /**
   * Returns the texture size of the requested level.
   *
   * @param {Node<int>} levelNode - The level to compute the size for.
   * @return {TextureSizeNode} The texture size.
   */
  size(levelNode) {
    return textureSize(this, levelNode);
  }
  /**
   * Samples the texture with the given bias.
   *
   * @param {Node<float>} biasNode - The bias node.
   * @return {TextureNode} A texture node representing the texture sample.
   */
  bias(biasNode) {
    const textureNode = this.clone();
    textureNode.biasNode = nodeObject(biasNode);
    textureNode.referenceNode = this.getBase();
    return nodeObject(textureNode);
  }
  /**
   * Returns the base texture of this node.
   * @return {TextureNode} The base texture node.
   */
  getBase() {
    return this.referenceNode ? this.referenceNode.getBase() : this;
  }
  /**
   * Samples the texture by executing a compare operation.
   *
   * @param {Node<float>} compareNode - The node that defines the compare value.
   * @return {TextureNode} A texture node representing the texture sample.
   */
  compare(compareNode) {
    const textureNode = this.clone();
    textureNode.compareNode = nodeObject(compareNode);
    textureNode.referenceNode = this.getBase();
    return nodeObject(textureNode);
  }
  /**
   * Samples the texture using an explicit gradient.
   *
   * @param {Node<vec2>} gradNodeX - The gradX node.
   * @param {Node<vec2>} gradNodeY - The gradY node.
   * @return {TextureNode} A texture node representing the texture sample.
   */
  grad(gradNodeX, gradNodeY) {
    const textureNode = this.clone();
    textureNode.gradNode = [nodeObject(gradNodeX), nodeObject(gradNodeY)];
    textureNode.referenceNode = this.getBase();
    return nodeObject(textureNode);
  }
  /**
   * Samples the texture by defining a depth node.
   *
   * @param {Node<int>} depthNode - The depth node.
   * @return {TextureNode} A texture node representing the texture sample.
   */
  depth(depthNode) {
    const textureNode = this.clone();
    textureNode.depthNode = nodeObject(depthNode);
    textureNode.referenceNode = this.getBase();
    return nodeObject(textureNode);
  }
  /**
   * Samples the texture by defining an offset node.
   *
   * @param {Node<ivec2>} offsetNode - The offset node.
   * @return {TextureNode} A texture node representing the texture sample.
   */
  offset(offsetNode) {
    const textureNode = this.clone();
    textureNode.offsetNode = nodeObject(offsetNode);
    textureNode.referenceNode = this.getBase();
    return nodeObject(textureNode);
  }
  // --
  serialize(data) {
    super.serialize(data);
    data.value = this.value.toJSON(data.meta).uuid;
    data.sampler = this.sampler;
    data.updateMatrix = this.updateMatrix;
    data.updateType = this.updateType;
  }
  deserialize(data) {
    super.deserialize(data);
    this.value = data.meta.textures[data.value];
    this.sampler = data.sampler;
    this.updateMatrix = data.updateMatrix;
    this.updateType = data.updateType;
  }
  /**
   * The update is used to implement the update of the uv transformation matrix.
   */
  update() {
    const texture3 = this.value;
    const matrixUniform = this._matrixUniform;
    if (matrixUniform !== null) matrixUniform.value = texture3.matrix;
    if (texture3.matrixAutoUpdate === true) {
      texture3.updateMatrix();
    }
  }
  /**
   * Clones the texture node.
   *
   * @return {TextureNode} The cloned texture node.
   */
  clone() {
    const newNode = new this.constructor(this.value, this.uvNode, this.levelNode, this.biasNode);
    newNode.sampler = this.sampler;
    newNode.depthNode = this.depthNode;
    newNode.compareNode = this.compareNode;
    newNode.gradNode = this.gradNode;
    newNode.offsetNode = this.offsetNode;
    return newNode;
  }
};
var textureBase = nodeProxy(TextureNode).setParameterLength(1, 4).setName("texture");
var texture = (value = EmptyTexture$1, uvNode = null, levelNode = null, biasNode = null) => {
  let textureNode;
  if (value && value.isTextureNode === true) {
    textureNode = nodeObject(value.clone());
    textureNode.referenceNode = value.getBase();
    if (uvNode !== null) textureNode.uvNode = nodeObject(uvNode);
    if (levelNode !== null) textureNode.levelNode = nodeObject(levelNode);
    if (biasNode !== null) textureNode.biasNode = nodeObject(biasNode);
  } else {
    textureNode = textureBase(value, uvNode, levelNode, biasNode);
  }
  return textureNode;
};
var uniformTexture = (value = EmptyTexture$1) => texture(value);
var textureLoad = (...params) => texture(...params).setSampler(false);
var sampler = (value) => (value.isNode === true ? value : texture(value)).convert("sampler");
var samplerComparison = (value) => (value.isNode === true ? value : texture(value)).convert("samplerComparison");
var BufferNode = class extends UniformNode {
  static get type() {
    return "BufferNode";
  }
  /**
   * Constructs a new buffer node.
   *
   * @param {Array<number>} value - Array-like buffer data.
   * @param {string} bufferType - The data type of the buffer.
   * @param {number} [bufferCount=0] - The count of buffer elements.
   */
  constructor(value, bufferType, bufferCount = 0) {
    super(value, bufferType);
    this.isBufferNode = true;
    this.bufferType = bufferType;
    this.bufferCount = bufferCount;
  }
  /**
   * The data type of the buffer elements.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The element type.
   */
  getElementType(builder) {
    return this.getNodeType(builder);
  }
  /**
   * Overwrites the default implementation to return a fixed value `'buffer'`.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The input type.
   */
  getInputType() {
    return "buffer";
  }
};
var buffer = (value, type, count2) => nodeObject(new BufferNode(value, type, count2));
var UniformArrayElementNode = class extends ArrayElementNode {
  static get type() {
    return "UniformArrayElementNode";
  }
  /**
   * Constructs a new buffer node.
   *
   * @param {UniformArrayNode} uniformArrayNode - The uniform array node to access.
   * @param {IndexNode} indexNode - The index data that define the position of the accessed element in the array.
   */
  constructor(uniformArrayNode, indexNode) {
    super(uniformArrayNode, indexNode);
    this.isArrayBufferElementNode = true;
  }
  generate(builder) {
    const snippet = super.generate(builder);
    const type = this.getNodeType();
    const paddedType = this.node.getPaddedType();
    return builder.format(snippet, paddedType, type);
  }
};
var UniformArrayNode = class extends BufferNode {
  static get type() {
    return "UniformArrayNode";
  }
  /**
   * Constructs a new uniform array node.
   *
   * @param {Array<any>} value - Array holding the buffer data.
   * @param {?string} [elementType=null] - The data type of a buffer element.
   */
  constructor(value, elementType = null) {
    super(null);
    this.array = value;
    this.elementType = elementType === null ? getValueType(value[0]) : elementType;
    this.paddedType = this.getPaddedType();
    this.updateType = NodeUpdateType.RENDER;
    this.isArrayBufferNode = true;
  }
  /**
   * This method is overwritten since the node type is inferred from the
   * {@link UniformArrayNode#paddedType}.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node type.
   */
  getNodeType() {
    return this.paddedType;
  }
  /**
   * The data type of the array elements.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The element type.
   */
  getElementType() {
    return this.elementType;
  }
  /**
   * Returns the padded type based on the element type.
   *
   * @return {string} The padded type.
   */
  getPaddedType() {
    const elementType = this.elementType;
    let paddedType = "vec4";
    if (elementType === "mat2") {
      paddedType = "mat2";
    } else if (/mat/.test(elementType) === true) {
      paddedType = "mat4";
    } else if (elementType.charAt(0) === "i") {
      paddedType = "ivec4";
    } else if (elementType.charAt(0) === "u") {
      paddedType = "uvec4";
    }
    return paddedType;
  }
  /**
   * The update makes sure to correctly transfer the data from the (complex) objects
   * in the array to the internal, correctly padded value buffer.
   *
   * @param {NodeFrame} frame - A reference to the current node frame.
   */
  update() {
    const { array: array4, value } = this;
    const elementType = this.elementType;
    if (elementType === "float" || elementType === "int" || elementType === "uint") {
      for (let i = 0; i < array4.length; i++) {
        const index5 = i * 4;
        value[index5] = array4[i];
      }
    } else if (elementType === "color") {
      for (let i = 0; i < array4.length; i++) {
        const index5 = i * 4;
        const vector = array4[i];
        value[index5] = vector.r;
        value[index5 + 1] = vector.g;
        value[index5 + 2] = vector.b || 0;
      }
    } else if (elementType === "mat2") {
      for (let i = 0; i < array4.length; i++) {
        const index5 = i * 4;
        const matrix = array4[i];
        value[index5] = matrix.elements[0];
        value[index5 + 1] = matrix.elements[1];
        value[index5 + 2] = matrix.elements[2];
        value[index5 + 3] = matrix.elements[3];
      }
    } else if (elementType === "mat3") {
      for (let i = 0; i < array4.length; i++) {
        const index5 = i * 16;
        const matrix = array4[i];
        value[index5] = matrix.elements[0];
        value[index5 + 1] = matrix.elements[1];
        value[index5 + 2] = matrix.elements[2];
        value[index5 + 4] = matrix.elements[3];
        value[index5 + 5] = matrix.elements[4];
        value[index5 + 6] = matrix.elements[5];
        value[index5 + 8] = matrix.elements[6];
        value[index5 + 9] = matrix.elements[7];
        value[index5 + 10] = matrix.elements[8];
        value[index5 + 15] = 1;
      }
    } else if (elementType === "mat4") {
      for (let i = 0; i < array4.length; i++) {
        const index5 = i * 16;
        const matrix = array4[i];
        for (let i2 = 0; i2 < matrix.elements.length; i2++) {
          value[index5 + i2] = matrix.elements[i2];
        }
      }
    } else {
      for (let i = 0; i < array4.length; i++) {
        const index5 = i * 4;
        const vector = array4[i];
        value[index5] = vector.x;
        value[index5 + 1] = vector.y;
        value[index5 + 2] = vector.z || 0;
        value[index5 + 3] = vector.w || 0;
      }
    }
  }
  /**
   * Implement the value buffer creation based on the array data.
   *
   * @param {NodeBuilder} builder - A reference to the current node builder.
   * @return {null}
   */
  setup(builder) {
    const length3 = this.array.length;
    const elementType = this.elementType;
    let arrayType = Float32Array;
    const paddedType = this.paddedType;
    const paddedElementLength = builder.getTypeLength(paddedType);
    if (elementType.charAt(0) === "i") arrayType = Int32Array;
    if (elementType.charAt(0) === "u") arrayType = Uint32Array;
    this.value = new arrayType(length3 * paddedElementLength);
    this.bufferCount = length3;
    this.bufferType = paddedType;
    return super.setup(builder);
  }
  /**
   * Overwrites the default `element()` method to provide element access
   * based on {@link UniformArrayNode}.
   *
   * @param {IndexNode} indexNode - The index node.
   * @return {UniformArrayElementNode}
   */
  element(indexNode) {
    return nodeObject(new UniformArrayElementNode(this, nodeObject(indexNode)));
  }
};
var uniformArray = (values, nodeType) => nodeObject(new UniformArrayNode(values, nodeType));
var BuiltinNode = class extends Node {
  /**
   * Constructs a new builtin node.
   *
   * @param {string} name - The name of the built-in shader variable.
   */
  constructor(name) {
    super("float");
    this.name = name;
    this.isBuiltinNode = true;
  }
  /**
   * Generates the code snippet of the builtin node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The generated code snippet.
   */
  generate() {
    return this.name;
  }
};
var builtin = nodeProxy(BuiltinNode).setParameterLength(1);
var _screenSizeVec;
var _viewportVec;
var ScreenNode = class _ScreenNode extends Node {
  static get type() {
    return "ScreenNode";
  }
  /**
   * Constructs a new screen node.
   *
   * @param {('coordinate'|'viewport'|'size'|'uv'|'dpr')} scope - The node's scope.
   */
  constructor(scope) {
    super();
    this.scope = scope;
    this._output = null;
    this.isViewportNode = true;
  }
  /**
   * This method is overwritten since the node type depends on the selected scope.
   *
   * @return {('float'|'vec2'|'vec4')} The node type.
   */
  getNodeType() {
    if (this.scope === _ScreenNode.DPR) return "float";
    if (this.scope === _ScreenNode.VIEWPORT) return "vec4";
    else return "vec2";
  }
  /**
   * This method is overwritten since the node's update type depends on the selected scope.
   *
   * @return {NodeUpdateType} The update type.
   */
  getUpdateType() {
    let updateType = NodeUpdateType.NONE;
    if (this.scope === _ScreenNode.SIZE || this.scope === _ScreenNode.VIEWPORT || this.scope === _ScreenNode.DPR) {
      updateType = NodeUpdateType.RENDER;
    }
    this.updateType = updateType;
    return updateType;
  }
  /**
   * `ScreenNode` implements {@link Node#update} to retrieve viewport and size information
   * from the current renderer.
   *
   * @param {NodeFrame} frame - A reference to the current node frame.
   */
  update({ renderer }) {
    const renderTarget = renderer.getRenderTarget();
    if (this.scope === _ScreenNode.VIEWPORT) {
      if (renderTarget !== null) {
        _viewportVec.copy(renderTarget.viewport);
      } else {
        renderer.getViewport(_viewportVec);
        _viewportVec.multiplyScalar(renderer.getPixelRatio());
      }
    } else if (this.scope === _ScreenNode.DPR) {
      this._output.value = renderer.getPixelRatio();
    } else {
      if (renderTarget !== null) {
        _screenSizeVec.width = renderTarget.width;
        _screenSizeVec.height = renderTarget.height;
      } else {
        renderer.getDrawingBufferSize(_screenSizeVec);
      }
    }
  }
  setup() {
    const scope = this.scope;
    let output3 = null;
    if (scope === _ScreenNode.SIZE) {
      output3 = uniform(_screenSizeVec || (_screenSizeVec = new Vector2()));
    } else if (scope === _ScreenNode.VIEWPORT) {
      output3 = uniform(_viewportVec || (_viewportVec = new Vector4()));
    } else if (scope === _ScreenNode.DPR) {
      output3 = uniform(1);
    } else {
      output3 = vec2(screenCoordinate.div(screenSize));
    }
    this._output = output3;
    return output3;
  }
  generate(builder) {
    if (this.scope === _ScreenNode.COORDINATE) {
      let coord = builder.getFragCoord();
      if (builder.isFlipY()) {
        const size = builder.getNodeProperties(screenSize).outputNode.build(builder);
        coord = `${builder.getType("vec2")}( ${coord}.x, ${size}.y - ${coord}.y )`;
      }
      return coord;
    }
    return super.generate(builder);
  }
};
ScreenNode.COORDINATE = "coordinate";
ScreenNode.VIEWPORT = "viewport";
ScreenNode.SIZE = "size";
ScreenNode.UV = "uv";
ScreenNode.DPR = "dpr";
var screenDPR = nodeImmutable(ScreenNode, ScreenNode.DPR);
var screenUV = nodeImmutable(ScreenNode, ScreenNode.UV);
var screenSize = nodeImmutable(ScreenNode, ScreenNode.SIZE);
var screenCoordinate = nodeImmutable(ScreenNode, ScreenNode.COORDINATE);
var viewport = nodeImmutable(ScreenNode, ScreenNode.VIEWPORT);
var viewportSize = viewport.zw;
var viewportCoordinate = screenCoordinate.sub(viewport.xy);
var viewportUV = viewportCoordinate.div(viewportSize);
var viewportResolution = Fn(() => {
  console.warn('THREE.TSL: "viewportResolution" is deprecated. Use "screenSize" instead.');
  return screenSize;
}, "vec2").once()();
var cameraIndex = uniform(0, "uint").setName("u_cameraIndex").setGroup(sharedUniformGroup("cameraIndex")).toVarying("v_cameraIndex");
var cameraNear = uniform("float").setName("cameraNear").setGroup(renderGroup).onRenderUpdate(({ camera }) => camera.near);
var cameraFar = uniform("float").setName("cameraFar").setGroup(renderGroup).onRenderUpdate(({ camera }) => camera.far);
var cameraProjectionMatrix = Fn(({ camera }) => {
  let cameraProjectionMatrix3;
  if (camera.isArrayCamera && camera.cameras.length > 0) {
    const matrices = [];
    for (const subCamera of camera.cameras) {
      matrices.push(subCamera.projectionMatrix);
    }
    const cameraProjectionMatrices = uniformArray(matrices).setGroup(renderGroup).setName("cameraProjectionMatrices");
    cameraProjectionMatrix3 = cameraProjectionMatrices.element(camera.isMultiViewCamera ? builtin("gl_ViewID_OVR") : cameraIndex).toConst("cameraProjectionMatrix");
  } else {
    cameraProjectionMatrix3 = uniform("mat4").setName("cameraProjectionMatrix").setGroup(renderGroup).onRenderUpdate(({ camera: camera2 }) => camera2.projectionMatrix);
  }
  return cameraProjectionMatrix3;
}).once()();
var cameraProjectionMatrixInverse = Fn(({ camera }) => {
  let cameraProjectionMatrixInverse3;
  if (camera.isArrayCamera && camera.cameras.length > 0) {
    const matrices = [];
    for (const subCamera of camera.cameras) {
      matrices.push(subCamera.projectionMatrixInverse);
    }
    const cameraProjectionMatricesInverse = uniformArray(matrices).setGroup(renderGroup).setName("cameraProjectionMatricesInverse");
    cameraProjectionMatrixInverse3 = cameraProjectionMatricesInverse.element(camera.isMultiViewCamera ? builtin("gl_ViewID_OVR") : cameraIndex).toConst("cameraProjectionMatrixInverse");
  } else {
    cameraProjectionMatrixInverse3 = uniform("mat4").setName("cameraProjectionMatrixInverse").setGroup(renderGroup).onRenderUpdate(({ camera: camera2 }) => camera2.projectionMatrixInverse);
  }
  return cameraProjectionMatrixInverse3;
}).once()();
var cameraViewMatrix = Fn(({ camera }) => {
  let cameraViewMatrix3;
  if (camera.isArrayCamera && camera.cameras.length > 0) {
    const matrices = [];
    for (const subCamera of camera.cameras) {
      matrices.push(subCamera.matrixWorldInverse);
    }
    const cameraViewMatrices = uniformArray(matrices).setGroup(renderGroup).setName("cameraViewMatrices");
    cameraViewMatrix3 = cameraViewMatrices.element(camera.isMultiViewCamera ? builtin("gl_ViewID_OVR") : cameraIndex).toConst("cameraViewMatrix");
  } else {
    cameraViewMatrix3 = uniform("mat4").setName("cameraViewMatrix").setGroup(renderGroup).onRenderUpdate(({ camera: camera2 }) => camera2.matrixWorldInverse);
  }
  return cameraViewMatrix3;
}).once()();
var cameraWorldMatrix = Fn(({ camera }) => {
  let cameraWorldMatrix3;
  if (camera.isArrayCamera && camera.cameras.length > 0) {
    const matrices = [];
    for (const subCamera of camera.cameras) {
      matrices.push(subCamera.matrixWorld);
    }
    const cameraWorldMatrices = uniformArray(matrices).setGroup(renderGroup).setName("cameraWorldMatrices");
    cameraWorldMatrix3 = cameraWorldMatrices.element(camera.isMultiViewCamera ? builtin("gl_ViewID_OVR") : cameraIndex).toConst("cameraWorldMatrix");
  } else {
    cameraWorldMatrix3 = uniform("mat4").setName("cameraWorldMatrix").setGroup(renderGroup).onRenderUpdate(({ camera: camera2 }) => camera2.matrixWorld);
  }
  return cameraWorldMatrix3;
}).once()();
var cameraNormalMatrix = Fn(({ camera }) => {
  let cameraNormalMatrix3;
  if (camera.isArrayCamera && camera.cameras.length > 0) {
    const matrices = [];
    for (const subCamera of camera.cameras) {
      matrices.push(subCamera.normalMatrix);
    }
    const cameraNormalMatrices = uniformArray(matrices).setGroup(renderGroup).setName("cameraNormalMatrices");
    cameraNormalMatrix3 = cameraNormalMatrices.element(camera.isMultiViewCamera ? builtin("gl_ViewID_OVR") : cameraIndex).toConst("cameraNormalMatrix");
  } else {
    cameraNormalMatrix3 = uniform("mat3").setName("cameraNormalMatrix").setGroup(renderGroup).onRenderUpdate(({ camera: camera2 }) => camera2.normalMatrix);
  }
  return cameraNormalMatrix3;
}).once()();
var cameraPosition = Fn(({ camera }) => {
  let cameraPosition3;
  if (camera.isArrayCamera && camera.cameras.length > 0) {
    const positions = [];
    for (let i = 0, l = camera.cameras.length; i < l; i++) {
      positions.push(new Vector3());
    }
    const cameraPositions = uniformArray(positions).setGroup(renderGroup).setName("cameraPositions").onRenderUpdate(({ camera: camera2 }, self2) => {
      const subCameras = camera2.cameras;
      const array4 = self2.array;
      for (let i = 0, l = subCameras.length; i < l; i++) {
        array4[i].setFromMatrixPosition(subCameras[i].matrixWorld);
      }
    });
    cameraPosition3 = cameraPositions.element(camera.isMultiViewCamera ? builtin("gl_ViewID_OVR") : cameraIndex).toConst("cameraPosition");
  } else {
    cameraPosition3 = uniform(new Vector3()).setName("cameraPosition").setGroup(renderGroup).onRenderUpdate(({ camera: camera2 }, self2) => self2.value.setFromMatrixPosition(camera2.matrixWorld));
  }
  return cameraPosition3;
}).once()();
var cameraViewport = Fn(({ camera }) => {
  let cameraViewport3;
  if (camera.isArrayCamera && camera.cameras.length > 0) {
    const viewports = [];
    for (const subCamera of camera.cameras) {
      viewports.push(subCamera.viewport);
    }
    const cameraViewports = uniformArray(viewports, "vec4").setGroup(renderGroup).setName("cameraViewports");
    cameraViewport3 = cameraViewports.element(cameraIndex).toConst("cameraViewport");
  } else {
    cameraViewport3 = vec4(0, 0, screenSize.x, screenSize.y).toConst("cameraViewport");
  }
  return cameraViewport3;
}).once()();
var _sphere = new Sphere();
var Object3DNode = class _Object3DNode extends Node {
  static get type() {
    return "Object3DNode";
  }
  /**
   * Constructs a new object 3D node.
   *
   * @param {('position'|'viewPosition'|'direction'|'scale'|'worldMatrix')} scope - The node represents a different type of transformation depending on the scope.
   * @param {?Object3D} [object3d=null] - The 3D object.
   */
  constructor(scope, object3d = null) {
    super();
    this.scope = scope;
    this.object3d = object3d;
    this.updateType = NodeUpdateType.OBJECT;
    this.uniformNode = new UniformNode(null);
  }
  /**
   * Overwritten since the node type is inferred from the scope.
   *
   * @return {('mat4'|'vec3'|'float')} The node type.
   */
  getNodeType() {
    const scope = this.scope;
    if (scope === _Object3DNode.WORLD_MATRIX) {
      return "mat4";
    } else if (scope === _Object3DNode.POSITION || scope === _Object3DNode.VIEW_POSITION || scope === _Object3DNode.DIRECTION || scope === _Object3DNode.SCALE) {
      return "vec3";
    } else if (scope === _Object3DNode.RADIUS) {
      return "float";
    }
  }
  /**
   * Updates the uniform value depending on the scope.
   *
   * @param {NodeFrame} frame - The current node frame.
   */
  update(frame) {
    const object2 = this.object3d;
    const uniformNode = this.uniformNode;
    const scope = this.scope;
    if (scope === _Object3DNode.WORLD_MATRIX) {
      uniformNode.value = object2.matrixWorld;
    } else if (scope === _Object3DNode.POSITION) {
      uniformNode.value = uniformNode.value || new Vector3();
      uniformNode.value.setFromMatrixPosition(object2.matrixWorld);
    } else if (scope === _Object3DNode.SCALE) {
      uniformNode.value = uniformNode.value || new Vector3();
      uniformNode.value.setFromMatrixScale(object2.matrixWorld);
    } else if (scope === _Object3DNode.DIRECTION) {
      uniformNode.value = uniformNode.value || new Vector3();
      object2.getWorldDirection(uniformNode.value);
    } else if (scope === _Object3DNode.VIEW_POSITION) {
      const camera = frame.camera;
      uniformNode.value = uniformNode.value || new Vector3();
      uniformNode.value.setFromMatrixPosition(object2.matrixWorld);
      uniformNode.value.applyMatrix4(camera.matrixWorldInverse);
    } else if (scope === _Object3DNode.RADIUS) {
      const geometry = frame.object.geometry;
      if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
      _sphere.copy(geometry.boundingSphere).applyMatrix4(object2.matrixWorld);
      uniformNode.value = _sphere.radius;
    }
  }
  /**
   * Generates the code snippet of the uniform node. The node type of the uniform
   * node also depends on the selected scope.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The generated code snippet.
   */
  generate(builder) {
    const scope = this.scope;
    if (scope === _Object3DNode.WORLD_MATRIX) {
      this.uniformNode.nodeType = "mat4";
    } else if (scope === _Object3DNode.POSITION || scope === _Object3DNode.VIEW_POSITION || scope === _Object3DNode.DIRECTION || scope === _Object3DNode.SCALE) {
      this.uniformNode.nodeType = "vec3";
    } else if (scope === _Object3DNode.RADIUS) {
      this.uniformNode.nodeType = "float";
    }
    return this.uniformNode.build(builder);
  }
  serialize(data) {
    super.serialize(data);
    data.scope = this.scope;
  }
  deserialize(data) {
    super.deserialize(data);
    this.scope = data.scope;
  }
};
Object3DNode.WORLD_MATRIX = "worldMatrix";
Object3DNode.POSITION = "position";
Object3DNode.SCALE = "scale";
Object3DNode.VIEW_POSITION = "viewPosition";
Object3DNode.DIRECTION = "direction";
Object3DNode.RADIUS = "radius";
var objectDirection = nodeProxy(Object3DNode, Object3DNode.DIRECTION).setParameterLength(1);
var objectWorldMatrix = nodeProxy(Object3DNode, Object3DNode.WORLD_MATRIX).setParameterLength(1);
var objectPosition = nodeProxy(Object3DNode, Object3DNode.POSITION).setParameterLength(1);
var objectScale = nodeProxy(Object3DNode, Object3DNode.SCALE).setParameterLength(1);
var objectViewPosition = nodeProxy(Object3DNode, Object3DNode.VIEW_POSITION).setParameterLength(1);
var objectRadius = nodeProxy(Object3DNode, Object3DNode.RADIUS).setParameterLength(1);
var ModelNode = class extends Object3DNode {
  static get type() {
    return "ModelNode";
  }
  /**
   * Constructs a new object model node.
   *
   * @param {('position'|'viewPosition'|'direction'|'scale'|'worldMatrix')} scope - The node represents a different type of transformation depending on the scope.
   */
  constructor(scope) {
    super(scope);
  }
  /**
   * Extracts the model reference from the frame state and then
   * updates the uniform value depending on the scope.
   *
   * @param {NodeFrame} frame - The current node frame.
   */
  update(frame) {
    this.object3d = frame.object;
    super.update(frame);
  }
};
var modelDirection = nodeImmutable(ModelNode, ModelNode.DIRECTION);
var modelWorldMatrix = nodeImmutable(ModelNode, ModelNode.WORLD_MATRIX);
var modelPosition = nodeImmutable(ModelNode, ModelNode.POSITION);
var modelScale = nodeImmutable(ModelNode, ModelNode.SCALE);
var modelViewPosition = nodeImmutable(ModelNode, ModelNode.VIEW_POSITION);
var modelRadius = nodeImmutable(ModelNode, ModelNode.RADIUS);
var modelNormalMatrix = uniform(new Matrix3()).onObjectUpdate(({ object: object2 }, self2) => self2.value.getNormalMatrix(object2.matrixWorld));
var modelWorldMatrixInverse = uniform(new Matrix4()).onObjectUpdate(({ object: object2 }, self2) => self2.value.copy(object2.matrixWorld).invert());
var modelViewMatrix = Fn((builder) => {
  return builder.renderer.overrideNodes.modelViewMatrix || mediumpModelViewMatrix;
}).once()().toVar("modelViewMatrix");
var mediumpModelViewMatrix = cameraViewMatrix.mul(modelWorldMatrix);
var highpModelViewMatrix = Fn((builder) => {
  builder.context.isHighPrecisionModelViewMatrix = true;
  return uniform("mat4").onObjectUpdate(({ object: object2, camera }) => {
    return object2.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object2.matrixWorld);
  });
}).once()().toVar("highpModelViewMatrix");
var highpModelNormalViewMatrix = Fn((builder) => {
  const isHighPrecisionModelViewMatrix = builder.context.isHighPrecisionModelViewMatrix;
  return uniform("mat3").onObjectUpdate(({ object: object2, camera }) => {
    if (isHighPrecisionModelViewMatrix !== true) {
      object2.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object2.matrixWorld);
    }
    return object2.normalMatrix.getNormalMatrix(object2.modelViewMatrix);
  });
}).once()().toVar("highpModelNormalViewMatrix");
var positionGeometry = attribute("position", "vec3");
var positionLocal = positionGeometry.toVarying("positionLocal");
var positionPrevious = positionGeometry.toVarying("positionPrevious");
var positionWorld = Fn((builder) => {
  return modelWorldMatrix.mul(positionLocal).xyz.toVarying(builder.getSubBuildProperty("v_positionWorld"));
}, "vec3").once(["POSITION"])();
var positionWorldDirection = Fn(() => {
  const vertexPWD = positionLocal.transformDirection(modelWorldMatrix).toVarying("v_positionWorldDirection");
  return vertexPWD.normalize().toVar("positionWorldDirection");
}, "vec3").once(["POSITION"])();
var positionView = Fn((builder) => {
  return builder.context.setupPositionView().toVarying("v_positionView");
}, "vec3").once(["POSITION"])();
var positionViewDirection = positionView.negate().toVarying("v_positionViewDirection").normalize().toVar("positionViewDirection");
var FrontFacingNode = class extends Node {
  static get type() {
    return "FrontFacingNode";
  }
  /**
   * Constructs a new front facing node.
   */
  constructor() {
    super("bool");
    this.isFrontFacingNode = true;
  }
  generate(builder) {
    if (builder.shaderStage !== "fragment") return "true";
    const { material } = builder;
    if (material.side === BackSide) {
      return "false";
    }
    return builder.getFrontFacing();
  }
};
var frontFacing = nodeImmutable(FrontFacingNode);
var faceDirection = float(frontFacing).mul(2).sub(1);
var directionToFaceDirection = Fn(([direction], { material }) => {
  const side = material.side;
  if (side === BackSide) {
    direction = direction.mul(-1);
  } else if (side === DoubleSide) {
    direction = direction.mul(faceDirection);
  }
  return direction;
});
var normalGeometry = attribute("normal", "vec3");
var normalLocal = Fn((builder) => {
  if (builder.geometry.hasAttribute("normal") === false) {
    console.warn('THREE.TSL: Vertex attribute "normal" not found on geometry.');
    return vec3(0, 1, 0);
  }
  return normalGeometry;
}, "vec3").once()().toVar("normalLocal");
var normalFlat = positionView.dFdx().cross(positionView.dFdy()).normalize().toVar("normalFlat");
var normalViewGeometry = Fn((builder) => {
  let node;
  if (builder.material.flatShading === true) {
    node = normalFlat;
  } else {
    node = transformNormalToView(normalLocal).toVarying("v_normalViewGeometry").normalize();
  }
  return node;
}, "vec3").once()().toVar("normalViewGeometry");
var normalWorldGeometry = Fn((builder) => {
  let normal2 = normalViewGeometry.transformDirection(cameraViewMatrix);
  if (builder.material.flatShading !== true) {
    normal2 = normal2.toVarying("v_normalWorldGeometry");
  }
  return normal2.normalize().toVar("normalWorldGeometry");
}, "vec3").once()();
var normalView = Fn(({ subBuildFn, material, context: context3 }) => {
  let node;
  if (subBuildFn === "NORMAL" || subBuildFn === "VERTEX") {
    node = normalViewGeometry;
    if (material.flatShading !== true) {
      node = directionToFaceDirection(node);
    }
  } else {
    node = context3.setupNormal().context({ getUV: null });
  }
  return node;
}, "vec3").once(["NORMAL", "VERTEX"])().toVar("normalView");
var normalWorld = normalView.transformDirection(cameraViewMatrix).toVar("normalWorld");
var clearcoatNormalView = Fn(({ subBuildFn, context: context3 }) => {
  let node;
  if (subBuildFn === "NORMAL" || subBuildFn === "VERTEX") {
    node = normalView;
  } else {
    node = context3.setupClearcoatNormal().context({ getUV: null });
  }
  return node;
}, "vec3").once(["NORMAL", "VERTEX"])().toVar("clearcoatNormalView");
var transformNormal = Fn(([normal2, matrix = modelWorldMatrix]) => {
  const m = mat3(matrix);
  const transformedNormal = normal2.div(vec3(m[0].dot(m[0]), m[1].dot(m[1]), m[2].dot(m[2])));
  return m.mul(transformedNormal).xyz;
});
var transformNormalToView = Fn(([normal2], builder) => {
  const modelNormalViewMatrix = builder.renderer.overrideNodes.modelNormalViewMatrix;
  if (modelNormalViewMatrix !== null) {
    return modelNormalViewMatrix.transformDirection(normal2);
  }
  const transformedNormal = modelNormalMatrix.mul(normal2);
  return cameraViewMatrix.transformDirection(transformedNormal);
});
var transformedNormalView = Fn(() => {
  console.warn('THREE.TSL: "transformedNormalView" is deprecated. Use "normalView" instead.');
  return normalView;
}).once(["NORMAL", "VERTEX"])();
var transformedNormalWorld = Fn(() => {
  console.warn('THREE.TSL: "transformedNormalWorld" is deprecated. Use "normalWorld" instead.');
  return normalWorld;
}).once(["NORMAL", "VERTEX"])();
var transformedClearcoatNormalView = Fn(() => {
  console.warn('THREE.TSL: "transformedClearcoatNormalView" is deprecated. Use "clearcoatNormalView" instead.');
  return clearcoatNormalView;
}).once(["NORMAL", "VERTEX"])();
var _e1$1 = new Euler();
var _m1$1 = new Matrix4();
var materialRefractionRatio = uniform(0).onReference(({ material }) => material).onObjectUpdate(({ material }) => material.refractionRatio);
var materialEnvIntensity = uniform(1).onReference(({ material }) => material).onObjectUpdate(function({ material, scene }) {
  return material.envMap ? material.envMapIntensity : scene.environmentIntensity;
});
var materialEnvRotation = uniform(new Matrix4()).onReference(function(frame) {
  return frame.material;
}).onObjectUpdate(function({ material, scene }) {
  const rotation = scene.environment !== null && material.envMap === null ? scene.environmentRotation : material.envMapRotation;
  if (rotation) {
    _e1$1.copy(rotation);
    _m1$1.makeRotationFromEuler(_e1$1);
  } else {
    _m1$1.identity();
  }
  return _m1$1;
});
var reflectView = positionViewDirection.negate().reflect(normalView);
var refractView = positionViewDirection.negate().refract(normalView, materialRefractionRatio);
var reflectVector = reflectView.transformDirection(cameraViewMatrix).toVar("reflectVector");
var refractVector = refractView.transformDirection(cameraViewMatrix).toVar("reflectVector");
var EmptyTexture = new CubeTexture();
var CubeTextureNode = class extends TextureNode {
  static get type() {
    return "CubeTextureNode";
  }
  /**
   * Constructs a new cube texture node.
   *
   * @param {CubeTexture} value - The cube texture.
   * @param {?Node<vec3>} [uvNode=null] - The uv node.
   * @param {?Node<int>} [levelNode=null] - The level node.
   * @param {?Node<float>} [biasNode=null] - The bias node.
   */
  constructor(value, uvNode = null, levelNode = null, biasNode = null) {
    super(value, uvNode, levelNode, biasNode);
    this.isCubeTextureNode = true;
  }
  /**
   * Overwrites the default implementation to return a fixed value `'cubeTexture'`.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The input type.
   */
  getInputType() {
    return "cubeTexture";
  }
  /**
   * Returns a default uvs based on the mapping type of the cube texture.
   *
   * @return {Node<vec3>} The default uv attribute.
   */
  getDefaultUV() {
    const texture3 = this.value;
    if (texture3.mapping === CubeReflectionMapping) {
      return reflectVector;
    } else if (texture3.mapping === CubeRefractionMapping) {
      return refractVector;
    } else {
      console.error('THREE.CubeTextureNode: Mapping "%s" not supported.', texture3.mapping);
      return vec3(0, 0, 0);
    }
  }
  /**
   * Overwritten with an empty implementation since the `updateMatrix` flag is ignored
   * for cube textures. The uv transformation matrix is not applied to cube textures.
   *
   * @param {boolean} value - The update toggle.
   */
  setUpdateMatrix() {
  }
  // Ignore .updateMatrix for CubeTextureNode
  /**
   * Setups the uv node. Depending on the backend as well as the texture type, it might be necessary
   * to modify the uv node for correct sampling.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {Node} uvNode - The uv node to setup.
   * @return {Node} The updated uv node.
   */
  setupUV(builder, uvNode) {
    const texture3 = this.value;
    if (builder.renderer.coordinateSystem === WebGPUCoordinateSystem || !texture3.isRenderTargetTexture) {
      uvNode = vec3(uvNode.x.negate(), uvNode.yz);
    }
    return materialEnvRotation.mul(uvNode);
  }
  /**
   * Generates the uv code snippet.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {Node} cubeUV - The uv node to generate code for.
   * @return {string} The generated code snippet.
   */
  generateUV(builder, cubeUV) {
    return cubeUV.build(builder, "vec3");
  }
};
var cubeTextureBase = nodeProxy(CubeTextureNode).setParameterLength(1, 4).setName("cubeTexture");
var cubeTexture = (value = EmptyTexture, uvNode = null, levelNode = null, biasNode = null) => {
  let textureNode;
  if (value && value.isCubeTextureNode === true) {
    textureNode = nodeObject(value.clone());
    textureNode.referenceNode = value;
    if (uvNode !== null) textureNode.uvNode = nodeObject(uvNode);
    if (levelNode !== null) textureNode.levelNode = nodeObject(levelNode);
    if (biasNode !== null) textureNode.biasNode = nodeObject(biasNode);
  } else {
    textureNode = cubeTextureBase(value, uvNode, levelNode, biasNode);
  }
  return textureNode;
};
var uniformCubeTexture = (value = EmptyTexture) => cubeTextureBase(value);
var ReferenceElementNode2 = class extends ArrayElementNode {
  static get type() {
    return "ReferenceElementNode";
  }
  /**
   * Constructs a new reference element node.
   *
   * @param {?ReferenceNode} referenceNode - The reference node.
   * @param {Node} indexNode - The index node that defines the element access.
   */
  constructor(referenceNode, indexNode) {
    super(referenceNode, indexNode);
    this.referenceNode = referenceNode;
    this.isReferenceElementNode = true;
  }
  /**
   * This method is overwritten since the node type is inferred from
   * the uniform type of the reference node.
   *
   * @return {string} The node type.
   */
  getNodeType() {
    return this.referenceNode.uniformType;
  }
  generate(builder) {
    const snippet = super.generate(builder);
    const arrayType = this.referenceNode.getNodeType();
    const elementType = this.getNodeType();
    return builder.format(snippet, arrayType, elementType);
  }
};
var ReferenceNode = class extends Node {
  static get type() {
    return "ReferenceNode";
  }
  /**
   * Constructs a new reference node.
   *
   * @param {string} property - The name of the property the node refers to.
   * @param {string} uniformType - The uniform type that should be used to represent the property value.
   * @param {?Object} [object=null] - The object the property belongs to.
   * @param {?number} [count=null] - When the linked property is an array-like, this parameter defines its length.
   */
  constructor(property3, uniformType, object2 = null, count2 = null) {
    super();
    this.property = property3;
    this.uniformType = uniformType;
    this.object = object2;
    this.count = count2;
    this.properties = property3.split(".");
    this.reference = object2;
    this.node = null;
    this.group = null;
    this.name = null;
    this.updateType = NodeUpdateType.OBJECT;
  }
  /**
   * When the referred property is array-like, this method can be used
   * to access elements via an index node.
   *
   * @param {IndexNode} indexNode - indexNode.
   * @return {ReferenceElementNode} A reference to an element.
   */
  element(indexNode) {
    return nodeObject(new ReferenceElementNode2(this, nodeObject(indexNode)));
  }
  /**
   * Sets the uniform group for this reference node.
   *
   * @param {UniformGroupNode} group - The uniform group to set.
   * @return {ReferenceNode} A reference to this node.
   */
  setGroup(group2) {
    this.group = group2;
    return this;
  }
  /**
   * Sets the name for the internal uniform.
   *
   * @param {string} name - The label to set.
   * @return {ReferenceNode} A reference to this node.
   */
  setName(name) {
    this.name = name;
    return this;
  }
  /**
   * Sets the label for the internal uniform.
   *
   * @deprecated
   * @param {string} name - The label to set.
   * @return {ReferenceNode} A reference to this node.
   */
  label(name) {
    console.warn('THREE.TSL: "label()" has been deprecated. Use "setName()" instead.');
    return this.setName(name);
  }
  /**
   * Sets the node type which automatically defines the internal
   * uniform type.
   *
   * @param {string} uniformType - The type to set.
   */
  setNodeType(uniformType) {
    let node = null;
    if (this.count !== null) {
      node = buffer(null, uniformType, this.count);
    } else if (Array.isArray(this.getValueFromReference())) {
      node = uniformArray(null, uniformType);
    } else if (uniformType === "texture") {
      node = texture(null);
    } else if (uniformType === "cubeTexture") {
      node = cubeTexture(null);
    } else {
      node = uniform(null, uniformType);
    }
    if (this.group !== null) {
      node.setGroup(this.group);
    }
    if (this.name !== null) node.setName(this.name);
    this.node = node;
  }
  /**
   * This method is overwritten since the node type is inferred from
   * the type of the reference node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node type.
   */
  getNodeType(builder) {
    if (this.node === null) {
      this.updateReference(builder);
      this.updateValue();
    }
    return this.node.getNodeType(builder);
  }
  /**
   * Returns the property value from the given referred object.
   *
   * @param {Object} [object=this.reference] - The object to retrieve the property value from.
   * @return {any} The value.
   */
  getValueFromReference(object2 = this.reference) {
    const { properties } = this;
    let value = object2[properties[0]];
    for (let i = 1; i < properties.length; i++) {
      value = value[properties[i]];
    }
    return value;
  }
  /**
   * Allows to update the reference based on the given state. The state is only
   * evaluated {@link ReferenceNode#object} is not set.
   *
   * @param {(NodeFrame|NodeBuilder)} state - The current state.
   * @return {Object} The updated reference.
   */
  updateReference(state) {
    this.reference = this.object !== null ? this.object : state.object;
    return this.reference;
  }
  /**
   * The output of the reference node is the internal uniform node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {UniformNode} The output node.
   */
  setup() {
    this.updateValue();
    return this.node;
  }
  /**
   * Overwritten to update the internal uniform value.
   *
   * @param {NodeFrame} frame - A reference to the current node frame.
   */
  update() {
    this.updateValue();
  }
  /**
   * Retrieves the value from the referred object property and uses it
   * to updated the internal uniform.
   */
  updateValue() {
    if (this.node === null) this.setNodeType(this.uniformType);
    const value = this.getValueFromReference();
    if (Array.isArray(value)) {
      this.node.array = value;
    } else {
      this.node.value = value;
    }
  }
};
var reference = (name, type, object2) => nodeObject(new ReferenceNode(name, type, object2));
var referenceBuffer = (name, type, count2, object2) => nodeObject(new ReferenceNode(name, type, object2, count2));
var MaterialReferenceNode = class extends ReferenceNode {
  static get type() {
    return "MaterialReferenceNode";
  }
  /**
   * Constructs a new material reference node.
   *
   * @param {string} property - The name of the property the node refers to.
   * @param {string} inputType - The uniform type that should be used to represent the property value.
   * @param {?Material} [material=null] - The material the property belongs to. When no material is set,
   * the node refers to the material of the current rendered object.
   */
  constructor(property3, inputType, material = null) {
    super(property3, inputType, material);
    this.material = material;
    this.isMaterialReferenceNode = true;
  }
  /**
   * Updates the reference based on the given state. The state is only evaluated
   * {@link MaterialReferenceNode#material} is not set.
   *
   * @param {(NodeFrame|NodeBuilder)} state - The current state.
   * @return {Object} The updated reference.
   */
  updateReference(state) {
    this.reference = this.material !== null ? this.material : state.material;
    return this.reference;
  }
};
var materialReference = (name, type, material = null) => nodeObject(new MaterialReferenceNode(name, type, material));
var uv = uv$1();
var q0 = positionView.dFdx();
var q1 = positionView.dFdy();
var st0 = uv.dFdx();
var st1 = uv.dFdy();
var N = normalView;
var q1perp = q1.cross(N);
var q0perp = N.cross(q0);
var T = q1perp.mul(st0.x).add(q0perp.mul(st1.x));
var B3 = q1perp.mul(st0.y).add(q0perp.mul(st1.y));
var det = T.dot(T).max(B3.dot(B3));
var scale$1 = det.equal(0).select(0, det.inverseSqrt());
var tangentViewFrame = T.mul(scale$1).toVar("tangentViewFrame");
var bitangentViewFrame = B3.mul(scale$1).toVar("bitangentViewFrame");
var tangentGeometry = Fn((builder) => {
  if (builder.geometry.hasAttribute("tangent") === false) {
    builder.geometry.computeTangents();
  }
  return attribute("tangent", "vec4");
})();
var tangentLocal = tangentGeometry.xyz.toVar("tangentLocal");
var tangentView = Fn(({ subBuildFn, geometry, material }) => {
  let node;
  if (subBuildFn === "VERTEX" || geometry.hasAttribute("tangent")) {
    node = modelViewMatrix.mul(vec4(tangentLocal, 0)).xyz.toVarying("v_tangentView").normalize();
  } else {
    node = tangentViewFrame;
  }
  if (material.flatShading !== true) {
    node = directionToFaceDirection(node);
  }
  return node;
}, "vec3").once(["NORMAL", "VERTEX"])().toVar("tangentView");
var tangentWorld = tangentView.transformDirection(cameraViewMatrix).toVarying("v_tangentWorld").normalize().toVar("tangentWorld");
var getBitangent = Fn(([crossNormalTangent, varyingName], { subBuildFn, material }) => {
  let bitangent = crossNormalTangent.mul(tangentGeometry.w).xyz;
  if (subBuildFn === "NORMAL" && material.flatShading !== true) {
    bitangent = bitangent.toVarying(varyingName);
  }
  return bitangent;
}).once(["NORMAL"]);
var bitangentGeometry = getBitangent(normalGeometry.cross(tangentGeometry), "v_bitangentGeometry").normalize().toVar("bitangentGeometry");
var bitangentLocal = getBitangent(normalLocal.cross(tangentLocal), "v_bitangentLocal").normalize().toVar("bitangentLocal");
var bitangentView = Fn(({ subBuildFn, geometry, material }) => {
  let node;
  if (subBuildFn === "VERTEX" || geometry.hasAttribute("tangent")) {
    node = getBitangent(normalView.cross(tangentView), "v_bitangentView").normalize();
  } else {
    node = bitangentViewFrame;
  }
  if (material.flatShading !== true) {
    node = directionToFaceDirection(node);
  }
  return node;
}, "vec3").once(["NORMAL", "VERTEX"])().toVar("bitangentView");
var bitangentWorld = getBitangent(normalWorld.cross(tangentWorld), "v_bitangentWorld").normalize().toVar("bitangentWorld");
var TBNViewMatrix = mat3(tangentView, bitangentView, normalView).toVar("TBNViewMatrix");
var parallaxDirection = positionViewDirection.mul(TBNViewMatrix);
var parallaxUV = (uv3, scale3) => uv3.sub(parallaxDirection.mul(scale3));
var bentNormalView = Fn(() => {
  let bentNormal = anisotropyB.cross(positionViewDirection);
  bentNormal = bentNormal.cross(anisotropyB).normalize();
  bentNormal = mix(bentNormal, normalView, anisotropy.mul(roughness.oneMinus()).oneMinus().pow2().pow2()).normalize();
  return bentNormal;
}).once()();
var NormalMapNode = class extends TempNode {
  static get type() {
    return "NormalMapNode";
  }
  /**
   * Constructs a new normal map node.
   *
   * @param {Node<vec3>} node - Represents the normal map data.
   * @param {?Node<vec2>} [scaleNode=null] - Controls the intensity of the effect.
   */
  constructor(node, scaleNode = null) {
    super("vec3");
    this.node = node;
    this.scaleNode = scaleNode;
    this.normalMapType = TangentSpaceNormalMap;
  }
  setup({ material }) {
    const { normalMapType, scaleNode } = this;
    let normalMap3 = this.node.mul(2).sub(1);
    if (scaleNode !== null) {
      let scale3 = scaleNode;
      if (material.flatShading === true) {
        scale3 = directionToFaceDirection(scale3);
      }
      normalMap3 = vec3(normalMap3.xy.mul(scale3), normalMap3.z);
    }
    let output3 = null;
    if (normalMapType === ObjectSpaceNormalMap) {
      output3 = transformNormalToView(normalMap3);
    } else if (normalMapType === TangentSpaceNormalMap) {
      output3 = TBNViewMatrix.mul(normalMap3).normalize();
    } else {
      console.error(`THREE.NodeMaterial: Unsupported normal map type: ${normalMapType}`);
      output3 = normalView;
    }
    return output3;
  }
};
var normalMap = nodeProxy(NormalMapNode).setParameterLength(1, 2);
var dHdxy_fwd = Fn(({ textureNode, bumpScale }) => {
  const sampleTexture = (callback) => textureNode.cache().context({ getUV: (texNode) => callback(texNode.uvNode || uv$1()), forceUVContext: true });
  const Hll = float(sampleTexture((uvNode) => uvNode));
  return vec2(
    float(sampleTexture((uvNode) => uvNode.add(uvNode.dFdx()))).sub(Hll),
    float(sampleTexture((uvNode) => uvNode.add(uvNode.dFdy()))).sub(Hll)
  ).mul(bumpScale);
});
var perturbNormalArb = Fn((inputs) => {
  const { surf_pos, surf_norm, dHdxy } = inputs;
  const vSigmaX = surf_pos.dFdx().normalize();
  const vSigmaY = surf_pos.dFdy().normalize();
  const vN = surf_norm;
  const R1 = vSigmaY.cross(vN);
  const R2 = vN.cross(vSigmaX);
  const fDet = vSigmaX.dot(R1).mul(faceDirection);
  const vGrad = fDet.sign().mul(dHdxy.x.mul(R1).add(dHdxy.y.mul(R2)));
  return fDet.abs().mul(surf_norm).sub(vGrad).normalize();
});
var BumpMapNode = class extends TempNode {
  static get type() {
    return "BumpMapNode";
  }
  /**
   * Constructs a new bump map node.
   *
   * @param {Node<float>} textureNode - Represents the bump map data.
   * @param {?Node<float>} [scaleNode=null] - Controls the intensity of the bump effect.
   */
  constructor(textureNode, scaleNode = null) {
    super("vec3");
    this.textureNode = textureNode;
    this.scaleNode = scaleNode;
  }
  setup() {
    const bumpScale = this.scaleNode !== null ? this.scaleNode : 1;
    const dHdxy = dHdxy_fwd({ textureNode: this.textureNode, bumpScale });
    return perturbNormalArb({
      surf_pos: positionView,
      surf_norm: normalView,
      dHdxy
    });
  }
};
var bumpMap = nodeProxy(BumpMapNode).setParameterLength(1, 2);
var _propertyCache = /* @__PURE__ */ new Map();
var MaterialNode = class _MaterialNode extends Node {
  static get type() {
    return "MaterialNode";
  }
  /**
   * Constructs a new material node.
   *
   * @param {string} scope - The scope defines what kind of material property is referred by the node.
   */
  constructor(scope) {
    super();
    this.scope = scope;
  }
  /**
   * Returns a cached reference node for the given property and type.
   *
   * @param {string} property - The name of the material property.
   * @param {string} type - The uniform type of the property.
   * @return {MaterialReferenceNode} A material reference node representing the property access.
   */
  getCache(property3, type) {
    let node = _propertyCache.get(property3);
    if (node === void 0) {
      node = materialReference(property3, type);
      _propertyCache.set(property3, node);
    }
    return node;
  }
  /**
   * Returns a float-typed material reference node for the given property name.
   *
   * @param {string} property - The name of the material property.
   * @return {MaterialReferenceNode<float>} A material reference node representing the property access.
   */
  getFloat(property3) {
    return this.getCache(property3, "float");
  }
  /**
   * Returns a color-typed material reference node for the given property name.
   *
   * @param {string} property - The name of the material property.
   * @return {MaterialReferenceNode<color>} A material reference node representing the property access.
   */
  getColor(property3) {
    return this.getCache(property3, "color");
  }
  /**
   * Returns a texture-typed material reference node for the given property name.
   *
   * @param {string} property - The name of the material property.
   * @return {MaterialReferenceNode} A material reference node representing the property access.
   */
  getTexture(property3) {
    return this.getCache(property3 === "map" ? "map" : property3 + "Map", "texture");
  }
  /**
   * The node setup is done depending on the selected scope. Multiple material properties
   * might be grouped into a single node composition if they logically belong together.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {Node} The node representing the selected scope.
   */
  setup(builder) {
    const material = builder.context.material;
    const scope = this.scope;
    let node = null;
    if (scope === _MaterialNode.COLOR) {
      const colorNode = material.color !== void 0 ? this.getColor(scope) : vec3();
      if (material.map && material.map.isTexture === true) {
        node = colorNode.mul(this.getTexture("map"));
      } else {
        node = colorNode;
      }
    } else if (scope === _MaterialNode.OPACITY) {
      const opacityNode = this.getFloat(scope);
      if (material.alphaMap && material.alphaMap.isTexture === true) {
        node = opacityNode.mul(this.getTexture("alpha"));
      } else {
        node = opacityNode;
      }
    } else if (scope === _MaterialNode.SPECULAR_STRENGTH) {
      if (material.specularMap && material.specularMap.isTexture === true) {
        node = this.getTexture("specular").r;
      } else {
        node = float(1);
      }
    } else if (scope === _MaterialNode.SPECULAR_INTENSITY) {
      const specularIntensityNode = this.getFloat(scope);
      if (material.specularIntensityMap && material.specularIntensityMap.isTexture === true) {
        node = specularIntensityNode.mul(this.getTexture(scope).a);
      } else {
        node = specularIntensityNode;
      }
    } else if (scope === _MaterialNode.SPECULAR_COLOR) {
      const specularColorNode = this.getColor(scope);
      if (material.specularColorMap && material.specularColorMap.isTexture === true) {
        node = specularColorNode.mul(this.getTexture(scope).rgb);
      } else {
        node = specularColorNode;
      }
    } else if (scope === _MaterialNode.ROUGHNESS) {
      const roughnessNode = this.getFloat(scope);
      if (material.roughnessMap && material.roughnessMap.isTexture === true) {
        node = roughnessNode.mul(this.getTexture(scope).g);
      } else {
        node = roughnessNode;
      }
    } else if (scope === _MaterialNode.METALNESS) {
      const metalnessNode = this.getFloat(scope);
      if (material.metalnessMap && material.metalnessMap.isTexture === true) {
        node = metalnessNode.mul(this.getTexture(scope).b);
      } else {
        node = metalnessNode;
      }
    } else if (scope === _MaterialNode.EMISSIVE) {
      const emissiveIntensityNode = this.getFloat("emissiveIntensity");
      const emissiveNode = this.getColor(scope).mul(emissiveIntensityNode);
      if (material.emissiveMap && material.emissiveMap.isTexture === true) {
        node = emissiveNode.mul(this.getTexture(scope));
      } else {
        node = emissiveNode;
      }
    } else if (scope === _MaterialNode.NORMAL) {
      if (material.normalMap) {
        node = normalMap(this.getTexture("normal"), this.getCache("normalScale", "vec2"));
        node.normalMapType = material.normalMapType;
      } else if (material.bumpMap) {
        node = bumpMap(this.getTexture("bump").r, this.getFloat("bumpScale"));
      } else {
        node = normalView;
      }
    } else if (scope === _MaterialNode.CLEARCOAT) {
      const clearcoatNode = this.getFloat(scope);
      if (material.clearcoatMap && material.clearcoatMap.isTexture === true) {
        node = clearcoatNode.mul(this.getTexture(scope).r);
      } else {
        node = clearcoatNode;
      }
    } else if (scope === _MaterialNode.CLEARCOAT_ROUGHNESS) {
      const clearcoatRoughnessNode = this.getFloat(scope);
      if (material.clearcoatRoughnessMap && material.clearcoatRoughnessMap.isTexture === true) {
        node = clearcoatRoughnessNode.mul(this.getTexture(scope).r);
      } else {
        node = clearcoatRoughnessNode;
      }
    } else if (scope === _MaterialNode.CLEARCOAT_NORMAL) {
      if (material.clearcoatNormalMap) {
        node = normalMap(this.getTexture(scope), this.getCache(scope + "Scale", "vec2"));
      } else {
        node = normalView;
      }
    } else if (scope === _MaterialNode.SHEEN) {
      const sheenNode = this.getColor("sheenColor").mul(this.getFloat("sheen"));
      if (material.sheenColorMap && material.sheenColorMap.isTexture === true) {
        node = sheenNode.mul(this.getTexture("sheenColor").rgb);
      } else {
        node = sheenNode;
      }
    } else if (scope === _MaterialNode.SHEEN_ROUGHNESS) {
      const sheenRoughnessNode = this.getFloat(scope);
      if (material.sheenRoughnessMap && material.sheenRoughnessMap.isTexture === true) {
        node = sheenRoughnessNode.mul(this.getTexture(scope).a);
      } else {
        node = sheenRoughnessNode;
      }
      node = node.clamp(0.07, 1);
    } else if (scope === _MaterialNode.ANISOTROPY) {
      if (material.anisotropyMap && material.anisotropyMap.isTexture === true) {
        const anisotropyPolar = this.getTexture(scope);
        const anisotropyMat = mat2(materialAnisotropyVector.x, materialAnisotropyVector.y, materialAnisotropyVector.y.negate(), materialAnisotropyVector.x);
        node = anisotropyMat.mul(anisotropyPolar.rg.mul(2).sub(vec2(1)).normalize().mul(anisotropyPolar.b));
      } else {
        node = materialAnisotropyVector;
      }
    } else if (scope === _MaterialNode.IRIDESCENCE_THICKNESS) {
      const iridescenceThicknessMaximum = reference("1", "float", material.iridescenceThicknessRange);
      if (material.iridescenceThicknessMap) {
        const iridescenceThicknessMinimum = reference("0", "float", material.iridescenceThicknessRange);
        node = iridescenceThicknessMaximum.sub(iridescenceThicknessMinimum).mul(this.getTexture(scope).g).add(iridescenceThicknessMinimum);
      } else {
        node = iridescenceThicknessMaximum;
      }
    } else if (scope === _MaterialNode.TRANSMISSION) {
      const transmissionNode = this.getFloat(scope);
      if (material.transmissionMap) {
        node = transmissionNode.mul(this.getTexture(scope).r);
      } else {
        node = transmissionNode;
      }
    } else if (scope === _MaterialNode.THICKNESS) {
      const thicknessNode = this.getFloat(scope);
      if (material.thicknessMap) {
        node = thicknessNode.mul(this.getTexture(scope).g);
      } else {
        node = thicknessNode;
      }
    } else if (scope === _MaterialNode.IOR) {
      node = this.getFloat(scope);
    } else if (scope === _MaterialNode.LIGHT_MAP) {
      node = this.getTexture(scope).rgb.mul(this.getFloat("lightMapIntensity"));
    } else if (scope === _MaterialNode.AO) {
      node = this.getTexture(scope).r.sub(1).mul(this.getFloat("aoMapIntensity")).add(1);
    } else if (scope === _MaterialNode.LINE_DASH_OFFSET) {
      node = material.dashOffset ? this.getFloat(scope) : float(0);
    } else {
      const outputType = this.getNodeType(builder);
      node = this.getCache(scope, outputType);
    }
    return node;
  }
};
MaterialNode.ALPHA_TEST = "alphaTest";
MaterialNode.COLOR = "color";
MaterialNode.OPACITY = "opacity";
MaterialNode.SHININESS = "shininess";
MaterialNode.SPECULAR = "specular";
MaterialNode.SPECULAR_STRENGTH = "specularStrength";
MaterialNode.SPECULAR_INTENSITY = "specularIntensity";
MaterialNode.SPECULAR_COLOR = "specularColor";
MaterialNode.REFLECTIVITY = "reflectivity";
MaterialNode.ROUGHNESS = "roughness";
MaterialNode.METALNESS = "metalness";
MaterialNode.NORMAL = "normal";
MaterialNode.CLEARCOAT = "clearcoat";
MaterialNode.CLEARCOAT_ROUGHNESS = "clearcoatRoughness";
MaterialNode.CLEARCOAT_NORMAL = "clearcoatNormal";
MaterialNode.EMISSIVE = "emissive";
MaterialNode.ROTATION = "rotation";
MaterialNode.SHEEN = "sheen";
MaterialNode.SHEEN_ROUGHNESS = "sheenRoughness";
MaterialNode.ANISOTROPY = "anisotropy";
MaterialNode.IRIDESCENCE = "iridescence";
MaterialNode.IRIDESCENCE_IOR = "iridescenceIOR";
MaterialNode.IRIDESCENCE_THICKNESS = "iridescenceThickness";
MaterialNode.IOR = "ior";
MaterialNode.TRANSMISSION = "transmission";
MaterialNode.THICKNESS = "thickness";
MaterialNode.ATTENUATION_DISTANCE = "attenuationDistance";
MaterialNode.ATTENUATION_COLOR = "attenuationColor";
MaterialNode.LINE_SCALE = "scale";
MaterialNode.LINE_DASH_SIZE = "dashSize";
MaterialNode.LINE_GAP_SIZE = "gapSize";
MaterialNode.LINE_WIDTH = "linewidth";
MaterialNode.LINE_DASH_OFFSET = "dashOffset";
MaterialNode.POINT_SIZE = "size";
MaterialNode.DISPERSION = "dispersion";
MaterialNode.LIGHT_MAP = "light";
MaterialNode.AO = "ao";
var materialAlphaTest = nodeImmutable(MaterialNode, MaterialNode.ALPHA_TEST);
var materialColor = nodeImmutable(MaterialNode, MaterialNode.COLOR);
var materialShininess = nodeImmutable(MaterialNode, MaterialNode.SHININESS);
var materialEmissive = nodeImmutable(MaterialNode, MaterialNode.EMISSIVE);
var materialOpacity = nodeImmutable(MaterialNode, MaterialNode.OPACITY);
var materialSpecular = nodeImmutable(MaterialNode, MaterialNode.SPECULAR);
var materialSpecularIntensity = nodeImmutable(MaterialNode, MaterialNode.SPECULAR_INTENSITY);
var materialSpecularColor = nodeImmutable(MaterialNode, MaterialNode.SPECULAR_COLOR);
var materialSpecularStrength = nodeImmutable(MaterialNode, MaterialNode.SPECULAR_STRENGTH);
var materialReflectivity = nodeImmutable(MaterialNode, MaterialNode.REFLECTIVITY);
var materialRoughness = nodeImmutable(MaterialNode, MaterialNode.ROUGHNESS);
var materialMetalness = nodeImmutable(MaterialNode, MaterialNode.METALNESS);
var materialNormal = nodeImmutable(MaterialNode, MaterialNode.NORMAL);
var materialClearcoat = nodeImmutable(MaterialNode, MaterialNode.CLEARCOAT);
var materialClearcoatRoughness = nodeImmutable(MaterialNode, MaterialNode.CLEARCOAT_ROUGHNESS);
var materialClearcoatNormal = nodeImmutable(MaterialNode, MaterialNode.CLEARCOAT_NORMAL);
var materialRotation = nodeImmutable(MaterialNode, MaterialNode.ROTATION);
var materialSheen = nodeImmutable(MaterialNode, MaterialNode.SHEEN);
var materialSheenRoughness = nodeImmutable(MaterialNode, MaterialNode.SHEEN_ROUGHNESS);
var materialAnisotropy = nodeImmutable(MaterialNode, MaterialNode.ANISOTROPY);
var materialIridescence = nodeImmutable(MaterialNode, MaterialNode.IRIDESCENCE);
var materialIridescenceIOR = nodeImmutable(MaterialNode, MaterialNode.IRIDESCENCE_IOR);
var materialIridescenceThickness = nodeImmutable(MaterialNode, MaterialNode.IRIDESCENCE_THICKNESS);
var materialTransmission = nodeImmutable(MaterialNode, MaterialNode.TRANSMISSION);
var materialThickness = nodeImmutable(MaterialNode, MaterialNode.THICKNESS);
var materialIOR = nodeImmutable(MaterialNode, MaterialNode.IOR);
var materialAttenuationDistance = nodeImmutable(MaterialNode, MaterialNode.ATTENUATION_DISTANCE);
var materialAttenuationColor = nodeImmutable(MaterialNode, MaterialNode.ATTENUATION_COLOR);
var materialLineScale = nodeImmutable(MaterialNode, MaterialNode.LINE_SCALE);
var materialLineDashSize = nodeImmutable(MaterialNode, MaterialNode.LINE_DASH_SIZE);
var materialLineGapSize = nodeImmutable(MaterialNode, MaterialNode.LINE_GAP_SIZE);
var materialLineWidth = nodeImmutable(MaterialNode, MaterialNode.LINE_WIDTH);
var materialLineDashOffset = nodeImmutable(MaterialNode, MaterialNode.LINE_DASH_OFFSET);
var materialPointSize = nodeImmutable(MaterialNode, MaterialNode.POINT_SIZE);
var materialDispersion = nodeImmutable(MaterialNode, MaterialNode.DISPERSION);
var materialLightMap = nodeImmutable(MaterialNode, MaterialNode.LIGHT_MAP);
var materialAO = nodeImmutable(MaterialNode, MaterialNode.AO);
var materialAnisotropyVector = uniform(new Vector2()).onReference(function(frame) {
  return frame.material;
}).onRenderUpdate(function({ material }) {
  this.value.set(material.anisotropy * Math.cos(material.anisotropyRotation), material.anisotropy * Math.sin(material.anisotropyRotation));
});
var modelViewProjection = Fn((builder) => {
  return builder.context.setupModelViewProjection();
}, "vec4").once()().toVarying("v_modelViewProjection");
var IndexNode = class _IndexNode extends Node {
  static get type() {
    return "IndexNode";
  }
  /**
   * Constructs a new index node.
   *
   * @param {('vertex'|'instance'|'subgroup'|'invocationLocal'|'invocationSubgroup'|'draw')} scope - The scope of the index node.
   */
  constructor(scope) {
    super("uint");
    this.scope = scope;
    this.isIndexNode = true;
  }
  generate(builder) {
    const nodeType = this.getNodeType(builder);
    const scope = this.scope;
    let propertyName;
    if (scope === _IndexNode.VERTEX) {
      propertyName = builder.getVertexIndex();
    } else if (scope === _IndexNode.INSTANCE) {
      propertyName = builder.getInstanceIndex();
    } else if (scope === _IndexNode.DRAW) {
      propertyName = builder.getDrawIndex();
    } else if (scope === _IndexNode.INVOCATION_LOCAL) {
      propertyName = builder.getInvocationLocalIndex();
    } else if (scope === _IndexNode.INVOCATION_SUBGROUP) {
      propertyName = builder.getInvocationSubgroupIndex();
    } else if (scope === _IndexNode.SUBGROUP) {
      propertyName = builder.getSubgroupIndex();
    } else {
      throw new Error("THREE.IndexNode: Unknown scope: " + scope);
    }
    let output3;
    if (builder.shaderStage === "vertex" || builder.shaderStage === "compute") {
      output3 = propertyName;
    } else {
      const nodeVarying = varying(this);
      output3 = nodeVarying.build(builder, nodeType);
    }
    return output3;
  }
};
IndexNode.VERTEX = "vertex";
IndexNode.INSTANCE = "instance";
IndexNode.SUBGROUP = "subgroup";
IndexNode.INVOCATION_LOCAL = "invocationLocal";
IndexNode.INVOCATION_SUBGROUP = "invocationSubgroup";
IndexNode.DRAW = "draw";
var vertexIndex = nodeImmutable(IndexNode, IndexNode.VERTEX);
var instanceIndex = nodeImmutable(IndexNode, IndexNode.INSTANCE);
var subgroupIndex = nodeImmutable(IndexNode, IndexNode.SUBGROUP);
var invocationSubgroupIndex = nodeImmutable(IndexNode, IndexNode.INVOCATION_SUBGROUP);
var invocationLocalIndex = nodeImmutable(IndexNode, IndexNode.INVOCATION_LOCAL);
var drawIndex = nodeImmutable(IndexNode, IndexNode.DRAW);
var InstanceNode = class extends Node {
  static get type() {
    return "InstanceNode";
  }
  /**
   * Constructs a new instance node.
   *
   * @param {number} count - The number of instances.
   * @param {InstancedBufferAttribute} instanceMatrix - Instanced buffer attribute representing the instance transformations.
   * @param {?InstancedBufferAttribute} instanceColor - Instanced buffer attribute representing the instance colors.
   */
  constructor(count2, instanceMatrix, instanceColor = null) {
    super("void");
    this.count = count2;
    this.instanceMatrix = instanceMatrix;
    this.instanceColor = instanceColor;
    this.instanceMatrixNode = null;
    this.instanceColorNode = null;
    this.updateType = NodeUpdateType.FRAME;
    this.buffer = null;
    this.bufferColor = null;
  }
  /**
   * Setups the internal buffers and nodes and assigns the transformed vertex data
   * to predefined node variables for accumulation. That follows the same patterns
   * like with morph and skinning nodes.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  setup(builder) {
    const { instanceMatrix, instanceColor } = this;
    const { count: count2 } = instanceMatrix;
    let { instanceMatrixNode, instanceColorNode } = this;
    if (instanceMatrixNode === null) {
      if (count2 <= 1e3) {
        instanceMatrixNode = buffer(instanceMatrix.array, "mat4", Math.max(count2, 1)).element(instanceIndex);
      } else {
        const buffer3 = new InstancedInterleavedBuffer(instanceMatrix.array, 16, 1);
        this.buffer = buffer3;
        const bufferFn = instanceMatrix.usage === DynamicDrawUsage ? instancedDynamicBufferAttribute : instancedBufferAttribute;
        const instanceBuffers = [
          // F.Signature -> bufferAttribute( array, type, stride, offset )
          bufferFn(buffer3, "vec4", 16, 0),
          bufferFn(buffer3, "vec4", 16, 4),
          bufferFn(buffer3, "vec4", 16, 8),
          bufferFn(buffer3, "vec4", 16, 12)
        ];
        instanceMatrixNode = mat4(...instanceBuffers);
      }
      this.instanceMatrixNode = instanceMatrixNode;
    }
    if (instanceColor && instanceColorNode === null) {
      const buffer3 = new InstancedBufferAttribute(instanceColor.array, 3);
      const bufferFn = instanceColor.usage === DynamicDrawUsage ? instancedDynamicBufferAttribute : instancedBufferAttribute;
      this.bufferColor = buffer3;
      instanceColorNode = vec3(bufferFn(buffer3, "vec3", 3, 0));
      this.instanceColorNode = instanceColorNode;
    }
    const instancePosition = instanceMatrixNode.mul(positionLocal).xyz;
    positionLocal.assign(instancePosition);
    if (builder.hasGeometryAttribute("normal")) {
      const instanceNormal = transformNormal(normalLocal, instanceMatrixNode);
      normalLocal.assign(instanceNormal);
    }
    if (this.instanceColorNode !== null) {
      varyingProperty("vec3", "vInstanceColor").assign(this.instanceColorNode);
    }
  }
  /**
   * Checks if the internal buffers required an update.
   *
   * @param {NodeFrame} frame - The current node frame.
   */
  update() {
    if (this.instanceMatrix.usage !== DynamicDrawUsage && this.buffer !== null && this.instanceMatrix.version !== this.buffer.version) {
      this.buffer.version = this.instanceMatrix.version;
    }
    if (this.instanceColor && this.instanceColor.usage !== DynamicDrawUsage && this.bufferColor !== null && this.instanceColor.version !== this.bufferColor.version) {
      this.bufferColor.version = this.instanceColor.version;
    }
  }
};
var instance = nodeProxy(InstanceNode).setParameterLength(2, 3);
var InstancedMeshNode = class extends InstanceNode {
  static get type() {
    return "InstancedMeshNode";
  }
  /**
   * Constructs a new instanced mesh node.
   *
   * @param {InstancedMesh} instancedMesh - The instanced mesh.
   */
  constructor(instancedMesh3) {
    const { count: count2, instanceMatrix, instanceColor } = instancedMesh3;
    super(count2, instanceMatrix, instanceColor);
    this.instancedMesh = instancedMesh3;
  }
};
var instancedMesh = nodeProxy(InstancedMeshNode).setParameterLength(1);
var BatchNode = class extends Node {
  static get type() {
    return "BatchNode";
  }
  /**
   * Constructs a new batch node.
   *
   * @param {BatchedMesh} batchMesh - A reference to batched mesh.
   */
  constructor(batchMesh) {
    super("void");
    this.batchMesh = batchMesh;
    this.batchingIdNode = null;
  }
  /**
   * Setups the internal buffers and nodes and assigns the transformed vertex data
   * to predefined node variables for accumulation. That follows the same patterns
   * like with morph and skinning nodes.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  setup(builder) {
    if (this.batchingIdNode === null) {
      if (builder.getDrawIndex() === null) {
        this.batchingIdNode = instanceIndex;
      } else {
        this.batchingIdNode = drawIndex;
      }
    }
    const getIndirectIndex = Fn(([id]) => {
      const size2 = int(textureSize(textureLoad(this.batchMesh._indirectTexture), 0).x);
      const x2 = int(id).mod(size2);
      const y2 = int(id).div(size2);
      return textureLoad(this.batchMesh._indirectTexture, ivec2(x2, y2)).x;
    }).setLayout({
      name: "getIndirectIndex",
      type: "uint",
      inputs: [
        { name: "id", type: "int" }
      ]
    });
    const indirectId = getIndirectIndex(int(this.batchingIdNode));
    const matricesTexture = this.batchMesh._matricesTexture;
    const size = int(textureSize(textureLoad(matricesTexture), 0).x);
    const j = float(indirectId).mul(4).toInt().toVar();
    const x = j.mod(size);
    const y = j.div(size);
    const batchingMatrix = mat4(
      textureLoad(matricesTexture, ivec2(x, y)),
      textureLoad(matricesTexture, ivec2(x.add(1), y)),
      textureLoad(matricesTexture, ivec2(x.add(2), y)),
      textureLoad(matricesTexture, ivec2(x.add(3), y))
    );
    const colorsTexture = this.batchMesh._colorsTexture;
    if (colorsTexture !== null) {
      const getBatchingColor = Fn(([id]) => {
        const size2 = int(textureSize(textureLoad(colorsTexture), 0).x);
        const j2 = id;
        const x2 = j2.mod(size2);
        const y2 = j2.div(size2);
        return textureLoad(colorsTexture, ivec2(x2, y2)).rgb;
      }).setLayout({
        name: "getBatchingColor",
        type: "vec3",
        inputs: [
          { name: "id", type: "int" }
        ]
      });
      const color4 = getBatchingColor(indirectId);
      varyingProperty("vec3", "vBatchColor").assign(color4);
    }
    const bm = mat3(batchingMatrix);
    positionLocal.assign(batchingMatrix.mul(positionLocal));
    const transformedNormal = normalLocal.div(vec3(bm[0].dot(bm[0]), bm[1].dot(bm[1]), bm[2].dot(bm[2])));
    const batchingNormal = bm.mul(transformedNormal).xyz;
    normalLocal.assign(batchingNormal);
    if (builder.hasGeometryAttribute("tangent")) {
      tangentLocal.mulAssign(bm);
    }
  }
};
var batch = nodeProxy(BatchNode).setParameterLength(1);
var StorageArrayElementNode = class extends ArrayElementNode {
  static get type() {
    return "StorageArrayElementNode";
  }
  /**
   * Constructs storage buffer element node.
   *
   * @param {StorageBufferNode} storageBufferNode - The storage buffer node.
   * @param {Node} indexNode - The index node that defines the element access.
   */
  constructor(storageBufferNode, indexNode) {
    super(storageBufferNode, indexNode);
    this.isStorageArrayElementNode = true;
  }
  /**
   * The storage buffer node.
   *
   * @param {Node} value
   * @type {StorageBufferNode}
   */
  set storageBufferNode(value) {
    this.node = value;
  }
  get storageBufferNode() {
    return this.node;
  }
  getMemberType(builder, name) {
    const structTypeNode = this.storageBufferNode.structTypeNode;
    if (structTypeNode) {
      return structTypeNode.getMemberType(builder, name);
    }
    return "void";
  }
  setup(builder) {
    if (builder.isAvailable("storageBuffer") === false) {
      if (this.node.isPBO === true) {
        builder.setupPBO(this.node);
      }
    }
    return super.setup(builder);
  }
  generate(builder, output3) {
    let snippet;
    const isAssignContext = builder.context.assign;
    if (builder.isAvailable("storageBuffer") === false) {
      if (this.node.isPBO === true && isAssignContext !== true && (this.node.value.isInstancedBufferAttribute || builder.shaderStage !== "compute")) {
        snippet = builder.generatePBO(this);
      } else {
        snippet = this.node.build(builder);
      }
    } else {
      snippet = super.generate(builder);
    }
    if (isAssignContext !== true) {
      const type = this.getNodeType(builder);
      snippet = builder.format(snippet, type, output3);
    }
    return snippet;
  }
};
var storageElement = nodeProxy(StorageArrayElementNode).setParameterLength(2);
var StorageBufferNode = class extends BufferNode {
  static get type() {
    return "StorageBufferNode";
  }
  /**
   * Constructs a new storage buffer node.
   *
   * @param {StorageBufferAttribute|StorageInstancedBufferAttribute|BufferAttribute} value - The buffer data.
   * @param {?(string|Struct)} [bufferType=null] - The buffer type (e.g. `'vec3'`).
   * @param {number} [bufferCount=0] - The buffer count.
   */
  constructor(value, bufferType = null, bufferCount = 0) {
    let nodeType, structTypeNode = null;
    if (bufferType && bufferType.isStruct) {
      nodeType = "struct";
      structTypeNode = bufferType.layout;
      if (value.isStorageBufferAttribute || value.isStorageInstancedBufferAttribute) {
        bufferCount = value.count;
      }
    } else if (bufferType === null && (value.isStorageBufferAttribute || value.isStorageInstancedBufferAttribute)) {
      nodeType = getTypeFromLength(value.itemSize);
      bufferCount = value.count;
    } else {
      nodeType = bufferType;
    }
    super(value, nodeType, bufferCount);
    this.isStorageBufferNode = true;
    this.structTypeNode = structTypeNode;
    this.access = NodeAccess.READ_WRITE;
    this.isAtomic = false;
    this.isPBO = false;
    this._attribute = null;
    this._varying = null;
    this.global = true;
    if (value.isStorageBufferAttribute !== true && value.isStorageInstancedBufferAttribute !== true) {
      if (value.isInstancedBufferAttribute) value.isStorageInstancedBufferAttribute = true;
      else value.isStorageBufferAttribute = true;
    }
  }
  /**
   * This method is overwritten since the buffer data might be shared
   * and thus the hash should be shared as well.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The hash.
   */
  getHash(builder) {
    if (this.bufferCount === 0) {
      let bufferData = builder.globalCache.getData(this.value);
      if (bufferData === void 0) {
        bufferData = {
          node: this
        };
        builder.globalCache.setData(this.value, bufferData);
      }
      return bufferData.node.uuid;
    }
    return this.uuid;
  }
  /**
   * Overwrites the default implementation to return a fixed value `'indirectStorageBuffer'` or `'storageBuffer'`.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The input type.
   */
  getInputType() {
    return this.value.isIndirectStorageBufferAttribute ? "indirectStorageBuffer" : "storageBuffer";
  }
  /**
   * Enables element access with the given index node.
   *
   * @param {IndexNode} indexNode - The index node.
   * @return {StorageArrayElementNode} A node representing the element access.
   */
  element(indexNode) {
    return storageElement(this, indexNode);
  }
  /**
   * Defines whether this node is a PBO or not. Only relevant for WebGL.
   *
   * @param {boolean} value - The value so set.
   * @return {StorageBufferNode} A reference to this node.
   */
  setPBO(value) {
    this.isPBO = value;
    return this;
  }
  /**
   * Returns the `isPBO` value.
   *
   * @return {boolean} Whether the node represents a PBO or not.
   */
  getPBO() {
    return this.isPBO;
  }
  /**
   * Defines the node access.
   *
   * @param {string} value - The node access.
   * @return {StorageBufferNode} A reference to this node.
   */
  setAccess(value) {
    this.access = value;
    return this;
  }
  /**
   * Convenience method for configuring a read-only node access.
   *
   * @return {StorageBufferNode} A reference to this node.
   */
  toReadOnly() {
    return this.setAccess(NodeAccess.READ_ONLY);
  }
  /**
   * Defines whether the node is atomic or not.
   *
   * @param {boolean} value - The atomic flag.
   * @return {StorageBufferNode} A reference to this node.
   */
  setAtomic(value) {
    this.isAtomic = value;
    return this;
  }
  /**
   * Convenience method for making this node atomic.
   *
   * @return {StorageBufferNode} A reference to this node.
   */
  toAtomic() {
    return this.setAtomic(true);
  }
  /**
   * Returns attribute data for this storage buffer node.
   *
   * @return {{attribute: BufferAttributeNode, varying: VaryingNode}} The attribute data.
   */
  getAttributeData() {
    if (this._attribute === null) {
      this._attribute = bufferAttribute(this.value);
      this._varying = varying(this._attribute);
    }
    return {
      attribute: this._attribute,
      varying: this._varying
    };
  }
  /**
   * This method is overwritten since the node type from the availability of storage buffers
   * and the attribute data.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node type.
   */
  getNodeType(builder) {
    if (this.structTypeNode !== null) {
      return this.structTypeNode.getNodeType(builder);
    }
    if (builder.isAvailable("storageBuffer") || builder.isAvailable("indirectStorageBuffer")) {
      return super.getNodeType(builder);
    }
    const { attribute: attribute3 } = this.getAttributeData();
    return attribute3.getNodeType(builder);
  }
  /**
   * Returns the type of a member of the struct.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {string} name - The name of the member.
   * @return {string} The type of the member.
   */
  getMemberType(builder, name) {
    if (this.structTypeNode !== null) {
      return this.structTypeNode.getMemberType(builder, name);
    }
    return "void";
  }
  /**
   * Generates the code snippet of the storage buffer node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The generated code snippet.
   */
  generate(builder) {
    if (this.structTypeNode !== null) this.structTypeNode.build(builder);
    if (builder.isAvailable("storageBuffer") || builder.isAvailable("indirectStorageBuffer")) {
      return super.generate(builder);
    }
    const { attribute: attribute3, varying: varying3 } = this.getAttributeData();
    const output3 = varying3.build(builder);
    builder.registerTransform(output3, attribute3);
    return output3;
  }
};
var storage = (value, type = null, count2 = 0) => nodeObject(new StorageBufferNode(value, type, count2));
var storageObject = (value, type, count2) => {
  console.warn('THREE.TSL: "storageObject()" is deprecated. Use "storage().setPBO( true )" instead.');
  return storage(value, type, count2).setPBO(true);
};
var _frameId = /* @__PURE__ */ new WeakMap();
var SkinningNode = class extends Node {
  static get type() {
    return "SkinningNode";
  }
  /**
   * Constructs a new skinning node.
   *
   * @param {SkinnedMesh} skinnedMesh - The skinned mesh.
   */
  constructor(skinnedMesh) {
    super("void");
    this.skinnedMesh = skinnedMesh;
    this.updateType = NodeUpdateType.OBJECT;
    this.skinIndexNode = attribute("skinIndex", "uvec4");
    this.skinWeightNode = attribute("skinWeight", "vec4");
    this.bindMatrixNode = reference("bindMatrix", "mat4");
    this.bindMatrixInverseNode = reference("bindMatrixInverse", "mat4");
    this.boneMatricesNode = referenceBuffer("skeleton.boneMatrices", "mat4", skinnedMesh.skeleton.bones.length);
    this.positionNode = positionLocal;
    this.toPositionNode = positionLocal;
    this.previousBoneMatricesNode = null;
  }
  /**
   * Transforms the given vertex position via skinning.
   *
   * @param {Node} [boneMatrices=this.boneMatricesNode] - The bone matrices
   * @param {Node<vec3>} [position=this.positionNode] - The vertex position in local space.
   * @return {Node<vec3>} The transformed vertex position.
   */
  getSkinnedPosition(boneMatrices = this.boneMatricesNode, position = this.positionNode) {
    const { skinIndexNode, skinWeightNode, bindMatrixNode, bindMatrixInverseNode } = this;
    const boneMatX = boneMatrices.element(skinIndexNode.x);
    const boneMatY = boneMatrices.element(skinIndexNode.y);
    const boneMatZ = boneMatrices.element(skinIndexNode.z);
    const boneMatW = boneMatrices.element(skinIndexNode.w);
    const skinVertex = bindMatrixNode.mul(position);
    const skinned = add3(
      boneMatX.mul(skinWeightNode.x).mul(skinVertex),
      boneMatY.mul(skinWeightNode.y).mul(skinVertex),
      boneMatZ.mul(skinWeightNode.z).mul(skinVertex),
      boneMatW.mul(skinWeightNode.w).mul(skinVertex)
    );
    return bindMatrixInverseNode.mul(skinned).xyz;
  }
  /**
   * Transforms the given vertex normal via skinning.
   *
   * @param {Node} [boneMatrices=this.boneMatricesNode] - The bone matrices
   * @param {Node<vec3>} [normal=normalLocal] - The vertex normal in local space.
   * @return {Node<vec3>} The transformed vertex normal.
   */
  getSkinnedNormal(boneMatrices = this.boneMatricesNode, normal2 = normalLocal) {
    const { skinIndexNode, skinWeightNode, bindMatrixNode, bindMatrixInverseNode } = this;
    const boneMatX = boneMatrices.element(skinIndexNode.x);
    const boneMatY = boneMatrices.element(skinIndexNode.y);
    const boneMatZ = boneMatrices.element(skinIndexNode.z);
    const boneMatW = boneMatrices.element(skinIndexNode.w);
    let skinMatrix = add3(
      skinWeightNode.x.mul(boneMatX),
      skinWeightNode.y.mul(boneMatY),
      skinWeightNode.z.mul(boneMatZ),
      skinWeightNode.w.mul(boneMatW)
    );
    skinMatrix = bindMatrixInverseNode.mul(skinMatrix).mul(bindMatrixNode);
    return skinMatrix.transformDirection(normal2).xyz;
  }
  /**
   * Computes the transformed/skinned vertex position of the previous frame.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {Node<vec3>} The skinned position from the previous frame.
   */
  getPreviousSkinnedPosition(builder) {
    const skinnedMesh = builder.object;
    if (this.previousBoneMatricesNode === null) {
      skinnedMesh.skeleton.previousBoneMatrices = new Float32Array(skinnedMesh.skeleton.boneMatrices);
      this.previousBoneMatricesNode = referenceBuffer("skeleton.previousBoneMatrices", "mat4", skinnedMesh.skeleton.bones.length);
    }
    return this.getSkinnedPosition(this.previousBoneMatricesNode, positionPrevious);
  }
  /**
   * Returns `true` if bone matrices from the previous frame are required. Relevant
   * when computing motion vectors with {@link VelocityNode}.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {boolean} Whether bone matrices from the previous frame are required or not.
   */
  needsPreviousBoneMatrices(builder) {
    const mrt3 = builder.renderer.getMRT();
    return mrt3 && mrt3.has("velocity") || getDataFromObject(builder.object).useVelocity === true;
  }
  /**
   * Setups the skinning node by assigning the transformed vertex data to predefined node variables.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {Node<vec3>} The transformed vertex position.
   */
  setup(builder) {
    if (this.needsPreviousBoneMatrices(builder)) {
      positionPrevious.assign(this.getPreviousSkinnedPosition(builder));
    }
    const skinPosition = this.getSkinnedPosition();
    if (this.toPositionNode) this.toPositionNode.assign(skinPosition);
    if (builder.hasGeometryAttribute("normal")) {
      const skinNormal = this.getSkinnedNormal();
      normalLocal.assign(skinNormal);
      if (builder.hasGeometryAttribute("tangent")) {
        tangentLocal.assign(skinNormal);
      }
    }
    return skinPosition;
  }
  /**
   * Generates the code snippet of the skinning node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {string} output - The current output.
   * @return {string} The generated code snippet.
   */
  generate(builder, output3) {
    if (output3 !== "void") {
      return super.generate(builder, output3);
    }
  }
  /**
   * Updates the state of the skinned mesh by updating the skeleton once per frame.
   *
   * @param {NodeFrame} frame - The current node frame.
   */
  update(frame) {
    const skeleton = frame.object && frame.object.skeleton ? frame.object.skeleton : this.skinnedMesh.skeleton;
    if (_frameId.get(skeleton) === frame.frameId) return;
    _frameId.set(skeleton, frame.frameId);
    if (this.previousBoneMatricesNode !== null) skeleton.previousBoneMatrices.set(skeleton.boneMatrices);
    skeleton.update();
  }
};
var skinning = (skinnedMesh) => nodeObject(new SkinningNode(skinnedMesh));
var computeSkinning = (skinnedMesh, toPosition = null) => {
  const node = new SkinningNode(skinnedMesh);
  node.positionNode = storage(new InstancedBufferAttribute(skinnedMesh.geometry.getAttribute("position").array, 3), "vec3").setPBO(true).toReadOnly().element(instanceIndex).toVar();
  node.skinIndexNode = storage(new InstancedBufferAttribute(new Uint32Array(skinnedMesh.geometry.getAttribute("skinIndex").array), 4), "uvec4").setPBO(true).toReadOnly().element(instanceIndex).toVar();
  node.skinWeightNode = storage(new InstancedBufferAttribute(skinnedMesh.geometry.getAttribute("skinWeight").array, 4), "vec4").setPBO(true).toReadOnly().element(instanceIndex).toVar();
  node.bindMatrixNode = uniform(skinnedMesh.bindMatrix, "mat4");
  node.bindMatrixInverseNode = uniform(skinnedMesh.bindMatrixInverse, "mat4");
  node.boneMatricesNode = buffer(skinnedMesh.skeleton.boneMatrices, "mat4", skinnedMesh.skeleton.bones.length);
  node.toPositionNode = toPosition;
  return nodeObject(node);
};
var LoopNode = class extends Node {
  static get type() {
    return "LoopNode";
  }
  /**
   * Constructs a new loop node.
   *
   * @param {Array<any>} params - Depending on the loop type, array holds different parameterization values for the loop.
   */
  constructor(params = []) {
    super();
    this.params = params;
  }
  /**
   * Returns a loop variable name based on an index. The pattern is
   * `0` = `i`, `1`= `j`, `2`= `k` and so on.
   *
   * @param {number} index - The index.
   * @return {string} The loop variable name.
   */
  getVarName(index5) {
    return String.fromCharCode("i".charCodeAt(0) + index5);
  }
  /**
   * Returns properties about this node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {Object} The node properties.
   */
  getProperties(builder) {
    const properties = builder.getNodeProperties(this);
    if (properties.stackNode !== void 0) return properties;
    const inputs = {};
    for (let i = 0, l = this.params.length - 1; i < l; i++) {
      const param = this.params[i];
      const name = param.isNode !== true && param.name || this.getVarName(i);
      const type = param.isNode !== true && param.type || "int";
      inputs[name] = expression(name, type);
    }
    const stack3 = builder.addStack();
    properties.returnsNode = this.params[this.params.length - 1](inputs, builder);
    properties.stackNode = stack3;
    const baseParam = this.params[0];
    if (baseParam.isNode !== true && typeof baseParam.update === "function") {
      properties.updateNode = Fn(this.params[0].update)(inputs);
    }
    builder.removeStack();
    return properties;
  }
  /**
   * This method is overwritten since the node type is inferred based on the loop configuration.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node type.
   */
  getNodeType(builder) {
    const { returnsNode } = this.getProperties(builder);
    return returnsNode ? returnsNode.getNodeType(builder) : "void";
  }
  setup(builder) {
    this.getProperties(builder);
  }
  generate(builder) {
    const properties = this.getProperties(builder);
    const params = this.params;
    const stackNode = properties.stackNode;
    for (let i = 0, l = params.length - 1; i < l; i++) {
      const param = params[i];
      let isWhile = false, start = null, end = null, name = null, type = null, condition = null, update18 = null;
      if (param.isNode) {
        if (param.getNodeType(builder) === "bool") {
          isWhile = true;
          type = "bool";
          end = param.build(builder, type);
        } else {
          type = "int";
          name = this.getVarName(i);
          start = "0";
          end = param.build(builder, type);
          condition = "<";
        }
      } else {
        type = param.type || "int";
        name = param.name || this.getVarName(i);
        start = param.start;
        end = param.end;
        condition = param.condition;
        update18 = param.update;
        if (typeof start === "number") start = builder.generateConst(type, start);
        else if (start && start.isNode) start = start.build(builder, type);
        if (typeof end === "number") end = builder.generateConst(type, end);
        else if (end && end.isNode) end = end.build(builder, type);
        if (start !== void 0 && end === void 0) {
          start = start + " - 1";
          end = "0";
          condition = ">=";
        } else if (end !== void 0 && start === void 0) {
          start = "0";
          condition = "<";
        }
        if (condition === void 0) {
          if (Number(start) > Number(end)) {
            condition = ">=";
          } else {
            condition = "<";
          }
        }
      }
      let loopSnippet;
      if (isWhile) {
        loopSnippet = `while ( ${end} )`;
      } else {
        const internalParam = { start, end };
        const startSnippet = internalParam.start;
        const endSnippet = internalParam.end;
        let updateSnippet;
        const deltaOperator = () => condition.includes("<") ? "+=" : "-=";
        if (update18 !== void 0 && update18 !== null) {
          switch (typeof update18) {
            case "function":
              const flow = builder.flowStagesNode(properties.updateNode, "void");
              const snippet = flow.code.replace(/\t|;/g, "");
              updateSnippet = snippet;
              break;
            case "number":
              updateSnippet = name + " " + deltaOperator() + " " + builder.generateConst(type, update18);
              break;
            case "string":
              updateSnippet = name + " " + update18;
              break;
            default:
              if (update18.isNode) {
                updateSnippet = name + " " + deltaOperator() + " " + update18.build(builder);
              } else {
                console.error("THREE.TSL: 'Loop( { update: ... } )' is not a function, string or number.");
                updateSnippet = "break /* invalid update */";
              }
          }
        } else {
          if (type === "int" || type === "uint") {
            update18 = condition.includes("<") ? "++" : "--";
          } else {
            update18 = deltaOperator() + " 1.";
          }
          updateSnippet = name + " " + update18;
        }
        const declarationSnippet = builder.getVar(type, name) + " = " + startSnippet;
        const conditionalSnippet = name + " " + condition + " " + endSnippet;
        loopSnippet = `for ( ${declarationSnippet}; ${conditionalSnippet}; ${updateSnippet} )`;
      }
      builder.addFlowCode((i === 0 ? "\n" : "") + builder.tab + loopSnippet + " {\n\n").addFlowTab();
    }
    const stackSnippet = stackNode.build(builder, "void");
    const returnsSnippet = properties.returnsNode ? properties.returnsNode.build(builder) : "";
    builder.removeFlowTab().addFlowCode("\n" + builder.tab + stackSnippet);
    for (let i = 0, l = this.params.length - 1; i < l; i++) {
      builder.addFlowCode((i === 0 ? "" : builder.tab) + "}\n\n").removeFlowTab();
    }
    builder.addFlowTab();
    return returnsSnippet;
  }
};
var Loop = (...params) => nodeObject(new LoopNode(nodeArray(params, "int"))).toStack();
var Continue = () => expression("continue").toStack();
var Break = () => expression("break").toStack();
var _morphTextures = /* @__PURE__ */ new WeakMap();
var _morphVec4 = new Vector4();
var getMorph = Fn(({ bufferMap, influence, stride, width, depth: depth3, offset }) => {
  const texelIndex = int(vertexIndex).mul(stride).add(offset);
  const y = texelIndex.div(width);
  const x = texelIndex.sub(y.mul(width));
  const bufferAttrib = textureLoad(bufferMap, ivec2(x, y)).depth(depth3).xyz;
  return bufferAttrib.mul(influence);
});
function getEntry(geometry) {
  const hasMorphPosition = geometry.morphAttributes.position !== void 0;
  const hasMorphNormals = geometry.morphAttributes.normal !== void 0;
  const hasMorphColors = geometry.morphAttributes.color !== void 0;
  const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
  const morphTargetsCount = morphAttribute !== void 0 ? morphAttribute.length : 0;
  let entry = _morphTextures.get(geometry);
  if (entry === void 0 || entry.count !== morphTargetsCount) {
    let disposeTexture = function() {
      bufferTexture.dispose();
      _morphTextures.delete(geometry);
      geometry.removeEventListener("dispose", disposeTexture);
    };
    if (entry !== void 0) entry.texture.dispose();
    const morphTargets = geometry.morphAttributes.position || [];
    const morphNormals = geometry.morphAttributes.normal || [];
    const morphColors = geometry.morphAttributes.color || [];
    let vertexDataCount = 0;
    if (hasMorphPosition === true) vertexDataCount = 1;
    if (hasMorphNormals === true) vertexDataCount = 2;
    if (hasMorphColors === true) vertexDataCount = 3;
    let width = geometry.attributes.position.count * vertexDataCount;
    let height = 1;
    const maxTextureSize = 4096;
    if (width > maxTextureSize) {
      height = Math.ceil(width / maxTextureSize);
      width = maxTextureSize;
    }
    const buffer3 = new Float32Array(width * height * 4 * morphTargetsCount);
    const bufferTexture = new DataArrayTexture(buffer3, width, height, morphTargetsCount);
    bufferTexture.type = FloatType;
    bufferTexture.needsUpdate = true;
    const vertexDataStride = vertexDataCount * 4;
    for (let i = 0; i < morphTargetsCount; i++) {
      const morphTarget = morphTargets[i];
      const morphNormal = morphNormals[i];
      const morphColor = morphColors[i];
      const offset = width * height * 4 * i;
      for (let j = 0; j < morphTarget.count; j++) {
        const stride = j * vertexDataStride;
        if (hasMorphPosition === true) {
          _morphVec4.fromBufferAttribute(morphTarget, j);
          buffer3[offset + stride + 0] = _morphVec4.x;
          buffer3[offset + stride + 1] = _morphVec4.y;
          buffer3[offset + stride + 2] = _morphVec4.z;
          buffer3[offset + stride + 3] = 0;
        }
        if (hasMorphNormals === true) {
          _morphVec4.fromBufferAttribute(morphNormal, j);
          buffer3[offset + stride + 4] = _morphVec4.x;
          buffer3[offset + stride + 5] = _morphVec4.y;
          buffer3[offset + stride + 6] = _morphVec4.z;
          buffer3[offset + stride + 7] = 0;
        }
        if (hasMorphColors === true) {
          _morphVec4.fromBufferAttribute(morphColor, j);
          buffer3[offset + stride + 8] = _morphVec4.x;
          buffer3[offset + stride + 9] = _morphVec4.y;
          buffer3[offset + stride + 10] = _morphVec4.z;
          buffer3[offset + stride + 11] = morphColor.itemSize === 4 ? _morphVec4.w : 1;
        }
      }
    }
    entry = {
      count: morphTargetsCount,
      texture: bufferTexture,
      stride: vertexDataCount,
      size: new Vector2(width, height)
    };
    _morphTextures.set(geometry, entry);
    geometry.addEventListener("dispose", disposeTexture);
  }
  return entry;
}
var MorphNode = class extends Node {
  static get type() {
    return "MorphNode";
  }
  /**
   * Constructs a new morph node.
   *
   * @param {Mesh} mesh - The mesh holding the morph targets.
   */
  constructor(mesh) {
    super("void");
    this.mesh = mesh;
    this.morphBaseInfluence = uniform(1);
    this.updateType = NodeUpdateType.OBJECT;
  }
  /**
   * Setups the morph node by assigning the transformed vertex data to predefined node variables.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  setup(builder) {
    const { geometry } = builder;
    const hasMorphPosition = geometry.morphAttributes.position !== void 0;
    const hasMorphNormals = geometry.hasAttribute("normal") && geometry.morphAttributes.normal !== void 0;
    const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
    const morphTargetsCount = morphAttribute !== void 0 ? morphAttribute.length : 0;
    const { texture: bufferMap, stride, size } = getEntry(geometry);
    if (hasMorphPosition === true) positionLocal.mulAssign(this.morphBaseInfluence);
    if (hasMorphNormals === true) normalLocal.mulAssign(this.morphBaseInfluence);
    const width = int(size.width);
    Loop(morphTargetsCount, ({ i }) => {
      const influence = float(0).toVar();
      if (this.mesh.count > 1 && (this.mesh.morphTexture !== null && this.mesh.morphTexture !== void 0)) {
        influence.assign(textureLoad(this.mesh.morphTexture, ivec2(int(i).add(1), int(instanceIndex))).r);
      } else {
        influence.assign(reference("morphTargetInfluences", "float").element(i).toVar());
      }
      If(influence.notEqual(0), () => {
        if (hasMorphPosition === true) {
          positionLocal.addAssign(getMorph({
            bufferMap,
            influence,
            stride,
            width,
            depth: i,
            offset: int(0)
          }));
        }
        if (hasMorphNormals === true) {
          normalLocal.addAssign(getMorph({
            bufferMap,
            influence,
            stride,
            width,
            depth: i,
            offset: int(1)
          }));
        }
      });
    });
  }
  /**
   * Updates the state of the morphed mesh by updating the base influence.
   *
   * @param {NodeFrame} frame - The current node frame.
   */
  update() {
    const morphBaseInfluence = this.morphBaseInfluence;
    if (this.mesh.geometry.morphTargetsRelative) {
      morphBaseInfluence.value = 1;
    } else {
      morphBaseInfluence.value = 1 - this.mesh.morphTargetInfluences.reduce((a, b) => a + b, 0);
    }
  }
};
var morphReference = nodeProxy(MorphNode).setParameterLength(1);
var LightingNode = class extends Node {
  static get type() {
    return "LightingNode";
  }
  /**
   * Constructs a new lighting node.
   */
  constructor() {
    super("vec3");
    this.isLightingNode = true;
  }
};
var AONode = class extends LightingNode {
  static get type() {
    return "AONode";
  }
  /**
   * Constructs a new AO node.
   *
   * @param {?Node<float>} [aoNode=null] - The ambient occlusion node.
   */
  constructor(aoNode = null) {
    super();
    this.aoNode = aoNode;
  }
  setup(builder) {
    builder.context.ambientOcclusion.mulAssign(this.aoNode);
  }
};
var LightingContextNode = class extends ContextNode {
  static get type() {
    return "LightingContextNode";
  }
  /**
   * Constructs a new lighting context node.
   *
   * @param {LightsNode} lightsNode - The lights node.
   * @param {?LightingModel} [lightingModel=null] - The current lighting model.
   * @param {?Node<vec3>} [backdropNode=null] - A backdrop node.
   * @param {?Node<float>} [backdropAlphaNode=null] - A backdrop alpha node.
   */
  constructor(lightsNode, lightingModel = null, backdropNode = null, backdropAlphaNode = null) {
    super(lightsNode);
    this.lightingModel = lightingModel;
    this.backdropNode = backdropNode;
    this.backdropAlphaNode = backdropAlphaNode;
    this._value = null;
  }
  /**
   * Returns a lighting context object.
   *
   * @return {{
   * radiance: Node<vec3>,
   * irradiance: Node<vec3>,
   * iblIrradiance: Node<vec3>,
   * ambientOcclusion: Node<float>,
   * reflectedLight: {directDiffuse: Node<vec3>, directSpecular: Node<vec3>, indirectDiffuse: Node<vec3>, indirectSpecular: Node<vec3>},
   * backdrop: Node<vec3>,
   * backdropAlpha: Node<float>
   * }} The lighting context object.
   */
  getContext() {
    const { backdropNode, backdropAlphaNode } = this;
    const directDiffuse = vec3().toVar("directDiffuse"), directSpecular = vec3().toVar("directSpecular"), indirectDiffuse = vec3().toVar("indirectDiffuse"), indirectSpecular = vec3().toVar("indirectSpecular");
    const reflectedLight = {
      directDiffuse,
      directSpecular,
      indirectDiffuse,
      indirectSpecular
    };
    const context3 = {
      radiance: vec3().toVar("radiance"),
      irradiance: vec3().toVar("irradiance"),
      iblIrradiance: vec3().toVar("iblIrradiance"),
      ambientOcclusion: float(1).toVar("ambientOcclusion"),
      reflectedLight,
      backdrop: backdropNode,
      backdropAlpha: backdropAlphaNode
    };
    return context3;
  }
  setup(builder) {
    this.value = this._value || (this._value = this.getContext());
    this.value.lightingModel = this.lightingModel || builder.context.lightingModel;
    return super.setup(builder);
  }
};
var lightingContext = nodeProxy(LightingContextNode);
var IrradianceNode = class extends LightingNode {
  static get type() {
    return "IrradianceNode";
  }
  /**
   * Constructs a new irradiance node.
   *
   * @param {Node<vec3>} node - A node contributing irradiance.
   */
  constructor(node) {
    super();
    this.node = node;
  }
  setup(builder) {
    builder.context.irradiance.addAssign(this.node);
  }
};
var _size$5 = new Vector2();
var ViewportTextureNode = class extends TextureNode {
  static get type() {
    return "ViewportTextureNode";
  }
  /**
   * Constructs a new viewport texture node.
   *
   * @param {Node} [uvNode=screenUV] - The uv node.
   * @param {?Node} [levelNode=null] - The level node.
   * @param {?Texture} [framebufferTexture=null] - A framebuffer texture holding the viewport data. If not provided, a framebuffer texture is created automatically.
   */
  constructor(uvNode = screenUV, levelNode = null, framebufferTexture = null) {
    let defaultFramebuffer = null;
    if (framebufferTexture === null) {
      defaultFramebuffer = new FramebufferTexture();
      defaultFramebuffer.minFilter = LinearMipmapLinearFilter;
      framebufferTexture = defaultFramebuffer;
    } else {
      defaultFramebuffer = framebufferTexture;
    }
    super(framebufferTexture, uvNode, levelNode);
    this.generateMipmaps = false;
    this.defaultFramebuffer = defaultFramebuffer;
    this.isOutputTextureNode = true;
    this.updateBeforeType = NodeUpdateType.FRAME;
    this._cacheTextures = /* @__PURE__ */ new WeakMap();
  }
  /**
   * This methods returns a texture for the given render target reference.
   *
   * To avoid rendering errors, `ViewportTextureNode` must use unique framebuffer textures
   * for different render contexts.
   *
   * @param {?RenderTarget} [reference=null] - The render target reference.
   * @return {Texture} The framebuffer texture.
   */
  getTextureForReference(reference3 = null) {
    let defaultFramebuffer;
    let cacheTextures;
    if (this.referenceNode) {
      defaultFramebuffer = this.referenceNode.defaultFramebuffer;
      cacheTextures = this.referenceNode._cacheTextures;
    } else {
      defaultFramebuffer = this.defaultFramebuffer;
      cacheTextures = this._cacheTextures;
    }
    if (reference3 === null) {
      return defaultFramebuffer;
    }
    if (cacheTextures.has(reference3) === false) {
      const framebufferTexture = defaultFramebuffer.clone();
      cacheTextures.set(reference3, framebufferTexture);
    }
    return cacheTextures.get(reference3);
  }
  updateReference(frame) {
    const renderTarget = frame.renderer.getRenderTarget();
    this.value = this.getTextureForReference(renderTarget);
    return this.value;
  }
  updateBefore(frame) {
    const renderer = frame.renderer;
    const renderTarget = renderer.getRenderTarget();
    if (renderTarget === null) {
      renderer.getDrawingBufferSize(_size$5);
    } else {
      _size$5.set(renderTarget.width, renderTarget.height);
    }
    const framebufferTexture = this.getTextureForReference(renderTarget);
    if (framebufferTexture.image.width !== _size$5.width || framebufferTexture.image.height !== _size$5.height) {
      framebufferTexture.image.width = _size$5.width;
      framebufferTexture.image.height = _size$5.height;
      framebufferTexture.needsUpdate = true;
    }
    const currentGenerateMipmaps = framebufferTexture.generateMipmaps;
    framebufferTexture.generateMipmaps = this.generateMipmaps;
    renderer.copyFramebufferToTexture(framebufferTexture);
    framebufferTexture.generateMipmaps = currentGenerateMipmaps;
  }
  clone() {
    const viewportTextureNode = new this.constructor(this.uvNode, this.levelNode, this.value);
    viewportTextureNode.generateMipmaps = this.generateMipmaps;
    return viewportTextureNode;
  }
};
var viewportTexture = nodeProxy(ViewportTextureNode).setParameterLength(0, 3);
var viewportMipTexture = nodeProxy(ViewportTextureNode, null, null, { generateMipmaps: true }).setParameterLength(0, 3);
var _sharedDepthbuffer = null;
var ViewportDepthTextureNode = class extends ViewportTextureNode {
  static get type() {
    return "ViewportDepthTextureNode";
  }
  /**
   * Constructs a new viewport depth texture node.
   *
   * @param {Node} [uvNode=screenUV] - The uv node.
   * @param {?Node} [levelNode=null] - The level node.
   */
  constructor(uvNode = screenUV, levelNode = null) {
    if (_sharedDepthbuffer === null) {
      _sharedDepthbuffer = new DepthTexture();
    }
    super(uvNode, levelNode, _sharedDepthbuffer);
  }
  /**
   * Overwritten so the method always returns the unique shared
   * depth texture.
   *
   * @return {DepthTexture} The shared depth texture.
   */
  getTextureForReference() {
    return _sharedDepthbuffer;
  }
};
var viewportDepthTexture = nodeProxy(ViewportDepthTextureNode).setParameterLength(0, 2);
var ViewportDepthNode = class _ViewportDepthNode extends Node {
  static get type() {
    return "ViewportDepthNode";
  }
  /**
   * Constructs a new viewport depth node.
   *
   * @param {('depth'|'depthBase'|'linearDepth')} scope - The node's scope.
   * @param {?Node} [valueNode=null] - The value node.
   */
  constructor(scope, valueNode = null) {
    super("float");
    this.scope = scope;
    this.valueNode = valueNode;
    this.isViewportDepthNode = true;
  }
  generate(builder) {
    const { scope } = this;
    if (scope === _ViewportDepthNode.DEPTH_BASE) {
      return builder.getFragDepth();
    }
    return super.generate(builder);
  }
  setup({ camera }) {
    const { scope } = this;
    const value = this.valueNode;
    let node = null;
    if (scope === _ViewportDepthNode.DEPTH_BASE) {
      if (value !== null) {
        node = depthBase().assign(value);
      }
    } else if (scope === _ViewportDepthNode.DEPTH) {
      if (camera.isPerspectiveCamera) {
        node = viewZToPerspectiveDepth(positionView.z, cameraNear, cameraFar);
      } else {
        node = viewZToOrthographicDepth(positionView.z, cameraNear, cameraFar);
      }
    } else if (scope === _ViewportDepthNode.LINEAR_DEPTH) {
      if (value !== null) {
        if (camera.isPerspectiveCamera) {
          const viewZ = perspectiveDepthToViewZ(value, cameraNear, cameraFar);
          node = viewZToOrthographicDepth(viewZ, cameraNear, cameraFar);
        } else {
          node = value;
        }
      } else {
        node = viewZToOrthographicDepth(positionView.z, cameraNear, cameraFar);
      }
    }
    return node;
  }
};
ViewportDepthNode.DEPTH_BASE = "depthBase";
ViewportDepthNode.DEPTH = "depth";
ViewportDepthNode.LINEAR_DEPTH = "linearDepth";
var viewZToOrthographicDepth = (viewZ, near, far) => viewZ.add(near).div(near.sub(far));
var orthographicDepthToViewZ = (depth3, near, far) => near.sub(far).mul(depth3).sub(near);
var viewZToPerspectiveDepth = (viewZ, near, far) => near.add(viewZ).mul(far).div(far.sub(near).mul(viewZ));
var perspectiveDepthToViewZ = (depth3, near, far) => near.mul(far).div(far.sub(near).mul(depth3).sub(far));
var viewZToLogarithmicDepth = (viewZ, near, far) => {
  near = near.max(1e-6).toVar();
  const numerator = log22(viewZ.negate().div(near));
  const denominator = log22(far.div(near));
  return numerator.div(denominator);
};
var logarithmicDepthToViewZ = (depth3, near, far) => {
  const exponent = depth3.mul(log3(far.div(near)));
  return float(Math.E).pow(exponent).mul(near).negate();
};
var depthBase = nodeProxy(ViewportDepthNode, ViewportDepthNode.DEPTH_BASE);
var depth = nodeImmutable(ViewportDepthNode, ViewportDepthNode.DEPTH);
var linearDepth = nodeProxy(ViewportDepthNode, ViewportDepthNode.LINEAR_DEPTH).setParameterLength(0, 1);
var viewportLinearDepth = linearDepth(viewportDepthTexture());
depth.assign = (value) => depthBase(value);
var ClippingNode = class _ClippingNode extends Node {
  static get type() {
    return "ClippingNode";
  }
  /**
   * Constructs a new clipping node.
   *
   * @param {('default'|'hardware'|'alphaToCoverage')} [scope='default'] - The node's scope. Similar to other nodes,
   * the selected scope influences the behavior of the node and what type of code is generated.
   */
  constructor(scope = _ClippingNode.DEFAULT) {
    super();
    this.scope = scope;
  }
  /**
   * Setups the node depending on the selected scope.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {Node} The result node.
   */
  setup(builder) {
    super.setup(builder);
    const clippingContext = builder.clippingContext;
    const { intersectionPlanes, unionPlanes } = clippingContext;
    this.hardwareClipping = builder.material.hardwareClipping;
    if (this.scope === _ClippingNode.ALPHA_TO_COVERAGE) {
      return this.setupAlphaToCoverage(intersectionPlanes, unionPlanes);
    } else if (this.scope === _ClippingNode.HARDWARE) {
      return this.setupHardwareClipping(unionPlanes, builder);
    } else {
      return this.setupDefault(intersectionPlanes, unionPlanes);
    }
  }
  /**
   * Setups alpha to coverage.
   *
   * @param {Array<Vector4>} intersectionPlanes - The intersection planes.
   * @param {Array<Vector4>} unionPlanes - The union planes.
   * @return {Node} The result node.
   */
  setupAlphaToCoverage(intersectionPlanes, unionPlanes) {
    return Fn(() => {
      const distanceToPlane = float().toVar("distanceToPlane");
      const distanceGradient = float().toVar("distanceToGradient");
      const clipOpacity = float(1).toVar("clipOpacity");
      const numUnionPlanes = unionPlanes.length;
      if (this.hardwareClipping === false && numUnionPlanes > 0) {
        const clippingPlanes = uniformArray(unionPlanes).setGroup(renderGroup);
        Loop(numUnionPlanes, ({ i }) => {
          const plane = clippingPlanes.element(i);
          distanceToPlane.assign(positionView.dot(plane.xyz).negate().add(plane.w));
          distanceGradient.assign(distanceToPlane.fwidth().div(2));
          clipOpacity.mulAssign(smoothstep(distanceGradient.negate(), distanceGradient, distanceToPlane));
        });
      }
      const numIntersectionPlanes = intersectionPlanes.length;
      if (numIntersectionPlanes > 0) {
        const clippingPlanes = uniformArray(intersectionPlanes).setGroup(renderGroup);
        const intersectionClipOpacity = float(1).toVar("intersectionClipOpacity");
        Loop(numIntersectionPlanes, ({ i }) => {
          const plane = clippingPlanes.element(i);
          distanceToPlane.assign(positionView.dot(plane.xyz).negate().add(plane.w));
          distanceGradient.assign(distanceToPlane.fwidth().div(2));
          intersectionClipOpacity.mulAssign(smoothstep(distanceGradient.negate(), distanceGradient, distanceToPlane).oneMinus());
        });
        clipOpacity.mulAssign(intersectionClipOpacity.oneMinus());
      }
      diffuseColor.a.mulAssign(clipOpacity);
      diffuseColor.a.equal(0).discard();
    })();
  }
  /**
   * Setups the default clipping.
   *
   * @param {Array<Vector4>} intersectionPlanes - The intersection planes.
   * @param {Array<Vector4>} unionPlanes - The union planes.
   * @return {Node} The result node.
   */
  setupDefault(intersectionPlanes, unionPlanes) {
    return Fn(() => {
      const numUnionPlanes = unionPlanes.length;
      if (this.hardwareClipping === false && numUnionPlanes > 0) {
        const clippingPlanes = uniformArray(unionPlanes).setGroup(renderGroup);
        Loop(numUnionPlanes, ({ i }) => {
          const plane = clippingPlanes.element(i);
          positionView.dot(plane.xyz).greaterThan(plane.w).discard();
        });
      }
      const numIntersectionPlanes = intersectionPlanes.length;
      if (numIntersectionPlanes > 0) {
        const clippingPlanes = uniformArray(intersectionPlanes).setGroup(renderGroup);
        const clipped = bool(true).toVar("clipped");
        Loop(numIntersectionPlanes, ({ i }) => {
          const plane = clippingPlanes.element(i);
          clipped.assign(positionView.dot(plane.xyz).greaterThan(plane.w).and(clipped));
        });
        clipped.discard();
      }
    })();
  }
  /**
   * Setups hardware clipping.
   *
   * @param {Array<Vector4>} unionPlanes - The union planes.
   * @param {NodeBuilder} builder - The current node builder.
   * @return {Node} The result node.
   */
  setupHardwareClipping(unionPlanes, builder) {
    const numUnionPlanes = unionPlanes.length;
    builder.enableHardwareClipping(numUnionPlanes);
    return Fn(() => {
      const clippingPlanes = uniformArray(unionPlanes).setGroup(renderGroup);
      const hw_clip_distances = builtin(builder.getClipDistance());
      Loop(numUnionPlanes, ({ i }) => {
        const plane = clippingPlanes.element(i);
        const distance4 = positionView.dot(plane.xyz).sub(plane.w).negate();
        hw_clip_distances.element(i).assign(distance4);
      });
    })();
  }
};
ClippingNode.ALPHA_TO_COVERAGE = "alphaToCoverage";
ClippingNode.DEFAULT = "default";
ClippingNode.HARDWARE = "hardware";
var clipping = () => nodeObject(new ClippingNode());
var clippingAlpha = () => nodeObject(new ClippingNode(ClippingNode.ALPHA_TO_COVERAGE));
var hardwareClipping = () => nodeObject(new ClippingNode(ClippingNode.HARDWARE));
var ALPHA_HASH_SCALE = 0.05;
var hash2D = Fn(([value]) => {
  return fract(mul(1e4, sin3(mul(17, value.x).add(mul(0.1, value.y)))).mul(add3(0.1, abs2(sin3(mul(13, value.y).add(value.x))))));
});
var hash3D = Fn(([value]) => {
  return hash2D(vec2(hash2D(value.xy), value.z));
});
var getAlphaHashThreshold = Fn(([position]) => {
  const maxDeriv = max$1(
    length(dFdx(position.xyz)),
    length(dFdy(position.xyz))
  );
  const pixScale = float(1).div(float(ALPHA_HASH_SCALE).mul(maxDeriv)).toVar("pixScale");
  const pixScales = vec2(
    exp22(floor(log22(pixScale))),
    exp22(ceil2(log22(pixScale)))
  );
  const alpha = vec2(
    hash3D(floor(pixScales.x.mul(position.xyz))),
    hash3D(floor(pixScales.y.mul(position.xyz)))
  );
  const lerpFactor = fract(log22(pixScale));
  const x = add3(mul(lerpFactor.oneMinus(), alpha.x), mul(lerpFactor, alpha.y));
  const a = min$1(lerpFactor, lerpFactor.oneMinus());
  const cases = vec3(
    x.mul(x).div(mul(2, a).mul(sub(1, a))),
    x.sub(mul(0.5, a)).div(sub(1, a)),
    sub(1, sub(1, x).mul(sub(1, x)).div(mul(2, a).mul(sub(1, a))))
  );
  const threshold2 = x.lessThan(a.oneMinus()).select(x.lessThan(a).select(cases.x, cases.y), cases.z);
  return clamp(threshold2, 1e-6, 1);
}).setLayout({
  name: "getAlphaHashThreshold",
  type: "float",
  inputs: [
    { name: "position", type: "vec3" }
  ]
});
var VertexColorNode = class extends AttributeNode {
  static get type() {
    return "VertexColorNode";
  }
  /**
   * Constructs a new vertex color node.
   *
   * @param {number} index - The attribute index.
   */
  constructor(index5) {
    super(null, "vec4");
    this.isVertexColorNode = true;
    this.index = index5;
  }
  /**
   * Overwrites the default implementation by honoring the attribute index.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The attribute name.
   */
  getAttributeName() {
    const index5 = this.index;
    return "color" + (index5 > 0 ? index5 : "");
  }
  generate(builder) {
    const attributeName = this.getAttributeName(builder);
    const geometryAttribute = builder.hasGeometryAttribute(attributeName);
    let result;
    if (geometryAttribute === true) {
      result = super.generate(builder);
    } else {
      result = builder.generateConst(this.nodeType, new Vector4(1, 1, 1, 1));
    }
    return result;
  }
  serialize(data) {
    super.serialize(data);
    data.index = this.index;
  }
  deserialize(data) {
    super.deserialize(data);
    this.index = data.index;
  }
};
var vertexColor = (index5 = 0) => nodeObject(new VertexColorNode(index5));
var blendBurn = Fn(([base, blend]) => {
  return min$1(1, base.oneMinus().div(blend)).oneMinus();
}).setLayout({
  name: "blendBurn",
  type: "vec3",
  inputs: [
    { name: "base", type: "vec3" },
    { name: "blend", type: "vec3" }
  ]
});
var blendDodge = Fn(([base, blend]) => {
  return min$1(base.div(blend.oneMinus()), 1);
}).setLayout({
  name: "blendDodge",
  type: "vec3",
  inputs: [
    { name: "base", type: "vec3" },
    { name: "blend", type: "vec3" }
  ]
});
var blendScreen = Fn(([base, blend]) => {
  return base.oneMinus().mul(blend.oneMinus()).oneMinus();
}).setLayout({
  name: "blendScreen",
  type: "vec3",
  inputs: [
    { name: "base", type: "vec3" },
    { name: "blend", type: "vec3" }
  ]
});
var blendOverlay = Fn(([base, blend]) => {
  return mix(base.mul(2).mul(blend), base.oneMinus().mul(2).mul(blend.oneMinus()).oneMinus(), step(0.5, base));
}).setLayout({
  name: "blendOverlay",
  type: "vec3",
  inputs: [
    { name: "base", type: "vec3" },
    { name: "blend", type: "vec3" }
  ]
});
var blendColor = Fn(([base, blend]) => {
  const outAlpha = blend.a.add(base.a.mul(blend.a.oneMinus()));
  return vec4(blend.rgb.mul(blend.a).add(base.rgb.mul(base.a).mul(blend.a.oneMinus())).div(outAlpha), outAlpha);
}).setLayout({
  name: "blendColor",
  type: "vec4",
  inputs: [
    { name: "base", type: "vec4" },
    { name: "blend", type: "vec4" }
  ]
});
var premultiplyAlpha = Fn(([color4]) => {
  return vec4(color4.rgb.mul(color4.a), color4.a);
}, { color: "vec4", return: "vec4" });
var unpremultiplyAlpha = Fn(([color4]) => {
  If(color4.a.equal(0), () => vec4(0));
  return vec4(color4.rgb.div(color4.a), color4.a);
}, { color: "vec4", return: "vec4" });
var burn = (...params) => {
  console.warn('THREE.TSL: "burn" has been renamed. Use "blendBurn" instead.');
  return blendBurn(params);
};
var dodge = (...params) => {
  console.warn('THREE.TSL: "dodge" has been renamed. Use "blendDodge" instead.');
  return blendDodge(params);
};
var screen = (...params) => {
  console.warn('THREE.TSL: "screen" has been renamed. Use "blendScreen" instead.');
  return blendScreen(params);
};
var overlay = (...params) => {
  console.warn('THREE.TSL: "overlay" has been renamed. Use "blendOverlay" instead.');
  return blendOverlay(params);
};
var NodeMaterial = class extends Material {
  static get type() {
    return "NodeMaterial";
  }
  /**
   * Represents the type of the node material.
   *
   * @type {string}
   */
  get type() {
    return this.constructor.type;
  }
  set type(_value) {
  }
  /**
   * Constructs a new node material.
   */
  constructor() {
    super();
    this.isNodeMaterial = true;
    this.fog = true;
    this.lights = false;
    this.hardwareClipping = false;
    this.lightsNode = null;
    this.envNode = null;
    this.aoNode = null;
    this.colorNode = null;
    this.normalNode = null;
    this.opacityNode = null;
    this.backdropNode = null;
    this.backdropAlphaNode = null;
    this.alphaTestNode = null;
    this.maskNode = null;
    this.positionNode = null;
    this.geometryNode = null;
    this.depthNode = null;
    this.receivedShadowPositionNode = null;
    this.castShadowPositionNode = null;
    this.receivedShadowNode = null;
    this.castShadowNode = null;
    this.outputNode = null;
    this.mrtNode = null;
    this.fragmentNode = null;
    this.vertexNode = null;
    Object.defineProperty(this, "shadowPositionNode", {
      // @deprecated, r176
      get: () => {
        return this.receivedShadowPositionNode;
      },
      set: (value) => {
        console.warn('THREE.NodeMaterial: ".shadowPositionNode" was renamed to ".receivedShadowPositionNode".');
        this.receivedShadowPositionNode = value;
      }
    });
  }
  /**
   * Allows to define a custom cache key that influence the material key computation
   * for render objects.
   *
   * @return {string} The custom cache key.
   */
  customProgramCacheKey() {
    return this.type + getCacheKey$1(this);
  }
  /**
   * Builds this material with the given node builder.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  build(builder) {
    this.setup(builder);
  }
  /**
   * Setups a node material observer with the given builder.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {NodeMaterialObserver} The node material observer.
   */
  setupObserver(builder) {
    return new NodeMaterialObserver(builder);
  }
  /**
   * Setups the vertex and fragment stage of this node material.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  setup(builder) {
    builder.context.setupNormal = () => subBuild(this.setupNormal(builder), "NORMAL", "vec3");
    builder.context.setupPositionView = () => this.setupPositionView(builder);
    builder.context.setupModelViewProjection = () => this.setupModelViewProjection(builder);
    const renderer = builder.renderer;
    const renderTarget = renderer.getRenderTarget();
    builder.addStack();
    const mvp = subBuild(this.setupVertex(builder), "VERTEX");
    const vertexNode = this.vertexNode || mvp;
    builder.stack.outputNode = vertexNode;
    this.setupHardwareClipping(builder);
    if (this.geometryNode !== null) {
      builder.stack.outputNode = builder.stack.outputNode.bypass(this.geometryNode);
    }
    builder.addFlow("vertex", builder.removeStack());
    builder.addStack();
    let resultNode;
    const clippingNode = this.setupClipping(builder);
    if (this.depthWrite === true || this.depthTest === true) {
      if (renderTarget !== null) {
        if (renderTarget.depthBuffer === true) this.setupDepth(builder);
      } else {
        if (renderer.depth === true) this.setupDepth(builder);
      }
    }
    if (this.fragmentNode === null) {
      this.setupDiffuseColor(builder);
      this.setupVariants(builder);
      const outgoingLightNode = this.setupLighting(builder);
      if (clippingNode !== null) builder.stack.add(clippingNode);
      const basicOutput = vec4(outgoingLightNode, diffuseColor.a).max(0);
      resultNode = this.setupOutput(builder, basicOutput);
      output.assign(resultNode);
      const isCustomOutput = this.outputNode !== null;
      if (isCustomOutput) resultNode = this.outputNode;
      if (renderTarget !== null) {
        const mrt3 = renderer.getMRT();
        const materialMRT = this.mrtNode;
        if (mrt3 !== null) {
          if (isCustomOutput) output.assign(resultNode);
          resultNode = mrt3;
          if (materialMRT !== null) {
            resultNode = mrt3.merge(materialMRT);
          }
        } else if (materialMRT !== null) {
          resultNode = materialMRT;
        }
      }
    } else {
      let fragmentNode = this.fragmentNode;
      if (fragmentNode.isOutputStructNode !== true) {
        fragmentNode = vec4(fragmentNode);
      }
      resultNode = this.setupOutput(builder, fragmentNode);
    }
    builder.stack.outputNode = resultNode;
    builder.addFlow("fragment", builder.removeStack());
    builder.observer = this.setupObserver(builder);
  }
  /**
   * Setups the clipping node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {ClippingNode} The clipping node.
   */
  setupClipping(builder) {
    if (builder.clippingContext === null) return null;
    const { unionPlanes, intersectionPlanes } = builder.clippingContext;
    let result = null;
    if (unionPlanes.length > 0 || intersectionPlanes.length > 0) {
      const samples = builder.renderer.samples;
      if (this.alphaToCoverage && samples > 1) {
        result = clippingAlpha();
      } else {
        builder.stack.add(clipping());
      }
    }
    return result;
  }
  /**
   * Setups the hardware clipping if available on the current device.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  setupHardwareClipping(builder) {
    this.hardwareClipping = false;
    if (builder.clippingContext === null) return;
    const candidateCount = builder.clippingContext.unionPlanes.length;
    if (candidateCount > 0 && candidateCount <= 8 && builder.isAvailable("clipDistance")) {
      builder.stack.add(hardwareClipping());
      this.hardwareClipping = true;
    }
    return;
  }
  /**
   * Setups the depth of this material.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  setupDepth(builder) {
    const { renderer, camera } = builder;
    let depthNode = this.depthNode;
    if (depthNode === null) {
      const mrt3 = renderer.getMRT();
      if (mrt3 && mrt3.has("depth")) {
        depthNode = mrt3.get("depth");
      } else if (renderer.logarithmicDepthBuffer === true) {
        if (camera.isPerspectiveCamera) {
          depthNode = viewZToLogarithmicDepth(positionView.z, cameraNear, cameraFar);
        } else {
          depthNode = viewZToOrthographicDepth(positionView.z, cameraNear, cameraFar);
        }
      }
    }
    if (depthNode !== null) {
      depth.assign(depthNode).toStack();
    }
  }
  /**
   * Setups the position node in view space. This method exists
   * so derived node materials can modify the implementation e.g. sprite materials.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {Node<vec3>} The position in view space.
   */
  setupPositionView() {
    return modelViewMatrix.mul(positionLocal).xyz;
  }
  /**
   * Setups the position in clip space.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {Node<vec4>} The position in view space.
   */
  setupModelViewProjection() {
    return cameraProjectionMatrix.mul(positionView);
  }
  /**
   * Setups the logic for the vertex stage.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {Node<vec4>} The position in clip space.
   */
  setupVertex(builder) {
    builder.addStack();
    this.setupPosition(builder);
    builder.context.vertex = builder.removeStack();
    return modelViewProjection;
  }
  /**
   * Setups the computation of the position in local space.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {Node<vec3>} The position in local space.
   */
  setupPosition(builder) {
    const { object: object2, geometry } = builder;
    if (geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color) {
      morphReference(object2).toStack();
    }
    if (object2.isSkinnedMesh === true) {
      skinning(object2).toStack();
    }
    if (this.displacementMap) {
      const displacementMap = materialReference("displacementMap", "texture");
      const displacementScale = materialReference("displacementScale", "float");
      const displacementBias = materialReference("displacementBias", "float");
      positionLocal.addAssign(normalLocal.normalize().mul(displacementMap.x.mul(displacementScale).add(displacementBias)));
    }
    if (object2.isBatchedMesh) {
      batch(object2).toStack();
    }
    if (object2.isInstancedMesh && object2.instanceMatrix && object2.instanceMatrix.isInstancedBufferAttribute === true) {
      instancedMesh(object2).toStack();
    }
    if (this.positionNode !== null) {
      positionLocal.assign(subBuild(this.positionNode, "POSITION", "vec3"));
    }
    return positionLocal;
  }
  /**
   * Setups the computation of the material's diffuse color.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {BufferGeometry} geometry - The geometry.
   */
  setupDiffuseColor({ object: object2, geometry }) {
    if (this.maskNode !== null) {
      bool(this.maskNode).not().discard();
    }
    let colorNode = this.colorNode ? vec4(this.colorNode) : materialColor;
    if (this.vertexColors === true && geometry.hasAttribute("color")) {
      colorNode = colorNode.mul(vertexColor());
    }
    if (object2.instanceColor) {
      const instanceColor = varyingProperty("vec3", "vInstanceColor");
      colorNode = instanceColor.mul(colorNode);
    }
    if (object2.isBatchedMesh && object2._colorsTexture) {
      const batchColor = varyingProperty("vec3", "vBatchColor");
      colorNode = batchColor.mul(colorNode);
    }
    diffuseColor.assign(colorNode);
    const opacityNode = this.opacityNode ? float(this.opacityNode) : materialOpacity;
    diffuseColor.a.assign(diffuseColor.a.mul(opacityNode));
    let alphaTestNode = null;
    if (this.alphaTestNode !== null || this.alphaTest > 0) {
      alphaTestNode = this.alphaTestNode !== null ? float(this.alphaTestNode) : materialAlphaTest;
      diffuseColor.a.lessThanEqual(alphaTestNode).discard();
    }
    if (this.alphaHash === true) {
      diffuseColor.a.lessThan(getAlphaHashThreshold(positionLocal)).discard();
    }
    const isOpaque = this.transparent === false && this.blending === NormalBlending && this.alphaToCoverage === false;
    if (isOpaque) {
      diffuseColor.a.assign(1);
    } else if (alphaTestNode === null) {
      diffuseColor.a.lessThanEqual(0).discard();
    }
  }
  /**
   * Abstract interface method that can be implemented by derived materials
   * to setup material-specific node variables.
   *
   * @abstract
   * @param {NodeBuilder} builder - The current node builder.
   */
  setupVariants() {
  }
  /**
   * Setups the outgoing light node variable
   *
   * @return {Node<vec3>} The outgoing light node.
   */
  setupOutgoingLight() {
    return this.lights === true ? vec3(0) : diffuseColor.rgb;
  }
  /**
   * Setups the normal node from the material.
   *
   * @return {Node<vec3>} The normal node.
   */
  setupNormal() {
    return this.normalNode ? vec3(this.normalNode) : materialNormal;
  }
  /**
   * Setups the environment node from the material.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {Node<vec4>} The environment node.
   */
  setupEnvironment() {
    let node = null;
    if (this.envNode) {
      node = this.envNode;
    } else if (this.envMap) {
      node = this.envMap.isCubeTexture ? materialReference("envMap", "cubeTexture") : materialReference("envMap", "texture");
    }
    return node;
  }
  /**
   * Setups the light map node from the material.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {Node<vec3>} The light map node.
   */
  setupLightMap(builder) {
    let node = null;
    if (builder.material.lightMap) {
      node = new IrradianceNode(materialLightMap);
    }
    return node;
  }
  /**
   * Setups the lights node based on the scene, environment and material.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {LightsNode} The lights node.
   */
  setupLights(builder) {
    const materialLightsNode = [];
    const envNode = this.setupEnvironment(builder);
    if (envNode && envNode.isLightingNode) {
      materialLightsNode.push(envNode);
    }
    const lightMapNode = this.setupLightMap(builder);
    if (lightMapNode && lightMapNode.isLightingNode) {
      materialLightsNode.push(lightMapNode);
    }
    if (this.aoNode !== null || builder.material.aoMap) {
      const aoNode = this.aoNode !== null ? this.aoNode : materialAO;
      materialLightsNode.push(new AONode(aoNode));
    }
    let lightsN = this.lightsNode || builder.lightsNode;
    if (materialLightsNode.length > 0) {
      lightsN = builder.renderer.lighting.createNode([...lightsN.getLights(), ...materialLightsNode]);
    }
    return lightsN;
  }
  /**
   * This method should be implemented by most derived materials
   * since it defines the material's lighting model.
   *
   * @abstract
   * @param {NodeBuilder} builder - The current node builder.
   * @return {LightingModel} The lighting model.
   */
  setupLightingModel() {
  }
  /**
   * Setups the outgoing light node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {Node<vec3>} The outgoing light node.
   */
  setupLighting(builder) {
    const { material } = builder;
    const { backdropNode, backdropAlphaNode, emissiveNode } = this;
    const lights3 = this.lights === true || this.lightsNode !== null;
    const lightsNode = lights3 ? this.setupLights(builder) : null;
    let outgoingLightNode = this.setupOutgoingLight(builder);
    if (lightsNode && lightsNode.getScope().hasLights) {
      const lightingModel = this.setupLightingModel(builder) || null;
      outgoingLightNode = lightingContext(lightsNode, lightingModel, backdropNode, backdropAlphaNode);
    } else if (backdropNode !== null) {
      outgoingLightNode = vec3(backdropAlphaNode !== null ? mix(outgoingLightNode, backdropNode, backdropAlphaNode) : backdropNode);
    }
    if (emissiveNode && emissiveNode.isNode === true || material.emissive && material.emissive.isColor === true) {
      emissive.assign(vec3(emissiveNode ? emissiveNode : materialEmissive));
      outgoingLightNode = outgoingLightNode.add(emissive);
    }
    return outgoingLightNode;
  }
  /**
   * Setup the fog.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {Node<vec4>} outputNode - The existing output node.
   * @return {Node<vec4>} The output node.
   */
  setupFog(builder, outputNode) {
    const fogNode = builder.fogNode;
    if (fogNode) {
      output.assign(outputNode);
      outputNode = vec4(fogNode.toVar());
    }
    return outputNode;
  }
  /**
   * Setups premultiplied alpha.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {Node<vec4>} outputNode - The existing output node.
   * @return {Node<vec4>} The output node.
   */
  setupPremultipliedAlpha(builder, outputNode) {
    return premultiplyAlpha(outputNode);
  }
  /**
   * Setups the output node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {Node<vec4>} outputNode - The existing output node.
   * @return {Node<vec4>} The output node.
   */
  setupOutput(builder, outputNode) {
    if (this.fog === true) {
      outputNode = this.setupFog(builder, outputNode);
    }
    if (this.premultipliedAlpha === true) {
      outputNode = this.setupPremultipliedAlpha(builder, outputNode);
    }
    return outputNode;
  }
  /**
   * Most classic material types have a node pendant e.g. for `MeshBasicMaterial`
   * there is `MeshBasicNodeMaterial`. This utility method is intended for
   * defining all material properties of the classic type in the node type.
   *
   * @param {Material} material - The material to copy properties with their values to this node material.
   */
  setDefaultValues(material) {
    for (const property3 in material) {
      const value = material[property3];
      if (this[property3] === void 0) {
        this[property3] = value;
        if (value && value.clone) this[property3] = value.clone();
      }
    }
    const descriptors = Object.getOwnPropertyDescriptors(material.constructor.prototype);
    for (const key in descriptors) {
      if (Object.getOwnPropertyDescriptor(this.constructor.prototype, key) === void 0 && descriptors[key].get !== void 0) {
        Object.defineProperty(this.constructor.prototype, key, descriptors[key]);
      }
    }
  }
  /**
   * Serializes this material to JSON.
   *
   * @param {?(Object|string)} meta - The meta information for serialization.
   * @return {Object} The serialized node.
   */
  toJSON(meta) {
    const isRoot = meta === void 0 || typeof meta === "string";
    if (isRoot) {
      meta = {
        textures: {},
        images: {},
        nodes: {}
      };
    }
    const data = Material.prototype.toJSON.call(this, meta);
    const nodeChildren = getNodeChildren(this);
    data.inputNodes = {};
    for (const { property: property3, childNode } of nodeChildren) {
      data.inputNodes[property3] = childNode.toJSON(meta).uuid;
    }
    function extractFromCache(cache3) {
      const values = [];
      for (const key in cache3) {
        const data2 = cache3[key];
        delete data2.metadata;
        values.push(data2);
      }
      return values;
    }
    if (isRoot) {
      const textures = extractFromCache(meta.textures);
      const images = extractFromCache(meta.images);
      const nodes = extractFromCache(meta.nodes);
      if (textures.length > 0) data.textures = textures;
      if (images.length > 0) data.images = images;
      if (nodes.length > 0) data.nodes = nodes;
    }
    return data;
  }
  /**
   * Copies the properties of the given node material to this instance.
   *
   * @param {NodeMaterial} source - The material to copy.
   * @return {NodeMaterial} A reference to this node material.
   */
  copy(source) {
    this.lightsNode = source.lightsNode;
    this.envNode = source.envNode;
    this.colorNode = source.colorNode;
    this.normalNode = source.normalNode;
    this.opacityNode = source.opacityNode;
    this.backdropNode = source.backdropNode;
    this.backdropAlphaNode = source.backdropAlphaNode;
    this.alphaTestNode = source.alphaTestNode;
    this.maskNode = source.maskNode;
    this.positionNode = source.positionNode;
    this.geometryNode = source.geometryNode;
    this.depthNode = source.depthNode;
    this.receivedShadowPositionNode = source.receivedShadowPositionNode;
    this.castShadowPositionNode = source.castShadowPositionNode;
    this.receivedShadowNode = source.receivedShadowNode;
    this.castShadowNode = source.castShadowNode;
    this.outputNode = source.outputNode;
    this.mrtNode = source.mrtNode;
    this.fragmentNode = source.fragmentNode;
    this.vertexNode = source.vertexNode;
    return super.copy(source);
  }
};
var _defaultValues$d = new LineBasicMaterial();
var LineBasicNodeMaterial = class extends NodeMaterial {
  static get type() {
    return "LineBasicNodeMaterial";
  }
  /**
   * Constructs a new line basic node material.
   *
   * @param {Object} [parameters] - The configuration parameter.
   */
  constructor(parameters) {
    super();
    this.isLineBasicNodeMaterial = true;
    this.setDefaultValues(_defaultValues$d);
    this.setValues(parameters);
  }
};
var _defaultValues$c = new LineDashedMaterial();
var LineDashedNodeMaterial = class extends NodeMaterial {
  static get type() {
    return "LineDashedNodeMaterial";
  }
  /**
   * Constructs a new line dashed node material.
   *
   * @param {Object} [parameters] - The configuration parameter.
   */
  constructor(parameters) {
    super();
    this.isLineDashedNodeMaterial = true;
    this.setDefaultValues(_defaultValues$c);
    this.dashOffset = 0;
    this.offsetNode = null;
    this.dashScaleNode = null;
    this.dashSizeNode = null;
    this.gapSizeNode = null;
    this.setValues(parameters);
  }
  /**
   * Setups the dash specific node variables.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  setupVariants() {
    const offsetNode = this.offsetNode ? float(this.offsetNode) : materialLineDashOffset;
    const dashScaleNode = this.dashScaleNode ? float(this.dashScaleNode) : materialLineScale;
    const dashSizeNode = this.dashSizeNode ? float(this.dashSizeNode) : materialLineDashSize;
    const gapSizeNode = this.gapSizeNode ? float(this.gapSizeNode) : materialLineGapSize;
    dashSize.assign(dashSizeNode);
    gapSize.assign(gapSizeNode);
    const vLineDistance = varying(attribute("lineDistance").mul(dashScaleNode));
    const vLineDistanceOffset = offsetNode ? vLineDistance.add(offsetNode) : vLineDistance;
    vLineDistanceOffset.mod(dashSize.add(gapSize)).greaterThan(dashSize).discard();
  }
};
var _sharedFramebuffer = null;
var ViewportSharedTextureNode = class extends ViewportTextureNode {
  static get type() {
    return "ViewportSharedTextureNode";
  }
  /**
   * Constructs a new viewport shared texture node.
   *
   * @param {Node} [uvNode=screenUV] - The uv node.
   * @param {?Node} [levelNode=null] - The level node.
   */
  constructor(uvNode = screenUV, levelNode = null) {
    if (_sharedFramebuffer === null) {
      _sharedFramebuffer = new FramebufferTexture();
    }
    super(uvNode, levelNode, _sharedFramebuffer);
  }
  /**
   * Overwritten so the method always returns the unique shared
   * framebuffer texture.
   *
   * @return {FramebufferTexture} The shared framebuffer texture.
   */
  getTextureForReference() {
    return _sharedFramebuffer;
  }
  updateReference() {
    return this;
  }
};
var viewportSharedTexture = nodeProxy(ViewportSharedTextureNode).setParameterLength(0, 2);
var _defaultValues$b = new LineDashedMaterial();
var directionToColor = (node) => nodeObject(node).mul(0.5).add(0.5);
var colorToDirection = (node) => nodeObject(node).mul(2).sub(1);
var _defaultValues$a = new MeshNormalMaterial();
var MeshNormalNodeMaterial = class extends NodeMaterial {
  static get type() {
    return "MeshNormalNodeMaterial";
  }
  /**
   * Constructs a new mesh normal node material.
   *
   * @param {Object} [parameters] - The configuration parameter.
   */
  constructor(parameters) {
    super();
    this.isMeshNormalNodeMaterial = true;
    this.setDefaultValues(_defaultValues$a);
    this.setValues(parameters);
  }
  /**
   * Overwrites the default implementation by computing the diffuse color
   * based on the normal data.
   */
  setupDiffuseColor() {
    const opacityNode = this.opacityNode ? float(this.opacityNode) : materialOpacity;
    diffuseColor.assign(colorSpaceToWorking(vec4(directionToColor(normalView), opacityNode), SRGBColorSpace));
  }
};
var equirectUV = Fn(([dir = positionWorldDirection]) => {
  const u4 = dir.z.atan(dir.x).mul(1 / (Math.PI * 2)).add(0.5);
  const v2 = dir.y.clamp(-1, 1).asin().mul(1 / Math.PI).add(0.5);
  return vec2(u4, v2);
});
var CubeRenderTarget = class extends WebGLCubeRenderTarget {
  /**
   * Constructs a new cube render target.
   *
   * @param {number} [size=1] - The size of the render target.
   * @param {RenderTarget~Options} [options] - The configuration object.
   */
  constructor(size = 1, options = {}) {
    super(size, options);
    this.isCubeRenderTarget = true;
  }
  /**
   * Converts the given equirectangular texture to a cube map.
   *
   * @param {Renderer} renderer - The renderer.
   * @param {Texture} texture - The equirectangular texture.
   * @return {CubeRenderTarget} A reference to this cube render target.
   */
  fromEquirectangularTexture(renderer, texture$1) {
    const currentMinFilter = texture$1.minFilter;
    const currentGenerateMipmaps = texture$1.generateMipmaps;
    texture$1.generateMipmaps = true;
    this.texture.type = texture$1.type;
    this.texture.colorSpace = texture$1.colorSpace;
    this.texture.generateMipmaps = texture$1.generateMipmaps;
    this.texture.minFilter = texture$1.minFilter;
    this.texture.magFilter = texture$1.magFilter;
    const geometry = new BoxGeometry(5, 5, 5);
    const uvNode = equirectUV(positionWorldDirection);
    const material = new NodeMaterial();
    material.colorNode = texture(texture$1, uvNode, 0);
    material.side = BackSide;
    material.blending = NoBlending;
    const mesh = new Mesh(geometry, material);
    const scene = new Scene();
    scene.add(mesh);
    if (texture$1.minFilter === LinearMipmapLinearFilter) texture$1.minFilter = LinearFilter;
    const camera = new CubeCamera(1, 10, this);
    const currentMRT = renderer.getMRT();
    renderer.setMRT(null);
    camera.update(renderer, scene);
    renderer.setMRT(currentMRT);
    texture$1.minFilter = currentMinFilter;
    texture$1.currentGenerateMipmaps = currentGenerateMipmaps;
    mesh.geometry.dispose();
    mesh.material.dispose();
    return this;
  }
};
var _cache$1 = /* @__PURE__ */ new WeakMap();
var CubeMapNode = class extends TempNode {
  static get type() {
    return "CubeMapNode";
  }
  /**
   * Constructs a new cube map node.
   *
   * @param {Node} envNode - The node representing the environment map.
   */
  constructor(envNode) {
    super("vec3");
    this.envNode = envNode;
    this._cubeTexture = null;
    this._cubeTextureNode = cubeTexture(null);
    const defaultTexture = new CubeTexture();
    defaultTexture.isRenderTargetTexture = true;
    this._defaultTexture = defaultTexture;
    this.updateBeforeType = NodeUpdateType.RENDER;
  }
  updateBefore(frame) {
    const { renderer, material } = frame;
    const envNode = this.envNode;
    if (envNode.isTextureNode || envNode.isMaterialReferenceNode) {
      const texture3 = envNode.isTextureNode ? envNode.value : material[envNode.property];
      if (texture3 && texture3.isTexture) {
        const mapping = texture3.mapping;
        if (mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping) {
          if (_cache$1.has(texture3)) {
            const cubeMap = _cache$1.get(texture3);
            mapTextureMapping(cubeMap, texture3.mapping);
            this._cubeTexture = cubeMap;
          } else {
            const image = texture3.image;
            if (isEquirectangularMapReady$1(image)) {
              const renderTarget = new CubeRenderTarget(image.height);
              renderTarget.fromEquirectangularTexture(renderer, texture3);
              mapTextureMapping(renderTarget.texture, texture3.mapping);
              this._cubeTexture = renderTarget.texture;
              _cache$1.set(texture3, renderTarget.texture);
              texture3.addEventListener("dispose", onTextureDispose);
            } else {
              this._cubeTexture = this._defaultTexture;
            }
          }
          this._cubeTextureNode.value = this._cubeTexture;
        } else {
          this._cubeTextureNode = this.envNode;
        }
      }
    }
  }
  setup(builder) {
    this.updateBefore(builder);
    return this._cubeTextureNode;
  }
};
function isEquirectangularMapReady$1(image) {
  if (image === null || image === void 0) return false;
  return image.height > 0;
}
function onTextureDispose(event) {
  const texture3 = event.target;
  texture3.removeEventListener("dispose", onTextureDispose);
  const renderTarget = _cache$1.get(texture3);
  if (renderTarget !== void 0) {
    _cache$1.delete(texture3);
    renderTarget.dispose();
  }
}
function mapTextureMapping(texture3, mapping) {
  if (mapping === EquirectangularReflectionMapping) {
    texture3.mapping = CubeReflectionMapping;
  } else if (mapping === EquirectangularRefractionMapping) {
    texture3.mapping = CubeRefractionMapping;
  }
}
var cubeMapNode = nodeProxy(CubeMapNode).setParameterLength(1);
var BasicEnvironmentNode = class extends LightingNode {
  static get type() {
    return "BasicEnvironmentNode";
  }
  /**
   * Constructs a new basic environment node.
   *
   * @param {Node} [envNode=null] - A node representing the environment.
   */
  constructor(envNode = null) {
    super();
    this.envNode = envNode;
  }
  setup(builder) {
    builder.context.environment = cubeMapNode(this.envNode);
  }
};
var BasicLightMapNode = class extends LightingNode {
  static get type() {
    return "BasicLightMapNode";
  }
  /**
   * Constructs a new basic light map node.
   *
   * @param {?Node<vec3>} [lightMapNode=null] - The light map node.
   */
  constructor(lightMapNode = null) {
    super();
    this.lightMapNode = lightMapNode;
  }
  setup(builder) {
    const RECIPROCAL_PI2 = float(1 / Math.PI);
    builder.context.irradianceLightMap = this.lightMapNode.mul(RECIPROCAL_PI2);
  }
};
var LightingModel = class {
  /**
   * This method is intended for setting up lighting model and context data
   * which are later used in the evaluation process.
   *
   * @abstract
   * @param {NodeBuilder} builder - The current node builder.
   */
  start(builder) {
    builder.lightsNode.setupLights(builder, builder.lightsNode.getLightNodes(builder));
    this.indirect(builder);
  }
  /**
   * This method is intended for executing final tasks like final updates
   * to the outgoing light.
   *
   * @abstract
   * @param {NodeBuilder} builder - The current node builder.
   */
  finish() {
  }
  /**
   * This method is intended for implementing the direct light term and
   * executed during the build process of directional, point and spot light nodes.
   *
   * @abstract
   * @param {Object} lightData - The light data.
   * @param {NodeBuilder} builder - The current node builder.
   */
  direct() {
  }
  /**
   * This method is intended for implementing the direct light term for
   * rect area light nodes.
   *
   * @abstract
   * @param {Object} lightData - The light data.
   * @param {NodeBuilder} builder - The current node builder.
   */
  directRectArea() {
  }
  /**
   * This method is intended for implementing the indirect light term.
   *
   * @abstract
   * @param {NodeBuilder} builder - The current node builder.
   */
  indirect() {
  }
  /**
   * This method is intended for implementing the ambient occlusion term.
   * Unlike other methods, this method must be called manually by the lighting
   * model in its indirect term.
   *
   * @abstract
   * @param {NodeBuilder} builder - The current node builder.
   */
  ambientOcclusion() {
  }
};
var BasicLightingModel = class extends LightingModel {
  /**
   * Constructs a new basic lighting model.
   */
  constructor() {
    super();
  }
  /**
   * Implements the baked indirect lighting with its modulation.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  indirect({ context: context3 }) {
    const ambientOcclusion = context3.ambientOcclusion;
    const reflectedLight = context3.reflectedLight;
    const irradianceLightMap = context3.irradianceLightMap;
    reflectedLight.indirectDiffuse.assign(vec4(0));
    if (irradianceLightMap) {
      reflectedLight.indirectDiffuse.addAssign(irradianceLightMap);
    } else {
      reflectedLight.indirectDiffuse.addAssign(vec4(1, 1, 1, 0));
    }
    reflectedLight.indirectDiffuse.mulAssign(ambientOcclusion);
    reflectedLight.indirectDiffuse.mulAssign(diffuseColor.rgb);
  }
  /**
   * Implements the environment mapping.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  finish(builder) {
    const { material, context: context3 } = builder;
    const outgoingLight = context3.outgoingLight;
    const envNode = builder.context.environment;
    if (envNode) {
      switch (material.combine) {
        case MultiplyOperation:
          outgoingLight.rgb.assign(mix(outgoingLight.rgb, outgoingLight.rgb.mul(envNode.rgb), materialSpecularStrength.mul(materialReflectivity)));
          break;
        case MixOperation:
          outgoingLight.rgb.assign(mix(outgoingLight.rgb, envNode.rgb, materialSpecularStrength.mul(materialReflectivity)));
          break;
        case AddOperation:
          outgoingLight.rgb.addAssign(envNode.rgb.mul(materialSpecularStrength.mul(materialReflectivity)));
          break;
        default:
          console.warn("THREE.BasicLightingModel: Unsupported .combine value:", material.combine);
          break;
      }
    }
  }
};
var _defaultValues$9 = new MeshBasicMaterial();
var MeshBasicNodeMaterial = class extends NodeMaterial {
  static get type() {
    return "MeshBasicNodeMaterial";
  }
  /**
   * Constructs a new mesh basic node material.
   *
   * @param {Object} [parameters] - The configuration parameter.
   */
  constructor(parameters) {
    super();
    this.isMeshBasicNodeMaterial = true;
    this.lights = true;
    this.setDefaultValues(_defaultValues$9);
    this.setValues(parameters);
  }
  /**
   * Basic materials are not affected by normal and bump maps so we
   * return by default {@link normalViewGeometry}.
   *
   * @return {Node<vec3>} The normal node.
   */
  setupNormal() {
    return directionToFaceDirection(normalViewGeometry);
  }
  /**
   * Overwritten since this type of material uses {@link BasicEnvironmentNode}
   * to implement the default environment mapping.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {?BasicEnvironmentNode<vec3>} The environment node.
   */
  setupEnvironment(builder) {
    const envNode = super.setupEnvironment(builder);
    return envNode ? new BasicEnvironmentNode(envNode) : null;
  }
  /**
   * This method must be overwritten since light maps are evaluated
   * with a special scaling factor for basic materials.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {?BasicLightMapNode<vec3>} The light map node.
   */
  setupLightMap(builder) {
    let node = null;
    if (builder.material.lightMap) {
      node = new BasicLightMapNode(materialLightMap);
    }
    return node;
  }
  /**
   * The material overwrites this method because `lights` is set to `true` but
   * we still want to return the diffuse color as the outgoing light.
   *
   * @return {Node<vec3>} The outgoing light node.
   */
  setupOutgoingLight() {
    return diffuseColor.rgb;
  }
  /**
   * Setups the lighting model.
   *
   * @return {BasicLightingModel} The lighting model.
   */
  setupLightingModel() {
    return new BasicLightingModel();
  }
};
var F_Schlick = Fn(({ f0, f90, dotVH }) => {
  const fresnel = dotVH.mul(-5.55473).sub(6.98316).mul(dotVH).exp2();
  return f0.mul(fresnel.oneMinus()).add(f90.mul(fresnel));
});
var BRDF_Lambert = Fn((inputs) => {
  return inputs.diffuseColor.mul(1 / Math.PI);
});
var G_BlinnPhong_Implicit = () => float(0.25);
var D_BlinnPhong = Fn(({ dotNH }) => {
  return shininess.mul(float(0.5)).add(1).mul(float(1 / Math.PI)).mul(dotNH.pow(shininess));
});
var BRDF_BlinnPhong = Fn(({ lightDirection }) => {
  const halfDir = lightDirection.add(positionViewDirection).normalize();
  const dotNH = normalView.dot(halfDir).clamp();
  const dotVH = positionViewDirection.dot(halfDir).clamp();
  const F = F_Schlick({ f0: specularColor, f90: 1, dotVH });
  const G = G_BlinnPhong_Implicit();
  const D3 = D_BlinnPhong({ dotNH });
  return F.mul(G).mul(D3);
});
var PhongLightingModel = class extends BasicLightingModel {
  /**
   * Constructs a new phong lighting model.
   *
   * @param {boolean} [specular=true] - Whether specular is supported or not.
   */
  constructor(specular = true) {
    super();
    this.specular = specular;
  }
  /**
   * Implements the direct lighting. The specular portion is optional an can be controlled
   * with the {@link PhongLightingModel#specular} flag.
   *
   * @param {Object} lightData - The light data.
   */
  direct({ lightDirection, lightColor, reflectedLight }) {
    const dotNL = normalView.dot(lightDirection).clamp();
    const irradiance = dotNL.mul(lightColor);
    reflectedLight.directDiffuse.addAssign(irradiance.mul(BRDF_Lambert({ diffuseColor: diffuseColor.rgb })));
    if (this.specular === true) {
      reflectedLight.directSpecular.addAssign(irradiance.mul(BRDF_BlinnPhong({ lightDirection })).mul(materialSpecularStrength));
    }
  }
  /**
   * Implements the indirect lighting.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  indirect(builder) {
    const { ambientOcclusion, irradiance, reflectedLight } = builder.context;
    reflectedLight.indirectDiffuse.addAssign(irradiance.mul(BRDF_Lambert({ diffuseColor })));
    reflectedLight.indirectDiffuse.mulAssign(ambientOcclusion);
  }
};
var _defaultValues$8 = new MeshLambertMaterial();
var MeshLambertNodeMaterial = class extends NodeMaterial {
  static get type() {
    return "MeshLambertNodeMaterial";
  }
  /**
   * Constructs a new mesh lambert node material.
   *
   * @param {Object} [parameters] - The configuration parameter.
   */
  constructor(parameters) {
    super();
    this.isMeshLambertNodeMaterial = true;
    this.lights = true;
    this.setDefaultValues(_defaultValues$8);
    this.setValues(parameters);
  }
  /**
   * Overwritten since this type of material uses {@link BasicEnvironmentNode}
   * to implement the default environment mapping.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {?BasicEnvironmentNode<vec3>} The environment node.
   */
  setupEnvironment(builder) {
    const envNode = super.setupEnvironment(builder);
    return envNode ? new BasicEnvironmentNode(envNode) : null;
  }
  /**
   * Setups the lighting model.
   *
   * @return {PhongLightingModel} The lighting model.
   */
  setupLightingModel() {
    return new PhongLightingModel(false);
  }
};
var _defaultValues$7 = new MeshPhongMaterial();
var MeshPhongNodeMaterial = class extends NodeMaterial {
  static get type() {
    return "MeshPhongNodeMaterial";
  }
  /**
   * Constructs a new mesh lambert node material.
   *
   * @param {Object} [parameters] - The configuration parameter.
   */
  constructor(parameters) {
    super();
    this.isMeshPhongNodeMaterial = true;
    this.lights = true;
    this.shininessNode = null;
    this.specularNode = null;
    this.setDefaultValues(_defaultValues$7);
    this.setValues(parameters);
  }
  /**
   * Overwritten since this type of material uses {@link BasicEnvironmentNode}
   * to implement the default environment mapping.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {?BasicEnvironmentNode<vec3>} The environment node.
   */
  setupEnvironment(builder) {
    const envNode = super.setupEnvironment(builder);
    return envNode ? new BasicEnvironmentNode(envNode) : null;
  }
  /**
   * Setups the lighting model.
   *
   * @return {PhongLightingModel} The lighting model.
   */
  setupLightingModel() {
    return new PhongLightingModel();
  }
  /**
   * Setups the phong specific node variables.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  setupVariants() {
    const shininessNode = (this.shininessNode ? float(this.shininessNode) : materialShininess).max(1e-4);
    shininess.assign(shininessNode);
    const specularNode = this.specularNode || materialSpecular;
    specularColor.assign(specularNode);
  }
  copy(source) {
    this.shininessNode = source.shininessNode;
    this.specularNode = source.specularNode;
    return super.copy(source);
  }
};
var getGeometryRoughness = Fn((builder) => {
  if (builder.geometry.hasAttribute("normal") === false) {
    return float(0);
  }
  const dxy = normalViewGeometry.dFdx().abs().max(normalViewGeometry.dFdy().abs());
  const geometryRoughness = dxy.x.max(dxy.y).max(dxy.z);
  return geometryRoughness;
});
var getRoughness = Fn((inputs) => {
  const { roughness: roughness3 } = inputs;
  const geometryRoughness = getGeometryRoughness();
  let roughnessFactor = roughness3.max(0.0525);
  roughnessFactor = roughnessFactor.add(geometryRoughness);
  roughnessFactor = roughnessFactor.min(1);
  return roughnessFactor;
});
var V_GGX_SmithCorrelated = Fn(({ alpha, dotNL, dotNV }) => {
  const a2 = alpha.pow2();
  const gv = dotNL.mul(a2.add(a2.oneMinus().mul(dotNV.pow2())).sqrt());
  const gl = dotNV.mul(a2.add(a2.oneMinus().mul(dotNL.pow2())).sqrt());
  return div(0.5, gv.add(gl).max(EPSILON2));
}).setLayout({
  name: "V_GGX_SmithCorrelated",
  type: "float",
  inputs: [
    { name: "alpha", type: "float" },
    { name: "dotNL", type: "float" },
    { name: "dotNV", type: "float" }
  ]
});
var V_GGX_SmithCorrelated_Anisotropic = Fn(({ alphaT: alphaT3, alphaB, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL }) => {
  const gv = dotNL.mul(vec3(alphaT3.mul(dotTV), alphaB.mul(dotBV), dotNV).length());
  const gl = dotNV.mul(vec3(alphaT3.mul(dotTL), alphaB.mul(dotBL), dotNL).length());
  const v2 = div(0.5, gv.add(gl));
  return v2.saturate();
}).setLayout({
  name: "V_GGX_SmithCorrelated_Anisotropic",
  type: "float",
  inputs: [
    { name: "alphaT", type: "float", qualifier: "in" },
    { name: "alphaB", type: "float", qualifier: "in" },
    { name: "dotTV", type: "float", qualifier: "in" },
    { name: "dotBV", type: "float", qualifier: "in" },
    { name: "dotTL", type: "float", qualifier: "in" },
    { name: "dotBL", type: "float", qualifier: "in" },
    { name: "dotNV", type: "float", qualifier: "in" },
    { name: "dotNL", type: "float", qualifier: "in" }
  ]
});
var D_GGX = Fn(({ alpha, dotNH }) => {
  const a2 = alpha.pow2();
  const denom = dotNH.pow2().mul(a2.oneMinus()).oneMinus();
  return a2.div(denom.pow2()).mul(1 / Math.PI);
}).setLayout({
  name: "D_GGX",
  type: "float",
  inputs: [
    { name: "alpha", type: "float" },
    { name: "dotNH", type: "float" }
  ]
});
var RECIPROCAL_PI = float(1 / Math.PI);
var D_GGX_Anisotropic = Fn(({ alphaT: alphaT3, alphaB, dotNH, dotTH, dotBH }) => {
  const a2 = alphaT3.mul(alphaB);
  const v2 = vec3(alphaB.mul(dotTH), alphaT3.mul(dotBH), a2.mul(dotNH));
  const v22 = v2.dot(v2);
  const w22 = a2.div(v22);
  return RECIPROCAL_PI.mul(a2.mul(w22.pow2()));
}).setLayout({
  name: "D_GGX_Anisotropic",
  type: "float",
  inputs: [
    { name: "alphaT", type: "float", qualifier: "in" },
    { name: "alphaB", type: "float", qualifier: "in" },
    { name: "dotNH", type: "float", qualifier: "in" },
    { name: "dotTH", type: "float", qualifier: "in" },
    { name: "dotBH", type: "float", qualifier: "in" }
  ]
});
var BRDF_GGX = Fn(({ lightDirection, f0, f90, roughness: roughness3, f, normalView: normalView$1 = normalView, USE_IRIDESCENCE, USE_ANISOTROPY }) => {
  const alpha = roughness3.pow2();
  const halfDir = lightDirection.add(positionViewDirection).normalize();
  const dotNL = normalView$1.dot(lightDirection).clamp();
  const dotNV = normalView$1.dot(positionViewDirection).clamp();
  const dotNH = normalView$1.dot(halfDir).clamp();
  const dotVH = positionViewDirection.dot(halfDir).clamp();
  let F = F_Schlick({ f0, f90, dotVH });
  let V, D3;
  if (defined(USE_IRIDESCENCE)) {
    F = iridescence.mix(F, f);
  }
  if (defined(USE_ANISOTROPY)) {
    const dotTL = anisotropyT.dot(lightDirection);
    const dotTV = anisotropyT.dot(positionViewDirection);
    const dotTH = anisotropyT.dot(halfDir);
    const dotBL = anisotropyB.dot(lightDirection);
    const dotBV = anisotropyB.dot(positionViewDirection);
    const dotBH = anisotropyB.dot(halfDir);
    V = V_GGX_SmithCorrelated_Anisotropic({ alphaT, alphaB: alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL });
    D3 = D_GGX_Anisotropic({ alphaT, alphaB: alpha, dotNH, dotTH, dotBH });
  } else {
    V = V_GGX_SmithCorrelated({ alpha, dotNL, dotNV });
    D3 = D_GGX({ alpha, dotNH });
  }
  return F.mul(V).mul(D3);
});
var DFGApprox = Fn(({ roughness: roughness3, dotNV }) => {
  const c0 = vec4(-1, -0.0275, -0.572, 0.022);
  const c1 = vec4(1, 0.0425, 1.04, -0.04);
  const r = roughness3.mul(c0).add(c1);
  const a004 = r.x.mul(r.x).min(dotNV.mul(-9.28).exp2()).mul(r.x).add(r.y);
  const fab = vec2(-1.04, 1.04).mul(a004).add(r.zw);
  return fab;
}).setLayout({
  name: "DFGApprox",
  type: "vec2",
  inputs: [
    { name: "roughness", type: "float" },
    { name: "dotNV", type: "vec3" }
  ]
});
var EnvironmentBRDF = Fn((inputs) => {
  const { dotNV, specularColor: specularColor3, specularF90: specularF903, roughness: roughness3 } = inputs;
  const fab = DFGApprox({ dotNV, roughness: roughness3 });
  return specularColor3.mul(fab.x).add(specularF903.mul(fab.y));
});
var Schlick_to_F0 = Fn(({ f, f90, dotVH }) => {
  const x = dotVH.oneMinus().saturate();
  const x2 = x.mul(x);
  const x5 = x.mul(x2, x2).clamp(0, 0.9999);
  return f.sub(vec3(f90).mul(x5)).div(x5.oneMinus());
}).setLayout({
  name: "Schlick_to_F0",
  type: "vec3",
  inputs: [
    { name: "f", type: "vec3" },
    { name: "f90", type: "float" },
    { name: "dotVH", type: "float" }
  ]
});
var D_Charlie = Fn(({ roughness: roughness3, dotNH }) => {
  const alpha = roughness3.pow2();
  const invAlpha = float(1).div(alpha);
  const cos2h = dotNH.pow2();
  const sin2h = cos2h.oneMinus().max(78125e-7);
  return float(2).add(invAlpha).mul(sin2h.pow(invAlpha.mul(0.5))).div(2 * Math.PI);
}).setLayout({
  name: "D_Charlie",
  type: "float",
  inputs: [
    { name: "roughness", type: "float" },
    { name: "dotNH", type: "float" }
  ]
});
var V_Neubelt = Fn(({ dotNV, dotNL }) => {
  return float(1).div(float(4).mul(dotNL.add(dotNV).sub(dotNL.mul(dotNV))));
}).setLayout({
  name: "V_Neubelt",
  type: "float",
  inputs: [
    { name: "dotNV", type: "float" },
    { name: "dotNL", type: "float" }
  ]
});
var BRDF_Sheen = Fn(({ lightDirection }) => {
  const halfDir = lightDirection.add(positionViewDirection).normalize();
  const dotNL = normalView.dot(lightDirection).clamp();
  const dotNV = normalView.dot(positionViewDirection).clamp();
  const dotNH = normalView.dot(halfDir).clamp();
  const D3 = D_Charlie({ roughness: sheenRoughness, dotNH });
  const V = V_Neubelt({ dotNV, dotNL });
  return sheen.mul(D3).mul(V);
});
var LTC_Uv = Fn(({ N: N2, V, roughness: roughness3 }) => {
  const LUT_SIZE = 64;
  const LUT_SCALE = (LUT_SIZE - 1) / LUT_SIZE;
  const LUT_BIAS = 0.5 / LUT_SIZE;
  const dotNV = N2.dot(V).saturate();
  const uv3 = vec2(roughness3, dotNV.oneMinus().sqrt());
  uv3.assign(uv3.mul(LUT_SCALE).add(LUT_BIAS));
  return uv3;
}).setLayout({
  name: "LTC_Uv",
  type: "vec2",
  inputs: [
    { name: "N", type: "vec3" },
    { name: "V", type: "vec3" },
    { name: "roughness", type: "float" }
  ]
});
var LTC_ClippedSphereFormFactor = Fn(({ f }) => {
  const l = f.length();
  return max$1(l.mul(l).add(f.z).div(l.add(1)), 0);
}).setLayout({
  name: "LTC_ClippedSphereFormFactor",
  type: "float",
  inputs: [
    { name: "f", type: "vec3" }
  ]
});
var LTC_EdgeVectorFormFactor = Fn(({ v1, v2 }) => {
  const x = v1.dot(v2);
  const y = x.abs().toVar();
  const a = y.mul(0.0145206).add(0.4965155).mul(y).add(0.8543985).toVar();
  const b = y.add(4.1616724).mul(y).add(3.417594).toVar();
  const v3 = a.div(b);
  const theta_sintheta = x.greaterThan(0).select(v3, max$1(x.mul(x).oneMinus(), 1e-7).inverseSqrt().mul(0.5).sub(v3));
  return v1.cross(v2).mul(theta_sintheta);
}).setLayout({
  name: "LTC_EdgeVectorFormFactor",
  type: "vec3",
  inputs: [
    { name: "v1", type: "vec3" },
    { name: "v2", type: "vec3" }
  ]
});
var LTC_Evaluate = Fn(({ N: N2, V, P, mInv, p0: p02, p1, p2, p3 }) => {
  const v1 = p1.sub(p02).toVar();
  const v2 = p3.sub(p02).toVar();
  const lightNormal = v1.cross(v2);
  const result = vec3().toVar();
  If(lightNormal.dot(P.sub(p02)).greaterThanEqual(0), () => {
    const T1 = V.sub(N2.mul(V.dot(N2))).normalize();
    const T2 = N2.cross(T1).negate();
    const mat = mInv.mul(mat3(T1, T2, N2).transpose()).toVar();
    const coords0 = mat.mul(p02.sub(P)).normalize().toVar();
    const coords1 = mat.mul(p1.sub(P)).normalize().toVar();
    const coords2 = mat.mul(p2.sub(P)).normalize().toVar();
    const coords3 = mat.mul(p3.sub(P)).normalize().toVar();
    const vectorFormFactor = vec3(0).toVar();
    vectorFormFactor.addAssign(LTC_EdgeVectorFormFactor({ v1: coords0, v2: coords1 }));
    vectorFormFactor.addAssign(LTC_EdgeVectorFormFactor({ v1: coords1, v2: coords2 }));
    vectorFormFactor.addAssign(LTC_EdgeVectorFormFactor({ v1: coords2, v2: coords3 }));
    vectorFormFactor.addAssign(LTC_EdgeVectorFormFactor({ v1: coords3, v2: coords0 }));
    result.assign(vec3(LTC_ClippedSphereFormFactor({ f: vectorFormFactor })));
  });
  return result;
}).setLayout({
  name: "LTC_Evaluate",
  type: "vec3",
  inputs: [
    { name: "N", type: "vec3" },
    { name: "V", type: "vec3" },
    { name: "P", type: "vec3" },
    { name: "mInv", type: "mat3" },
    { name: "p0", type: "vec3" },
    { name: "p1", type: "vec3" },
    { name: "p2", type: "vec3" },
    { name: "p3", type: "vec3" }
  ]
});
var LTC_Evaluate_Volume = Fn(({ P, p0: p02, p1, p2, p3 }) => {
  const v1 = p1.sub(p02).toVar();
  const v2 = p3.sub(p02).toVar();
  const lightNormal = v1.cross(v2);
  const result = vec3().toVar();
  If(lightNormal.dot(P.sub(p02)).greaterThanEqual(0), () => {
    const coords0 = p02.sub(P).normalize().toVar();
    const coords1 = p1.sub(P).normalize().toVar();
    const coords2 = p2.sub(P).normalize().toVar();
    const coords3 = p3.sub(P).normalize().toVar();
    const vectorFormFactor = vec3(0).toVar();
    vectorFormFactor.addAssign(LTC_EdgeVectorFormFactor({ v1: coords0, v2: coords1 }));
    vectorFormFactor.addAssign(LTC_EdgeVectorFormFactor({ v1: coords1, v2: coords2 }));
    vectorFormFactor.addAssign(LTC_EdgeVectorFormFactor({ v1: coords2, v2: coords3 }));
    vectorFormFactor.addAssign(LTC_EdgeVectorFormFactor({ v1: coords3, v2: coords0 }));
    result.assign(vec3(LTC_ClippedSphereFormFactor({ f: vectorFormFactor.abs() })));
  });
  return result;
}).setLayout({
  name: "LTC_Evaluate",
  type: "vec3",
  inputs: [
    { name: "P", type: "vec3" },
    { name: "p0", type: "vec3" },
    { name: "p1", type: "vec3" },
    { name: "p2", type: "vec3" },
    { name: "p3", type: "vec3" }
  ]
});
var bC = 1 / 6;
var w0 = (a) => mul(bC, mul(a, mul(a, a.negate().add(3)).sub(3)).add(1));
var w1 = (a) => mul(bC, mul(a, mul(a, mul(3, a).sub(6))).add(4));
var w2 = (a) => mul(bC, mul(a, mul(a, mul(-3, a).add(3)).add(3)).add(1));
var w3 = (a) => mul(bC, pow4(a, 3));
var g0 = (a) => w0(a).add(w1(a));
var g1 = (a) => w2(a).add(w3(a));
var h0 = (a) => add3(-1, w1(a).div(w0(a).add(w1(a))));
var h1 = (a) => add3(1, w3(a).div(w2(a).add(w3(a))));
var bicubic = (textureNode, texelSize, lod) => {
  const uv3 = textureNode.uvNode;
  const uvScaled = mul(uv3, texelSize.zw).add(0.5);
  const iuv = floor(uvScaled);
  const fuv = fract(uvScaled);
  const g0x = g0(fuv.x);
  const g1x = g1(fuv.x);
  const h0x = h0(fuv.x);
  const h1x = h1(fuv.x);
  const h0y = h0(fuv.y);
  const h1y = h1(fuv.y);
  const p02 = vec2(iuv.x.add(h0x), iuv.y.add(h0y)).sub(0.5).mul(texelSize.xy);
  const p1 = vec2(iuv.x.add(h1x), iuv.y.add(h0y)).sub(0.5).mul(texelSize.xy);
  const p2 = vec2(iuv.x.add(h0x), iuv.y.add(h1y)).sub(0.5).mul(texelSize.xy);
  const p3 = vec2(iuv.x.add(h1x), iuv.y.add(h1y)).sub(0.5).mul(texelSize.xy);
  const a = g0(fuv.y).mul(add3(g0x.mul(textureNode.sample(p02).level(lod)), g1x.mul(textureNode.sample(p1).level(lod))));
  const b = g1(fuv.y).mul(add3(g0x.mul(textureNode.sample(p2).level(lod)), g1x.mul(textureNode.sample(p3).level(lod))));
  return a.add(b);
};
var textureBicubicLevel = Fn(([textureNode, lodNode]) => {
  const fLodSize = vec2(textureNode.size(int(lodNode)));
  const cLodSize = vec2(textureNode.size(int(lodNode.add(1))));
  const fLodSizeInv = div(1, fLodSize);
  const cLodSizeInv = div(1, cLodSize);
  const fSample = bicubic(textureNode, vec4(fLodSizeInv, fLodSize), floor(lodNode));
  const cSample = bicubic(textureNode, vec4(cLodSizeInv, cLodSize), ceil2(lodNode));
  return fract(lodNode).mix(fSample, cSample);
});
var textureBicubic = Fn(([textureNode, strength]) => {
  const lod = strength.mul(maxMipLevel(textureNode));
  return textureBicubicLevel(textureNode, lod);
});
var getVolumeTransmissionRay = Fn(([n, v2, thickness3, ior3, modelMatrix]) => {
  const refractionVector = vec3(refract(v2.negate(), normalize2(n), div(1, ior3)));
  const modelScale3 = vec3(
    length(modelMatrix[0].xyz),
    length(modelMatrix[1].xyz),
    length(modelMatrix[2].xyz)
  );
  return normalize2(refractionVector).mul(thickness3.mul(modelScale3));
}).setLayout({
  name: "getVolumeTransmissionRay",
  type: "vec3",
  inputs: [
    { name: "n", type: "vec3" },
    { name: "v", type: "vec3" },
    { name: "thickness", type: "float" },
    { name: "ior", type: "float" },
    { name: "modelMatrix", type: "mat4" }
  ]
});
var applyIorToRoughness = Fn(([roughness3, ior3]) => {
  return roughness3.mul(clamp(ior3.mul(2).sub(2), 0, 1));
}).setLayout({
  name: "applyIorToRoughness",
  type: "float",
  inputs: [
    { name: "roughness", type: "float" },
    { name: "ior", type: "float" }
  ]
});
var viewportBackSideTexture = viewportMipTexture();
var viewportFrontSideTexture = viewportMipTexture();
var getTransmissionSample = Fn(([fragCoord, roughness3, ior3], { material }) => {
  const vTexture = material.side === BackSide ? viewportBackSideTexture : viewportFrontSideTexture;
  const transmissionSample = vTexture.sample(fragCoord);
  const lod = log22(screenSize.x).mul(applyIorToRoughness(roughness3, ior3));
  return textureBicubicLevel(transmissionSample, lod);
});
var volumeAttenuation = Fn(([transmissionDistance, attenuationColor3, attenuationDistance3]) => {
  If(attenuationDistance3.notEqual(0), () => {
    const attenuationCoefficient = log3(attenuationColor3).negate().div(attenuationDistance3);
    const transmittance = exp2(attenuationCoefficient.negate().mul(transmissionDistance));
    return transmittance;
  });
  return vec3(1);
}).setLayout({
  name: "volumeAttenuation",
  type: "vec3",
  inputs: [
    { name: "transmissionDistance", type: "float" },
    { name: "attenuationColor", type: "vec3" },
    { name: "attenuationDistance", type: "float" }
  ]
});
var getIBLVolumeRefraction = Fn(([n, v2, roughness3, diffuseColor3, specularColor3, specularF903, position, modelMatrix, viewMatrix, projMatrix, ior3, thickness3, attenuationColor3, attenuationDistance3, dispersion3]) => {
  let transmittedLight, transmittance;
  if (dispersion3) {
    transmittedLight = vec4().toVar();
    transmittance = vec3().toVar();
    const halfSpread = ior3.sub(1).mul(dispersion3.mul(0.025));
    const iors = vec3(ior3.sub(halfSpread), ior3, ior3.add(halfSpread));
    Loop({ start: 0, end: 3 }, ({ i }) => {
      const ior4 = iors.element(i);
      const transmissionRay = getVolumeTransmissionRay(n, v2, thickness3, ior4, modelMatrix);
      const refractedRayExit = position.add(transmissionRay);
      const ndcPos = projMatrix.mul(viewMatrix.mul(vec4(refractedRayExit, 1)));
      const refractionCoords = vec2(ndcPos.xy.div(ndcPos.w)).toVar();
      refractionCoords.addAssign(1);
      refractionCoords.divAssign(2);
      refractionCoords.assign(vec2(refractionCoords.x, refractionCoords.y.oneMinus()));
      const transmissionSample = getTransmissionSample(refractionCoords, roughness3, ior4);
      transmittedLight.element(i).assign(transmissionSample.element(i));
      transmittedLight.a.addAssign(transmissionSample.a);
      transmittance.element(i).assign(diffuseColor3.element(i).mul(volumeAttenuation(length(transmissionRay), attenuationColor3, attenuationDistance3).element(i)));
    });
    transmittedLight.a.divAssign(3);
  } else {
    const transmissionRay = getVolumeTransmissionRay(n, v2, thickness3, ior3, modelMatrix);
    const refractedRayExit = position.add(transmissionRay);
    const ndcPos = projMatrix.mul(viewMatrix.mul(vec4(refractedRayExit, 1)));
    const refractionCoords = vec2(ndcPos.xy.div(ndcPos.w)).toVar();
    refractionCoords.addAssign(1);
    refractionCoords.divAssign(2);
    refractionCoords.assign(vec2(refractionCoords.x, refractionCoords.y.oneMinus()));
    transmittedLight = getTransmissionSample(refractionCoords, roughness3, ior3);
    transmittance = diffuseColor3.mul(volumeAttenuation(length(transmissionRay), attenuationColor3, attenuationDistance3));
  }
  const attenuatedColor = transmittance.rgb.mul(transmittedLight.rgb);
  const dotNV = n.dot(v2).clamp();
  const F = vec3(EnvironmentBRDF({
    // n, v, specularColor, specularF90, roughness
    dotNV,
    specularColor: specularColor3,
    specularF90: specularF903,
    roughness: roughness3
  }));
  const transmittanceFactor = transmittance.r.add(transmittance.g, transmittance.b).div(3);
  return vec4(F.oneMinus().mul(attenuatedColor), transmittedLight.a.oneMinus().mul(transmittanceFactor).oneMinus());
});
var XYZ_TO_REC709 = mat3(
  3.2404542,
  -0.969266,
  0.0556434,
  -1.5371385,
  1.8760108,
  -0.2040259,
  -0.4985314,
  0.041556,
  1.0572252
);
var Fresnel0ToIor = (fresnel0) => {
  const sqrtF0 = fresnel0.sqrt();
  return vec3(1).add(sqrtF0).div(vec3(1).sub(sqrtF0));
};
var IorToFresnel0 = (transmittedIor, incidentIor) => {
  return transmittedIor.sub(incidentIor).div(transmittedIor.add(incidentIor)).pow2();
};
var evalSensitivity = (OPD, shift) => {
  const phase = OPD.mul(2 * Math.PI * 1e-9);
  const val = vec3(54856e-17, 44201e-17, 52481e-17);
  const pos = vec3(1681e3, 1795300, 2208400);
  const VAR = vec3(43278e5, 93046e5, 66121e5);
  const x = float(9747e-17 * Math.sqrt(2 * Math.PI * 45282e5)).mul(phase.mul(2239900).add(shift.x).cos()).mul(phase.pow2().mul(-45282e5).exp());
  let xyz = val.mul(VAR.mul(2 * Math.PI).sqrt()).mul(pos.mul(phase).add(shift).cos()).mul(phase.pow2().negate().mul(VAR).exp());
  xyz = vec3(xyz.x.add(x), xyz.y, xyz.z).div(10685e-11);
  const rgb2 = XYZ_TO_REC709.mul(xyz);
  return rgb2;
};
var evalIridescence = Fn(({ outsideIOR, eta2, cosTheta1, thinFilmThickness, baseF0 }) => {
  const iridescenceIOR3 = mix(outsideIOR, eta2, smoothstep(0, 0.03, thinFilmThickness));
  const sinTheta2Sq = outsideIOR.div(iridescenceIOR3).pow2().mul(cosTheta1.pow2().oneMinus());
  const cosTheta2Sq = sinTheta2Sq.oneMinus();
  If(cosTheta2Sq.lessThan(0), () => {
    return vec3(1);
  });
  const cosTheta2 = cosTheta2Sq.sqrt();
  const R0 = IorToFresnel0(iridescenceIOR3, outsideIOR);
  const R12 = F_Schlick({ f0: R0, f90: 1, dotVH: cosTheta1 });
  const T121 = R12.oneMinus();
  const phi12 = iridescenceIOR3.lessThan(outsideIOR).select(Math.PI, 0);
  const phi21 = float(Math.PI).sub(phi12);
  const baseIOR = Fresnel0ToIor(baseF0.clamp(0, 0.9999));
  const R1 = IorToFresnel0(baseIOR, iridescenceIOR3.toVec3());
  const R23 = F_Schlick({ f0: R1, f90: 1, dotVH: cosTheta2 });
  const phi23 = vec3(
    baseIOR.x.lessThan(iridescenceIOR3).select(Math.PI, 0),
    baseIOR.y.lessThan(iridescenceIOR3).select(Math.PI, 0),
    baseIOR.z.lessThan(iridescenceIOR3).select(Math.PI, 0)
  );
  const OPD = iridescenceIOR3.mul(thinFilmThickness, cosTheta2, 2);
  const phi = vec3(phi21).add(phi23);
  const R123 = R12.mul(R23).clamp(1e-5, 0.9999);
  const r123 = R123.sqrt();
  const Rs = T121.pow2().mul(R23).div(vec3(1).sub(R123));
  const C0 = R12.add(Rs);
  const I = C0.toVar();
  const Cm = Rs.sub(T121).toVar();
  Loop({ start: 1, end: 2, condition: "<=", name: "m" }, ({ m }) => {
    Cm.mulAssign(r123);
    const Sm = evalSensitivity(float(m).mul(OPD), float(m).mul(phi)).mul(2);
    I.addAssign(Cm.mul(Sm));
  });
  return I.max(vec3(0));
}).setLayout({
  name: "evalIridescence",
  type: "vec3",
  inputs: [
    { name: "outsideIOR", type: "float" },
    { name: "eta2", type: "float" },
    { name: "cosTheta1", type: "float" },
    { name: "thinFilmThickness", type: "float" },
    { name: "baseF0", type: "vec3" }
  ]
});
var IBLSheenBRDF = Fn(({ normal: normal2, viewDir, roughness: roughness3 }) => {
  const dotNV = normal2.dot(viewDir).saturate();
  const r2 = roughness3.pow2();
  const a = select(
    roughness3.lessThan(0.25),
    float(-339.2).mul(r2).add(float(161.4).mul(roughness3)).sub(25.9),
    float(-8.48).mul(r2).add(float(14.3).mul(roughness3)).sub(9.95)
  );
  const b = select(
    roughness3.lessThan(0.25),
    float(44).mul(r2).sub(float(23.7).mul(roughness3)).add(3.26),
    float(1.97).mul(r2).sub(float(3.27).mul(roughness3)).add(0.72)
  );
  const DG = select(roughness3.lessThan(0.25), 0, float(0.1).mul(roughness3).sub(0.025)).add(a.mul(dotNV).add(b).exp());
  return DG.mul(1 / Math.PI).saturate();
});
var clearcoatF0 = vec3(0.04);
var clearcoatF90 = float(1);
var PhysicalLightingModel = class extends LightingModel {
  /**
   * Constructs a new physical lighting model.
   *
   * @param {boolean} [clearcoat=false] - Whether clearcoat is supported or not.
   * @param {boolean} [sheen=false] - Whether sheen is supported or not.
   * @param {boolean} [iridescence=false] - Whether iridescence is supported or not.
   * @param {boolean} [anisotropy=false] - Whether anisotropy is supported or not.
   * @param {boolean} [transmission=false] - Whether transmission is supported or not.
   * @param {boolean} [dispersion=false] - Whether dispersion is supported or not.
   */
  constructor(clearcoat3 = false, sheen3 = false, iridescence3 = false, anisotropy3 = false, transmission3 = false, dispersion3 = false) {
    super();
    this.clearcoat = clearcoat3;
    this.sheen = sheen3;
    this.iridescence = iridescence3;
    this.anisotropy = anisotropy3;
    this.transmission = transmission3;
    this.dispersion = dispersion3;
    this.clearcoatRadiance = null;
    this.clearcoatSpecularDirect = null;
    this.clearcoatSpecularIndirect = null;
    this.sheenSpecularDirect = null;
    this.sheenSpecularIndirect = null;
    this.iridescenceFresnel = null;
    this.iridescenceF0 = null;
  }
  /**
   * Depending on what features are requested, the method prepares certain node variables
   * which are later used for lighting computations.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  start(builder) {
    if (this.clearcoat === true) {
      this.clearcoatRadiance = vec3().toVar("clearcoatRadiance");
      this.clearcoatSpecularDirect = vec3().toVar("clearcoatSpecularDirect");
      this.clearcoatSpecularIndirect = vec3().toVar("clearcoatSpecularIndirect");
    }
    if (this.sheen === true) {
      this.sheenSpecularDirect = vec3().toVar("sheenSpecularDirect");
      this.sheenSpecularIndirect = vec3().toVar("sheenSpecularIndirect");
    }
    if (this.iridescence === true) {
      const dotNVi = normalView.dot(positionViewDirection).clamp();
      this.iridescenceFresnel = evalIridescence({
        outsideIOR: float(1),
        eta2: iridescenceIOR,
        cosTheta1: dotNVi,
        thinFilmThickness: iridescenceThickness,
        baseF0: specularColor
      });
      this.iridescenceF0 = Schlick_to_F0({ f: this.iridescenceFresnel, f90: 1, dotVH: dotNVi });
    }
    if (this.transmission === true) {
      const position = positionWorld;
      const v2 = cameraPosition.sub(positionWorld).normalize();
      const n = normalWorld;
      const context3 = builder.context;
      context3.backdrop = getIBLVolumeRefraction(
        n,
        v2,
        roughness,
        diffuseColor,
        specularColor,
        specularF90,
        // specularF90
        position,
        // positionWorld
        modelWorldMatrix,
        // modelMatrix
        cameraViewMatrix,
        // viewMatrix
        cameraProjectionMatrix,
        // projMatrix
        ior,
        thickness,
        attenuationColor,
        attenuationDistance,
        this.dispersion ? dispersion : null
      );
      context3.backdropAlpha = transmission;
      diffuseColor.a.mulAssign(mix(1, context3.backdrop.a, transmission));
    }
    super.start(builder);
  }
  // Fdez-Agera's "Multiple-Scattering Microfacet Model for Real-Time Image Based Lighting"
  // Approximates multi-scattering in order to preserve energy.
  // http://www.jcgt.org/published/0008/01/03/
  computeMultiscattering(singleScatter, multiScatter, specularF903) {
    const dotNV = normalView.dot(positionViewDirection).clamp();
    const fab = DFGApprox({ roughness, dotNV });
    const Fr = this.iridescenceF0 ? iridescence.mix(specularColor, this.iridescenceF0) : specularColor;
    const FssEss = Fr.mul(fab.x).add(specularF903.mul(fab.y));
    const Ess = fab.x.add(fab.y);
    const Ems = Ess.oneMinus();
    const Favg = specularColor.add(specularColor.oneMinus().mul(0.047619));
    const Fms = FssEss.mul(Favg).div(Ems.mul(Favg).oneMinus());
    singleScatter.addAssign(FssEss);
    multiScatter.addAssign(Fms.mul(Ems));
  }
  /**
   * Implements the direct light.
   *
   * @param {Object} lightData - The light data.
   * @param {NodeBuilder} builder - The current node builder.
   */
  direct({ lightDirection, lightColor, reflectedLight }) {
    const dotNL = normalView.dot(lightDirection).clamp();
    const irradiance = dotNL.mul(lightColor);
    if (this.sheen === true) {
      this.sheenSpecularDirect.addAssign(irradiance.mul(BRDF_Sheen({ lightDirection })));
    }
    if (this.clearcoat === true) {
      const dotNLcc = clearcoatNormalView.dot(lightDirection).clamp();
      const ccIrradiance = dotNLcc.mul(lightColor);
      this.clearcoatSpecularDirect.addAssign(ccIrradiance.mul(BRDF_GGX({ lightDirection, f0: clearcoatF0, f90: clearcoatF90, roughness: clearcoatRoughness, normalView: clearcoatNormalView })));
    }
    reflectedLight.directDiffuse.addAssign(irradiance.mul(BRDF_Lambert({ diffuseColor: diffuseColor.rgb })));
    reflectedLight.directSpecular.addAssign(irradiance.mul(BRDF_GGX({ lightDirection, f0: specularColor, f90: 1, roughness, iridescence: this.iridescence, f: this.iridescenceFresnel, USE_IRIDESCENCE: this.iridescence, USE_ANISOTROPY: this.anisotropy })));
  }
  /**
   * This method is intended for implementing the direct light term for
   * rect area light nodes.
   *
   * @param {Object} input - The input data.
   * @param {NodeBuilder} builder - The current node builder.
   */
  directRectArea({ lightColor, lightPosition: lightPosition3, halfWidth, halfHeight, reflectedLight, ltc_1, ltc_2 }) {
    const p02 = lightPosition3.add(halfWidth).sub(halfHeight);
    const p1 = lightPosition3.sub(halfWidth).sub(halfHeight);
    const p2 = lightPosition3.sub(halfWidth).add(halfHeight);
    const p3 = lightPosition3.add(halfWidth).add(halfHeight);
    const N2 = normalView;
    const V = positionViewDirection;
    const P = positionView.toVar();
    const uv3 = LTC_Uv({ N: N2, V, roughness });
    const t13 = ltc_1.sample(uv3).toVar();
    const t22 = ltc_2.sample(uv3).toVar();
    const mInv = mat3(
      vec3(t13.x, 0, t13.y),
      vec3(0, 1, 0),
      vec3(t13.z, 0, t13.w)
    ).toVar();
    const fresnel = specularColor.mul(t22.x).add(specularColor.oneMinus().mul(t22.y)).toVar();
    reflectedLight.directSpecular.addAssign(lightColor.mul(fresnel).mul(LTC_Evaluate({ N: N2, V, P, mInv, p0: p02, p1, p2, p3 })));
    reflectedLight.directDiffuse.addAssign(lightColor.mul(diffuseColor).mul(LTC_Evaluate({ N: N2, V, P, mInv: mat3(1, 0, 0, 0, 1, 0, 0, 0, 1), p0: p02, p1, p2, p3 })));
  }
  /**
   * Implements the indirect lighting.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  indirect(builder) {
    this.indirectDiffuse(builder);
    this.indirectSpecular(builder);
    this.ambientOcclusion(builder);
  }
  /**
   * Implements the indirect diffuse term.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  indirectDiffuse(builder) {
    const { irradiance, reflectedLight } = builder.context;
    reflectedLight.indirectDiffuse.addAssign(irradiance.mul(BRDF_Lambert({ diffuseColor })));
  }
  /**
   * Implements the indirect specular term.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  indirectSpecular(builder) {
    const { radiance, iblIrradiance, reflectedLight } = builder.context;
    if (this.sheen === true) {
      this.sheenSpecularIndirect.addAssign(iblIrradiance.mul(
        sheen,
        IBLSheenBRDF({
          normal: normalView,
          viewDir: positionViewDirection,
          roughness: sheenRoughness
        })
      ));
    }
    if (this.clearcoat === true) {
      const dotNVcc = clearcoatNormalView.dot(positionViewDirection).clamp();
      const clearcoatEnv = EnvironmentBRDF({
        dotNV: dotNVcc,
        specularColor: clearcoatF0,
        specularF90: clearcoatF90,
        roughness: clearcoatRoughness
      });
      this.clearcoatSpecularIndirect.addAssign(this.clearcoatRadiance.mul(clearcoatEnv));
    }
    const singleScattering = vec3().toVar("singleScattering");
    const multiScattering = vec3().toVar("multiScattering");
    const cosineWeightedIrradiance = iblIrradiance.mul(1 / Math.PI);
    this.computeMultiscattering(singleScattering, multiScattering, specularF90);
    const totalScattering = singleScattering.add(multiScattering);
    const diffuse = diffuseColor.mul(totalScattering.r.max(totalScattering.g).max(totalScattering.b).oneMinus());
    reflectedLight.indirectSpecular.addAssign(radiance.mul(singleScattering));
    reflectedLight.indirectSpecular.addAssign(multiScattering.mul(cosineWeightedIrradiance));
    reflectedLight.indirectDiffuse.addAssign(diffuse.mul(cosineWeightedIrradiance));
  }
  /**
   * Implements the ambient occlusion term.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  ambientOcclusion(builder) {
    const { ambientOcclusion, reflectedLight } = builder.context;
    const dotNV = normalView.dot(positionViewDirection).clamp();
    const aoNV = dotNV.add(ambientOcclusion);
    const aoExp = roughness.mul(-16).oneMinus().negate().exp2();
    const aoNode = ambientOcclusion.sub(aoNV.pow(aoExp).oneMinus()).clamp();
    if (this.clearcoat === true) {
      this.clearcoatSpecularIndirect.mulAssign(ambientOcclusion);
    }
    if (this.sheen === true) {
      this.sheenSpecularIndirect.mulAssign(ambientOcclusion);
    }
    reflectedLight.indirectDiffuse.mulAssign(ambientOcclusion);
    reflectedLight.indirectSpecular.mulAssign(aoNode);
  }
  /**
   * Used for final lighting accumulations depending on the requested features.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  finish({ context: context3 }) {
    const { outgoingLight } = context3;
    if (this.clearcoat === true) {
      const dotNVcc = clearcoatNormalView.dot(positionViewDirection).clamp();
      const Fcc = F_Schlick({
        dotVH: dotNVcc,
        f0: clearcoatF0,
        f90: clearcoatF90
      });
      const clearcoatLight = outgoingLight.mul(clearcoat.mul(Fcc).oneMinus()).add(this.clearcoatSpecularDirect.add(this.clearcoatSpecularIndirect).mul(clearcoat));
      outgoingLight.assign(clearcoatLight);
    }
    if (this.sheen === true) {
      const sheenEnergyComp = sheen.r.max(sheen.g).max(sheen.b).mul(0.157).oneMinus();
      const sheenLight = outgoingLight.mul(sheenEnergyComp).add(this.sheenSpecularDirect, this.sheenSpecularIndirect);
      outgoingLight.assign(sheenLight);
    }
  }
};
var cubeUV_r0 = float(1);
var cubeUV_m0 = float(-2);
var cubeUV_r1 = float(0.8);
var cubeUV_m1 = float(-1);
var cubeUV_r4 = float(0.4);
var cubeUV_m4 = float(2);
var cubeUV_r5 = float(0.305);
var cubeUV_m5 = float(3);
var cubeUV_r6 = float(0.21);
var cubeUV_m6 = float(4);
var cubeUV_minMipLevel = float(4);
var cubeUV_minTileSize = float(16);
var getFace = Fn(([direction]) => {
  const absDirection = vec3(abs2(direction)).toVar();
  const face = float(-1).toVar();
  If(absDirection.x.greaterThan(absDirection.z), () => {
    If(absDirection.x.greaterThan(absDirection.y), () => {
      face.assign(select(direction.x.greaterThan(0), 0, 3));
    }).Else(() => {
      face.assign(select(direction.y.greaterThan(0), 1, 4));
    });
  }).Else(() => {
    If(absDirection.z.greaterThan(absDirection.y), () => {
      face.assign(select(direction.z.greaterThan(0), 2, 5));
    }).Else(() => {
      face.assign(select(direction.y.greaterThan(0), 1, 4));
    });
  });
  return face;
}).setLayout({
  name: "getFace",
  type: "float",
  inputs: [
    { name: "direction", type: "vec3" }
  ]
});
var getUV = Fn(([direction, face]) => {
  const uv3 = vec2().toVar();
  If(face.equal(0), () => {
    uv3.assign(vec2(direction.z, direction.y).div(abs2(direction.x)));
  }).ElseIf(face.equal(1), () => {
    uv3.assign(vec2(direction.x.negate(), direction.z.negate()).div(abs2(direction.y)));
  }).ElseIf(face.equal(2), () => {
    uv3.assign(vec2(direction.x.negate(), direction.y).div(abs2(direction.z)));
  }).ElseIf(face.equal(3), () => {
    uv3.assign(vec2(direction.z.negate(), direction.y).div(abs2(direction.x)));
  }).ElseIf(face.equal(4), () => {
    uv3.assign(vec2(direction.x.negate(), direction.z).div(abs2(direction.y)));
  }).Else(() => {
    uv3.assign(vec2(direction.x, direction.y).div(abs2(direction.z)));
  });
  return mul(0.5, uv3.add(1));
}).setLayout({
  name: "getUV",
  type: "vec2",
  inputs: [
    { name: "direction", type: "vec3" },
    { name: "face", type: "float" }
  ]
});
var roughnessToMip = Fn(([roughness3]) => {
  const mip = float(0).toVar();
  If(roughness3.greaterThanEqual(cubeUV_r1), () => {
    mip.assign(cubeUV_r0.sub(roughness3).mul(cubeUV_m1.sub(cubeUV_m0)).div(cubeUV_r0.sub(cubeUV_r1)).add(cubeUV_m0));
  }).ElseIf(roughness3.greaterThanEqual(cubeUV_r4), () => {
    mip.assign(cubeUV_r1.sub(roughness3).mul(cubeUV_m4.sub(cubeUV_m1)).div(cubeUV_r1.sub(cubeUV_r4)).add(cubeUV_m1));
  }).ElseIf(roughness3.greaterThanEqual(cubeUV_r5), () => {
    mip.assign(cubeUV_r4.sub(roughness3).mul(cubeUV_m5.sub(cubeUV_m4)).div(cubeUV_r4.sub(cubeUV_r5)).add(cubeUV_m4));
  }).ElseIf(roughness3.greaterThanEqual(cubeUV_r6), () => {
    mip.assign(cubeUV_r5.sub(roughness3).mul(cubeUV_m6.sub(cubeUV_m5)).div(cubeUV_r5.sub(cubeUV_r6)).add(cubeUV_m5));
  }).Else(() => {
    mip.assign(float(-2).mul(log22(mul(1.16, roughness3))));
  });
  return mip;
}).setLayout({
  name: "roughnessToMip",
  type: "float",
  inputs: [
    { name: "roughness", type: "float" }
  ]
});
var getDirection = Fn(([uv_immutable, face]) => {
  const uv3 = uv_immutable.toVar();
  uv3.assign(mul(2, uv3).sub(1));
  const direction = vec3(uv3, 1).toVar();
  If(face.equal(0), () => {
    direction.assign(direction.zyx);
  }).ElseIf(face.equal(1), () => {
    direction.assign(direction.xzy);
    direction.xz.mulAssign(-1);
  }).ElseIf(face.equal(2), () => {
    direction.x.mulAssign(-1);
  }).ElseIf(face.equal(3), () => {
    direction.assign(direction.zyx);
    direction.xz.mulAssign(-1);
  }).ElseIf(face.equal(4), () => {
    direction.assign(direction.xzy);
    direction.xy.mulAssign(-1);
  }).ElseIf(face.equal(5), () => {
    direction.z.mulAssign(-1);
  });
  return direction;
}).setLayout({
  name: "getDirection",
  type: "vec3",
  inputs: [
    { name: "uv", type: "vec2" },
    { name: "face", type: "float" }
  ]
});
var textureCubeUV = Fn(([envMap, sampleDir_immutable, roughness_immutable, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP]) => {
  const roughness3 = float(roughness_immutable);
  const sampleDir = vec3(sampleDir_immutable);
  const mip = clamp(roughnessToMip(roughness3), cubeUV_m0, CUBEUV_MAX_MIP);
  const mipF = fract(mip);
  const mipInt = floor(mip);
  const color0 = vec3(bilinearCubeUV(envMap, sampleDir, mipInt, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP)).toVar();
  If(mipF.notEqual(0), () => {
    const color1 = vec3(bilinearCubeUV(envMap, sampleDir, mipInt.add(1), CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP)).toVar();
    color0.assign(mix(color0, color1, mipF));
  });
  return color0;
});
var bilinearCubeUV = Fn(([envMap, direction_immutable, mipInt_immutable, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP]) => {
  const mipInt = float(mipInt_immutable).toVar();
  const direction = vec3(direction_immutable);
  const face = float(getFace(direction)).toVar();
  const filterInt = float(max$1(cubeUV_minMipLevel.sub(mipInt), 0)).toVar();
  mipInt.assign(max$1(mipInt, cubeUV_minMipLevel));
  const faceSize = float(exp22(mipInt)).toVar();
  const uv3 = vec2(getUV(direction, face).mul(faceSize.sub(2)).add(1)).toVar();
  If(face.greaterThan(2), () => {
    uv3.y.addAssign(faceSize);
    face.subAssign(3);
  });
  uv3.x.addAssign(face.mul(faceSize));
  uv3.x.addAssign(filterInt.mul(mul(3, cubeUV_minTileSize)));
  uv3.y.addAssign(mul(4, exp22(CUBEUV_MAX_MIP).sub(faceSize)));
  uv3.x.mulAssign(CUBEUV_TEXEL_WIDTH);
  uv3.y.mulAssign(CUBEUV_TEXEL_HEIGHT);
  return envMap.sample(uv3).grad(vec2(), vec2());
});
var getSample = Fn(({ envMap, mipInt, outputDirection, theta, axis, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP }) => {
  const cosTheta = cos3(theta);
  const sampleDirection = outputDirection.mul(cosTheta).add(axis.cross(outputDirection).mul(sin3(theta))).add(axis.mul(axis.dot(outputDirection).mul(cosTheta.oneMinus())));
  return bilinearCubeUV(envMap, sampleDirection, mipInt, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP);
});
var blur3 = Fn(({ n, latitudinal, poleAxis, outputDirection, weights, samples, dTheta, mipInt, envMap, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP }) => {
  const axis = vec3(select(latitudinal, poleAxis, cross2(poleAxis, outputDirection))).toVar();
  If(axis.equal(vec3(0)), () => {
    axis.assign(vec3(outputDirection.z, 0, outputDirection.x.negate()));
  });
  axis.assign(normalize2(axis));
  const gl_FragColor = vec3().toVar();
  gl_FragColor.addAssign(weights.element(0).mul(getSample({ theta: 0, axis, outputDirection, mipInt, envMap, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP })));
  Loop({ start: int(1), end: n }, ({ i }) => {
    If(i.greaterThanEqual(samples), () => {
      Break();
    });
    const theta = float(dTheta.mul(float(i))).toVar();
    gl_FragColor.addAssign(weights.element(i).mul(getSample({ theta: theta.mul(-1), axis, outputDirection, mipInt, envMap, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP })));
    gl_FragColor.addAssign(weights.element(i).mul(getSample({ theta, axis, outputDirection, mipInt, envMap, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP })));
  });
  return vec4(gl_FragColor, 1);
});
var LOD_MIN = 4;
var EXTRA_LOD_SIGMA = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582];
var MAX_SAMPLES = 20;
var _flatCamera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
var _cubeCamera = new PerspectiveCamera(90, 1);
var _clearColor$2 = new Color();
var _oldTarget = null;
var _oldActiveCubeFace = 0;
var _oldActiveMipmapLevel = 0;
var PHI = (1 + Math.sqrt(5)) / 2;
var INV_PHI = 1 / PHI;
var _axisDirections = [
  new Vector3(-PHI, INV_PHI, 0),
  new Vector3(PHI, INV_PHI, 0),
  new Vector3(-INV_PHI, 0, PHI),
  new Vector3(INV_PHI, 0, PHI),
  new Vector3(0, PHI, -INV_PHI),
  new Vector3(0, PHI, INV_PHI),
  new Vector3(-1, 1, -1),
  new Vector3(1, 1, -1),
  new Vector3(-1, 1, 1),
  new Vector3(1, 1, 1)
];
var _origin = new Vector3();
var _uniformsMap = /* @__PURE__ */ new WeakMap();
var _faceLib = [
  3,
  1,
  5,
  0,
  4,
  2
];
var _direction = getDirection(uv$1(), attribute("faceIndex")).normalize();
var _outputDirection = vec3(_direction.x, _direction.y, _direction.z);
var PMREMGenerator = class {
  /**
   * Constructs a new PMREM generator.
   *
   * @param {Renderer} renderer - The renderer.
   */
  constructor(renderer) {
    this._renderer = renderer;
    this._pingPongRenderTarget = null;
    this._lodMax = 0;
    this._cubeSize = 0;
    this._lodPlanes = [];
    this._sizeLods = [];
    this._sigmas = [];
    this._lodMeshes = [];
    this._blurMaterial = null;
    this._cubemapMaterial = null;
    this._equirectMaterial = null;
    this._backgroundBox = null;
  }
  get _hasInitialized() {
    return this._renderer.hasInitialized();
  }
  /**
   * Generates a PMREM from a supplied Scene, which can be faster than using an
   * image if networking bandwidth is low. Optional sigma specifies a blur radius
   * in radians to be applied to the scene before PMREM generation. Optional near
   * and far planes ensure the scene is rendered in its entirety.
   *
   * @param {Scene} scene - The scene to be captured.
   * @param {number} [sigma=0] - The blur radius in radians.
   * @param {number} [near=0.1] - The near plane distance.
   * @param {number} [far=100] - The far plane distance.
   * @param {Object} [options={}] - The configuration options.
   * @param {number} [options.size=256] - The texture size of the PMREM.
   * @param {Vector3} [options.renderTarget=origin] - The position of the internal cube camera that renders the scene.
   * @param {?RenderTarget} [options.renderTarget=null] - The render target to use.
   * @return {RenderTarget} The resulting PMREM.
   * @see {@link PMREMGenerator#fromSceneAsync}
   */
  fromScene(scene, sigma = 0, near = 0.1, far = 100, options = {}) {
    const {
      size = 256,
      position = _origin,
      renderTarget = null
    } = options;
    this._setSize(size);
    if (this._hasInitialized === false) {
      console.warn("THREE.PMREMGenerator: .fromScene() called before the backend is initialized. Try using .fromSceneAsync() instead.");
      const cubeUVRenderTarget2 = renderTarget || this._allocateTarget();
      options.renderTarget = cubeUVRenderTarget2;
      this.fromSceneAsync(scene, sigma, near, far, options);
      return cubeUVRenderTarget2;
    }
    _oldTarget = this._renderer.getRenderTarget();
    _oldActiveCubeFace = this._renderer.getActiveCubeFace();
    _oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel();
    const cubeUVRenderTarget = renderTarget || this._allocateTarget();
    cubeUVRenderTarget.depthBuffer = true;
    this._init(cubeUVRenderTarget);
    this._sceneToCubeUV(scene, near, far, cubeUVRenderTarget, position);
    if (sigma > 0) {
      this._blur(cubeUVRenderTarget, 0, 0, sigma);
    }
    this._applyPMREM(cubeUVRenderTarget);
    this._cleanup(cubeUVRenderTarget);
    return cubeUVRenderTarget;
  }
  /**
   * Generates a PMREM from a supplied Scene, which can be faster than using an
   * image if networking bandwidth is low. Optional sigma specifies a blur radius
   * in radians to be applied to the scene before PMREM generation. Optional near
   * and far planes ensure the scene is rendered in its entirety (the cubeCamera
   * is placed at the origin).
   *
   * @param {Scene} scene - The scene to be captured.
   * @param {number} [sigma=0] - The blur radius in radians.
   * @param {number} [near=0.1] - The near plane distance.
   * @param {number} [far=100] - The far plane distance.
   * @param {Object} [options={}] - The configuration options.
   * @param {number} [options.size=256] - The texture size of the PMREM.
   * @param {Vector3} [options.position=origin] - The position of the internal cube camera that renders the scene.
   * @param {?RenderTarget} [options.renderTarget=null] - The render target to use.
   * @return {Promise<RenderTarget>} A Promise that resolve with the PMREM when the generation has been finished.
   * @see {@link PMREMGenerator#fromScene}
   */
  async fromSceneAsync(scene, sigma = 0, near = 0.1, far = 100, options = {}) {
    if (this._hasInitialized === false) await this._renderer.init();
    return this.fromScene(scene, sigma, near, far, options);
  }
  /**
   * Generates a PMREM from an equirectangular texture, which can be either LDR
   * or HDR. The ideal input image size is 1k (1024 x 512),
   * as this matches best with the 256 x 256 cubemap output.
   *
   * @param {Texture} equirectangular - The equirectangular texture to be converted.
   * @param {?RenderTarget} [renderTarget=null] - The render target to use.
   * @return {RenderTarget} The resulting PMREM.
   * @see {@link PMREMGenerator#fromEquirectangularAsync}
   */
  fromEquirectangular(equirectangular, renderTarget = null) {
    if (this._hasInitialized === false) {
      console.warn("THREE.PMREMGenerator: .fromEquirectangular() called before the backend is initialized. Try using .fromEquirectangularAsync() instead.");
      this._setSizeFromTexture(equirectangular);
      const cubeUVRenderTarget = renderTarget || this._allocateTarget();
      this.fromEquirectangularAsync(equirectangular, cubeUVRenderTarget);
      return cubeUVRenderTarget;
    }
    return this._fromTexture(equirectangular, renderTarget);
  }
  /**
   * Generates a PMREM from an equirectangular texture, which can be either LDR
   * or HDR. The ideal input image size is 1k (1024 x 512),
   * as this matches best with the 256 x 256 cubemap output.
   *
   * @param {Texture} equirectangular - The equirectangular texture to be converted.
   * @param {?RenderTarget} [renderTarget=null] - The render target to use.
   * @return {Promise<RenderTarget>} The resulting PMREM.
   * @see {@link PMREMGenerator#fromEquirectangular}
   */
  async fromEquirectangularAsync(equirectangular, renderTarget = null) {
    if (this._hasInitialized === false) await this._renderer.init();
    return this._fromTexture(equirectangular, renderTarget);
  }
  /**
   * Generates a PMREM from an cubemap texture, which can be either LDR
   * or HDR. The ideal input cube size is 256 x 256,
   * as this matches best with the 256 x 256 cubemap output.
   *
   * @param {Texture} cubemap - The cubemap texture to be converted.
   * @param {?RenderTarget} [renderTarget=null] - The render target to use.
   * @return {RenderTarget} The resulting PMREM.
   * @see {@link PMREMGenerator#fromCubemapAsync}
   */
  fromCubemap(cubemap, renderTarget = null) {
    if (this._hasInitialized === false) {
      console.warn("THREE.PMREMGenerator: .fromCubemap() called before the backend is initialized. Try using .fromCubemapAsync() instead.");
      this._setSizeFromTexture(cubemap);
      const cubeUVRenderTarget = renderTarget || this._allocateTarget();
      this.fromCubemapAsync(cubemap, renderTarget);
      return cubeUVRenderTarget;
    }
    return this._fromTexture(cubemap, renderTarget);
  }
  /**
   * Generates a PMREM from an cubemap texture, which can be either LDR
   * or HDR. The ideal input cube size is 256 x 256,
   * with the 256 x 256 cubemap output.
   *
   * @param {Texture} cubemap - The cubemap texture to be converted.
   * @param {?RenderTarget} [renderTarget=null] - The render target to use.
   * @return {Promise<RenderTarget>} The resulting PMREM.
   * @see {@link PMREMGenerator#fromCubemap}
   */
  async fromCubemapAsync(cubemap, renderTarget = null) {
    if (this._hasInitialized === false) await this._renderer.init();
    return this._fromTexture(cubemap, renderTarget);
  }
  /**
   * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   *
   * @returns {Promise}
   */
  async compileCubemapShader() {
    if (this._cubemapMaterial === null) {
      this._cubemapMaterial = _getCubemapMaterial();
      await this._compileMaterial(this._cubemapMaterial);
    }
  }
  /**
   * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   *
   * @returns {Promise}
   */
  async compileEquirectangularShader() {
    if (this._equirectMaterial === null) {
      this._equirectMaterial = _getEquirectMaterial();
      await this._compileMaterial(this._equirectMaterial);
    }
  }
  /**
   * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
   * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
   * one of them will cause any others to also become unusable.
   */
  dispose() {
    this._dispose();
    if (this._cubemapMaterial !== null) this._cubemapMaterial.dispose();
    if (this._equirectMaterial !== null) this._equirectMaterial.dispose();
    if (this._backgroundBox !== null) {
      this._backgroundBox.geometry.dispose();
      this._backgroundBox.material.dispose();
    }
  }
  // private interface
  _setSizeFromTexture(texture3) {
    if (texture3.mapping === CubeReflectionMapping || texture3.mapping === CubeRefractionMapping) {
      this._setSize(texture3.image.length === 0 ? 16 : texture3.image[0].width || texture3.image[0].image.width);
    } else {
      this._setSize(texture3.image.width / 4);
    }
  }
  _setSize(cubeSize) {
    this._lodMax = Math.floor(Math.log2(cubeSize));
    this._cubeSize = Math.pow(2, this._lodMax);
  }
  _dispose() {
    if (this._blurMaterial !== null) this._blurMaterial.dispose();
    if (this._pingPongRenderTarget !== null) this._pingPongRenderTarget.dispose();
    for (let i = 0; i < this._lodPlanes.length; i++) {
      this._lodPlanes[i].dispose();
    }
  }
  _cleanup(outputTarget) {
    this._renderer.setRenderTarget(_oldTarget, _oldActiveCubeFace, _oldActiveMipmapLevel);
    outputTarget.scissorTest = false;
    _setViewport(outputTarget, 0, 0, outputTarget.width, outputTarget.height);
  }
  _fromTexture(texture3, renderTarget) {
    this._setSizeFromTexture(texture3);
    _oldTarget = this._renderer.getRenderTarget();
    _oldActiveCubeFace = this._renderer.getActiveCubeFace();
    _oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel();
    const cubeUVRenderTarget = renderTarget || this._allocateTarget();
    this._init(cubeUVRenderTarget);
    this._textureToCubeUV(texture3, cubeUVRenderTarget);
    this._applyPMREM(cubeUVRenderTarget);
    this._cleanup(cubeUVRenderTarget);
    return cubeUVRenderTarget;
  }
  _allocateTarget() {
    const width = 3 * Math.max(this._cubeSize, 16 * 7);
    const height = 4 * this._cubeSize;
    const cubeUVRenderTarget = _createRenderTarget(width, height);
    return cubeUVRenderTarget;
  }
  _init(renderTarget) {
    if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== renderTarget.width || this._pingPongRenderTarget.height !== renderTarget.height) {
      if (this._pingPongRenderTarget !== null) {
        this._dispose();
      }
      this._pingPongRenderTarget = _createRenderTarget(renderTarget.width, renderTarget.height);
      const { _lodMax } = this;
      ({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas, lodMeshes: this._lodMeshes } = _createPlanes(_lodMax));
      this._blurMaterial = _getBlurShader(_lodMax, renderTarget.width, renderTarget.height);
    }
  }
  async _compileMaterial(material) {
    const tmpMesh = new Mesh(this._lodPlanes[0], material);
    await this._renderer.compile(tmpMesh, _flatCamera);
  }
  _sceneToCubeUV(scene, near, far, cubeUVRenderTarget, position) {
    const cubeCamera = _cubeCamera;
    cubeCamera.near = near;
    cubeCamera.far = far;
    const upSign = [1, 1, 1, 1, -1, 1];
    const forwardSign = [1, -1, 1, -1, 1, -1];
    const renderer = this._renderer;
    const originalAutoClear = renderer.autoClear;
    renderer.getClearColor(_clearColor$2);
    renderer.autoClear = false;
    let backgroundBox = this._backgroundBox;
    if (backgroundBox === null) {
      const backgroundMaterial = new MeshBasicMaterial({
        name: "PMREM.Background",
        side: BackSide,
        depthWrite: false,
        depthTest: false
      });
      backgroundBox = new Mesh(new BoxGeometry(), backgroundMaterial);
    }
    let useSolidColor = false;
    const background = scene.background;
    if (background) {
      if (background.isColor) {
        backgroundBox.material.color.copy(background);
        scene.background = null;
        useSolidColor = true;
      }
    } else {
      backgroundBox.material.color.copy(_clearColor$2);
      useSolidColor = true;
    }
    renderer.setRenderTarget(cubeUVRenderTarget);
    renderer.clear();
    if (useSolidColor) {
      renderer.render(backgroundBox, cubeCamera);
    }
    for (let i = 0; i < 6; i++) {
      const col = i % 3;
      if (col === 0) {
        cubeCamera.up.set(0, upSign[i], 0);
        cubeCamera.position.set(position.x, position.y, position.z);
        cubeCamera.lookAt(position.x + forwardSign[i], position.y, position.z);
      } else if (col === 1) {
        cubeCamera.up.set(0, 0, upSign[i]);
        cubeCamera.position.set(position.x, position.y, position.z);
        cubeCamera.lookAt(position.x, position.y + forwardSign[i], position.z);
      } else {
        cubeCamera.up.set(0, upSign[i], 0);
        cubeCamera.position.set(position.x, position.y, position.z);
        cubeCamera.lookAt(position.x, position.y, position.z + forwardSign[i]);
      }
      const size = this._cubeSize;
      _setViewport(cubeUVRenderTarget, col * size, i > 2 ? size : 0, size, size);
      renderer.render(scene, cubeCamera);
    }
    renderer.autoClear = originalAutoClear;
    scene.background = background;
  }
  _textureToCubeUV(texture3, cubeUVRenderTarget) {
    const renderer = this._renderer;
    const isCubeTexture = texture3.mapping === CubeReflectionMapping || texture3.mapping === CubeRefractionMapping;
    if (isCubeTexture) {
      if (this._cubemapMaterial === null) {
        this._cubemapMaterial = _getCubemapMaterial(texture3);
      }
    } else {
      if (this._equirectMaterial === null) {
        this._equirectMaterial = _getEquirectMaterial(texture3);
      }
    }
    const material = isCubeTexture ? this._cubemapMaterial : this._equirectMaterial;
    material.fragmentNode.value = texture3;
    const mesh = this._lodMeshes[0];
    mesh.material = material;
    const size = this._cubeSize;
    _setViewport(cubeUVRenderTarget, 0, 0, 3 * size, 2 * size);
    renderer.setRenderTarget(cubeUVRenderTarget);
    renderer.render(mesh, _flatCamera);
  }
  _applyPMREM(cubeUVRenderTarget) {
    const renderer = this._renderer;
    const autoClear = renderer.autoClear;
    renderer.autoClear = false;
    const n = this._lodPlanes.length;
    for (let i = 1; i < n; i++) {
      const sigma = Math.sqrt(this._sigmas[i] * this._sigmas[i] - this._sigmas[i - 1] * this._sigmas[i - 1]);
      const poleAxis = _axisDirections[(n - i - 1) % _axisDirections.length];
      this._blur(cubeUVRenderTarget, i - 1, i, sigma, poleAxis);
    }
    renderer.autoClear = autoClear;
  }
  /**
   * This is a two-pass Gaussian blur for a cubemap. Normally this is done
   * vertically and horizontally, but this breaks down on a cube. Here we apply
   * the blur latitudinally (around the poles), and then longitudinally (towards
   * the poles) to approximate the orthogonally-separable blur. It is least
   * accurate at the poles, but still does a decent job.
   *
   * @private
   * @param {RenderTarget} cubeUVRenderTarget - The cubemap render target.
   * @param {number} lodIn - The input level-of-detail.
   * @param {number} lodOut - The output level-of-detail.
   * @param {number} sigma - The blur radius in radians.
   * @param {Vector3} [poleAxis] - The pole axis.
   */
  _blur(cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis) {
    const pingPongRenderTarget = this._pingPongRenderTarget;
    this._halfBlur(
      cubeUVRenderTarget,
      pingPongRenderTarget,
      lodIn,
      lodOut,
      sigma,
      "latitudinal",
      poleAxis
    );
    this._halfBlur(
      pingPongRenderTarget,
      cubeUVRenderTarget,
      lodOut,
      lodOut,
      sigma,
      "longitudinal",
      poleAxis
    );
  }
  _halfBlur(targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis) {
    const renderer = this._renderer;
    const blurMaterial = this._blurMaterial;
    if (direction !== "latitudinal" && direction !== "longitudinal") {
      console.error("blur direction must be either latitudinal or longitudinal!");
    }
    const STANDARD_DEVIATIONS = 3;
    const blurMesh = this._lodMeshes[lodOut];
    blurMesh.material = blurMaterial;
    const blurUniforms = _uniformsMap.get(blurMaterial);
    const pixels = this._sizeLods[lodIn] - 1;
    const radiansPerPixel = isFinite(sigmaRadians) ? Math.PI / (2 * pixels) : 2 * Math.PI / (2 * MAX_SAMPLES - 1);
    const sigmaPixels = sigmaRadians / radiansPerPixel;
    const samples = isFinite(sigmaRadians) ? 1 + Math.floor(STANDARD_DEVIATIONS * sigmaPixels) : MAX_SAMPLES;
    if (samples > MAX_SAMPLES) {
      console.warn(`sigmaRadians, ${sigmaRadians}, is too large and will clip, as it requested ${samples} samples when the maximum is set to ${MAX_SAMPLES}`);
    }
    const weights = [];
    let sum3 = 0;
    for (let i = 0; i < MAX_SAMPLES; ++i) {
      const x2 = i / sigmaPixels;
      const weight = Math.exp(-x2 * x2 / 2);
      weights.push(weight);
      if (i === 0) {
        sum3 += weight;
      } else if (i < samples) {
        sum3 += 2 * weight;
      }
    }
    for (let i = 0; i < weights.length; i++) {
      weights[i] = weights[i] / sum3;
    }
    targetIn.texture.frame = (targetIn.texture.frame || 0) + 1;
    blurUniforms.envMap.value = targetIn.texture;
    blurUniforms.samples.value = samples;
    blurUniforms.weights.array = weights;
    blurUniforms.latitudinal.value = direction === "latitudinal" ? 1 : 0;
    if (poleAxis) {
      blurUniforms.poleAxis.value = poleAxis;
    }
    const { _lodMax } = this;
    blurUniforms.dTheta.value = radiansPerPixel;
    blurUniforms.mipInt.value = _lodMax - lodIn;
    const outputSize = this._sizeLods[lodOut];
    const x = 3 * outputSize * (lodOut > _lodMax - LOD_MIN ? lodOut - _lodMax + LOD_MIN : 0);
    const y = 4 * (this._cubeSize - outputSize);
    _setViewport(targetOut, x, y, 3 * outputSize, 2 * outputSize);
    renderer.setRenderTarget(targetOut);
    renderer.render(blurMesh, _flatCamera);
  }
};
function _createPlanes(lodMax) {
  const lodPlanes = [];
  const sizeLods = [];
  const sigmas = [];
  const lodMeshes = [];
  let lod = lodMax;
  const totalLods = lodMax - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;
  for (let i = 0; i < totalLods; i++) {
    const sizeLod = Math.pow(2, lod);
    sizeLods.push(sizeLod);
    let sigma = 1 / sizeLod;
    if (i > lodMax - LOD_MIN) {
      sigma = EXTRA_LOD_SIGMA[i - lodMax + LOD_MIN - 1];
    } else if (i === 0) {
      sigma = 0;
    }
    sigmas.push(sigma);
    const texelSize = 1 / (sizeLod - 2);
    const min5 = -texelSize;
    const max5 = 1 + texelSize;
    const uv1 = [min5, min5, max5, min5, max5, max5, min5, min5, max5, max5, min5, max5];
    const cubeFaces = 6;
    const vertices = 6;
    const positionSize = 3;
    const uvSize = 2;
    const faceIndexSize = 1;
    const position = new Float32Array(positionSize * vertices * cubeFaces);
    const uv3 = new Float32Array(uvSize * vertices * cubeFaces);
    const faceIndex = new Float32Array(faceIndexSize * vertices * cubeFaces);
    for (let face = 0; face < cubeFaces; face++) {
      const x = face % 3 * 2 / 3 - 1;
      const y = face > 2 ? 0 : -1;
      const coordinates2 = [
        x,
        y,
        0,
        x + 2 / 3,
        y,
        0,
        x + 2 / 3,
        y + 1,
        0,
        x,
        y,
        0,
        x + 2 / 3,
        y + 1,
        0,
        x,
        y + 1,
        0
      ];
      const faceIdx = _faceLib[face];
      position.set(coordinates2, positionSize * vertices * faceIdx);
      uv3.set(uv1, uvSize * vertices * faceIdx);
      const fill = [faceIdx, faceIdx, faceIdx, faceIdx, faceIdx, faceIdx];
      faceIndex.set(fill, faceIndexSize * vertices * faceIdx);
    }
    const planes = new BufferGeometry();
    planes.setAttribute("position", new BufferAttribute(position, positionSize));
    planes.setAttribute("uv", new BufferAttribute(uv3, uvSize));
    planes.setAttribute("faceIndex", new BufferAttribute(faceIndex, faceIndexSize));
    lodPlanes.push(planes);
    lodMeshes.push(new Mesh(planes, null));
    if (lod > LOD_MIN) {
      lod--;
    }
  }
  return { lodPlanes, sizeLods, sigmas, lodMeshes };
}
function _createRenderTarget(width, height) {
  const params = {
    magFilter: LinearFilter,
    minFilter: LinearFilter,
    generateMipmaps: false,
    type: HalfFloatType,
    format: RGBAFormat,
    colorSpace: LinearSRGBColorSpace
    //depthBuffer: false
  };
  const cubeUVRenderTarget = new RenderTarget(width, height, params);
  cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;
  cubeUVRenderTarget.texture.name = "PMREM.cubeUv";
  cubeUVRenderTarget.texture.isPMREMTexture = true;
  cubeUVRenderTarget.scissorTest = true;
  return cubeUVRenderTarget;
}
function _setViewport(target, x, y, width, height) {
  target.viewport.set(x, y, width, height);
  target.scissor.set(x, y, width, height);
}
function _getMaterial(type) {
  const material = new NodeMaterial();
  material.depthTest = false;
  material.depthWrite = false;
  material.blending = NoBlending;
  material.name = `PMREM_${type}`;
  return material;
}
function _getBlurShader(lodMax, width, height) {
  const weights = uniformArray(new Array(MAX_SAMPLES).fill(0));
  const poleAxis = uniform(new Vector3(0, 1, 0));
  const dTheta = uniform(0);
  const n = float(MAX_SAMPLES);
  const latitudinal = uniform(0);
  const samples = uniform(1);
  const envMap = texture(null);
  const mipInt = uniform(0);
  const CUBEUV_TEXEL_WIDTH = float(1 / width);
  const CUBEUV_TEXEL_HEIGHT = float(1 / height);
  const CUBEUV_MAX_MIP = float(lodMax);
  const materialUniforms = {
    n,
    latitudinal,
    weights,
    poleAxis,
    outputDirection: _outputDirection,
    dTheta,
    samples,
    envMap,
    mipInt,
    CUBEUV_TEXEL_WIDTH,
    CUBEUV_TEXEL_HEIGHT,
    CUBEUV_MAX_MIP
  };
  const material = _getMaterial("blur");
  material.fragmentNode = blur3({ ...materialUniforms, latitudinal: latitudinal.equal(1) });
  _uniformsMap.set(material, materialUniforms);
  return material;
}
function _getCubemapMaterial(envTexture) {
  const material = _getMaterial("cubemap");
  material.fragmentNode = cubeTexture(envTexture, _outputDirection);
  return material;
}
function _getEquirectMaterial(envTexture) {
  const material = _getMaterial("equirect");
  material.fragmentNode = texture(envTexture, equirectUV(_outputDirection), 0);
  return material;
}
var _cache = /* @__PURE__ */ new WeakMap();
function _generateCubeUVSize(imageHeight) {
  const maxMip = Math.log2(imageHeight) - 2;
  const texelHeight = 1 / imageHeight;
  const texelWidth = 1 / (3 * Math.max(Math.pow(2, maxMip), 7 * 16));
  return { texelWidth, texelHeight, maxMip };
}
function _getPMREMFromTexture(texture3, renderer, generator) {
  const cache3 = _getCache(renderer);
  let cacheTexture = cache3.get(texture3);
  const pmremVersion = cacheTexture !== void 0 ? cacheTexture.pmremVersion : -1;
  if (pmremVersion !== texture3.pmremVersion) {
    const image = texture3.image;
    if (texture3.isCubeTexture) {
      if (isCubeMapReady(image)) {
        cacheTexture = generator.fromCubemap(texture3, cacheTexture);
      } else {
        return null;
      }
    } else {
      if (isEquirectangularMapReady(image)) {
        cacheTexture = generator.fromEquirectangular(texture3, cacheTexture);
      } else {
        return null;
      }
    }
    cacheTexture.pmremVersion = texture3.pmremVersion;
    cache3.set(texture3, cacheTexture);
  }
  return cacheTexture.texture;
}
function _getCache(renderer) {
  let rendererCache2 = _cache.get(renderer);
  if (rendererCache2 === void 0) {
    rendererCache2 = /* @__PURE__ */ new WeakMap();
    _cache.set(renderer, rendererCache2);
  }
  return rendererCache2;
}
var PMREMNode = class extends TempNode {
  static get type() {
    return "PMREMNode";
  }
  /**
   * Constructs a new function overloading node.
   *
   * @param {Texture} value - The input texture.
   * @param {Node<vec2>} [uvNode=null] - The uv node.
   * @param {Node<float>} [levelNode=null] - The level node.
   */
  constructor(value, uvNode = null, levelNode = null) {
    super("vec3");
    this._value = value;
    this._pmrem = null;
    this.uvNode = uvNode;
    this.levelNode = levelNode;
    this._generator = null;
    const defaultTexture = new Texture();
    defaultTexture.isRenderTargetTexture = true;
    this._texture = texture(defaultTexture);
    this._width = uniform(0);
    this._height = uniform(0);
    this._maxMip = uniform(0);
    this.updateBeforeType = NodeUpdateType.RENDER;
  }
  set value(value) {
    this._value = value;
    this._pmrem = null;
  }
  /**
   * The node's texture value.
   *
   * @type {Texture}
   */
  get value() {
    return this._value;
  }
  /**
   * Uses the given PMREM texture to update internal values.
   *
   * @param {Texture} texture - The PMREM texture.
   */
  updateFromTexture(texture3) {
    const cubeUVSize = _generateCubeUVSize(texture3.image.height);
    this._texture.value = texture3;
    this._width.value = cubeUVSize.texelWidth;
    this._height.value = cubeUVSize.texelHeight;
    this._maxMip.value = cubeUVSize.maxMip;
  }
  updateBefore(frame) {
    let pmrem = this._pmrem;
    const pmremVersion = pmrem ? pmrem.pmremVersion : -1;
    const texture3 = this._value;
    if (pmremVersion !== texture3.pmremVersion) {
      if (texture3.isPMREMTexture === true) {
        pmrem = texture3;
      } else {
        pmrem = _getPMREMFromTexture(texture3, frame.renderer, this._generator);
      }
      if (pmrem !== null) {
        this._pmrem = pmrem;
        this.updateFromTexture(pmrem);
      }
    }
  }
  setup(builder) {
    if (this._generator === null) {
      this._generator = new PMREMGenerator(builder.renderer);
    }
    this.updateBefore(builder);
    let uvNode = this.uvNode;
    if (uvNode === null && builder.context.getUV) {
      uvNode = builder.context.getUV(this);
    }
    uvNode = materialEnvRotation.mul(vec3(uvNode.x, uvNode.y.negate(), uvNode.z));
    let levelNode = this.levelNode;
    if (levelNode === null && builder.context.getTextureLevel) {
      levelNode = builder.context.getTextureLevel(this);
    }
    return textureCubeUV(this._texture, uvNode, levelNode, this._width, this._height, this._maxMip);
  }
  dispose() {
    super.dispose();
    if (this._generator !== null) this._generator.dispose();
  }
};
function isCubeMapReady(image) {
  if (image === null || image === void 0) return false;
  let count2 = 0;
  const length3 = 6;
  for (let i = 0; i < length3; i++) {
    if (image[i] !== void 0) count2++;
  }
  return count2 === length3;
}
function isEquirectangularMapReady(image) {
  if (image === null || image === void 0) return false;
  return image.height > 0;
}
var pmremTexture = nodeProxy(PMREMNode).setParameterLength(1, 3);
var _envNodeCache = /* @__PURE__ */ new WeakMap();
var EnvironmentNode = class extends LightingNode {
  static get type() {
    return "EnvironmentNode";
  }
  /**
   * Constructs a new environment node.
   *
   * @param {Node} [envNode=null] - A node representing the environment.
   */
  constructor(envNode = null) {
    super();
    this.envNode = envNode;
  }
  setup(builder) {
    const { material } = builder;
    let envNode = this.envNode;
    if (envNode.isTextureNode || envNode.isMaterialReferenceNode) {
      const value = envNode.isTextureNode ? envNode.value : material[envNode.property];
      let cacheEnvNode = _envNodeCache.get(value);
      if (cacheEnvNode === void 0) {
        cacheEnvNode = pmremTexture(value);
        _envNodeCache.set(value, cacheEnvNode);
      }
      envNode = cacheEnvNode;
    }
    const useAnisotropy = material.useAnisotropy === true || material.anisotropy > 0;
    const radianceNormalView = useAnisotropy ? bentNormalView : normalView;
    const radiance = envNode.context(createRadianceContext(roughness, radianceNormalView)).mul(materialEnvIntensity);
    const irradiance = envNode.context(createIrradianceContext(normalWorld)).mul(Math.PI).mul(materialEnvIntensity);
    const isolateRadiance = cache(radiance);
    const isolateIrradiance = cache(irradiance);
    builder.context.radiance.addAssign(isolateRadiance);
    builder.context.iblIrradiance.addAssign(isolateIrradiance);
    const clearcoatRadiance = builder.context.lightingModel.clearcoatRadiance;
    if (clearcoatRadiance) {
      const clearcoatRadianceContext = envNode.context(createRadianceContext(clearcoatRoughness, clearcoatNormalView)).mul(materialEnvIntensity);
      const isolateClearcoatRadiance = cache(clearcoatRadianceContext);
      clearcoatRadiance.addAssign(isolateClearcoatRadiance);
    }
  }
};
var createRadianceContext = (roughnessNode, normalViewNode) => {
  let reflectVec = null;
  return {
    getUV: () => {
      if (reflectVec === null) {
        reflectVec = positionViewDirection.negate().reflect(normalViewNode);
        reflectVec = roughnessNode.mul(roughnessNode).mix(reflectVec, normalViewNode).normalize();
        reflectVec = reflectVec.transformDirection(cameraViewMatrix);
      }
      return reflectVec;
    },
    getTextureLevel: () => {
      return roughnessNode;
    }
  };
};
var createIrradianceContext = (normalWorldNode) => {
  return {
    getUV: () => {
      return normalWorldNode;
    },
    getTextureLevel: () => {
      return float(1);
    }
  };
};
var _defaultValues$6 = new MeshStandardMaterial();
var MeshStandardNodeMaterial = class extends NodeMaterial {
  static get type() {
    return "MeshStandardNodeMaterial";
  }
  /**
   * Constructs a new mesh standard node material.
   *
   * @param {Object} [parameters] - The configuration parameter.
   */
  constructor(parameters) {
    super();
    this.isMeshStandardNodeMaterial = true;
    this.lights = true;
    this.emissiveNode = null;
    this.metalnessNode = null;
    this.roughnessNode = null;
    this.setDefaultValues(_defaultValues$6);
    this.setValues(parameters);
  }
  /**
   * Overwritten since this type of material uses {@link EnvironmentNode}
   * to implement the PBR (PMREM based) environment mapping. Besides, the
   * method honors `Scene.environment`.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {?EnvironmentNode<vec3>} The environment node.
   */
  setupEnvironment(builder) {
    let envNode = super.setupEnvironment(builder);
    if (envNode === null && builder.environmentNode) {
      envNode = builder.environmentNode;
    }
    return envNode ? new EnvironmentNode(envNode) : null;
  }
  /**
   * Setups the lighting model.
   *
   * @return {PhysicalLightingModel} The lighting model.
   */
  setupLightingModel() {
    return new PhysicalLightingModel();
  }
  /**
   * Setups the specular related node variables.
   */
  setupSpecular() {
    const specularColorNode = mix(vec3(0.04), diffuseColor.rgb, metalness);
    specularColor.assign(specularColorNode);
    specularF90.assign(1);
  }
  /**
   * Setups the standard specific node variables.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  setupVariants() {
    const metalnessNode = this.metalnessNode ? float(this.metalnessNode) : materialMetalness;
    metalness.assign(metalnessNode);
    let roughnessNode = this.roughnessNode ? float(this.roughnessNode) : materialRoughness;
    roughnessNode = getRoughness({ roughness: roughnessNode });
    roughness.assign(roughnessNode);
    this.setupSpecular();
    diffuseColor.assign(vec4(diffuseColor.rgb.mul(metalnessNode.oneMinus()), diffuseColor.a));
  }
  copy(source) {
    this.emissiveNode = source.emissiveNode;
    this.metalnessNode = source.metalnessNode;
    this.roughnessNode = source.roughnessNode;
    return super.copy(source);
  }
};
var _defaultValues$5 = new MeshPhysicalMaterial();
var MeshPhysicalNodeMaterial = class extends MeshStandardNodeMaterial {
  static get type() {
    return "MeshPhysicalNodeMaterial";
  }
  /**
   * Constructs a new mesh physical node material.
   *
   * @param {Object} [parameters] - The configuration parameter.
   */
  constructor(parameters) {
    super();
    this.isMeshPhysicalNodeMaterial = true;
    this.clearcoatNode = null;
    this.clearcoatRoughnessNode = null;
    this.clearcoatNormalNode = null;
    this.sheenNode = null;
    this.sheenRoughnessNode = null;
    this.iridescenceNode = null;
    this.iridescenceIORNode = null;
    this.iridescenceThicknessNode = null;
    this.specularIntensityNode = null;
    this.specularColorNode = null;
    this.iorNode = null;
    this.transmissionNode = null;
    this.thicknessNode = null;
    this.attenuationDistanceNode = null;
    this.attenuationColorNode = null;
    this.dispersionNode = null;
    this.anisotropyNode = null;
    this.setDefaultValues(_defaultValues$5);
    this.setValues(parameters);
  }
  /**
   * Whether the lighting model should use clearcoat or not.
   *
   * @type {boolean}
   * @default true
   */
  get useClearcoat() {
    return this.clearcoat > 0 || this.clearcoatNode !== null;
  }
  /**
   * Whether the lighting model should use iridescence or not.
   *
   * @type {boolean}
   * @default true
   */
  get useIridescence() {
    return this.iridescence > 0 || this.iridescenceNode !== null;
  }
  /**
   * Whether the lighting model should use sheen or not.
   *
   * @type {boolean}
   * @default true
   */
  get useSheen() {
    return this.sheen > 0 || this.sheenNode !== null;
  }
  /**
   * Whether the lighting model should use anisotropy or not.
   *
   * @type {boolean}
   * @default true
   */
  get useAnisotropy() {
    return this.anisotropy > 0 || this.anisotropyNode !== null;
  }
  /**
   * Whether the lighting model should use transmission or not.
   *
   * @type {boolean}
   * @default true
   */
  get useTransmission() {
    return this.transmission > 0 || this.transmissionNode !== null;
  }
  /**
   * Whether the lighting model should use dispersion or not.
   *
   * @type {boolean}
   * @default true
   */
  get useDispersion() {
    return this.dispersion > 0 || this.dispersionNode !== null;
  }
  /**
   * Setups the specular related node variables.
   */
  setupSpecular() {
    const iorNode = this.iorNode ? float(this.iorNode) : materialIOR;
    ior.assign(iorNode);
    specularColor.assign(mix(min$1(pow22(ior.sub(1).div(ior.add(1))).mul(materialSpecularColor), vec3(1)).mul(materialSpecularIntensity), diffuseColor.rgb, metalness));
    specularF90.assign(mix(materialSpecularIntensity, 1, metalness));
  }
  /**
   * Setups the lighting model.
   *
   * @return {PhysicalLightingModel} The lighting model.
   */
  setupLightingModel() {
    return new PhysicalLightingModel(this.useClearcoat, this.useSheen, this.useIridescence, this.useAnisotropy, this.useTransmission, this.useDispersion);
  }
  /**
   * Setups the physical specific node variables.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  setupVariants(builder) {
    super.setupVariants(builder);
    if (this.useClearcoat) {
      const clearcoatNode = this.clearcoatNode ? float(this.clearcoatNode) : materialClearcoat;
      const clearcoatRoughnessNode = this.clearcoatRoughnessNode ? float(this.clearcoatRoughnessNode) : materialClearcoatRoughness;
      clearcoat.assign(clearcoatNode);
      clearcoatRoughness.assign(getRoughness({ roughness: clearcoatRoughnessNode }));
    }
    if (this.useSheen) {
      const sheenNode = this.sheenNode ? vec3(this.sheenNode) : materialSheen;
      const sheenRoughnessNode = this.sheenRoughnessNode ? float(this.sheenRoughnessNode) : materialSheenRoughness;
      sheen.assign(sheenNode);
      sheenRoughness.assign(sheenRoughnessNode);
    }
    if (this.useIridescence) {
      const iridescenceNode = this.iridescenceNode ? float(this.iridescenceNode) : materialIridescence;
      const iridescenceIORNode = this.iridescenceIORNode ? float(this.iridescenceIORNode) : materialIridescenceIOR;
      const iridescenceThicknessNode = this.iridescenceThicknessNode ? float(this.iridescenceThicknessNode) : materialIridescenceThickness;
      iridescence.assign(iridescenceNode);
      iridescenceIOR.assign(iridescenceIORNode);
      iridescenceThickness.assign(iridescenceThicknessNode);
    }
    if (this.useAnisotropy) {
      const anisotropyV = (this.anisotropyNode ? vec2(this.anisotropyNode) : materialAnisotropy).toVar();
      anisotropy.assign(anisotropyV.length());
      If(anisotropy.equal(0), () => {
        anisotropyV.assign(vec2(1, 0));
      }).Else(() => {
        anisotropyV.divAssign(vec2(anisotropy));
        anisotropy.assign(anisotropy.saturate());
      });
      alphaT.assign(anisotropy.pow2().mix(roughness.pow2(), 1));
      anisotropyT.assign(TBNViewMatrix[0].mul(anisotropyV.x).add(TBNViewMatrix[1].mul(anisotropyV.y)));
      anisotropyB.assign(TBNViewMatrix[1].mul(anisotropyV.x).sub(TBNViewMatrix[0].mul(anisotropyV.y)));
    }
    if (this.useTransmission) {
      const transmissionNode = this.transmissionNode ? float(this.transmissionNode) : materialTransmission;
      const thicknessNode = this.thicknessNode ? float(this.thicknessNode) : materialThickness;
      const attenuationDistanceNode = this.attenuationDistanceNode ? float(this.attenuationDistanceNode) : materialAttenuationDistance;
      const attenuationColorNode = this.attenuationColorNode ? vec3(this.attenuationColorNode) : materialAttenuationColor;
      transmission.assign(transmissionNode);
      thickness.assign(thicknessNode);
      attenuationDistance.assign(attenuationDistanceNode);
      attenuationColor.assign(attenuationColorNode);
      if (this.useDispersion) {
        const dispersionNode = this.dispersionNode ? float(this.dispersionNode) : materialDispersion;
        dispersion.assign(dispersionNode);
      }
    }
  }
  /**
   * Setups the clearcoat normal node.
   *
   * @return {Node<vec3>} The clearcoat normal.
   */
  setupClearcoatNormal() {
    return this.clearcoatNormalNode ? vec3(this.clearcoatNormalNode) : materialClearcoatNormal;
  }
  setup(builder) {
    builder.context.setupClearcoatNormal = () => subBuild(this.setupClearcoatNormal(builder), "NORMAL", "vec3");
    super.setup(builder);
  }
  copy(source) {
    this.clearcoatNode = source.clearcoatNode;
    this.clearcoatRoughnessNode = source.clearcoatRoughnessNode;
    this.clearcoatNormalNode = source.clearcoatNormalNode;
    this.sheenNode = source.sheenNode;
    this.sheenRoughnessNode = source.sheenRoughnessNode;
    this.iridescenceNode = source.iridescenceNode;
    this.iridescenceIORNode = source.iridescenceIORNode;
    this.iridescenceThicknessNode = source.iridescenceThicknessNode;
    this.specularIntensityNode = source.specularIntensityNode;
    this.specularColorNode = source.specularColorNode;
    this.transmissionNode = source.transmissionNode;
    this.thicknessNode = source.thicknessNode;
    this.attenuationDistanceNode = source.attenuationDistanceNode;
    this.attenuationColorNode = source.attenuationColorNode;
    this.dispersionNode = source.dispersionNode;
    this.anisotropyNode = source.anisotropyNode;
    return super.copy(source);
  }
};
var getGradientIrradiance = Fn(({ normal: normal2, lightDirection, builder }) => {
  const dotNL = normal2.dot(lightDirection);
  const coord = vec2(dotNL.mul(0.5).add(0.5), 0);
  if (builder.material.gradientMap) {
    const gradientMap = materialReference("gradientMap", "texture").context({ getUV: () => coord });
    return vec3(gradientMap.r);
  } else {
    const fw = coord.fwidth().mul(0.5);
    return mix(vec3(0.7), vec3(1), smoothstep(float(0.7).sub(fw.x), float(0.7).add(fw.x), coord.x));
  }
});
var ToonLightingModel = class extends LightingModel {
  /**
   * Implements the direct lighting. Instead of using a conventional smooth irradiance, the irradiance is
   * reduced to a small number of discrete shades to create a comic-like, flat look.
   *
   * @param {Object} lightData - The light data.
   * @param {NodeBuilder} builder - The current node builder.
   */
  direct({ lightDirection, lightColor, reflectedLight }, builder) {
    const irradiance = getGradientIrradiance({ normal: normalGeometry, lightDirection, builder }).mul(lightColor);
    reflectedLight.directDiffuse.addAssign(irradiance.mul(BRDF_Lambert({ diffuseColor: diffuseColor.rgb })));
  }
  /**
   * Implements the indirect lighting.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  indirect(builder) {
    const { ambientOcclusion, irradiance, reflectedLight } = builder.context;
    reflectedLight.indirectDiffuse.addAssign(irradiance.mul(BRDF_Lambert({ diffuseColor })));
    reflectedLight.indirectDiffuse.mulAssign(ambientOcclusion);
  }
};
var _defaultValues$4 = new MeshToonMaterial();
var MeshToonNodeMaterial = class extends NodeMaterial {
  static get type() {
    return "MeshToonNodeMaterial";
  }
  /**
   * Constructs a new mesh toon node material.
   *
   * @param {Object} [parameters] - The configuration parameter.
   */
  constructor(parameters) {
    super();
    this.isMeshToonNodeMaterial = true;
    this.lights = true;
    this.setDefaultValues(_defaultValues$4);
    this.setValues(parameters);
  }
  /**
   * Setups the lighting model.
   *
   * @return {ToonLightingModel} The lighting model.
   */
  setupLightingModel() {
    return new ToonLightingModel();
  }
};
var matcapUV = Fn(() => {
  const x = vec3(positionViewDirection.z, 0, positionViewDirection.x.negate()).normalize();
  const y = positionViewDirection.cross(x);
  return vec2(x.dot(normalView), y.dot(normalView)).mul(0.495).add(0.5);
}).once(["NORMAL", "VERTEX"])().toVar("matcapUV");
var _defaultValues$3 = new MeshMatcapMaterial();
var MeshMatcapNodeMaterial = class extends NodeMaterial {
  static get type() {
    return "MeshMatcapNodeMaterial";
  }
  /**
   * Constructs a new mesh normal node material.
   *
   * @param {Object} [parameters] - The configuration parameter.
   */
  constructor(parameters) {
    super();
    this.isMeshMatcapNodeMaterial = true;
    this.setDefaultValues(_defaultValues$3);
    this.setValues(parameters);
  }
  /**
   * Setups the matcap specific node variables.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  setupVariants(builder) {
    const uv3 = matcapUV;
    let matcapColor;
    if (builder.material.matcap) {
      matcapColor = materialReference("matcap", "texture").context({ getUV: () => uv3 });
    } else {
      matcapColor = vec3(mix(0.2, 0.8, uv3.y));
    }
    diffuseColor.rgb.mulAssign(matcapColor.rgb);
  }
};
var RotateNode = class extends TempNode {
  static get type() {
    return "RotateNode";
  }
  /**
   * Constructs a new rotate node.
   *
   * @param {Node} positionNode - The position node.
   * @param {Node} rotationNode - Represents the rotation that is applied to the position node. Depending
   * on whether the position data are 2D or 3D, the rotation is expressed a single float value or an Euler value.
   */
  constructor(positionNode, rotationNode) {
    super();
    this.positionNode = positionNode;
    this.rotationNode = rotationNode;
  }
  /**
   * The type of the {@link RotateNode#positionNode} defines the node's type.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node's type.
   */
  getNodeType(builder) {
    return this.positionNode.getNodeType(builder);
  }
  setup(builder) {
    const { rotationNode, positionNode } = this;
    const nodeType = this.getNodeType(builder);
    if (nodeType === "vec2") {
      const cosAngle = rotationNode.cos();
      const sinAngle = rotationNode.sin();
      const rotationMatrix = mat2(
        cosAngle,
        sinAngle,
        sinAngle.negate(),
        cosAngle
      );
      return rotationMatrix.mul(positionNode);
    } else {
      const rotation = rotationNode;
      const rotationXMatrix = mat4(vec4(1, 0, 0, 0), vec4(0, cos3(rotation.x), sin3(rotation.x).negate(), 0), vec4(0, sin3(rotation.x), cos3(rotation.x), 0), vec4(0, 0, 0, 1));
      const rotationYMatrix = mat4(vec4(cos3(rotation.y), 0, sin3(rotation.y), 0), vec4(0, 1, 0, 0), vec4(sin3(rotation.y).negate(), 0, cos3(rotation.y), 0), vec4(0, 0, 0, 1));
      const rotationZMatrix = mat4(vec4(cos3(rotation.z), sin3(rotation.z).negate(), 0, 0), vec4(sin3(rotation.z), cos3(rotation.z), 0, 0), vec4(0, 0, 1, 0), vec4(0, 0, 0, 1));
      return rotationXMatrix.mul(rotationYMatrix).mul(rotationZMatrix).mul(vec4(positionNode, 1)).xyz;
    }
  }
};
var rotate = nodeProxy(RotateNode).setParameterLength(2);
var _defaultValues$2 = new SpriteMaterial();
var SpriteNodeMaterial = class extends NodeMaterial {
  static get type() {
    return "SpriteNodeMaterial";
  }
  /**
   * Constructs a new sprite node material.
   *
   * @param {Object} [parameters] - The configuration parameter.
   */
  constructor(parameters) {
    super();
    this.isSpriteNodeMaterial = true;
    this._useSizeAttenuation = true;
    this.positionNode = null;
    this.rotationNode = null;
    this.scaleNode = null;
    this.transparent = true;
    this.setDefaultValues(_defaultValues$2);
    this.setValues(parameters);
  }
  /**
   * Setups the position node in view space. This method implements
   * the sprite specific vertex shader.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {Node<vec3>} The position in view space.
   */
  setupPositionView(builder) {
    const { object: object2, camera } = builder;
    const { positionNode, rotationNode, scaleNode, sizeAttenuation } = this;
    const mvPosition = modelViewMatrix.mul(vec3(positionNode || 0));
    let scale3 = vec2(modelWorldMatrix[0].xyz.length(), modelWorldMatrix[1].xyz.length());
    if (scaleNode !== null) {
      scale3 = scale3.mul(vec2(scaleNode));
    }
    if (camera.isPerspectiveCamera && sizeAttenuation === false) {
      scale3 = scale3.mul(mvPosition.z.negate());
    }
    let alignedPosition = positionGeometry.xy;
    if (object2.center && object2.center.isVector2 === true) {
      const center = reference$1("center", "vec2", object2);
      alignedPosition = alignedPosition.sub(center.sub(0.5));
    }
    alignedPosition = alignedPosition.mul(scale3);
    const rotation = float(rotationNode || materialRotation);
    const rotatedPosition = rotate(alignedPosition, rotation);
    return vec4(mvPosition.xy.add(rotatedPosition), mvPosition.zw);
  }
  copy(source) {
    this.positionNode = source.positionNode;
    this.rotationNode = source.rotationNode;
    this.scaleNode = source.scaleNode;
    return super.copy(source);
  }
  /**
   * Whether to use size attenuation or not.
   *
   * @type {boolean}
   * @default true
   */
  get sizeAttenuation() {
    return this._useSizeAttenuation;
  }
  set sizeAttenuation(value) {
    if (this._useSizeAttenuation !== value) {
      this._useSizeAttenuation = value;
      this.needsUpdate = true;
    }
  }
};
var _defaultValues$1 = new PointsMaterial();
var _size$4 = new Vector2();
var PointsNodeMaterial = class extends SpriteNodeMaterial {
  static get type() {
    return "PointsNodeMaterial";
  }
  /**
   * Constructs a new points node material.
   *
   * @param {Object} [parameters] - The configuration parameter.
   */
  constructor(parameters) {
    super();
    this.sizeNode = null;
    this.isPointsNodeMaterial = true;
    this.setDefaultValues(_defaultValues$1);
    this.setValues(parameters);
  }
  setupPositionView() {
    const { positionNode } = this;
    return modelViewMatrix.mul(vec3(positionNode || positionLocal)).xyz;
  }
  setupVertexSprite(builder) {
    const { material, camera } = builder;
    const { rotationNode, scaleNode, sizeNode, sizeAttenuation } = this;
    let mvp = super.setupVertex(builder);
    if (material.isNodeMaterial !== true) {
      return mvp;
    }
    let pointSize = sizeNode !== null ? vec2(sizeNode) : materialPointSize;
    pointSize = pointSize.mul(screenDPR);
    if (camera.isPerspectiveCamera && sizeAttenuation === true) {
      pointSize = pointSize.mul(scale2.div(positionView.z.negate()));
    }
    if (scaleNode && scaleNode.isNode) {
      pointSize = pointSize.mul(vec2(scaleNode));
    }
    let offset = positionGeometry.xy;
    if (rotationNode && rotationNode.isNode) {
      const rotation = float(rotationNode);
      offset = rotate(offset, rotation);
    }
    offset = offset.mul(pointSize);
    offset = offset.div(viewportSize.div(2));
    offset = offset.mul(mvp.w);
    mvp = mvp.add(vec4(offset, 0, 0));
    return mvp;
  }
  setupVertex(builder) {
    if (builder.object.isPoints) {
      return super.setupVertex(builder);
    } else {
      return this.setupVertexSprite(builder);
    }
  }
  /**
   * Whether alpha to coverage should be used or not.
   *
   * @type {boolean}
   * @default true
   */
  get alphaToCoverage() {
    return this._useAlphaToCoverage;
  }
  set alphaToCoverage(value) {
    if (this._useAlphaToCoverage !== value) {
      this._useAlphaToCoverage = value;
      this.needsUpdate = true;
    }
  }
};
var scale2 = uniform(1).onFrameUpdate(function({ renderer }) {
  const size = renderer.getSize(_size$4);
  this.value = 0.5 * size.y;
});
var ShadowMaskModel = class extends LightingModel {
  /**
   * Constructs a new shadow mask model.
   */
  constructor() {
    super();
    this.shadowNode = float(1).toVar("shadowMask");
  }
  /**
   * Only used to save the shadow mask.
   *
   * @param {Object} input - The input data.
   */
  direct({ lightNode }) {
    if (lightNode.shadowNode !== null) {
      this.shadowNode.mulAssign(lightNode.shadowNode);
    }
  }
  /**
   * Uses the shadow mask to produce the final color.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  finish({ context: context3 }) {
    diffuseColor.a.mulAssign(this.shadowNode.oneMinus());
    context3.outgoingLight.rgb.assign(diffuseColor.rgb);
  }
};
var _defaultValues = new ShadowMaterial();
var ShadowNodeMaterial = class extends NodeMaterial {
  static get type() {
    return "ShadowNodeMaterial";
  }
  /**
   * Constructs a new shadow node material.
   *
   * @param {Object} [parameters] - The configuration parameter.
   */
  constructor(parameters) {
    super();
    this.isShadowNodeMaterial = true;
    this.lights = true;
    this.transparent = true;
    this.setDefaultValues(_defaultValues);
    this.setValues(parameters);
  }
  /**
   * Setups the lighting model.
   *
   * @return {ShadowMaskModel} The lighting model.
   */
  setupLightingModel() {
    return new ShadowMaskModel();
  }
};
var scatteringDensity = property("vec3");
var linearDepthRay = property("vec3");
var outgoingRayLight = property("vec3");
var Animation = class {
  /**
   * Constructs a new animation loop management component.
   *
   * @param {Nodes} nodes - Renderer component for managing nodes related logic.
   * @param {Info} info - Renderer component for managing metrics and monitoring data.
   */
  constructor(nodes, info) {
    this.nodes = nodes;
    this.info = info;
    this._context = typeof self !== "undefined" ? self : null;
    this._animationLoop = null;
    this._requestId = null;
  }
  /**
   * Starts the internal animation loop.
   */
  start() {
    const update18 = (time4, xrFrame) => {
      this._requestId = this._context.requestAnimationFrame(update18);
      if (this.info.autoReset === true) this.info.reset();
      this.nodes.nodeFrame.update();
      this.info.frame = this.nodes.nodeFrame.frameId;
      if (this._animationLoop !== null) this._animationLoop(time4, xrFrame);
    };
    update18();
  }
  /**
   * Stops the internal animation loop.
   */
  stop() {
    this._context.cancelAnimationFrame(this._requestId);
    this._requestId = null;
  }
  /**
   * Returns the user-level animation loop.
   *
   * @return {?Function} The animation loop.
   */
  getAnimationLoop() {
    return this._animationLoop;
  }
  /**
   * Defines the user-level animation loop.
   *
   * @param {?Function} callback - The animation loop.
   */
  setAnimationLoop(callback) {
    this._animationLoop = callback;
  }
  /**
   * Returns the animation context.
   *
   * @return {Window|XRSession} The animation context.
   */
  getContext() {
    return this._context;
  }
  /**
   * Defines the context in which `requestAnimationFrame()` is executed.
   *
   * @param {Window|XRSession} context - The context to set.
   */
  setContext(context3) {
    this._context = context3;
  }
  /**
   * Frees all internal resources and stops the animation loop.
   */
  dispose() {
    this.stop();
  }
};
var ChainMap = class {
  /**
   * Constructs a new Chain Map.
   */
  constructor() {
    this.weakMap = /* @__PURE__ */ new WeakMap();
  }
  /**
   * Returns the value for the given array of keys.
   *
   * @param {Array<Object>} keys - List of keys.
   * @return {any} The value. Returns `undefined` if no value was found.
   */
  get(keys) {
    let map4 = this.weakMap;
    for (let i = 0; i < keys.length - 1; i++) {
      map4 = map4.get(keys[i]);
      if (map4 === void 0) return void 0;
    }
    return map4.get(keys[keys.length - 1]);
  }
  /**
   * Sets the value for the given keys.
   *
   * @param {Array<Object>} keys - List of keys.
   * @param {any} value - The value to set.
   * @return {ChainMap} A reference to this Chain Map.
   */
  set(keys, value) {
    let map4 = this.weakMap;
    for (let i = 0; i < keys.length - 1; i++) {
      const key = keys[i];
      if (map4.has(key) === false) map4.set(key, /* @__PURE__ */ new WeakMap());
      map4 = map4.get(key);
    }
    map4.set(keys[keys.length - 1], value);
    return this;
  }
  /**
   * Deletes a value for the given keys.
   *
   * @param {Array<Object>} keys - The keys.
   * @return {boolean} Returns `true` if the value has been removed successfully and `false` if the value has not be found.
   */
  delete(keys) {
    let map4 = this.weakMap;
    for (let i = 0; i < keys.length - 1; i++) {
      map4 = map4.get(keys[i]);
      if (map4 === void 0) return false;
    }
    return map4.delete(keys[keys.length - 1]);
  }
};
var _id$9 = 0;
function getKeys(obj) {
  const keys = Object.keys(obj);
  let proto2 = Object.getPrototypeOf(obj);
  while (proto2) {
    const descriptors = Object.getOwnPropertyDescriptors(proto2);
    for (const key in descriptors) {
      if (descriptors[key] !== void 0) {
        const descriptor = descriptors[key];
        if (descriptor && typeof descriptor.get === "function") {
          keys.push(key);
        }
      }
    }
    proto2 = Object.getPrototypeOf(proto2);
  }
  return keys;
}
var RenderObject = class {
  /**
   * Constructs a new render object.
   *
   * @param {Nodes} nodes - Renderer component for managing nodes related logic.
   * @param {Geometries} geometries - Renderer component for managing geometries.
   * @param {Renderer} renderer - The renderer.
   * @param {Object3D} object - The 3D object.
   * @param {Material} material - The 3D object's material.
   * @param {Scene} scene - The scene the 3D object belongs to.
   * @param {Camera} camera - The camera the object should be rendered with.
   * @param {LightsNode} lightsNode - The lights node.
   * @param {RenderContext} renderContext - The render context.
   * @param {ClippingContext} clippingContext - The clipping context.
   */
  constructor(nodes, geometries, renderer, object2, material, scene, camera, lightsNode, renderContext, clippingContext) {
    this.id = _id$9++;
    this._nodes = nodes;
    this._geometries = geometries;
    this.renderer = renderer;
    this.object = object2;
    this.material = material;
    this.scene = scene;
    this.camera = camera;
    this.lightsNode = lightsNode;
    this.context = renderContext;
    this.geometry = object2.geometry;
    this.version = material.version;
    this.drawRange = null;
    this.attributes = null;
    this.attributesId = null;
    this.pipeline = null;
    this.group = null;
    this.vertexBuffers = null;
    this.drawParams = null;
    this.bundle = null;
    this.clippingContext = clippingContext;
    this.clippingContextCacheKey = clippingContext !== null ? clippingContext.cacheKey : "";
    this.initialNodesCacheKey = this.getDynamicCacheKey();
    this.initialCacheKey = this.getCacheKey();
    this._nodeBuilderState = null;
    this._bindings = null;
    this._monitor = null;
    this.onDispose = null;
    this.isRenderObject = true;
    this.onMaterialDispose = () => {
      this.dispose();
    };
    this.onGeometryDispose = () => {
      this.attributes = null;
      this.attributesId = null;
    };
    this.material.addEventListener("dispose", this.onMaterialDispose);
    this.geometry.addEventListener("dispose", this.onGeometryDispose);
  }
  /**
   * Updates the clipping context.
   *
   * @param {ClippingContext} context - The clipping context to set.
   */
  updateClipping(context3) {
    this.clippingContext = context3;
  }
  /**
   * Whether the clipping requires an update or not.
   *
   * @type {boolean}
   * @readonly
   */
  get clippingNeedsUpdate() {
    if (this.clippingContext === null || this.clippingContext.cacheKey === this.clippingContextCacheKey) return false;
    this.clippingContextCacheKey = this.clippingContext.cacheKey;
    return true;
  }
  /**
   * The number of clipping planes defined in context of hardware clipping.
   *
   * @type {number}
   * @readonly
   */
  get hardwareClippingPlanes() {
    return this.material.hardwareClipping === true ? this.clippingContext.unionClippingCount : 0;
  }
  /**
   * Returns the node builder state of this render object.
   *
   * @return {NodeBuilderState} The node builder state.
   */
  getNodeBuilderState() {
    return this._nodeBuilderState || (this._nodeBuilderState = this._nodes.getForRender(this));
  }
  /**
   * Returns the node material observer of this render object.
   *
   * @return {NodeMaterialObserver} The node material observer.
   */
  getMonitor() {
    return this._monitor || (this._monitor = this.getNodeBuilderState().observer);
  }
  /**
   * Returns an array of bind groups of this render object.
   *
   * @return {Array<BindGroup>} The bindings.
   */
  getBindings() {
    return this._bindings || (this._bindings = this.getNodeBuilderState().createBindings());
  }
  /**
   * Returns a binding group by group name of this render object.
   *
   * @param {string} name - The name of the binding group.
   * @return {?BindGroup} The bindings.
   */
  getBindingGroup(name) {
    for (const bindingGroup of this.getBindings()) {
      if (bindingGroup.name === name) {
        return bindingGroup;
      }
    }
  }
  /**
   * Returns the index of the render object's geometry.
   *
   * @return {?BufferAttribute} The index. Returns `null` for non-indexed geometries.
   */
  getIndex() {
    return this._geometries.getIndex(this);
  }
  /**
   * Returns the indirect buffer attribute.
   *
   * @return {?BufferAttribute} The indirect attribute. `null` if no indirect drawing is used.
   */
  getIndirect() {
    return this._geometries.getIndirect(this);
  }
  /**
   * Returns an array that acts as a key for identifying the render object in a chain map.
   *
   * @return {Array<Object>} An array with object references.
   */
  getChainArray() {
    return [this.object, this.material, this.context, this.lightsNode];
  }
  /**
   * This method is used when the geometry of a 3D object has been exchanged and the
   * respective render object now requires an update.
   *
   * @param {BufferGeometry} geometry - The geometry to set.
   */
  setGeometry(geometry) {
    this.geometry = geometry;
    this.attributes = null;
    this.attributesId = null;
  }
  /**
   * Returns the buffer attributes of the render object. The returned array holds
   * attribute definitions on geometry and node level.
   *
   * @return {Array<BufferAttribute>} An array with buffer attributes.
   */
  getAttributes() {
    if (this.attributes !== null) return this.attributes;
    const nodeAttributes = this.getNodeBuilderState().nodeAttributes;
    const geometry = this.geometry;
    const attributes = [];
    const vertexBuffers = /* @__PURE__ */ new Set();
    const attributesId = {};
    for (const nodeAttribute of nodeAttributes) {
      let attribute3;
      if (nodeAttribute.node && nodeAttribute.node.attribute) {
        attribute3 = nodeAttribute.node.attribute;
      } else {
        attribute3 = geometry.getAttribute(nodeAttribute.name);
        attributesId[nodeAttribute.name] = attribute3.version;
      }
      if (attribute3 === void 0) continue;
      attributes.push(attribute3);
      const bufferAttribute3 = attribute3.isInterleavedBufferAttribute ? attribute3.data : attribute3;
      vertexBuffers.add(bufferAttribute3);
    }
    this.attributes = attributes;
    this.attributesId = attributesId;
    this.vertexBuffers = Array.from(vertexBuffers.values());
    return attributes;
  }
  /**
   * Returns the vertex buffers of the render object.
   *
   * @return {Array<BufferAttribute|InterleavedBuffer>} An array with buffer attribute or interleaved buffers.
   */
  getVertexBuffers() {
    if (this.vertexBuffers === null) this.getAttributes();
    return this.vertexBuffers;
  }
  /**
   * Returns the draw parameters for the render object.
   *
   * @return {?{vertexCount: number, firstVertex: number, instanceCount: number, firstInstance: number}} The draw parameters.
   */
  getDrawParameters() {
    const { object: object2, material, geometry, group: group2, drawRange } = this;
    const drawParams = this.drawParams || (this.drawParams = {
      vertexCount: 0,
      firstVertex: 0,
      instanceCount: 0,
      firstInstance: 0
    });
    const index5 = this.getIndex();
    const hasIndex = index5 !== null;
    let instanceCount = 1;
    if (geometry.isInstancedBufferGeometry === true) {
      instanceCount = geometry.instanceCount;
    } else if (object2.count !== void 0) {
      instanceCount = Math.max(0, object2.count);
    }
    if (instanceCount === 0) return null;
    drawParams.instanceCount = instanceCount;
    if (object2.isBatchedMesh === true) return drawParams;
    let rangeFactor = 1;
    if (material.wireframe === true && !object2.isPoints && !object2.isLineSegments && !object2.isLine && !object2.isLineLoop) {
      rangeFactor = 2;
    }
    let firstVertex = drawRange.start * rangeFactor;
    let lastVertex = (drawRange.start + drawRange.count) * rangeFactor;
    if (group2 !== null) {
      firstVertex = Math.max(firstVertex, group2.start * rangeFactor);
      lastVertex = Math.min(lastVertex, (group2.start + group2.count) * rangeFactor);
    }
    const position = geometry.attributes.position;
    let itemCount = Infinity;
    if (hasIndex) {
      itemCount = index5.count;
    } else if (position !== void 0 && position !== null) {
      itemCount = position.count;
    }
    firstVertex = Math.max(firstVertex, 0);
    lastVertex = Math.min(lastVertex, itemCount);
    const count2 = lastVertex - firstVertex;
    if (count2 < 0 || count2 === Infinity) return null;
    drawParams.vertexCount = count2;
    drawParams.firstVertex = firstVertex;
    return drawParams;
  }
  /**
   * Returns the render object's geometry cache key.
   *
   * The geometry cache key is part of the material cache key.
   *
   * @return {string} The geometry cache key.
   */
  getGeometryCacheKey() {
    const { geometry } = this;
    let cacheKey = "";
    for (const name of Object.keys(geometry.attributes).sort()) {
      const attribute3 = geometry.attributes[name];
      cacheKey += name + ",";
      if (attribute3.data) cacheKey += attribute3.data.stride + ",";
      if (attribute3.offset) cacheKey += attribute3.offset + ",";
      if (attribute3.itemSize) cacheKey += attribute3.itemSize + ",";
      if (attribute3.normalized) cacheKey += "n,";
    }
    for (const name of Object.keys(geometry.morphAttributes).sort()) {
      const targets = geometry.morphAttributes[name];
      cacheKey += "morph-" + name + ",";
      for (let i = 0, l = targets.length; i < l; i++) {
        const attribute3 = targets[i];
        cacheKey += attribute3.id + ",";
      }
    }
    if (geometry.index) {
      cacheKey += "index,";
    }
    return cacheKey;
  }
  /**
   * Returns the render object's material cache key.
   *
   * The material cache key is part of the render object cache key.
   *
   * @return {number} The material cache key.
   */
  getMaterialCacheKey() {
    const { object: object2, material, renderer } = this;
    let cacheKey = material.customProgramCacheKey();
    for (const property3 of getKeys(material)) {
      if (/^(is[A-Z]|_)|^(visible|version|uuid|name|opacity|userData)$/.test(property3)) continue;
      const value = material[property3];
      let valueKey;
      if (value !== null) {
        const type = typeof value;
        if (type === "number") {
          valueKey = value !== 0 ? "1" : "0";
        } else if (type === "object") {
          valueKey = "{";
          if (value.isTexture) {
            valueKey += value.mapping;
            if (renderer.backend.isWebGPUBackend === true) {
              valueKey += value.magFilter;
              valueKey += value.minFilter;
              valueKey += value.wrapS;
              valueKey += value.wrapT;
              valueKey += value.wrapR;
            }
          }
          valueKey += "}";
        } else {
          valueKey = String(value);
        }
      } else {
        valueKey = String(value);
      }
      cacheKey += /*property + ':' +*/
      valueKey + ",";
    }
    cacheKey += this.clippingContextCacheKey + ",";
    if (object2.geometry) {
      cacheKey += this.getGeometryCacheKey();
    }
    if (object2.skeleton) {
      cacheKey += object2.skeleton.bones.length + ",";
    }
    if (object2.isBatchedMesh) {
      cacheKey += object2._matricesTexture.uuid + ",";
      if (object2._colorsTexture !== null) {
        cacheKey += object2._colorsTexture.uuid + ",";
      }
    }
    if (object2.isInstancedMesh || object2.count > 1) {
      cacheKey += object2.uuid + ",";
    }
    cacheKey += object2.receiveShadow + ",";
    return hashString(cacheKey);
  }
  /**
   * Whether the geometry requires an update or not.
   *
   * @type {boolean}
   * @readonly
   */
  get needsGeometryUpdate() {
    if (this.geometry.id !== this.object.geometry.id) return true;
    if (this.attributes !== null) {
      const attributesId = this.attributesId;
      for (const name in attributesId) {
        const attribute3 = this.geometry.getAttribute(name);
        if (attribute3 === void 0 || attributesId[name] !== attribute3.id) {
          return true;
        }
      }
    }
    return false;
  }
  /**
   * Whether the render object requires an update or not.
   *
   * Note: There are two distinct places where render objects are checked for an update.
   *
   * 1. In `RenderObjects.get()` which is executed when the render object is request. This
   * method checks the `needsUpdate` flag and recreates the render object if necessary.
   * 2. In `Renderer._renderObjectDirect()` right after getting the render object via
   * `RenderObjects.get()`. The render object's NodeMaterialObserver is then used to detect
   * a need for a refresh due to material, geometry or object related value changes.
   *
   * TODO: Investigate if it's possible to merge both steps so there is only a single place
   * that performs the 'needsUpdate' check.
   *
   * @type {boolean}
   * @readonly
   */
  get needsUpdate() {
    return (
      /*this.object.static !== true &&*/
      this.initialNodesCacheKey !== this.getDynamicCacheKey() || this.clippingNeedsUpdate
    );
  }
  /**
   * Returns the dynamic cache key which represents a key that is computed per draw command.
   *
   * @return {number} The cache key.
   */
  getDynamicCacheKey() {
    let cacheKey = 0;
    if (this.material.isShadowPassMaterial !== true) {
      cacheKey = this._nodes.getCacheKey(this.scene, this.lightsNode);
    }
    if (this.camera.isArrayCamera) {
      cacheKey = hash$1(cacheKey, this.camera.cameras.length);
    }
    if (this.object.receiveShadow) {
      cacheKey = hash$1(cacheKey, 1);
    }
    return cacheKey;
  }
  /**
   * Returns the render object's cache key.
   *
   * @return {number} The cache key.
   */
  getCacheKey() {
    return this.getMaterialCacheKey() + this.getDynamicCacheKey();
  }
  /**
   * Frees internal resources.
   */
  dispose() {
    this.material.removeEventListener("dispose", this.onMaterialDispose);
    this.geometry.removeEventListener("dispose", this.onGeometryDispose);
    this.onDispose();
  }
};
var _chainKeys$5 = [];
var RenderObjects = class {
  /**
   * Constructs a new render object management component.
   *
   * @param {Renderer} renderer - The renderer.
   * @param {Nodes} nodes - Renderer component for managing nodes related logic.
   * @param {Geometries} geometries - Renderer component for managing geometries.
   * @param {Pipelines} pipelines - Renderer component for managing pipelines.
   * @param {Bindings} bindings - Renderer component for managing bindings.
   * @param {Info} info - Renderer component for managing metrics and monitoring data.
   */
  constructor(renderer, nodes, geometries, pipelines, bindings, info) {
    this.renderer = renderer;
    this.nodes = nodes;
    this.geometries = geometries;
    this.pipelines = pipelines;
    this.bindings = bindings;
    this.info = info;
    this.chainMaps = {};
  }
  /**
   * Returns a render object for the given object and state data.
   *
   * @param {Object3D} object - The 3D object.
   * @param {Material} material - The 3D object's material.
   * @param {Scene} scene - The scene the 3D object belongs to.
   * @param {Camera} camera - The camera the 3D object should be rendered with.
   * @param {LightsNode} lightsNode - The lights node.
   * @param {RenderContext} renderContext - The render context.
   * @param {ClippingContext} clippingContext - The clipping context.
   * @param {string} [passId] - An optional ID for identifying the pass.
   * @return {RenderObject} The render object.
   */
  get(object2, material, scene, camera, lightsNode, renderContext, clippingContext, passId) {
    const chainMap = this.getChainMap(passId);
    _chainKeys$5[0] = object2;
    _chainKeys$5[1] = material;
    _chainKeys$5[2] = renderContext;
    _chainKeys$5[3] = lightsNode;
    let renderObject = chainMap.get(_chainKeys$5);
    if (renderObject === void 0) {
      renderObject = this.createRenderObject(this.nodes, this.geometries, this.renderer, object2, material, scene, camera, lightsNode, renderContext, clippingContext, passId);
      chainMap.set(_chainKeys$5, renderObject);
    } else {
      renderObject.updateClipping(clippingContext);
      if (renderObject.needsGeometryUpdate) {
        renderObject.setGeometry(object2.geometry);
      }
      if (renderObject.version !== material.version || renderObject.needsUpdate) {
        if (renderObject.initialCacheKey !== renderObject.getCacheKey()) {
          renderObject.dispose();
          renderObject = this.get(object2, material, scene, camera, lightsNode, renderContext, clippingContext, passId);
        } else {
          renderObject.version = material.version;
        }
      }
    }
    _chainKeys$5.length = 0;
    return renderObject;
  }
  /**
   * Returns a chain map for the given pass ID.
   *
   * @param {string} [passId='default'] - The pass ID.
   * @return {ChainMap} The chain map.
   */
  getChainMap(passId = "default") {
    return this.chainMaps[passId] || (this.chainMaps[passId] = new ChainMap());
  }
  /**
   * Frees internal resources.
   */
  dispose() {
    this.chainMaps = {};
  }
  /**
   * Factory method for creating render objects with the given list of parameters.
   *
   * @param {Nodes} nodes - Renderer component for managing nodes related logic.
   * @param {Geometries} geometries - Renderer component for managing geometries.
   * @param {Renderer} renderer - The renderer.
   * @param {Object3D} object - The 3D object.
   * @param {Material} material - The object's material.
   * @param {Scene} scene - The scene the 3D object belongs to.
   * @param {Camera} camera - The camera the object should be rendered with.
   * @param {LightsNode} lightsNode - The lights node.
   * @param {RenderContext} renderContext - The render context.
   * @param {ClippingContext} clippingContext - The clipping context.
   * @param {string} [passId] - An optional ID for identifying the pass.
   * @return {RenderObject} The render object.
   */
  createRenderObject(nodes, geometries, renderer, object2, material, scene, camera, lightsNode, renderContext, clippingContext, passId) {
    const chainMap = this.getChainMap(passId);
    const renderObject = new RenderObject(nodes, geometries, renderer, object2, material, scene, camera, lightsNode, renderContext, clippingContext);
    renderObject.onDispose = () => {
      this.pipelines.delete(renderObject);
      this.bindings.delete(renderObject);
      this.nodes.delete(renderObject);
      chainMap.delete(renderObject.getChainArray());
    };
    return renderObject;
  }
};
var DataMap = class {
  /**
   * Constructs a new data map.
   */
  constructor() {
    this.data = /* @__PURE__ */ new WeakMap();
  }
  /**
   * Returns the dictionary for the given object.
   *
   * @param {Object} object - The object.
   * @return {Object} The dictionary.
   */
  get(object2) {
    let map4 = this.data.get(object2);
    if (map4 === void 0) {
      map4 = {};
      this.data.set(object2, map4);
    }
    return map4;
  }
  /**
   * Deletes the dictionary for the given object.
   *
   * @param {Object} object - The object.
   * @return {?Object} The deleted dictionary.
   */
  delete(object2) {
    let map4 = null;
    if (this.data.has(object2)) {
      map4 = this.data.get(object2);
      this.data.delete(object2);
    }
    return map4;
  }
  /**
   * Returns `true` if the given object has a dictionary defined.
   *
   * @param {Object} object - The object to test.
   * @return {boolean} Whether a dictionary is defined or not.
   */
  has(object2) {
    return this.data.has(object2);
  }
  /**
   * Frees internal resources.
   */
  dispose() {
    this.data = /* @__PURE__ */ new WeakMap();
  }
};
var AttributeType = {
  VERTEX: 1,
  INDEX: 2,
  STORAGE: 3,
  INDIRECT: 4
};
var GPU_CHUNK_BYTES = 16;
var BlendColorFactor = 211;
var OneMinusBlendColorFactor = 212;
var Attributes = class extends DataMap {
  /**
   * Constructs a new attribute management component.
   *
   * @param {Backend} backend - The renderer's backend.
   */
  constructor(backend) {
    super();
    this.backend = backend;
  }
  /**
   * Deletes the data for the given attribute.
   *
   * @param {BufferAttribute} attribute - The attribute.
   * @return {?Object} The deleted attribute data.
   */
  delete(attribute3) {
    const attributeData = super.delete(attribute3);
    if (attributeData !== null) {
      this.backend.destroyAttribute(attribute3);
    }
    return attributeData;
  }
  /**
   * Updates the given attribute. This method creates attribute buffers
   * for new attributes and updates data for existing ones.
   *
   * @param {BufferAttribute} attribute - The attribute to update.
   * @param {number} type - The attribute type.
   */
  update(attribute3, type) {
    const data = this.get(attribute3);
    if (data.version === void 0) {
      if (type === AttributeType.VERTEX) {
        this.backend.createAttribute(attribute3);
      } else if (type === AttributeType.INDEX) {
        this.backend.createIndexAttribute(attribute3);
      } else if (type === AttributeType.STORAGE) {
        this.backend.createStorageAttribute(attribute3);
      } else if (type === AttributeType.INDIRECT) {
        this.backend.createIndirectStorageAttribute(attribute3);
      }
      data.version = this._getBufferAttribute(attribute3).version;
    } else {
      const bufferAttribute3 = this._getBufferAttribute(attribute3);
      if (data.version < bufferAttribute3.version || bufferAttribute3.usage === DynamicDrawUsage) {
        this.backend.updateAttribute(attribute3);
        data.version = bufferAttribute3.version;
      }
    }
  }
  /**
   * Utility method for handling interleaved buffer attributes correctly.
   * To process them, their `InterleavedBuffer` is returned.
   *
   * @param {BufferAttribute} attribute - The attribute.
   * @return {BufferAttribute|InterleavedBuffer}
   */
  _getBufferAttribute(attribute3) {
    if (attribute3.isInterleavedBufferAttribute) attribute3 = attribute3.data;
    return attribute3;
  }
};
function getWireframeVersion(geometry) {
  return geometry.index !== null ? geometry.index.version : geometry.attributes.position.version;
}
function getWireframeIndex(geometry) {
  const indices = [];
  const geometryIndex = geometry.index;
  const geometryPosition = geometry.attributes.position;
  if (geometryIndex !== null) {
    const array4 = geometryIndex.array;
    for (let i = 0, l = array4.length; i < l; i += 3) {
      const a = array4[i + 0];
      const b = array4[i + 1];
      const c3 = array4[i + 2];
      indices.push(a, b, b, c3, c3, a);
    }
  } else {
    const array4 = geometryPosition.array;
    for (let i = 0, l = array4.length / 3 - 1; i < l; i += 3) {
      const a = i + 0;
      const b = i + 1;
      const c3 = i + 2;
      indices.push(a, b, b, c3, c3, a);
    }
  }
  const attribute3 = new (arrayNeedsUint32(indices) ? Uint32BufferAttribute : Uint16BufferAttribute)(indices, 1);
  attribute3.version = getWireframeVersion(geometry);
  return attribute3;
}
var Geometries = class extends DataMap {
  /**
   * Constructs a new geometry management component.
   *
   * @param {Attributes} attributes - Renderer component for managing attributes.
   * @param {Info} info - Renderer component for managing metrics and monitoring data.
   */
  constructor(attributes, info) {
    super();
    this.attributes = attributes;
    this.info = info;
    this.wireframes = /* @__PURE__ */ new WeakMap();
    this.attributeCall = /* @__PURE__ */ new WeakMap();
  }
  /**
   * Returns `true` if the given render object has an initialized geometry.
   *
   * @param {RenderObject} renderObject - The render object.
   * @return {boolean} Whether if the given render object has an initialized geometry or not.
   */
  has(renderObject) {
    const geometry = renderObject.geometry;
    return super.has(geometry) && this.get(geometry).initialized === true;
  }
  /**
   * Prepares the geometry of the given render object for rendering.
   *
   * @param {RenderObject} renderObject - The render object.
   */
  updateForRender(renderObject) {
    if (this.has(renderObject) === false) this.initGeometry(renderObject);
    this.updateAttributes(renderObject);
  }
  /**
   * Initializes the geometry of the given render object.
   *
   * @param {RenderObject} renderObject - The render object.
   */
  initGeometry(renderObject) {
    const geometry = renderObject.geometry;
    const geometryData = this.get(geometry);
    geometryData.initialized = true;
    this.info.memory.geometries++;
    const onDispose = () => {
      this.info.memory.geometries--;
      const index5 = geometry.index;
      const geometryAttributes = renderObject.getAttributes();
      if (index5 !== null) {
        this.attributes.delete(index5);
      }
      for (const geometryAttribute of geometryAttributes) {
        this.attributes.delete(geometryAttribute);
      }
      const wireframeAttribute = this.wireframes.get(geometry);
      if (wireframeAttribute !== void 0) {
        this.attributes.delete(wireframeAttribute);
      }
      geometry.removeEventListener("dispose", onDispose);
    };
    geometry.addEventListener("dispose", onDispose);
  }
  /**
   * Updates the geometry attributes of the given render object.
   *
   * @param {RenderObject} renderObject - The render object.
   */
  updateAttributes(renderObject) {
    const attributes = renderObject.getAttributes();
    for (const attribute3 of attributes) {
      if (attribute3.isStorageBufferAttribute || attribute3.isStorageInstancedBufferAttribute) {
        this.updateAttribute(attribute3, AttributeType.STORAGE);
      } else {
        this.updateAttribute(attribute3, AttributeType.VERTEX);
      }
    }
    const index5 = this.getIndex(renderObject);
    if (index5 !== null) {
      this.updateAttribute(index5, AttributeType.INDEX);
    }
    const indirect = renderObject.geometry.indirect;
    if (indirect !== null) {
      this.updateAttribute(indirect, AttributeType.INDIRECT);
    }
  }
  /**
   * Updates the given attribute.
   *
   * @param {BufferAttribute} attribute - The attribute to update.
   * @param {number} type - The attribute type.
   */
  updateAttribute(attribute3, type) {
    const callId = this.info.render.calls;
    if (!attribute3.isInterleavedBufferAttribute) {
      if (this.attributeCall.get(attribute3) !== callId) {
        this.attributes.update(attribute3, type);
        this.attributeCall.set(attribute3, callId);
      }
    } else {
      if (this.attributeCall.get(attribute3) === void 0) {
        this.attributes.update(attribute3, type);
        this.attributeCall.set(attribute3, callId);
      } else if (this.attributeCall.get(attribute3.data) !== callId) {
        this.attributes.update(attribute3, type);
        this.attributeCall.set(attribute3.data, callId);
        this.attributeCall.set(attribute3, callId);
      }
    }
  }
  /**
   * Returns the indirect buffer attribute of the given render object.
   *
   * @param {RenderObject} renderObject - The render object.
   * @return {?BufferAttribute} The indirect attribute. `null` if no indirect drawing is used.
   */
  getIndirect(renderObject) {
    return renderObject.geometry.indirect;
  }
  /**
   * Returns the index of the given render object's geometry. This is implemented
   * in a method to return a wireframe index if necessary.
   *
   * @param {RenderObject} renderObject - The render object.
   * @return {?BufferAttribute} The index. Returns `null` for non-indexed geometries.
   */
  getIndex(renderObject) {
    const { geometry, material } = renderObject;
    let index5 = geometry.index;
    if (material.wireframe === true) {
      const wireframes = this.wireframes;
      let wireframeAttribute = wireframes.get(geometry);
      if (wireframeAttribute === void 0) {
        wireframeAttribute = getWireframeIndex(geometry);
        wireframes.set(geometry, wireframeAttribute);
      } else if (wireframeAttribute.version !== getWireframeVersion(geometry)) {
        this.attributes.delete(wireframeAttribute);
        wireframeAttribute = getWireframeIndex(geometry);
        wireframes.set(geometry, wireframeAttribute);
      }
      index5 = wireframeAttribute;
    }
    return index5;
  }
};
var Info = class {
  /**
   * Constructs a new info component.
   */
  constructor() {
    this.autoReset = true;
    this.frame = 0;
    this.calls = 0;
    this.render = {
      calls: 0,
      frameCalls: 0,
      drawCalls: 0,
      triangles: 0,
      points: 0,
      lines: 0,
      timestamp: 0
    };
    this.compute = {
      calls: 0,
      frameCalls: 0,
      timestamp: 0
    };
    this.memory = {
      geometries: 0,
      textures: 0
    };
  }
  /**
   * This method should be executed per draw call and updates the corresponding metrics.
   *
   * @param {Object3D} object - The 3D object that is going to be rendered.
   * @param {number} count - The vertex or index count.
   * @param {number} instanceCount - The instance count.
   */
  update(object2, count2, instanceCount) {
    this.render.drawCalls++;
    if (object2.isMesh || object2.isSprite) {
      this.render.triangles += instanceCount * (count2 / 3);
    } else if (object2.isPoints) {
      this.render.points += instanceCount * count2;
    } else if (object2.isLineSegments) {
      this.render.lines += instanceCount * (count2 / 2);
    } else if (object2.isLine) {
      this.render.lines += instanceCount * (count2 - 1);
    } else {
      console.error("THREE.WebGPUInfo: Unknown object type.");
    }
  }
  /**
   * Resets frame related metrics.
   */
  reset() {
    this.render.drawCalls = 0;
    this.render.frameCalls = 0;
    this.compute.frameCalls = 0;
    this.render.triangles = 0;
    this.render.points = 0;
    this.render.lines = 0;
  }
  /**
   * Performs a complete reset of the object.
   */
  dispose() {
    this.reset();
    this.calls = 0;
    this.render.calls = 0;
    this.compute.calls = 0;
    this.render.timestamp = 0;
    this.compute.timestamp = 0;
    this.memory.geometries = 0;
    this.memory.textures = 0;
  }
};
var Pipeline = class {
  /**
   * Constructs a new pipeline.
   *
   * @param {string} cacheKey - The pipeline's cache key.
   */
  constructor(cacheKey) {
    this.cacheKey = cacheKey;
    this.usedTimes = 0;
  }
};
var RenderPipeline = class extends Pipeline {
  /**
   * Constructs a new render pipeline.
   *
   * @param {string} cacheKey - The pipeline's cache key.
   * @param {ProgrammableStage} vertexProgram - The pipeline's vertex shader.
   * @param {ProgrammableStage} fragmentProgram - The pipeline's fragment shader.
   */
  constructor(cacheKey, vertexProgram, fragmentProgram) {
    super(cacheKey);
    this.vertexProgram = vertexProgram;
    this.fragmentProgram = fragmentProgram;
  }
};
var ComputePipeline = class extends Pipeline {
  /**
   * Constructs a new render pipeline.
   *
   * @param {string} cacheKey - The pipeline's cache key.
   * @param {ProgrammableStage} computeProgram - The pipeline's compute shader.
   */
  constructor(cacheKey, computeProgram) {
    super(cacheKey);
    this.computeProgram = computeProgram;
    this.isComputePipeline = true;
  }
};
var _id$8 = 0;
var ProgrammableStage = class {
  /**
   * Constructs a new programmable stage.
   *
   * @param {string} code - The shader code.
   * @param {('vertex'|'fragment'|'compute')} stage - The type of stage.
   * @param {string} name - The name of the shader.
   * @param {?Array<Object>} [transforms=null] - The transforms (only relevant for compute stages with WebGL 2 which uses Transform Feedback).
   * @param {?Array<Object>} [attributes=null] - The attributes (only relevant for compute stages with WebGL 2 which uses Transform Feedback).
   */
  constructor(code3, stage, name, transforms = null, attributes = null) {
    this.id = _id$8++;
    this.code = code3;
    this.stage = stage;
    this.name = name;
    this.transforms = transforms;
    this.attributes = attributes;
    this.usedTimes = 0;
  }
};
var Pipelines = class extends DataMap {
  /**
   * Constructs a new pipeline management component.
   *
   * @param {Backend} backend - The renderer's backend.
   * @param {Nodes} nodes - Renderer component for managing nodes related logic.
   */
  constructor(backend, nodes) {
    super();
    this.backend = backend;
    this.nodes = nodes;
    this.bindings = null;
    this.caches = /* @__PURE__ */ new Map();
    this.programs = {
      vertex: /* @__PURE__ */ new Map(),
      fragment: /* @__PURE__ */ new Map(),
      compute: /* @__PURE__ */ new Map()
    };
  }
  /**
   * Returns a compute pipeline for the given compute node.
   *
   * @param {Node} computeNode - The compute node.
   * @param {Array<BindGroup>} bindings - The bindings.
   * @return {ComputePipeline} The compute pipeline.
   */
  getForCompute(computeNode, bindings) {
    const { backend } = this;
    const data = this.get(computeNode);
    if (this._needsComputeUpdate(computeNode)) {
      const previousPipeline = data.pipeline;
      if (previousPipeline) {
        previousPipeline.usedTimes--;
        previousPipeline.computeProgram.usedTimes--;
      }
      const nodeBuilderState = this.nodes.getForCompute(computeNode);
      let stageCompute = this.programs.compute.get(nodeBuilderState.computeShader);
      if (stageCompute === void 0) {
        if (previousPipeline && previousPipeline.computeProgram.usedTimes === 0) this._releaseProgram(previousPipeline.computeProgram);
        stageCompute = new ProgrammableStage(nodeBuilderState.computeShader, "compute", computeNode.name, nodeBuilderState.transforms, nodeBuilderState.nodeAttributes);
        this.programs.compute.set(nodeBuilderState.computeShader, stageCompute);
        backend.createProgram(stageCompute);
      }
      const cacheKey = this._getComputeCacheKey(computeNode, stageCompute);
      let pipeline = this.caches.get(cacheKey);
      if (pipeline === void 0) {
        if (previousPipeline && previousPipeline.usedTimes === 0) this._releasePipeline(previousPipeline);
        pipeline = this._getComputePipeline(computeNode, stageCompute, cacheKey, bindings);
      }
      pipeline.usedTimes++;
      stageCompute.usedTimes++;
      data.version = computeNode.version;
      data.pipeline = pipeline;
    }
    return data.pipeline;
  }
  /**
   * Returns a render pipeline for the given render object.
   *
   * @param {RenderObject} renderObject - The render object.
   * @param {?Array<Promise>} [promises=null] - An array of compilation promises which is only relevant in context of `Renderer.compileAsync()`.
   * @return {RenderPipeline} The render pipeline.
   */
  getForRender(renderObject, promises = null) {
    const { backend } = this;
    const data = this.get(renderObject);
    if (this._needsRenderUpdate(renderObject)) {
      const previousPipeline = data.pipeline;
      if (previousPipeline) {
        previousPipeline.usedTimes--;
        previousPipeline.vertexProgram.usedTimes--;
        previousPipeline.fragmentProgram.usedTimes--;
      }
      const nodeBuilderState = renderObject.getNodeBuilderState();
      const name = renderObject.material ? renderObject.material.name : "";
      let stageVertex = this.programs.vertex.get(nodeBuilderState.vertexShader);
      if (stageVertex === void 0) {
        if (previousPipeline && previousPipeline.vertexProgram.usedTimes === 0) this._releaseProgram(previousPipeline.vertexProgram);
        stageVertex = new ProgrammableStage(nodeBuilderState.vertexShader, "vertex", name);
        this.programs.vertex.set(nodeBuilderState.vertexShader, stageVertex);
        backend.createProgram(stageVertex);
      }
      let stageFragment = this.programs.fragment.get(nodeBuilderState.fragmentShader);
      if (stageFragment === void 0) {
        if (previousPipeline && previousPipeline.fragmentProgram.usedTimes === 0) this._releaseProgram(previousPipeline.fragmentProgram);
        stageFragment = new ProgrammableStage(nodeBuilderState.fragmentShader, "fragment", name);
        this.programs.fragment.set(nodeBuilderState.fragmentShader, stageFragment);
        backend.createProgram(stageFragment);
      }
      const cacheKey = this._getRenderCacheKey(renderObject, stageVertex, stageFragment);
      let pipeline = this.caches.get(cacheKey);
      if (pipeline === void 0) {
        if (previousPipeline && previousPipeline.usedTimes === 0) this._releasePipeline(previousPipeline);
        pipeline = this._getRenderPipeline(renderObject, stageVertex, stageFragment, cacheKey, promises);
      } else {
        renderObject.pipeline = pipeline;
      }
      pipeline.usedTimes++;
      stageVertex.usedTimes++;
      stageFragment.usedTimes++;
      data.pipeline = pipeline;
    }
    return data.pipeline;
  }
  /**
   * Deletes the pipeline for the given render object.
   *
   * @param {RenderObject} object - The render object.
   * @return {?Object} The deleted dictionary.
   */
  delete(object2) {
    const pipeline = this.get(object2).pipeline;
    if (pipeline) {
      pipeline.usedTimes--;
      if (pipeline.usedTimes === 0) this._releasePipeline(pipeline);
      if (pipeline.isComputePipeline) {
        pipeline.computeProgram.usedTimes--;
        if (pipeline.computeProgram.usedTimes === 0) this._releaseProgram(pipeline.computeProgram);
      } else {
        pipeline.fragmentProgram.usedTimes--;
        pipeline.vertexProgram.usedTimes--;
        if (pipeline.vertexProgram.usedTimes === 0) this._releaseProgram(pipeline.vertexProgram);
        if (pipeline.fragmentProgram.usedTimes === 0) this._releaseProgram(pipeline.fragmentProgram);
      }
    }
    return super.delete(object2);
  }
  /**
   * Frees internal resources.
   */
  dispose() {
    super.dispose();
    this.caches = /* @__PURE__ */ new Map();
    this.programs = {
      vertex: /* @__PURE__ */ new Map(),
      fragment: /* @__PURE__ */ new Map(),
      compute: /* @__PURE__ */ new Map()
    };
  }
  /**
   * Updates the pipeline for the given render object.
   *
   * @param {RenderObject} renderObject - The render object.
   */
  updateForRender(renderObject) {
    this.getForRender(renderObject);
  }
  /**
   * Returns a compute pipeline for the given parameters.
   *
   * @private
   * @param {Node} computeNode - The compute node.
   * @param {ProgrammableStage} stageCompute - The programmable stage representing the compute shader.
   * @param {string} cacheKey - The cache key.
   * @param {Array<BindGroup>} bindings - The bindings.
   * @return {ComputePipeline} The compute pipeline.
   */
  _getComputePipeline(computeNode, stageCompute, cacheKey, bindings) {
    cacheKey = cacheKey || this._getComputeCacheKey(computeNode, stageCompute);
    let pipeline = this.caches.get(cacheKey);
    if (pipeline === void 0) {
      pipeline = new ComputePipeline(cacheKey, stageCompute);
      this.caches.set(cacheKey, pipeline);
      this.backend.createComputePipeline(pipeline, bindings);
    }
    return pipeline;
  }
  /**
   * Returns a render pipeline for the given parameters.
   *
   * @private
   * @param {RenderObject} renderObject - The render object.
   * @param {ProgrammableStage} stageVertex - The programmable stage representing the vertex shader.
   * @param {ProgrammableStage} stageFragment - The programmable stage representing the fragment shader.
   * @param {string} cacheKey - The cache key.
   * @param {?Array<Promise>} promises - An array of compilation promises which is only relevant in context of `Renderer.compileAsync()`.
   * @return {ComputePipeline} The compute pipeline.
   */
  _getRenderPipeline(renderObject, stageVertex, stageFragment, cacheKey, promises) {
    cacheKey = cacheKey || this._getRenderCacheKey(renderObject, stageVertex, stageFragment);
    let pipeline = this.caches.get(cacheKey);
    if (pipeline === void 0) {
      pipeline = new RenderPipeline(cacheKey, stageVertex, stageFragment);
      this.caches.set(cacheKey, pipeline);
      renderObject.pipeline = pipeline;
      this.backend.createRenderPipeline(renderObject, promises);
    }
    return pipeline;
  }
  /**
   * Computes a cache key representing a compute pipeline.
   *
   * @private
   * @param {Node} computeNode - The compute node.
   * @param {ProgrammableStage} stageCompute - The programmable stage representing the compute shader.
   * @return {string} The cache key.
   */
  _getComputeCacheKey(computeNode, stageCompute) {
    return computeNode.id + "," + stageCompute.id;
  }
  /**
   * Computes a cache key representing a render pipeline.
   *
   * @private
   * @param {RenderObject} renderObject - The render object.
   * @param {ProgrammableStage} stageVertex - The programmable stage representing the vertex shader.
   * @param {ProgrammableStage} stageFragment - The programmable stage representing the fragment shader.
   * @return {string} The cache key.
   */
  _getRenderCacheKey(renderObject, stageVertex, stageFragment) {
    return stageVertex.id + "," + stageFragment.id + "," + this.backend.getRenderCacheKey(renderObject);
  }
  /**
   * Releases the given pipeline.
   *
   * @private
   * @param {Pipeline} pipeline - The pipeline to release.
   */
  _releasePipeline(pipeline) {
    this.caches.delete(pipeline.cacheKey);
  }
  /**
   * Releases the shader program.
   *
   * @private
   * @param {Object} program - The shader program to release.
   */
  _releaseProgram(program) {
    const code3 = program.code;
    const stage = program.stage;
    this.programs[stage].delete(code3);
  }
  /**
   * Returns `true` if the compute pipeline for the given compute node requires an update.
   *
   * @private
   * @param {Node} computeNode - The compute node.
   * @return {boolean} Whether the compute pipeline for the given compute node requires an update or not.
   */
  _needsComputeUpdate(computeNode) {
    const data = this.get(computeNode);
    return data.pipeline === void 0 || data.version !== computeNode.version;
  }
  /**
   * Returns `true` if the render pipeline for the given render object requires an update.
   *
   * @private
   * @param {RenderObject} renderObject - The render object.
   * @return {boolean} Whether the render object for the given render object requires an update or not.
   */
  _needsRenderUpdate(renderObject) {
    const data = this.get(renderObject);
    return data.pipeline === void 0 || this.backend.needsRenderUpdate(renderObject);
  }
};
var Bindings = class extends DataMap {
  /**
   * Constructs a new bindings management component.
   *
   * @param {Backend} backend - The renderer's backend.
   * @param {Nodes} nodes - Renderer component for managing nodes related logic.
   * @param {Textures} textures - Renderer component for managing textures.
   * @param {Attributes} attributes - Renderer component for managing attributes.
   * @param {Pipelines} pipelines - Renderer component for managing pipelines.
   * @param {Info} info - Renderer component for managing metrics and monitoring data.
   */
  constructor(backend, nodes, textures, attributes, pipelines, info) {
    super();
    this.backend = backend;
    this.textures = textures;
    this.pipelines = pipelines;
    this.attributes = attributes;
    this.nodes = nodes;
    this.info = info;
    this.pipelines.bindings = this;
  }
  /**
   * Returns the bind groups for the given render object.
   *
   * @param {RenderObject} renderObject - The render object.
   * @return {Array<BindGroup>} The bind groups.
   */
  getForRender(renderObject) {
    const bindings = renderObject.getBindings();
    for (const bindGroup of bindings) {
      const groupData = this.get(bindGroup);
      if (groupData.bindGroup === void 0) {
        this._init(bindGroup);
        this.backend.createBindings(bindGroup, bindings, 0);
        groupData.bindGroup = bindGroup;
      }
    }
    return bindings;
  }
  /**
   * Returns the bind groups for the given compute node.
   *
   * @param {Node} computeNode - The compute node.
   * @return {Array<BindGroup>} The bind groups.
   */
  getForCompute(computeNode) {
    const bindings = this.nodes.getForCompute(computeNode).bindings;
    for (const bindGroup of bindings) {
      const groupData = this.get(bindGroup);
      if (groupData.bindGroup === void 0) {
        this._init(bindGroup);
        this.backend.createBindings(bindGroup, bindings, 0);
        groupData.bindGroup = bindGroup;
      }
    }
    return bindings;
  }
  /**
   * Updates the bindings for the given compute node.
   *
   * @param {Node} computeNode - The compute node.
   */
  updateForCompute(computeNode) {
    this._updateBindings(this.getForCompute(computeNode));
  }
  /**
   * Updates the bindings for the given render object.
   *
   * @param {RenderObject} renderObject - The render object.
   */
  updateForRender(renderObject) {
    this._updateBindings(this.getForRender(renderObject));
  }
  /**
   * Updates the given array of bindings.
   *
   * @param {Array<BindGroup>} bindings - The bind groups.
   */
  _updateBindings(bindings) {
    for (const bindGroup of bindings) {
      this._update(bindGroup, bindings);
    }
  }
  /**
   * Initializes the given bind group.
   *
   * @param {BindGroup} bindGroup - The bind group to initialize.
   */
  _init(bindGroup) {
    for (const binding of bindGroup.bindings) {
      if (binding.isSampledTexture) {
        this.textures.updateTexture(binding.texture);
      } else if (binding.isStorageBuffer) {
        const attribute3 = binding.attribute;
        const attributeType = attribute3.isIndirectStorageBufferAttribute ? AttributeType.INDIRECT : AttributeType.STORAGE;
        this.attributes.update(attribute3, attributeType);
      }
    }
  }
  /**
   * Updates the given bind group.
   *
   * @param {BindGroup} bindGroup - The bind group to update.
   * @param {Array<BindGroup>} bindings - The bind groups.
   */
  _update(bindGroup, bindings) {
    const { backend } = this;
    let needsBindingsUpdate = false;
    let cacheBindings = true;
    let cacheIndex = 0;
    let version = 0;
    for (const binding of bindGroup.bindings) {
      if (binding.isNodeUniformsGroup) {
        const updated = this.nodes.updateGroup(binding);
        if (updated === false) continue;
      }
      if (binding.isStorageBuffer) {
        const attribute3 = binding.attribute;
        const attributeType = attribute3.isIndirectStorageBufferAttribute ? AttributeType.INDIRECT : AttributeType.STORAGE;
        this.attributes.update(attribute3, attributeType);
      }
      if (binding.isUniformBuffer) {
        const updated = binding.update();
        if (updated) {
          backend.updateBinding(binding);
        }
      } else if (binding.isSampledTexture) {
        const updated = binding.update();
        const texture3 = binding.texture;
        const texturesTextureData = this.textures.get(texture3);
        if (updated) {
          this.textures.updateTexture(texture3);
          if (binding.generation !== texturesTextureData.generation) {
            binding.generation = texturesTextureData.generation;
            needsBindingsUpdate = true;
            cacheBindings = false;
          }
        }
        const textureData = backend.get(texture3);
        if (textureData.externalTexture !== void 0 || texturesTextureData.isDefaultTexture) {
          cacheBindings = false;
        } else {
          cacheIndex = cacheIndex * 10 + texture3.id;
          version += texture3.version;
        }
        if (texture3.isStorageTexture === true) {
          const textureData2 = this.get(texture3);
          if (binding.store === true) {
            textureData2.needsMipmap = true;
          } else if (this.textures.needsMipmaps(texture3) && textureData2.needsMipmap === true) {
            this.backend.generateMipmaps(texture3);
            textureData2.needsMipmap = false;
          }
        }
      } else if (binding.isSampler) {
        binding.update();
      }
    }
    if (needsBindingsUpdate === true) {
      this.backend.updateBindings(bindGroup, bindings, cacheBindings ? cacheIndex : 0, version);
    }
  }
};
function painterSortStable(a, b) {
  if (a.groupOrder !== b.groupOrder) {
    return a.groupOrder - b.groupOrder;
  } else if (a.renderOrder !== b.renderOrder) {
    return a.renderOrder - b.renderOrder;
  } else if (a.z !== b.z) {
    return a.z - b.z;
  } else {
    return a.id - b.id;
  }
}
function reversePainterSortStable(a, b) {
  if (a.groupOrder !== b.groupOrder) {
    return a.groupOrder - b.groupOrder;
  } else if (a.renderOrder !== b.renderOrder) {
    return a.renderOrder - b.renderOrder;
  } else if (a.z !== b.z) {
    return b.z - a.z;
  } else {
    return a.id - b.id;
  }
}
function needsDoublePass(material) {
  const hasTransmission = material.transmission > 0 || material.transmissionNode;
  return hasTransmission && material.side === DoubleSide && material.forceSinglePass === false;
}
var RenderList = class {
  /**
   * Constructs a render list.
   *
   * @param {Lighting} lighting - The lighting management component.
   * @param {Scene} scene - The scene.
   * @param {Camera} camera - The camera the scene is rendered with.
   */
  constructor(lighting, scene, camera) {
    this.renderItems = [];
    this.renderItemsIndex = 0;
    this.opaque = [];
    this.transparentDoublePass = [];
    this.transparent = [];
    this.bundles = [];
    this.lightsNode = lighting.getNode(scene, camera);
    this.lightsArray = [];
    this.scene = scene;
    this.camera = camera;
    this.occlusionQueryCount = 0;
  }
  /**
   * This method is called right at the beginning of a render call
   * before the scene is analyzed. It prepares the internal data
   * structures for the upcoming render lists generation.
   *
   * @return {RenderList} A reference to this render list.
   */
  begin() {
    this.renderItemsIndex = 0;
    this.opaque.length = 0;
    this.transparentDoublePass.length = 0;
    this.transparent.length = 0;
    this.bundles.length = 0;
    this.lightsArray.length = 0;
    this.occlusionQueryCount = 0;
    return this;
  }
  /**
   * Returns a render item for the giving render item state. The state is defined
   * by a series of object-related parameters.
   *
   * The method avoids object creation by holding render items and reusing them in
   * subsequent render calls (just with different property values).
   *
   * @param {Object3D} object - The 3D object.
   * @param {BufferGeometry} geometry - The 3D object's geometry.
   * @param {Material} material - The 3D object's material.
   * @param {number} groupOrder - The current group order.
   * @param {number} z - Th 3D object's depth value (z value in clip space).
   * @param {?number} group - {?Object} group - Only relevant for objects using multiple materials. This represents a group entry from the respective `BufferGeometry`.
   * @param {ClippingContext} clippingContext - The current clipping context.
   * @return {Object} The render item.
   */
  getNextRenderItem(object2, geometry, material, groupOrder, z, group2, clippingContext) {
    let renderItem = this.renderItems[this.renderItemsIndex];
    if (renderItem === void 0) {
      renderItem = {
        id: object2.id,
        object: object2,
        geometry,
        material,
        groupOrder,
        renderOrder: object2.renderOrder,
        z,
        group: group2,
        clippingContext
      };
      this.renderItems[this.renderItemsIndex] = renderItem;
    } else {
      renderItem.id = object2.id;
      renderItem.object = object2;
      renderItem.geometry = geometry;
      renderItem.material = material;
      renderItem.groupOrder = groupOrder;
      renderItem.renderOrder = object2.renderOrder;
      renderItem.z = z;
      renderItem.group = group2;
      renderItem.clippingContext = clippingContext;
    }
    this.renderItemsIndex++;
    return renderItem;
  }
  /**
   * Pushes the given object as a render item to the internal render lists.
   * The selected lists depend on the object properties.
   *
   * @param {Object3D} object - The 3D object.
   * @param {BufferGeometry} geometry - The 3D object's geometry.
   * @param {Material} material - The 3D object's material.
   * @param {number} groupOrder - The current group order.
   * @param {number} z - Th 3D object's depth value (z value in clip space).
   * @param {?number} group - {?Object} group - Only relevant for objects using multiple materials. This represents a group entry from the respective `BufferGeometry`.
   * @param {ClippingContext} clippingContext - The current clipping context.
   */
  push(object2, geometry, material, groupOrder, z, group2, clippingContext) {
    const renderItem = this.getNextRenderItem(object2, geometry, material, groupOrder, z, group2, clippingContext);
    if (object2.occlusionTest === true) this.occlusionQueryCount++;
    if (material.transparent === true || material.transmission > 0) {
      if (needsDoublePass(material)) this.transparentDoublePass.push(renderItem);
      this.transparent.push(renderItem);
    } else {
      this.opaque.push(renderItem);
    }
  }
  /**
   * Inserts the given object as a render item at the start of the internal render lists.
   * The selected lists depend on the object properties.
   *
   * @param {Object3D} object - The 3D object.
   * @param {BufferGeometry} geometry - The 3D object's geometry.
   * @param {Material} material - The 3D object's material.
   * @param {number} groupOrder - The current group order.
   * @param {number} z - Th 3D object's depth value (z value in clip space).
   * @param {?number} group - {?Object} group - Only relevant for objects using multiple materials. This represents a group entry from the respective `BufferGeometry`.
   * @param {ClippingContext} clippingContext - The current clipping context.
   */
  unshift(object2, geometry, material, groupOrder, z, group2, clippingContext) {
    const renderItem = this.getNextRenderItem(object2, geometry, material, groupOrder, z, group2, clippingContext);
    if (material.transparent === true || material.transmission > 0) {
      if (needsDoublePass(material)) this.transparentDoublePass.unshift(renderItem);
      this.transparent.unshift(renderItem);
    } else {
      this.opaque.unshift(renderItem);
    }
  }
  /**
   * Pushes render bundle group data into the render list.
   *
   * @param {Object} group - Bundle group data.
   */
  pushBundle(group2) {
    this.bundles.push(group2);
  }
  /**
   * Pushes a light into the render list.
   *
   * @param {Light} light - The light.
   */
  pushLight(light) {
    this.lightsArray.push(light);
  }
  /**
   * Sorts the internal render lists.
   *
   * @param {?function(any, any): number} customOpaqueSort - A custom sort function for opaque objects.
   * @param {?function(any, any): number} customTransparentSort -  A custom sort function for transparent objects.
   */
  sort(customOpaqueSort, customTransparentSort) {
    if (this.opaque.length > 1) this.opaque.sort(customOpaqueSort || painterSortStable);
    if (this.transparentDoublePass.length > 1) this.transparentDoublePass.sort(customTransparentSort || reversePainterSortStable);
    if (this.transparent.length > 1) this.transparent.sort(customTransparentSort || reversePainterSortStable);
  }
  /**
   * This method performs finalizing tasks right after the render lists
   * have been generated.
   */
  finish() {
    this.lightsNode.setLights(this.lightsArray);
    for (let i = this.renderItemsIndex, il = this.renderItems.length; i < il; i++) {
      const renderItem = this.renderItems[i];
      if (renderItem.id === null) break;
      renderItem.id = null;
      renderItem.object = null;
      renderItem.geometry = null;
      renderItem.material = null;
      renderItem.groupOrder = null;
      renderItem.renderOrder = null;
      renderItem.z = null;
      renderItem.group = null;
      renderItem.clippingContext = null;
    }
  }
};
var _chainKeys$4 = [];
var RenderLists = class {
  /**
   * Constructs a render lists management component.
   *
   * @param {Lighting} lighting - The lighting management component.
   */
  constructor(lighting) {
    this.lighting = lighting;
    this.lists = new ChainMap();
  }
  /**
   * Returns a render list for the given scene and camera.
   *
   * @param {Scene} scene - The scene.
   * @param {Camera} camera - The camera.
   * @return {RenderList} The render list.
   */
  get(scene, camera) {
    const lists = this.lists;
    _chainKeys$4[0] = scene;
    _chainKeys$4[1] = camera;
    let list = lists.get(_chainKeys$4);
    if (list === void 0) {
      list = new RenderList(this.lighting, scene, camera);
      lists.set(_chainKeys$4, list);
    }
    _chainKeys$4.length = 0;
    return list;
  }
  /**
   * Frees all internal resources.
   */
  dispose() {
    this.lists = new ChainMap();
  }
};
var _id$7 = 0;
var RenderContext = class {
  /**
   * Constructs a new render context.
   */
  constructor() {
    this.id = _id$7++;
    this.color = true;
    this.clearColor = true;
    this.clearColorValue = { r: 0, g: 0, b: 0, a: 1 };
    this.depth = true;
    this.clearDepth = true;
    this.clearDepthValue = 1;
    this.stencil = false;
    this.clearStencil = true;
    this.clearStencilValue = 1;
    this.viewport = false;
    this.viewportValue = new Vector4();
    this.scissor = false;
    this.scissorValue = new Vector4();
    this.renderTarget = null;
    this.textures = null;
    this.depthTexture = null;
    this.activeCubeFace = 0;
    this.activeMipmapLevel = 0;
    this.sampleCount = 1;
    this.width = 0;
    this.height = 0;
    this.occlusionQueryCount = 0;
    this.clippingContext = null;
    this.isRenderContext = true;
  }
  /**
   * Returns the cache key of this render context.
   *
   * @return {number} The cache key.
   */
  getCacheKey() {
    return getCacheKey(this);
  }
};
function getCacheKey(renderContext) {
  const { textures, activeCubeFace, activeMipmapLevel } = renderContext;
  const values = [activeCubeFace, activeMipmapLevel];
  for (const texture3 of textures) {
    values.push(texture3.id);
  }
  return hashArray(values);
}
var _chainKeys$3 = [];
var _defaultScene = new Scene();
var _defaultCamera = new Camera();
var RenderContexts = class {
  /**
   * Constructs a new render context management component.
   */
  constructor() {
    this.chainMaps = {};
  }
  /**
   * Returns a render context for the given scene, camera and render target.
   *
   * @param {Scene} scene - The scene.
   * @param {Camera} camera - The camera that is used to render the scene.
   * @param {?RenderTarget} [renderTarget=null] - The active render target.
   * @return {RenderContext} The render context.
   */
  get(scene, camera, renderTarget = null) {
    _chainKeys$3[0] = scene;
    _chainKeys$3[1] = camera;
    let attachmentState;
    if (renderTarget === null) {
      attachmentState = "default";
    } else {
      const format2 = renderTarget.texture.format;
      const count2 = renderTarget.textures.length;
      attachmentState = `${count2}:${format2}:${renderTarget.samples}:${renderTarget.depthBuffer}:${renderTarget.stencilBuffer}`;
    }
    const chainMap = this._getChainMap(attachmentState);
    let renderState = chainMap.get(_chainKeys$3);
    if (renderState === void 0) {
      renderState = new RenderContext();
      chainMap.set(_chainKeys$3, renderState);
    }
    _chainKeys$3.length = 0;
    if (renderTarget !== null) renderState.sampleCount = renderTarget.samples === 0 ? 1 : renderTarget.samples;
    return renderState;
  }
  /**
   * Returns a render context intended for clear operations.
   *
   * @param {?RenderTarget} [renderTarget=null] - The active render target.
   * @return {RenderContext} The render context.
   */
  getForClear(renderTarget = null) {
    return this.get(_defaultScene, _defaultCamera, renderTarget);
  }
  /**
   * Returns a chain map for the given attachment state.
   *
   * @private
   * @param {string} attachmentState - The attachment state.
   * @return {ChainMap} The chain map.
   */
  _getChainMap(attachmentState) {
    return this.chainMaps[attachmentState] || (this.chainMaps[attachmentState] = new ChainMap());
  }
  /**
   * Frees internal resources.
   */
  dispose() {
    this.chainMaps = {};
  }
};
var _size$3 = new Vector3();
var Textures = class extends DataMap {
  /**
   * Constructs a new texture management component.
   *
   * @param {Renderer} renderer - The renderer.
   * @param {Backend} backend - The renderer's backend.
   * @param {Info} info - Renderer component for managing metrics and monitoring data.
   */
  constructor(renderer, backend, info) {
    super();
    this.renderer = renderer;
    this.backend = backend;
    this.info = info;
  }
  /**
   * Updates the given render target. Based on the given render target configuration,
   * it updates the texture states representing the attachments of the framebuffer.
   *
   * @param {RenderTarget} renderTarget - The render target to update.
   * @param {number} [activeMipmapLevel=0] - The active mipmap level.
   */
  updateRenderTarget(renderTarget, activeMipmapLevel = 0) {
    const renderTargetData = this.get(renderTarget);
    const sampleCount = renderTarget.samples === 0 ? 1 : renderTarget.samples;
    const depthTextureMips = renderTargetData.depthTextureMips || (renderTargetData.depthTextureMips = {});
    const textures = renderTarget.textures;
    const size = this.getSize(textures[0]);
    const mipWidth = size.width >> activeMipmapLevel;
    const mipHeight = size.height >> activeMipmapLevel;
    let depthTexture = renderTarget.depthTexture || depthTextureMips[activeMipmapLevel];
    const useDepthTexture = renderTarget.depthBuffer === true || renderTarget.stencilBuffer === true;
    let textureNeedsUpdate = false;
    if (depthTexture === void 0 && useDepthTexture) {
      depthTexture = new DepthTexture();
      depthTexture.format = renderTarget.stencilBuffer ? DepthStencilFormat : DepthFormat;
      depthTexture.type = renderTarget.stencilBuffer ? UnsignedInt248Type : UnsignedIntType;
      depthTexture.image.width = mipWidth;
      depthTexture.image.height = mipHeight;
      depthTexture.image.depth = size.depth;
      depthTexture.isArrayTexture = renderTarget.multiview === true && size.depth > 1;
      depthTextureMips[activeMipmapLevel] = depthTexture;
    }
    if (renderTargetData.width !== size.width || size.height !== renderTargetData.height) {
      textureNeedsUpdate = true;
      if (depthTexture) {
        depthTexture.needsUpdate = true;
        depthTexture.image.width = mipWidth;
        depthTexture.image.height = mipHeight;
        depthTexture.image.depth = depthTexture.isArrayTexture ? depthTexture.image.depth : 1;
      }
    }
    renderTargetData.width = size.width;
    renderTargetData.height = size.height;
    renderTargetData.textures = textures;
    renderTargetData.depthTexture = depthTexture || null;
    renderTargetData.depth = renderTarget.depthBuffer;
    renderTargetData.stencil = renderTarget.stencilBuffer;
    renderTargetData.renderTarget = renderTarget;
    if (renderTargetData.sampleCount !== sampleCount) {
      textureNeedsUpdate = true;
      if (depthTexture) {
        depthTexture.needsUpdate = true;
      }
      renderTargetData.sampleCount = sampleCount;
    }
    const options = { sampleCount };
    if (renderTarget.isXRRenderTarget !== true) {
      for (let i = 0; i < textures.length; i++) {
        const texture3 = textures[i];
        if (textureNeedsUpdate) texture3.needsUpdate = true;
        this.updateTexture(texture3, options);
      }
      if (depthTexture) {
        this.updateTexture(depthTexture, options);
      }
    }
    if (renderTargetData.initialized !== true) {
      renderTargetData.initialized = true;
      const onDispose = () => {
        renderTarget.removeEventListener("dispose", onDispose);
        for (let i = 0; i < textures.length; i++) {
          this._destroyTexture(textures[i]);
        }
        if (depthTexture) {
          this._destroyTexture(depthTexture);
        }
        this.delete(renderTarget);
        this.backend.delete(renderTarget);
      };
      renderTarget.addEventListener("dispose", onDispose);
    }
  }
  /**
   * Updates the given texture. Depending on the texture state, this method
   * triggers the upload of texture data to the GPU memory. If the texture data are
   * not yet ready for the upload, it uses default texture data for as a placeholder.
   *
   * @param {Texture} texture - The texture to update.
   * @param {Object} [options={}] - The options.
   */
  updateTexture(texture3, options = {}) {
    const textureData = this.get(texture3);
    if (textureData.initialized === true && textureData.version === texture3.version) return;
    const isRenderTarget = texture3.isRenderTargetTexture || texture3.isDepthTexture || texture3.isFramebufferTexture;
    const backend = this.backend;
    if (isRenderTarget && textureData.initialized === true) {
      backend.destroySampler(texture3);
      backend.destroyTexture(texture3);
    }
    if (texture3.isFramebufferTexture) {
      const renderTarget = this.renderer.getRenderTarget();
      if (renderTarget) {
        texture3.type = renderTarget.texture.type;
      } else {
        texture3.type = UnsignedByteType;
      }
    }
    const { width, height, depth: depth3 } = this.getSize(texture3);
    options.width = width;
    options.height = height;
    options.depth = depth3;
    options.needsMipmaps = this.needsMipmaps(texture3);
    options.levels = options.needsMipmaps ? this.getMipLevels(texture3, width, height) : 1;
    if (texture3.isCubeTexture && texture3.mipmaps.length > 0) options.levels++;
    if (isRenderTarget || texture3.isStorageTexture === true || texture3.isExternalTexture === true) {
      backend.createSampler(texture3);
      backend.createTexture(texture3, options);
      textureData.generation = texture3.version;
    } else {
      const needsCreate = textureData.initialized !== true;
      if (needsCreate) backend.createSampler(texture3);
      if (texture3.version > 0) {
        const image = texture3.image;
        if (image === void 0) {
          console.warn("THREE.Renderer: Texture marked for update but image is undefined.");
        } else if (image.complete === false) {
          console.warn("THREE.Renderer: Texture marked for update but image is incomplete.");
        } else {
          if (texture3.images) {
            const images = [];
            for (const image2 of texture3.images) {
              images.push(image2);
            }
            options.images = images;
          } else {
            options.image = image;
          }
          if (textureData.isDefaultTexture === void 0 || textureData.isDefaultTexture === true) {
            backend.createTexture(texture3, options);
            textureData.isDefaultTexture = false;
            textureData.generation = texture3.version;
          }
          if (texture3.source.dataReady === true) backend.updateTexture(texture3, options);
          if (options.needsMipmaps && texture3.mipmaps.length === 0) backend.generateMipmaps(texture3);
          if (texture3.onUpdate) texture3.onUpdate(texture3);
        }
      } else {
        backend.createDefaultTexture(texture3);
        textureData.isDefaultTexture = true;
        textureData.generation = texture3.version;
      }
    }
    if (textureData.initialized !== true) {
      textureData.initialized = true;
      textureData.generation = texture3.version;
      this.info.memory.textures++;
      if (texture3.isVideoTexture && ColorManagement.getTransfer(texture3.colorSpace) !== SRGBTransfer) {
        console.warn("WebGPURenderer: Video textures must use a color space with a sRGB transfer function, e.g. SRGBColorSpace.");
      }
      const onDispose = () => {
        texture3.removeEventListener("dispose", onDispose);
        this._destroyTexture(texture3);
      };
      texture3.addEventListener("dispose", onDispose);
    }
    textureData.version = texture3.version;
  }
  /**
   * Computes the size of the given texture and writes the result
   * into the target vector. This vector is also returned by the
   * method.
   *
   * If no texture data are available for the compute yet, the method
   * returns default size values.
   *
   * @param {Texture} texture - The texture to compute the size for.
   * @param {Vector3} target - The target vector.
   * @return {Vector3} The target vector.
   */
  getSize(texture3, target = _size$3) {
    let image = texture3.images ? texture3.images[0] : texture3.image;
    if (image) {
      if (image.image !== void 0) image = image.image;
      if (typeof HTMLVideoElement !== "undefined" && image instanceof HTMLVideoElement) {
        target.width = image.videoWidth || 1;
        target.height = image.videoHeight || 1;
        target.depth = 1;
      } else if (image instanceof VideoFrame) {
        target.width = image.displayWidth || 1;
        target.height = image.displayHeight || 1;
        target.depth = 1;
      } else {
        target.width = image.width || 1;
        target.height = image.height || 1;
        target.depth = texture3.isCubeTexture ? 6 : image.depth || 1;
      }
    } else {
      target.width = target.height = target.depth = 1;
    }
    return target;
  }
  /**
   * Computes the number of mipmap levels for the given texture.
   *
   * @param {Texture} texture - The texture.
   * @param {number} width - The texture's width.
   * @param {number} height - The texture's height.
   * @return {number} The number of mipmap levels.
   */
  getMipLevels(texture3, width, height) {
    let mipLevelCount;
    if (texture3.mipmaps.length > 0) {
      mipLevelCount = texture3.mipmaps.length;
    } else {
      if (texture3.isCompressedTexture === true) {
        mipLevelCount = 1;
      } else {
        mipLevelCount = Math.floor(Math.log2(Math.max(width, height))) + 1;
      }
    }
    return mipLevelCount;
  }
  /**
   * Returns `true` if the given texture makes use of mipmapping.
   *
   * @param {Texture} texture - The texture.
   * @return {boolean} Whether mipmaps are required or not.
   */
  needsMipmaps(texture3) {
    return texture3.generateMipmaps === true || texture3.mipmaps.length > 0;
  }
  /**
   * Frees internal resource when the given texture isn't
   * required anymore.
   *
   * @param {Texture} texture - The texture to destroy.
   */
  _destroyTexture(texture3) {
    if (this.has(texture3) === true) {
      this.backend.destroySampler(texture3);
      this.backend.destroyTexture(texture3);
      this.delete(texture3);
      this.info.memory.textures--;
    }
  }
};
var Color4 = class extends Color {
  /**
   * Constructs a new four-component color.
   * You can also pass a single THREE.Color, hex or
   * string argument to this constructor.
   *
   * @param {number|string} [r=1] - The red value.
   * @param {number} [g=1] - The green value.
   * @param {number} [b=1] - The blue value.
   * @param {number} [a=1] - The alpha value.
   */
  constructor(r, g, b, a = 1) {
    super(r, g, b);
    this.a = a;
  }
  /**
   * Overwrites the default to honor alpha.
   * You can also pass a single THREE.Color, hex or
   * string argument to this method.
   *
   * @param {number|string|Color} r - The red value.
   * @param {number} [g] - The green value.
   * @param {number} [b] - The blue value.
   * @param {number} [a=1] - The alpha value.
   * @return {Color4} A reference to this object.
   */
  set(r, g, b, a = 1) {
    this.a = a;
    return super.set(r, g, b);
  }
  /**
   * Overwrites the default to honor alpha.
   *
   * @param {Color4} color - The color to copy.
   * @return {Color4} A reference to this object.
   */
  copy(color4) {
    if (color4.a !== void 0) this.a = color4.a;
    return super.copy(color4);
  }
  /**
   * Overwrites the default to honor alpha.
   *
   * @return {Color4} The cloned color.
   */
  clone() {
    return new this.constructor(this.r, this.g, this.b, this.a);
  }
};
var ParameterNode = class extends PropertyNode {
  static get type() {
    return "ParameterNode";
  }
  /**
   * Constructs a new parameter node.
   *
   * @param {string} nodeType - The type of the node.
   * @param {?string} [name=null] - The name of the parameter in the shader.
   */
  constructor(nodeType, name = null) {
    super(nodeType, name);
    this.isParameterNode = true;
  }
  getHash() {
    return this.uuid;
  }
  generate() {
    return this.name;
  }
};
var parameter = (type, name) => nodeObject(new ParameterNode(type, name));
var StackNode = class extends Node {
  static get type() {
    return "StackNode";
  }
  /**
   * Constructs a new stack node.
   *
   * @param {?StackNode} [parent=null] - The parent stack node.
   */
  constructor(parent = null) {
    super();
    this.nodes = [];
    this.outputNode = null;
    this.parent = parent;
    this._currentCond = null;
    this._expressionNode = null;
    this.isStackNode = true;
  }
  getNodeType(builder) {
    return this.hasOutput ? this.outputNode.getNodeType(builder) : "void";
  }
  getMemberType(builder, name) {
    return this.hasOutput ? this.outputNode.getMemberType(builder, name) : "void";
  }
  /**
   * Adds a node to this stack.
   *
   * @param {Node} node - The node to add.
   * @return {StackNode} A reference to this stack node.
   */
  add(node) {
    if (node.isNode !== true) {
      console.error("THREE.TSL: Invalid node added to stack.");
      return this;
    }
    this.nodes.push(node);
    return this;
  }
  /**
   * Represent an `if` statement in TSL.
   *
   * @param {Node} boolNode - Represents the condition.
   * @param {Function} method - TSL code which is executed if the condition evaluates to `true`.
   * @return {StackNode} A reference to this stack node.
   */
  If(boolNode, method) {
    const methodNode = new ShaderNode(method);
    this._currentCond = select(boolNode, methodNode);
    return this.add(this._currentCond);
  }
  /**
   * Represent an `elseif` statement in TSL.
   *
   * @param {Node} boolNode - Represents the condition.
   * @param {Function} method - TSL code which is executed if the condition evaluates to `true`.
   * @return {StackNode} A reference to this stack node.
   */
  ElseIf(boolNode, method) {
    const methodNode = new ShaderNode(method);
    const ifNode = select(boolNode, methodNode);
    this._currentCond.elseNode = ifNode;
    this._currentCond = ifNode;
    return this;
  }
  /**
   * Represent an `else` statement in TSL.
   *
   * @param {Function} method - TSL code which is executed in the `else` case.
   * @return {StackNode} A reference to this stack node.
   */
  Else(method) {
    this._currentCond.elseNode = new ShaderNode(method);
    return this;
  }
  /**
   * Represents a `switch` statement in TSL.
   *
   * @param {any} expression - Represents the expression.
   * @param {Function} method - TSL code which is executed if the condition evaluates to `true`.
   * @return {StackNode} A reference to this stack node.
   */
  Switch(expression3) {
    this._expressionNode = nodeObject(expression3);
    return this;
  }
  /**
   * Represents a `case` statement in TSL. The TSL version accepts an arbitrary numbers of values.
   * The last parameter must be the callback method that should be executed in the `true` case.
   *
   * @param {...any} params - The values of the `Case()` statement as well as the callback method.
   * @return {StackNode} A reference to this stack node.
   */
  Case(...params) {
    const caseNodes = [];
    if (params.length >= 2) {
      for (let i = 0; i < params.length - 1; i++) {
        caseNodes.push(this._expressionNode.equal(nodeObject(params[i])));
      }
    } else {
      console.error("THREE.TSL: Invalid parameter length. Case() requires at least two parameters.");
    }
    const method = params[params.length - 1];
    const methodNode = new ShaderNode(method);
    let caseNode = caseNodes[0];
    for (let i = 1; i < caseNodes.length; i++) {
      caseNode = caseNode.or(caseNodes[i]);
    }
    const condNode = select(caseNode, methodNode);
    if (this._currentCond === null) {
      this._currentCond = condNode;
      return this.add(this._currentCond);
    } else {
      this._currentCond.elseNode = condNode;
      this._currentCond = condNode;
      return this;
    }
  }
  /**
   * Represents the default code block of a Switch/Case statement.
   *
   * @param {Function} method - TSL code which is executed in the `else` case.
   * @return {StackNode} A reference to this stack node.
   */
  Default(method) {
    this.Else(method);
    return this;
  }
  setup(builder) {
    const nodeProperties = builder.getNodeProperties(this);
    let index5 = 0;
    for (const childNode of this.getChildren()) {
      if (childNode.isVarNode && childNode.intent === true) {
        const properties = builder.getNodeProperties(childNode);
        if (properties.assign !== true) {
          continue;
        }
      }
      nodeProperties["node" + index5++] = childNode;
    }
    return nodeProperties.outputNode || null;
  }
  get hasOutput() {
    return this.outputNode && this.outputNode.isNode;
  }
  build(builder, ...params) {
    const previousBuildStack = builder.currentStack;
    const previousStack = getCurrentStack();
    setCurrentStack(this);
    builder.currentStack = this;
    const buildStage = builder.buildStage;
    for (const node of this.nodes) {
      if (node.isVarNode && node.intent === true) {
        const properties = builder.getNodeProperties(node);
        if (properties.assign !== true) {
          continue;
        }
      }
      if (buildStage === "setup") {
        node.build(builder);
      } else if (buildStage === "analyze") {
        node.build(builder, this);
      } else if (buildStage === "generate") {
        const stages = builder.getDataFromNode(node, "any").stages;
        const parents = stages && stages[builder.shaderStage];
        if (node.isVarNode && parents && parents.length === 1 && parents[0] && parents[0].isStackNode) {
          continue;
        }
        node.build(builder, "void");
      }
    }
    let result;
    if (this.hasOutput) {
      result = this.outputNode.build(builder, ...params);
    } else {
      result = super.build(builder, ...params);
    }
    setCurrentStack(previousStack);
    builder.currentStack = previousBuildStack;
    return result;
  }
};
var stack = nodeProxy(StackNode).setParameterLength(0, 1);
function getMembersLayout(members) {
  return Object.entries(members).map(([name, value]) => {
    if (typeof value === "string") {
      return { name, type: value, atomic: false };
    }
    return { name, type: value.type, atomic: value.atomic || false };
  });
}
var StructTypeNode = class extends Node {
  static get type() {
    return "StructTypeNode";
  }
  /**
   * Creates an instance of StructTypeNode.
   *
   * @param {Object} membersLayout - The layout of the members for the struct.
   * @param {?string} [name=null] - The optional name of the struct.
   */
  constructor(membersLayout, name = null) {
    super("struct");
    this.membersLayout = getMembersLayout(membersLayout);
    this.name = name;
    this.isStructLayoutNode = true;
  }
  /**
   * Returns the length of the struct.
   * The length is calculated by summing the lengths of the struct's members.
   *
   * @returns {number} The length of the struct.
   */
  getLength() {
    const GPU_CHUNK_BYTES2 = 8;
    const BYTES_PER_ELEMENT = Float32Array.BYTES_PER_ELEMENT;
    let offset = 0;
    for (const member of this.membersLayout) {
      const type = member.type;
      const itemSize = getMemoryLengthFromType(type) * BYTES_PER_ELEMENT;
      const boundary = getByteBoundaryFromType(type);
      const chunkOffset = offset % GPU_CHUNK_BYTES2;
      const chunkPadding = chunkOffset % boundary;
      const chunkStart = chunkOffset + chunkPadding;
      offset += chunkPadding;
      if (chunkStart !== 0 && GPU_CHUNK_BYTES2 - chunkStart < itemSize) {
        offset += GPU_CHUNK_BYTES2 - chunkStart;
      }
      offset += itemSize;
    }
    return Math.ceil(offset / GPU_CHUNK_BYTES2) * GPU_CHUNK_BYTES2 / BYTES_PER_ELEMENT;
  }
  getMemberType(builder, name) {
    const member = this.membersLayout.find((m) => m.name === name);
    return member ? member.type : "void";
  }
  getNodeType(builder) {
    const structType = builder.getStructTypeFromNode(this, this.membersLayout, this.name);
    return structType.name;
  }
  setup(builder) {
    builder.getStructTypeFromNode(this, this.membersLayout, this.name);
    builder.addInclude(this);
  }
  generate(builder) {
    return this.getNodeType(builder);
  }
};
var StructNode = class extends Node {
  static get type() {
    return "StructNode";
  }
  constructor(structTypeNode, values) {
    super("vec3");
    this.structTypeNode = structTypeNode;
    this.values = values;
    this.isStructNode = true;
  }
  getNodeType(builder) {
    return this.structTypeNode.getNodeType(builder);
  }
  getMemberType(builder, name) {
    return this.structTypeNode.getMemberType(builder, name);
  }
  generate(builder) {
    const nodeVar = builder.getVarFromNode(this);
    const structType = nodeVar.type;
    const propertyName = builder.getPropertyName(nodeVar);
    builder.addLineFlowCode(`${propertyName} = ${builder.generateStruct(structType, this.structTypeNode.membersLayout, this.values)}`, this);
    return nodeVar.name;
  }
};
var struct = (membersLayout, name = null) => {
  const structLayout = new StructTypeNode(membersLayout, name);
  const struct3 = (...params) => {
    let values = null;
    if (params.length > 0) {
      if (params[0].isNode) {
        values = {};
        const names2 = Object.keys(membersLayout);
        for (let i = 0; i < params.length; i++) {
          values[names2[i]] = params[i];
        }
      } else {
        values = params[0];
      }
    }
    return nodeObject(new StructNode(structLayout, values));
  };
  struct3.layout = structLayout;
  struct3.isStruct = true;
  return struct3;
};
var OutputStructNode = class extends Node {
  static get type() {
    return "OutputStructNode";
  }
  /**
   * Constructs a new output struct node. The constructor can be invoked with an
   * arbitrary number of nodes representing the members.
   *
   * @param {...Node} members - A parameter list of nodes.
   */
  constructor(...members) {
    super();
    this.members = members;
    this.isOutputStructNode = true;
  }
  getNodeType(builder) {
    const properties = builder.getNodeProperties(this);
    if (properties.membersLayout === void 0) {
      const members = this.members;
      const membersLayout = [];
      for (let i = 0; i < members.length; i++) {
        const name = "m" + i;
        const type = members[i].getNodeType(builder);
        membersLayout.push({ name, type, index: i });
      }
      properties.membersLayout = membersLayout;
      properties.structType = builder.getOutputStructTypeFromNode(this, properties.membersLayout);
    }
    return properties.structType.name;
  }
  generate(builder) {
    const propertyName = builder.getOutputStructName();
    const members = this.members;
    const structPrefix = propertyName !== "" ? propertyName + "." : "";
    for (let i = 0; i < members.length; i++) {
      const snippet = members[i].build(builder);
      builder.addLineFlowCode(`${structPrefix}m${i} = ${snippet}`, this);
    }
    return propertyName;
  }
};
var outputStruct = nodeProxy(OutputStructNode);
function getTextureIndex(textures, name) {
  for (let i = 0; i < textures.length; i++) {
    if (textures[i].name === name) {
      return i;
    }
  }
  return -1;
}
var MRTNode = class extends OutputStructNode {
  static get type() {
    return "MRTNode";
  }
  /**
   * Constructs a new output struct node.
   *
   * @param {Object<string, Node>} outputNodes - The MRT outputs.
   */
  constructor(outputNodes) {
    super();
    this.outputNodes = outputNodes;
    this.isMRTNode = true;
  }
  /**
   * Returns `true` if the MRT node has an output with the given name.
   *
   * @param {string} name - The name of the output.
   * @return {NodeBuilder} Whether the MRT node has an output for the given name or not.
   */
  has(name) {
    return this.outputNodes[name] !== void 0;
  }
  /**
   * Returns the output node for the given name.
   *
   * @param {string} name - The name of the output.
   * @return {Node} The output node.
   */
  get(name) {
    return this.outputNodes[name];
  }
  /**
   * Merges the outputs of the given MRT node with the outputs of this node.
   *
   * @param {MRTNode} mrtNode - The MRT to merge.
   * @return {MRTNode} A new MRT node with merged outputs..
   */
  merge(mrtNode) {
    const outputs = { ...this.outputNodes, ...mrtNode.outputNodes };
    return mrt(outputs);
  }
  setup(builder) {
    const outputNodes = this.outputNodes;
    const mrt3 = builder.renderer.getRenderTarget();
    const members = [];
    const textures = mrt3.textures;
    for (const name in outputNodes) {
      const index5 = getTextureIndex(textures, name);
      members[index5] = vec4(outputNodes[name]);
    }
    this.members = members;
    return super.setup(builder);
  }
};
var mrt = nodeProxy(MRTNode);
var BitcastNode = class extends TempNode {
  static get type() {
    return "BitcastNode";
  }
  /**
   * Constructs a new bitcast node.
   *
   * @param {Node} valueNode - The value to convert.
   * @param {string} conversionType - The type to convert to.
   * @param {?string} [inputType = null] - The expected input data type of the bitcast operation.
   */
  constructor(valueNode, conversionType, inputType = null) {
    super();
    this.valueNode = valueNode;
    this.conversionType = conversionType;
    this.inputType = inputType;
    this.isBitcastNode = true;
  }
  getNodeType(builder) {
    if (this.inputType !== null) {
      const valueType = this.valueNode.getNodeType(builder);
      const valueLength = builder.getTypeLength(valueType);
      return builder.getTypeFromLength(valueLength, this.conversionType);
    }
    return this.conversionType;
  }
  generate(builder) {
    const type = this.getNodeType(builder);
    let inputType = "";
    if (this.inputType !== null) {
      const valueType = this.valueNode.getNodeType(builder);
      const valueTypeLength = builder.getTypeLength(valueType);
      inputType = valueTypeLength === 1 ? this.inputType : builder.changeComponentType(valueType, this.inputType);
    } else {
      inputType = this.valueNode.getNodeType(builder);
    }
    return `${builder.getBitcastMethod(type, inputType)}( ${this.valueNode.build(builder, inputType)} )`;
  }
};
var bitcast = nodeProxyIntent(BitcastNode).setParameterLength(2);
var floatBitsToInt = (value) => new BitcastNode(value, "int", "float");
var floatBitsToUint = (value) => new BitcastNode(value, "uint", "float");
var intBitsToFloat = (value) => new BitcastNode(value, "float", "int");
var uintBitsToFloat = (value) => new BitcastNode(value, "float", "uint");
var hash = Fn(([seed]) => {
  const state = seed.toUint().mul(747796405).add(2891336453);
  const word = state.shiftRight(state.shiftRight(28).add(4)).bitXor(state).mul(277803737);
  const result = word.shiftRight(22).bitXor(word);
  return result.toFloat().mul(1 / 2 ** 32);
});
var parabola = (x, k) => pow4(mul(4, x.mul(sub(1, x))), k);
var gain = (x, k) => x.lessThan(0.5) ? parabola(x.mul(2), k).div(2) : sub(1, parabola(mul(sub(1, x), 2), k).div(2));
var pcurve = (x, a, b) => pow4(div(pow4(x, a), add3(pow4(x, a), pow4(sub(1, x), b))), 1 / a);
var sinc = (x, k) => sin3(PI.mul(k.mul(x).sub(1))).div(PI.mul(k.mul(x).sub(1)));
var tri = Fn(([x]) => {
  return x.fract().sub(0.5).abs();
}).setLayout({
  name: "tri",
  type: "float",
  inputs: [
    { name: "x", type: "float" }
  ]
});
var tri3 = Fn(([p]) => {
  return vec3(tri(p.z.add(tri(p.y.mul(1)))), tri(p.z.add(tri(p.x.mul(1)))), tri(p.y.add(tri(p.x.mul(1)))));
}).setLayout({
  name: "tri3",
  type: "vec3",
  inputs: [
    { name: "p", type: "vec3" }
  ]
});
var triNoise3D = Fn(([position, speed, time4]) => {
  const p = vec3(position).toVar();
  const z = float(1.4).toVar();
  const rz = float(0).toVar();
  const bp = vec3(p).toVar();
  Loop({ start: float(0), end: float(3), type: "float", condition: "<=" }, () => {
    const dg = vec3(tri3(bp.mul(2))).toVar();
    p.addAssign(dg.add(time4.mul(float(0.1).mul(speed))));
    bp.mulAssign(1.8);
    z.mulAssign(1.5);
    p.mulAssign(1.2);
    const t = float(tri(p.z.add(tri(p.x.add(tri(p.y)))))).toVar();
    rz.addAssign(t.div(z));
    bp.addAssign(0.14);
  });
  return rz;
}).setLayout({
  name: "triNoise3D",
  type: "float",
  inputs: [
    { name: "position", type: "vec3" },
    { name: "speed", type: "float" },
    { name: "time", type: "float" }
  ]
});
var FunctionOverloadingNode = class extends Node {
  static get type() {
    return "FunctionOverloadingNode";
  }
  /**
   * Constructs a new function overloading node.
   *
   * @param {Array<Function>} functionNodes - Array of `Fn` function definitions.
   * @param {...Node} parametersNodes - A list of parameter nodes.
   */
  constructor(functionNodes = [], ...parametersNodes) {
    super();
    this.functionNodes = functionNodes;
    this.parametersNodes = parametersNodes;
    this._candidateFnCall = null;
    this.global = true;
  }
  /**
   * This method is overwritten since the node type is inferred from
   * the function's return type.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node type.
   */
  getNodeType() {
    return this.functionNodes[0].shaderNode.layout.type;
  }
  setup(builder) {
    const params = this.parametersNodes;
    let candidateFnCall = this._candidateFnCall;
    if (candidateFnCall === null) {
      let candidateFn = null;
      let candidateScore = -1;
      for (const functionNode of this.functionNodes) {
        const shaderNode = functionNode.shaderNode;
        const layout = shaderNode.layout;
        if (layout === null) {
          throw new Error("FunctionOverloadingNode: FunctionNode must be a layout.");
        }
        const inputs = layout.inputs;
        if (params.length === inputs.length) {
          let score = 0;
          for (let i = 0; i < params.length; i++) {
            const param = params[i];
            const input = inputs[i];
            if (param.getNodeType(builder) === input.type) {
              score++;
            } else {
              score = 0;
            }
          }
          if (score > candidateScore) {
            candidateFn = functionNode;
            candidateScore = score;
          }
        }
      }
      this._candidateFnCall = candidateFnCall = candidateFn(...params);
    }
    return candidateFnCall;
  }
};
var overloadingBaseFn = nodeProxy(FunctionOverloadingNode);
var overloadingFn = (functionNodes) => (...params) => overloadingBaseFn(functionNodes, ...params);
var time2 = uniform(0).setGroup(renderGroup).onRenderUpdate((frame) => frame.time);
var deltaTime = uniform(0).setGroup(renderGroup).onRenderUpdate((frame) => frame.deltaTime);
var frameId = uniform(0, "uint").setGroup(renderGroup).onRenderUpdate((frame) => frame.frameId);
var oscSine = (t = time2) => t.add(0.75).mul(Math.PI * 2).sin().mul(0.5).add(0.5);
var oscSquare = (t = time2) => t.fract().round();
var oscTriangle = (t = time2) => t.add(0.5).fract().mul(2).sub(1).abs();
var oscSawtooth = (t = time2) => t.fract();
var rotateUV = Fn(([uv3, rotation, center = vec2(0.5)]) => {
  return rotate(uv3.sub(center), rotation).add(center);
});
var spherizeUV = Fn(([uv3, strength, center = vec2(0.5)]) => {
  const delta = uv3.sub(center);
  const delta2 = delta.dot(delta);
  const delta4 = delta2.mul(delta2);
  const deltaOffset = delta4.mul(strength);
  return uv3.add(delta.mul(deltaOffset));
});
var billboarding = Fn(({ position = null, horizontal = true, vertical = false }) => {
  let worldMatrix;
  if (position !== null) {
    worldMatrix = modelWorldMatrix.toVar();
    worldMatrix[3][0] = position.x;
    worldMatrix[3][1] = position.y;
    worldMatrix[3][2] = position.z;
  } else {
    worldMatrix = modelWorldMatrix;
  }
  const modelViewMatrix3 = cameraViewMatrix.mul(worldMatrix);
  if (defined(horizontal)) {
    modelViewMatrix3[0][0] = modelWorldMatrix[0].length();
    modelViewMatrix3[0][1] = 0;
    modelViewMatrix3[0][2] = 0;
  }
  if (defined(vertical)) {
    modelViewMatrix3[1][0] = 0;
    modelViewMatrix3[1][1] = modelWorldMatrix[1].length();
    modelViewMatrix3[1][2] = 0;
  }
  modelViewMatrix3[2][0] = 0;
  modelViewMatrix3[2][1] = 0;
  modelViewMatrix3[2][2] = 1;
  return cameraProjectionMatrix.mul(modelViewMatrix3).mul(positionLocal);
});
var viewportSafeUV = Fn(([uv3 = null]) => {
  const depth3 = linearDepth();
  const depthDiff = linearDepth(viewportDepthTexture(uv3)).sub(depth3);
  const finalUV = depthDiff.lessThan(0).select(screenUV, uv3);
  return finalUV;
});
var SpriteSheetUVNode = class extends Node {
  static get type() {
    return "SpriteSheetUVNode";
  }
  /**
   * Constructs a new sprite sheet uv node.
   *
   * @param {Node<vec2>} countNode - The node that defines the number of sprites in the x and y direction (e.g 6x6).
   * @param {Node<vec2>} [uvNode=uv()] - The uv node.
   * @param {Node<float>} [frameNode=float()] - The node that defines the current frame/sprite.
   */
  constructor(countNode, uvNode = uv$1(), frameNode = float(0)) {
    super("vec2");
    this.countNode = countNode;
    this.uvNode = uvNode;
    this.frameNode = frameNode;
  }
  setup() {
    const { frameNode, uvNode, countNode } = this;
    const { width, height } = countNode;
    const frameNum = frameNode.mod(width.mul(height)).floor();
    const column = frameNum.mod(width);
    const row = height.sub(frameNum.add(1).div(width).ceil());
    const scale3 = countNode.reciprocal();
    const uvFrameOffset = vec2(column, row);
    return uvNode.add(uvFrameOffset).mul(scale3);
  }
};
var spritesheetUV = nodeProxy(SpriteSheetUVNode).setParameterLength(3);
var triplanarTextures = Fn(([textureXNode, textureYNode = null, textureZNode = null, scaleNode = float(1), positionNode = positionLocal, normalNode = normalLocal]) => {
  let bf = normalNode.abs().normalize();
  bf = bf.div(bf.dot(vec3(1)));
  const tx = positionNode.yz.mul(scaleNode);
  const ty = positionNode.zx.mul(scaleNode);
  const tz = positionNode.xy.mul(scaleNode);
  const textureX = textureXNode.value;
  const textureY = textureYNode !== null ? textureYNode.value : textureX;
  const textureZ = textureZNode !== null ? textureZNode.value : textureX;
  const cx = texture(textureX, tx).mul(bf.x);
  const cy = texture(textureY, ty).mul(bf.y);
  const cz = texture(textureZ, tz).mul(bf.z);
  return add3(cx, cy, cz);
});
var triplanarTexture = (...params) => triplanarTextures(...params);
var _reflectorPlane = new Plane();
var _normal = new Vector3();
var _reflectorWorldPosition = new Vector3();
var _cameraWorldPosition = new Vector3();
var _rotationMatrix = new Matrix4();
var _lookAtPosition = new Vector3(0, 0, -1);
var clipPlane = new Vector4();
var _view = new Vector3();
var _target = new Vector3();
var _q = new Vector4();
var _size$2 = new Vector2();
var _defaultRT = new RenderTarget();
var _defaultUV = screenUV.flipX();
_defaultRT.depthTexture = new DepthTexture(1, 1);
var _inReflector = false;
var ReflectorNode = class _ReflectorNode extends TextureNode {
  static get type() {
    return "ReflectorNode";
  }
  /**
   * Constructs a new reflector node.
   *
   * @param {Object} [parameters={}] - An object holding configuration parameters.
   * @param {Object3D} [parameters.target=new Object3D()] - The 3D object the reflector is linked to.
   * @param {number} [parameters.resolutionScale=1] - The resolution scale.
   * @param {boolean} [parameters.generateMipmaps=false] - Whether mipmaps should be generated or not.
   * @param {boolean} [parameters.bounces=true] - Whether reflectors can render other reflector nodes or not.
   * @param {boolean} [parameters.depth=false] - Whether depth data should be generated or not.
   * @param {number} [parameters.samples] - Anti-Aliasing samples of the internal render-target.
   * @param {TextureNode} [parameters.defaultTexture] - The default texture node.
   * @param {ReflectorBaseNode} [parameters.reflector] - The reflector base node.
   */
  constructor(parameters = {}) {
    super(parameters.defaultTexture || _defaultRT.texture, _defaultUV);
    this._reflectorBaseNode = parameters.reflector || new ReflectorBaseNode(this, parameters);
    this._depthNode = null;
    this.setUpdateMatrix(false);
  }
  /**
   * A reference to the internal reflector node.
   *
   * @type {ReflectorBaseNode}
   */
  get reflector() {
    return this._reflectorBaseNode;
  }
  /**
   * A reference to 3D object the reflector is linked to.
   *
   * @type {Object3D}
   */
  get target() {
    return this._reflectorBaseNode.target;
  }
  /**
   * Returns a node representing the mirror's depth. That can be used
   * to implement more advanced reflection effects like distance attenuation.
   *
   * @return {Node} The depth node.
   */
  getDepthNode() {
    if (this._depthNode === null) {
      if (this._reflectorBaseNode.depth !== true) {
        throw new Error("THREE.ReflectorNode: Depth node can only be requested when the reflector is created with { depth: true }. ");
      }
      this._depthNode = nodeObject(new _ReflectorNode({
        defaultTexture: _defaultRT.depthTexture,
        reflector: this._reflectorBaseNode
      }));
    }
    return this._depthNode;
  }
  setup(builder) {
    if (!builder.object.isQuadMesh) this._reflectorBaseNode.build(builder);
    return super.setup(builder);
  }
  clone() {
    const newNode = new this.constructor(this.reflectorNode);
    newNode.uvNode = this.uvNode;
    newNode.levelNode = this.levelNode;
    newNode.biasNode = this.biasNode;
    newNode.sampler = this.sampler;
    newNode.depthNode = this.depthNode;
    newNode.compareNode = this.compareNode;
    newNode.gradNode = this.gradNode;
    newNode._reflectorBaseNode = this._reflectorBaseNode;
    return newNode;
  }
  /**
   * Frees internal resources. Should be called when the node is no longer in use.
   */
  dispose() {
    super.dispose();
    this._reflectorBaseNode.dispose();
  }
};
var ReflectorBaseNode = class extends Node {
  static get type() {
    return "ReflectorBaseNode";
  }
  /**
   * Constructs a new reflector base node.
   *
   * @param {TextureNode} textureNode - Represents the rendered reflections as a texture node.
   * @param {Object} [parameters={}] - An object holding configuration parameters.
   * @param {Object3D} [parameters.target=new Object3D()] - The 3D object the reflector is linked to.
   * @param {number} [parameters.resolutionScale=1] - The resolution scale.
   * @param {boolean} [parameters.generateMipmaps=false] - Whether mipmaps should be generated or not.
   * @param {boolean} [parameters.bounces=true] - Whether reflectors can render other reflector nodes or not.
   * @param {boolean} [parameters.depth=false] - Whether depth data should be generated or not.
   * @param {number} [parameters.samples] - Anti-Aliasing samples of the internal render-target.
   */
  constructor(textureNode, parameters = {}) {
    super();
    const {
      target = new Object3D(),
      resolutionScale = 1,
      generateMipmaps = false,
      bounces = true,
      depth: depth3 = false,
      samples = 0
    } = parameters;
    this.textureNode = textureNode;
    this.target = target;
    this.resolutionScale = resolutionScale;
    if (parameters.resolution !== void 0) {
      warnOnce('THREE.ReflectorNode: The "resolution" parameter has been renamed to "resolutionScale".');
      this.resolutionScale = parameters.resolution;
    }
    this.generateMipmaps = generateMipmaps;
    this.bounces = bounces;
    this.depth = depth3;
    this.samples = samples;
    this.updateBeforeType = bounces ? NodeUpdateType.RENDER : NodeUpdateType.FRAME;
    this.virtualCameras = /* @__PURE__ */ new WeakMap();
    this.renderTargets = /* @__PURE__ */ new Map();
    this.forceUpdate = false;
    this.hasOutput = false;
  }
  /**
   * Updates the resolution of the internal render target.
   *
   * @private
   * @param {RenderTarget} renderTarget - The render target to resize.
   * @param {Renderer} renderer - The renderer that is used to determine the new size.
   */
  _updateResolution(renderTarget, renderer) {
    const resolution2 = this.resolutionScale;
    renderer.getDrawingBufferSize(_size$2);
    renderTarget.setSize(Math.round(_size$2.width * resolution2), Math.round(_size$2.height * resolution2));
  }
  setup(builder) {
    this._updateResolution(_defaultRT, builder.renderer);
    return super.setup(builder);
  }
  /**
   * Frees internal resources. Should be called when the node is no longer in use.
   */
  dispose() {
    super.dispose();
    for (const renderTarget of this.renderTargets.values()) {
      renderTarget.dispose();
    }
  }
  /**
   * Returns a virtual camera for the given camera. The virtual camera is used to
   * render the scene from the reflector's view so correct reflections can be produced.
   *
   * @param {Camera} camera - The scene's camera.
   * @return {Camera} The corresponding virtual camera.
   */
  getVirtualCamera(camera) {
    let virtualCamera = this.virtualCameras.get(camera);
    if (virtualCamera === void 0) {
      virtualCamera = camera.clone();
      this.virtualCameras.set(camera, virtualCamera);
    }
    return virtualCamera;
  }
  /**
   * Returns a render target for the given camera. The reflections are rendered
   * into this render target.
   *
   * @param {Camera} camera - The scene's camera.
   * @return {RenderTarget} The render target.
   */
  getRenderTarget(camera) {
    let renderTarget = this.renderTargets.get(camera);
    if (renderTarget === void 0) {
      renderTarget = new RenderTarget(0, 0, { type: HalfFloatType, samples: this.samples });
      if (this.generateMipmaps === true) {
        renderTarget.texture.minFilter = LinearMipMapLinearFilter;
        renderTarget.texture.generateMipmaps = true;
      }
      if (this.depth === true) {
        renderTarget.depthTexture = new DepthTexture();
      }
      this.renderTargets.set(camera, renderTarget);
    }
    return renderTarget;
  }
  updateBefore(frame) {
    if (this.bounces === false && _inReflector) return false;
    _inReflector = true;
    const { scene, camera, renderer, material } = frame;
    const { target } = this;
    const virtualCamera = this.getVirtualCamera(camera);
    const renderTarget = this.getRenderTarget(virtualCamera);
    renderer.getDrawingBufferSize(_size$2);
    this._updateResolution(renderTarget, renderer);
    _reflectorWorldPosition.setFromMatrixPosition(target.matrixWorld);
    _cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);
    _rotationMatrix.extractRotation(target.matrixWorld);
    _normal.set(0, 0, 1);
    _normal.applyMatrix4(_rotationMatrix);
    _view.subVectors(_reflectorWorldPosition, _cameraWorldPosition);
    const isFacingAway = _view.dot(_normal) > 0;
    let needsClear = false;
    if (isFacingAway === true && this.forceUpdate === false) {
      if (this.hasOutput === false) {
        _inReflector = false;
        return;
      }
      needsClear = true;
    }
    _view.reflect(_normal).negate();
    _view.add(_reflectorWorldPosition);
    _rotationMatrix.extractRotation(camera.matrixWorld);
    _lookAtPosition.set(0, 0, -1);
    _lookAtPosition.applyMatrix4(_rotationMatrix);
    _lookAtPosition.add(_cameraWorldPosition);
    _target.subVectors(_reflectorWorldPosition, _lookAtPosition);
    _target.reflect(_normal).negate();
    _target.add(_reflectorWorldPosition);
    virtualCamera.coordinateSystem = camera.coordinateSystem;
    virtualCamera.position.copy(_view);
    virtualCamera.up.set(0, 1, 0);
    virtualCamera.up.applyMatrix4(_rotationMatrix);
    virtualCamera.up.reflect(_normal);
    virtualCamera.lookAt(_target);
    virtualCamera.near = camera.near;
    virtualCamera.far = camera.far;
    virtualCamera.updateMatrixWorld();
    virtualCamera.projectionMatrix.copy(camera.projectionMatrix);
    _reflectorPlane.setFromNormalAndCoplanarPoint(_normal, _reflectorWorldPosition);
    _reflectorPlane.applyMatrix4(virtualCamera.matrixWorldInverse);
    clipPlane.set(_reflectorPlane.normal.x, _reflectorPlane.normal.y, _reflectorPlane.normal.z, _reflectorPlane.constant);
    const projectionMatrix = virtualCamera.projectionMatrix;
    _q.x = (Math.sign(clipPlane.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];
    _q.y = (Math.sign(clipPlane.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];
    _q.z = -1;
    _q.w = (1 + projectionMatrix.elements[10]) / projectionMatrix.elements[14];
    clipPlane.multiplyScalar(1 / clipPlane.dot(_q));
    const clipBias = 0;
    projectionMatrix.elements[2] = clipPlane.x;
    projectionMatrix.elements[6] = clipPlane.y;
    projectionMatrix.elements[10] = renderer.coordinateSystem === WebGPUCoordinateSystem ? clipPlane.z - clipBias : clipPlane.z + 1 - clipBias;
    projectionMatrix.elements[14] = clipPlane.w;
    this.textureNode.value = renderTarget.texture;
    if (this.depth === true) {
      this.textureNode.getDepthNode().value = renderTarget.depthTexture;
    }
    material.visible = false;
    const currentRenderTarget = renderer.getRenderTarget();
    const currentMRT = renderer.getMRT();
    const currentAutoClear = renderer.autoClear;
    renderer.setMRT(null);
    renderer.setRenderTarget(renderTarget);
    renderer.autoClear = true;
    if (needsClear) {
      renderer.clear();
      this.hasOutput = false;
    } else {
      renderer.render(scene, virtualCamera);
      this.hasOutput = true;
    }
    renderer.setMRT(currentMRT);
    renderer.setRenderTarget(currentRenderTarget);
    renderer.autoClear = currentAutoClear;
    material.visible = true;
    _inReflector = false;
    this.forceUpdate = false;
  }
  /**
   * The resolution scale.
   *
   * @deprecated
   * @type {number}
   * @default {1}
   */
  get resolution() {
    warnOnce('THREE.ReflectorNode: The "resolution" property has been renamed to "resolutionScale".');
    return this.resolutionScale;
  }
  set resolution(value) {
    warnOnce('THREE.ReflectorNode: The "resolution" property has been renamed to "resolutionScale".');
    this.resolutionScale = value;
  }
};
var reflector = (parameters) => nodeObject(new ReflectorNode(parameters));
var _camera2 = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
var QuadGeometry = class extends BufferGeometry {
  /**
   * Constructs a new quad geometry.
   *
   * @param {boolean} [flipY=false] - Whether the uv coordinates should be flipped along the vertical axis or not.
   */
  constructor(flipY = false) {
    super();
    const uv3 = flipY === false ? [0, -1, 0, 1, 2, 1] : [0, 2, 0, 0, 2, 0];
    this.setAttribute("position", new Float32BufferAttribute([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3));
    this.setAttribute("uv", new Float32BufferAttribute(uv3, 2));
  }
};
var _geometry = new QuadGeometry();
var QuadMesh = class extends Mesh {
  /**
   * Constructs a new quad mesh.
   *
   * @param {?Material} [material=null] - The material to render the quad mesh with.
   */
  constructor(material = null) {
    super(_geometry, material);
    this.camera = _camera2;
    this.isQuadMesh = true;
  }
  /**
   * Async version of `render()`.
   *
   * @async
   * @param {Renderer} renderer - The renderer.
   * @return {Promise} A Promise that resolves when the render has been finished.
   */
  async renderAsync(renderer) {
    return renderer.renderAsync(this, _camera2);
  }
  /**
   * Renders the quad mesh
   *
   * @param {Renderer} renderer - The renderer.
   */
  render(renderer) {
    renderer.render(this, _camera2);
  }
};
var _size$1 = new Vector2();
var RTTNode = class extends TextureNode {
  static get type() {
    return "RTTNode";
  }
  /**
   * Constructs a new RTT node.
   *
   * @param {Node} node - The node to render a texture with.
   * @param {?number} [width=null] - The width of the internal render target. If not width is applied, the render target is automatically resized.
   * @param {?number} [height=null] - The height of the internal render target.
   * @param {Object} [options={type:HalfFloatType}] - The options for the internal render target.
   */
  constructor(node, width = null, height = null, options = { type: HalfFloatType }) {
    const renderTarget = new RenderTarget(width, height, options);
    super(renderTarget.texture, uv$1());
    this.isRTTNode = true;
    this.node = node;
    this.width = width;
    this.height = height;
    this.pixelRatio = 1;
    this.renderTarget = renderTarget;
    this.textureNeedsUpdate = true;
    this.autoUpdate = true;
    this._rttNode = null;
    this._quadMesh = new QuadMesh(new NodeMaterial());
    this.updateBeforeType = NodeUpdateType.RENDER;
  }
  /**
   * Whether the internal render target should automatically be resized or not.
   *
   * @type {boolean}
   * @readonly
   * @default true
   */
  get autoResize() {
    return this.width === null;
  }
  setup(builder) {
    this._rttNode = this.node.context(builder.getSharedContext());
    this._quadMesh.material.name = "RTT";
    this._quadMesh.material.needsUpdate = true;
    return super.setup(builder);
  }
  /**
   * Sets the size of the internal render target
   *
   * @param {number} width - The width to set.
   * @param {number} height - The width to set.
   */
  setSize(width, height) {
    this.width = width;
    this.height = height;
    const effectiveWidth = width * this.pixelRatio;
    const effectiveHeight = height * this.pixelRatio;
    this.renderTarget.setSize(effectiveWidth, effectiveHeight);
    this.textureNeedsUpdate = true;
  }
  /**
   * Sets the pixel ratio. This will also resize the render target.
   *
   * @param {number} pixelRatio - The pixel ratio to set.
   */
  setPixelRatio(pixelRatio) {
    this.pixelRatio = pixelRatio;
    this.setSize(this.width, this.height);
  }
  updateBefore({ renderer }) {
    if (this.textureNeedsUpdate === false && this.autoUpdate === false) return;
    this.textureNeedsUpdate = false;
    if (this.autoResize === true) {
      const pixelRatio = renderer.getPixelRatio();
      const size = renderer.getSize(_size$1);
      const effectiveWidth = size.width * pixelRatio;
      const effectiveHeight = size.height * pixelRatio;
      if (effectiveWidth !== this.renderTarget.width || effectiveHeight !== this.renderTarget.height) {
        this.renderTarget.setSize(effectiveWidth, effectiveHeight);
        this.textureNeedsUpdate = true;
      }
    }
    this._quadMesh.material.fragmentNode = this._rttNode;
    const currentRenderTarget = renderer.getRenderTarget();
    renderer.setRenderTarget(this.renderTarget);
    this._quadMesh.render(renderer);
    renderer.setRenderTarget(currentRenderTarget);
  }
  clone() {
    const newNode = new TextureNode(this.value, this.uvNode, this.levelNode);
    newNode.sampler = this.sampler;
    newNode.referenceNode = this;
    return newNode;
  }
};
var rtt = (node, ...params) => nodeObject(new RTTNode(nodeObject(node), ...params));
var convertToTexture = (node, ...params) => {
  if (node.isSampleNode || node.isTextureNode) return node;
  if (node.isPassNode) return node.getTextureNode();
  return rtt(node, ...params);
};
var getViewPosition = Fn(([screenPosition, depth3, projectionMatrixInverse], builder) => {
  let clipSpacePosition;
  if (builder.renderer.coordinateSystem === WebGPUCoordinateSystem) {
    screenPosition = vec2(screenPosition.x, screenPosition.y.oneMinus()).mul(2).sub(1);
    clipSpacePosition = vec4(vec3(screenPosition, depth3), 1);
  } else {
    clipSpacePosition = vec4(vec3(screenPosition.x, screenPosition.y.oneMinus(), depth3).mul(2).sub(1), 1);
  }
  const viewSpacePosition = vec4(projectionMatrixInverse.mul(clipSpacePosition));
  return viewSpacePosition.xyz.div(viewSpacePosition.w);
});
var getScreenPosition = Fn(([viewPosition, projectionMatrix]) => {
  const sampleClipPos = projectionMatrix.mul(vec4(viewPosition, 1));
  const sampleUv = sampleClipPos.xy.div(sampleClipPos.w).mul(0.5).add(0.5).toVar();
  return vec2(sampleUv.x, sampleUv.y.oneMinus());
});
var getNormalFromDepth = Fn(([uv3, depthTexture, projectionMatrixInverse]) => {
  const size = textureSize(textureLoad(depthTexture));
  const p = ivec2(uv3.mul(size)).toVar();
  const c0 = textureLoad(depthTexture, p).toVar();
  const l2 = textureLoad(depthTexture, p.sub(ivec2(2, 0))).toVar();
  const l1 = textureLoad(depthTexture, p.sub(ivec2(1, 0))).toVar();
  const r1 = textureLoad(depthTexture, p.add(ivec2(1, 0))).toVar();
  const r2 = textureLoad(depthTexture, p.add(ivec2(2, 0))).toVar();
  const b2 = textureLoad(depthTexture, p.add(ivec2(0, 2))).toVar();
  const b1 = textureLoad(depthTexture, p.add(ivec2(0, 1))).toVar();
  const t13 = textureLoad(depthTexture, p.sub(ivec2(0, 1))).toVar();
  const t22 = textureLoad(depthTexture, p.sub(ivec2(0, 2))).toVar();
  const dl = abs2(sub(float(2).mul(l1).sub(l2), c0)).toVar();
  const dr = abs2(sub(float(2).mul(r1).sub(r2), c0)).toVar();
  const db = abs2(sub(float(2).mul(b1).sub(b2), c0)).toVar();
  const dt = abs2(sub(float(2).mul(t13).sub(t22), c0)).toVar();
  const ce2 = getViewPosition(uv3, c0, projectionMatrixInverse).toVar();
  const dpdx = dl.lessThan(dr).select(ce2.sub(getViewPosition(uv3.sub(vec2(float(1).div(size.x), 0)), l1, projectionMatrixInverse)), ce2.negate().add(getViewPosition(uv3.add(vec2(float(1).div(size.x), 0)), r1, projectionMatrixInverse)));
  const dpdy = db.lessThan(dt).select(ce2.sub(getViewPosition(uv3.add(vec2(0, float(1).div(size.y))), b1, projectionMatrixInverse)), ce2.negate().add(getViewPosition(uv3.sub(vec2(0, float(1).div(size.y))), t13, projectionMatrixInverse)));
  return normalize2(cross2(dpdx, dpdy));
});
var SampleNode = class extends Node {
  /**
   * Returns the type of the node.
   *
   * @type {string}
   * @readonly
   * @static
   */
  static get type() {
    return "SampleNode";
  }
  /**
   * Creates an instance of SampleNode.
   *
   * @param {Function} callback - The function to be called when sampling. Should accept a UV node and return a value.
   * @param {?Node<vec2>} [uvNode=null] - The UV node to be used in the texture sampling.
   */
  constructor(callback, uvNode = null) {
    super();
    this.callback = callback;
    this.uvNode = uvNode;
    this.isSampleNode = true;
  }
  /**
   * Sets up the node by sampling with the default UV accessor.
   *
   * @returns {Node} The result of the callback function when called with the UV node.
   */
  setup() {
    return this.sample(uv$1());
  }
  /**
   * Calls the callback function with the provided UV node.
   *
   * @param {Node<vec2>} uv - The UV node or value to be passed to the callback.
   * @returns {Node} The result of the callback function.
   */
  sample(uv3) {
    return this.callback(uv3);
  }
};
var sample = (callback, uv3 = null) => nodeObject(new SampleNode(callback, nodeObject(uv3)));
var EventNode = class _EventNode extends Node {
  static get type() {
    return "EventNode";
  }
  /**
   * Creates an EventNode.
   *
   * @param {string} eventType - The type of event
   * @param {Function} callback - The callback to execute on update.
   */
  constructor(eventType, callback) {
    super("void");
    this.eventType = eventType;
    this.callback = callback;
    if (eventType === _EventNode.OBJECT) {
      this.updateType = NodeUpdateType.OBJECT;
    } else if (eventType === _EventNode.MATERIAL) {
      this.updateType = NodeUpdateType.RENDER;
    }
  }
  update(frame) {
    this.callback(frame);
  }
};
EventNode.OBJECT = "object";
EventNode.MATERIAL = "material";
var createEvent = (type, callback) => nodeObject(new EventNode(type, callback)).toStack();
var OnObjectUpdate = (callback) => createEvent(EventNode.OBJECT, callback);
var OnMaterialUpdate = (callback) => createEvent(EventNode.MATERIAL, callback);
var StorageInstancedBufferAttribute = class extends InstancedBufferAttribute {
  /**
   * Constructs a new storage instanced buffer attribute.
   *
   * @param {number|TypedArray} count - The item count. It is also valid to pass a typed array as an argument.
   * The subsequent parameters are then obsolete.
   * @param {number} itemSize - The item size.
   * @param {TypedArray.constructor} [typeClass=Float32Array] - A typed array constructor.
   */
  constructor(count2, itemSize, typeClass = Float32Array) {
    const array4 = ArrayBuffer.isView(count2) ? count2 : new typeClass(count2 * itemSize);
    super(array4, itemSize);
    this.isStorageInstancedBufferAttribute = true;
  }
};
var StorageBufferAttribute = class extends BufferAttribute {
  /**
   * Constructs a new storage buffer attribute.
   *
   * @param {number|TypedArray} count - The item count. It is also valid to pass a typed array as an argument.
   * The subsequent parameters are then obsolete.
   * @param {number} itemSize - The item size.
   * @param {TypedArray.constructor} [typeClass=Float32Array] - A typed array constructor.
   */
  constructor(count2, itemSize, typeClass = Float32Array) {
    const array4 = ArrayBuffer.isView(count2) ? count2 : new typeClass(count2 * itemSize);
    super(array4, itemSize);
    this.isStorageBufferAttribute = true;
  }
};
var attributeArray = (count2, type = "float") => {
  let itemSize, typedArray;
  if (type.isStruct === true) {
    itemSize = type.layout.getLength();
    typedArray = getTypedArrayFromType("float");
  } else {
    itemSize = getLengthFromType(type);
    typedArray = getTypedArrayFromType(type);
  }
  const buffer3 = new StorageBufferAttribute(count2, itemSize, typedArray);
  const node = storage(buffer3, type, count2);
  return node;
};
var instancedArray = (count2, type = "float") => {
  let itemSize, typedArray;
  if (type.isStruct === true) {
    itemSize = type.layout.getLength();
    typedArray = getTypedArrayFromType("float");
  } else {
    itemSize = getLengthFromType(type);
    typedArray = getTypedArrayFromType(type);
  }
  const buffer3 = new StorageInstancedBufferAttribute(count2, itemSize, typedArray);
  const node = storage(buffer3, type, count2);
  return node;
};
var PointUVNode = class extends Node {
  static get type() {
    return "PointUVNode";
  }
  /**
   * Constructs a new point uv node.
   */
  constructor() {
    super("vec2");
    this.isPointUVNode = true;
  }
  generate() {
    return "vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y )";
  }
};
var pointUV = nodeImmutable(PointUVNode);
var _e1 = new Euler();
var _m1 = new Matrix4();
var SceneNode = class _SceneNode extends Node {
  static get type() {
    return "SceneNode";
  }
  /**
   * Constructs a new scene node.
   *
   * @param {('backgroundBlurriness'|'backgroundIntensity'|'backgroundRotation')} scope - The scope defines the type of scene property that is accessed.
   * @param {?Scene} [scene=null] - A reference to the scene.
   */
  constructor(scope = _SceneNode.BACKGROUND_BLURRINESS, scene = null) {
    super();
    this.scope = scope;
    this.scene = scene;
  }
  /**
   * Depending on the scope, the method returns a different type of node that represents
   * the respective scene property.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {Node} The output node.
   */
  setup(builder) {
    const scope = this.scope;
    const scene = this.scene !== null ? this.scene : builder.scene;
    let output3;
    if (scope === _SceneNode.BACKGROUND_BLURRINESS) {
      output3 = reference("backgroundBlurriness", "float", scene);
    } else if (scope === _SceneNode.BACKGROUND_INTENSITY) {
      output3 = reference("backgroundIntensity", "float", scene);
    } else if (scope === _SceneNode.BACKGROUND_ROTATION) {
      output3 = uniform("mat4").setName("backgroundRotation").setGroup(renderGroup).onRenderUpdate(() => {
        const background = scene.background;
        if (background !== null && background.isTexture && background.mapping !== UVMapping) {
          _e1.copy(scene.backgroundRotation);
          _e1.x *= -1;
          _e1.y *= -1;
          _e1.z *= -1;
          _m1.makeRotationFromEuler(_e1);
        } else {
          _m1.identity();
        }
        return _m1;
      });
    } else {
      console.error("THREE.SceneNode: Unknown scope:", scope);
    }
    return output3;
  }
};
SceneNode.BACKGROUND_BLURRINESS = "backgroundBlurriness";
SceneNode.BACKGROUND_INTENSITY = "backgroundIntensity";
SceneNode.BACKGROUND_ROTATION = "backgroundRotation";
var backgroundBlurriness = nodeImmutable(SceneNode, SceneNode.BACKGROUND_BLURRINESS);
var backgroundIntensity = nodeImmutable(SceneNode, SceneNode.BACKGROUND_INTENSITY);
var backgroundRotation = nodeImmutable(SceneNode, SceneNode.BACKGROUND_ROTATION);
var StorageTextureNode = class extends TextureNode {
  static get type() {
    return "StorageTextureNode";
  }
  /**
   * Constructs a new storage texture node.
   *
   * @param {StorageTexture} value - The storage texture.
   * @param {Node<vec2|vec3>} uvNode - The uv node.
   * @param {?Node} [storeNode=null] - The value node that should be stored in the texture.
   */
  constructor(value, uvNode, storeNode = null) {
    super(value, uvNode);
    this.storeNode = storeNode;
    this.isStorageTextureNode = true;
    this.access = NodeAccess.WRITE_ONLY;
  }
  /**
   * Overwrites the default implementation to return a fixed value `'storageTexture'`.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The input type.
   */
  getInputType() {
    return "storageTexture";
  }
  setup(builder) {
    super.setup(builder);
    const properties = builder.getNodeProperties(this);
    properties.storeNode = this.storeNode;
    return properties;
  }
  /**
   * Defines the node access.
   *
   * @param {string} value - The node access.
   * @return {StorageTextureNode} A reference to this node.
   */
  setAccess(value) {
    this.access = value;
    return this;
  }
  /**
   * Generates the code snippet of the storage node. If no `storeNode`
   * is defined, the texture node is generated as normal texture.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {string} output - The current output.
   * @return {string} The generated code snippet.
   */
  generate(builder, output3) {
    let snippet;
    if (this.storeNode !== null) {
      snippet = this.generateStore(builder);
    } else {
      snippet = super.generate(builder, output3);
    }
    return snippet;
  }
  /**
   * Convenience method for configuring a read/write node access.
   *
   * @return {StorageTextureNode} A reference to this node.
   */
  toReadWrite() {
    return this.setAccess(NodeAccess.READ_WRITE);
  }
  /**
   * Convenience method for configuring a read-only node access.
   *
   * @return {StorageTextureNode} A reference to this node.
   */
  toReadOnly() {
    return this.setAccess(NodeAccess.READ_ONLY);
  }
  /**
   * Convenience method for configuring a write-only node access.
   *
   * @return {StorageTextureNode} A reference to this node.
   */
  toWriteOnly() {
    return this.setAccess(NodeAccess.WRITE_ONLY);
  }
  /**
   * Generates the code snippet of the storage texture node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  generateStore(builder) {
    const properties = builder.getNodeProperties(this);
    const { uvNode, storeNode, depthNode } = properties;
    const textureProperty = super.generate(builder, "property");
    const uvSnippet = uvNode.build(builder, this.value.is3DTexture === true ? "uvec3" : "uvec2");
    const storeSnippet = storeNode.build(builder, "vec4");
    const depthSnippet = depthNode ? depthNode.build(builder, "int") : null;
    const snippet = builder.generateTextureStore(builder, textureProperty, uvSnippet, depthSnippet, storeSnippet);
    builder.addLineFlowCode(snippet, this);
  }
  clone() {
    const newNode = super.clone();
    newNode.storeNode = this.storeNode;
    return newNode;
  }
};
var storageTexture = nodeProxy(StorageTextureNode).setParameterLength(1, 3);
var textureStore = (value, uvNode, storeNode) => {
  const node = storageTexture(value, uvNode, storeNode);
  if (storeNode !== null) node.toStack();
  return node;
};
var normal = Fn(({ texture: texture3, uv: uv3 }) => {
  const epsilon5 = 1e-4;
  const ret = vec3().toVar();
  If(uv3.x.lessThan(epsilon5), () => {
    ret.assign(vec3(1, 0, 0));
  }).ElseIf(uv3.y.lessThan(epsilon5), () => {
    ret.assign(vec3(0, 1, 0));
  }).ElseIf(uv3.z.lessThan(epsilon5), () => {
    ret.assign(vec3(0, 0, 1));
  }).ElseIf(uv3.x.greaterThan(1 - epsilon5), () => {
    ret.assign(vec3(-1, 0, 0));
  }).ElseIf(uv3.y.greaterThan(1 - epsilon5), () => {
    ret.assign(vec3(0, -1, 0));
  }).ElseIf(uv3.z.greaterThan(1 - epsilon5), () => {
    ret.assign(vec3(0, 0, -1));
  }).Else(() => {
    const step3 = 0.01;
    const x = texture3.sample(uv3.add(vec3(-step3, 0, 0))).r.sub(texture3.sample(uv3.add(vec3(step3, 0, 0))).r);
    const y = texture3.sample(uv3.add(vec3(0, -step3, 0))).r.sub(texture3.sample(uv3.add(vec3(0, step3, 0))).r);
    const z = texture3.sample(uv3.add(vec3(0, 0, -step3))).r.sub(texture3.sample(uv3.add(vec3(0, 0, step3))).r);
    ret.assign(vec3(x, y, z));
  });
  return ret.normalize();
});
var Texture3DNode = class extends TextureNode {
  static get type() {
    return "Texture3DNode";
  }
  /**
   * Constructs a new 3D texture node.
   *
   * @param {Data3DTexture} value - The 3D texture.
   * @param {?Node<vec2|vec3>} [uvNode=null] - The uv node.
   * @param {?Node<int>} [levelNode=null] - The level node.
   */
  constructor(value, uvNode = null, levelNode = null) {
    super(value, uvNode, levelNode);
    this.isTexture3DNode = true;
  }
  /**
   * Overwrites the default implementation to return a fixed value `'texture3D'`.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The input type.
   */
  getInputType() {
    return "texture3D";
  }
  /**
   * Returns a default uv node which is in context of 3D textures a three-dimensional
   * uv node.
   *
   * @return {Node<vec3>} The default uv node.
   */
  getDefaultUV() {
    return vec3(0.5, 0.5, 0.5);
  }
  /**
   * Overwritten with an empty implementation since the `updateMatrix` flag is ignored
   * for 3D textures. The uv transformation matrix is not applied to 3D textures.
   *
   * @param {boolean} value - The update toggle.
   */
  setUpdateMatrix() {
  }
  // Ignore .updateMatrix for 3d TextureNode
  /**
   * Overwrites the default implementation to return the unmodified uv node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {Node} uvNode - The uv node to setup.
   * @return {Node} The unmodified uv node.
   */
  setupUV(builder, uvNode) {
    const texture3 = this.value;
    if (builder.isFlipY() && (texture3.isRenderTargetTexture === true || texture3.isFramebufferTexture === true)) {
      if (this.sampler) {
        uvNode = uvNode.flipY();
      } else {
        uvNode = uvNode.setY(int(textureSize(this, this.levelNode).y).sub(uvNode.y).sub(1));
      }
    }
    return uvNode;
  }
  /**
   * Generates the uv code snippet.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {Node} uvNode - The uv node to generate code for.
   * @return {string} The generated code snippet.
   */
  generateUV(builder, uvNode) {
    return uvNode.build(builder, "vec3");
  }
  /**
   * Generates the offset code snippet.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {Node} offsetNode - The offset node to generate code for.
   * @return {string} The generated code snippet.
   */
  generateOffset(builder, offsetNode) {
    return offsetNode.build(builder, "ivec3");
  }
  /**
   * TODO.
   *
   * @param {Node<vec3>} uvNode - The uv node .
   * @return {Node<vec3>} TODO.
   */
  normal(uvNode) {
    return normal({ texture: this, uv: uvNode });
  }
};
var texture3D = nodeProxy(Texture3DNode).setParameterLength(1, 3);
var UserDataNode = class extends ReferenceNode {
  static get type() {
    return "UserDataNode";
  }
  /**
   * Constructs a new user data node.
   *
   * @param {string} property - The property name that should be referenced by the node.
   * @param {string} inputType - The node data type of the reference.
   * @param {?Object} [userData=null] - A reference to the `userData` object. If not provided, the `userData` property of the 3D object that uses the node material is evaluated.
   */
  constructor(property3, inputType, userData3 = null) {
    super(property3, inputType, userData3);
    this.userData = userData3;
  }
  /**
   * Overwritten to make sure {@link ReferenceNode#reference} points to the correct
   * `userData` field.
   *
   * @param {(NodeFrame|NodeBuilder)} state - The current state to evaluate.
   * @return {Object} A reference to the `userData` field.
   */
  updateReference(state) {
    this.reference = this.userData !== null ? this.userData : state.object.userData;
    return this.reference;
  }
};
var userData = (name, inputType, userData3) => nodeObject(new UserDataNode(name, inputType, userData3));
var _objectData = /* @__PURE__ */ new WeakMap();
var VelocityNode = class extends TempNode {
  static get type() {
    return "VelocityNode";
  }
  /**
   * Constructs a new vertex color node.
   */
  constructor() {
    super("vec2");
    this.projectionMatrix = null;
    this.updateType = NodeUpdateType.OBJECT;
    this.updateAfterType = NodeUpdateType.OBJECT;
    this.previousModelWorldMatrix = uniform(new Matrix4());
    this.previousProjectionMatrix = uniform(new Matrix4()).setGroup(renderGroup);
    this.previousCameraViewMatrix = uniform(new Matrix4());
  }
  /**
   * Sets the given projection matrix.
   *
   * @param {Matrix4} projectionMatrix - The projection matrix to set.
   */
  setProjectionMatrix(projectionMatrix) {
    this.projectionMatrix = projectionMatrix;
  }
  /**
   * Updates velocity specific uniforms.
   *
   * @param {NodeFrame} frame - A reference to the current node frame.
   */
  update({ frameId: frameId3, camera, object: object2 }) {
    const previousModelMatrix = getPreviousMatrix(object2);
    this.previousModelWorldMatrix.value.copy(previousModelMatrix);
    const cameraData = getData(camera);
    if (cameraData.frameId !== frameId3) {
      cameraData.frameId = frameId3;
      if (cameraData.previousProjectionMatrix === void 0) {
        cameraData.previousProjectionMatrix = new Matrix4();
        cameraData.previousCameraViewMatrix = new Matrix4();
        cameraData.currentProjectionMatrix = new Matrix4();
        cameraData.currentCameraViewMatrix = new Matrix4();
        cameraData.previousProjectionMatrix.copy(this.projectionMatrix || camera.projectionMatrix);
        cameraData.previousCameraViewMatrix.copy(camera.matrixWorldInverse);
      } else {
        cameraData.previousProjectionMatrix.copy(cameraData.currentProjectionMatrix);
        cameraData.previousCameraViewMatrix.copy(cameraData.currentCameraViewMatrix);
      }
      cameraData.currentProjectionMatrix.copy(this.projectionMatrix || camera.projectionMatrix);
      cameraData.currentCameraViewMatrix.copy(camera.matrixWorldInverse);
      this.previousProjectionMatrix.value.copy(cameraData.previousProjectionMatrix);
      this.previousCameraViewMatrix.value.copy(cameraData.previousCameraViewMatrix);
    }
  }
  /**
   * Overwritten to updated velocity specific uniforms.
   *
   * @param {NodeFrame} frame - A reference to the current node frame.
   */
  updateAfter({ object: object2 }) {
    getPreviousMatrix(object2).copy(object2.matrixWorld);
  }
  /**
   * Implements the velocity computation based on the previous and current vertex data.
   *
   * @param {NodeBuilder} builder - A reference to the current node builder.
   * @return {Node<vec2>} The motion vector.
   */
  setup() {
    const projectionMatrix = this.projectionMatrix === null ? cameraProjectionMatrix : uniform(this.projectionMatrix);
    const previousModelViewMatrix = this.previousCameraViewMatrix.mul(this.previousModelWorldMatrix);
    const clipPositionCurrent = projectionMatrix.mul(modelViewMatrix).mul(positionLocal);
    const clipPositionPrevious = this.previousProjectionMatrix.mul(previousModelViewMatrix).mul(positionPrevious);
    const ndcPositionCurrent = clipPositionCurrent.xy.div(clipPositionCurrent.w);
    const ndcPositionPrevious = clipPositionPrevious.xy.div(clipPositionPrevious.w);
    const velocity3 = sub(ndcPositionCurrent, ndcPositionPrevious);
    return velocity3;
  }
};
function getData(object2) {
  let objectData = _objectData.get(object2);
  if (objectData === void 0) {
    objectData = {};
    _objectData.set(object2, objectData);
  }
  return objectData;
}
function getPreviousMatrix(object2, index5 = 0) {
  const objectData = getData(object2);
  let matrix = objectData[index5];
  if (matrix === void 0) {
    objectData[index5] = matrix = new Matrix4();
    objectData[index5].copy(object2.matrixWorld);
  }
  return matrix;
}
var velocity = nodeImmutable(VelocityNode);
var grayscale = Fn(([color4]) => {
  return luminance(color4.rgb);
});
var saturation = Fn(([color4, adjustment = float(1)]) => {
  return adjustment.mix(luminance(color4.rgb), color4.rgb);
});
var vibrance = Fn(([color4, adjustment = float(1)]) => {
  const average = add3(color4.r, color4.g, color4.b).div(3);
  const mx = color4.r.max(color4.g.max(color4.b));
  const amt = mx.sub(average).mul(adjustment).mul(-3);
  return mix(color4.rgb, mx, amt);
});
var hue2 = Fn(([color4, adjustment = float(1)]) => {
  const k = vec3(0.57735, 0.57735, 0.57735);
  const cosAngle = adjustment.cos();
  return vec3(color4.rgb.mul(cosAngle).add(k.cross(color4.rgb).mul(adjustment.sin()).add(k.mul(dot(k, color4.rgb).mul(cosAngle.oneMinus())))));
});
var luminance = (color4, luminanceCoefficients = vec3(ColorManagement.getLuminanceCoefficients(new Vector3()))) => dot(color4, luminanceCoefficients);
var cdl = Fn(([
  color4,
  slope = vec3(1),
  offset = vec3(0),
  power = vec3(1),
  saturation3 = float(1),
  // ASC CDL v1.2 explicitly requires Rec. 709 luminance coefficients.
  luminanceCoefficients = vec3(ColorManagement.getLuminanceCoefficients(new Vector3(), LinearSRGBColorSpace))
]) => {
  const luma = color4.rgb.dot(vec3(luminanceCoefficients));
  const v2 = max$1(color4.rgb.mul(slope).add(offset), 0).toVar();
  const pv = v2.pow(power).toVar();
  If(v2.r.greaterThan(0), () => {
    v2.r.assign(pv.r);
  });
  If(v2.g.greaterThan(0), () => {
    v2.g.assign(pv.g);
  });
  If(v2.b.greaterThan(0), () => {
    v2.b.assign(pv.b);
  });
  v2.assign(luma.add(v2.sub(luma).mul(saturation3)));
  return vec4(v2.rgb, color4.a);
});
var PosterizeNode = class extends TempNode {
  static get type() {
    return "PosterizeNode";
  }
  /**
   * Constructs a new posterize node.
   *
   * @param {Node} sourceNode - The input color.
   * @param {Node} stepsNode - Controls the intensity of the posterization effect. A lower number results in a more blocky appearance.
   */
  constructor(sourceNode, stepsNode) {
    super();
    this.sourceNode = sourceNode;
    this.stepsNode = stepsNode;
  }
  setup() {
    const { sourceNode, stepsNode } = this;
    return sourceNode.mul(stepsNode).floor().div(stepsNode);
  }
};
var posterize = nodeProxy(PosterizeNode).setParameterLength(2);
var _size = new Vector2();
var PassTextureNode = class extends TextureNode {
  static get type() {
    return "PassTextureNode";
  }
  /**
   * Constructs a new pass texture node.
   *
   * @param {PassNode} passNode - The pass node.
   * @param {Texture} texture - The output texture.
   */
  constructor(passNode, texture3) {
    super(texture3);
    this.passNode = passNode;
    this.setUpdateMatrix(false);
  }
  setup(builder) {
    this.passNode.build(builder);
    return super.setup(builder);
  }
  clone() {
    return new this.constructor(this.passNode, this.value);
  }
};
var PassMultipleTextureNode = class extends PassTextureNode {
  static get type() {
    return "PassMultipleTextureNode";
  }
  /**
   * Constructs a new pass texture node.
   *
   * @param {PassNode} passNode - The pass node.
   * @param {string} textureName - The output texture name.
   * @param {boolean} [previousTexture=false] - Whether previous frame data should be used or not.
   */
  constructor(passNode, textureName, previousTexture = false) {
    super(passNode, null);
    this.textureName = textureName;
    this.previousTexture = previousTexture;
  }
  /**
   * Updates the texture reference of this node.
   */
  updateTexture() {
    this.value = this.previousTexture ? this.passNode.getPreviousTexture(this.textureName) : this.passNode.getTexture(this.textureName);
  }
  setup(builder) {
    this.updateTexture();
    return super.setup(builder);
  }
  clone() {
    const newNode = new this.constructor(this.passNode, this.textureName, this.previousTexture);
    newNode.uvNode = this.uvNode;
    newNode.levelNode = this.levelNode;
    newNode.biasNode = this.biasNode;
    newNode.sampler = this.sampler;
    newNode.depthNode = this.depthNode;
    newNode.compareNode = this.compareNode;
    newNode.gradNode = this.gradNode;
    return newNode;
  }
};
var PassNode = class _PassNode extends TempNode {
  static get type() {
    return "PassNode";
  }
  /**
   * Constructs a new pass node.
   *
   * @param {('color'|'depth')} scope - The scope of the pass. The scope determines whether the node outputs color or depth.
   * @param {Scene} scene - A reference to the scene.
   * @param {Camera} camera - A reference to the camera.
   * @param {Object} options - Options for the internal render target.
   */
  constructor(scope, scene, camera, options = {}) {
    super("vec4");
    this.scope = scope;
    this.scene = scene;
    this.camera = camera;
    this.options = options;
    this._pixelRatio = 1;
    this._width = 1;
    this._height = 1;
    const depthTexture = new DepthTexture();
    depthTexture.isRenderTargetTexture = true;
    depthTexture.name = "depth";
    const renderTarget = new RenderTarget(this._width * this._pixelRatio, this._height * this._pixelRatio, { type: HalfFloatType, ...options });
    renderTarget.texture.name = "output";
    renderTarget.depthTexture = depthTexture;
    this.renderTarget = renderTarget;
    this._textures = {
      output: renderTarget.texture,
      depth: depthTexture
    };
    this._textureNodes = {};
    this._linearDepthNodes = {};
    this._viewZNodes = {};
    this._previousTextures = {};
    this._previousTextureNodes = {};
    this._cameraNear = uniform(0);
    this._cameraFar = uniform(0);
    this._mrt = null;
    this._layers = null;
    this._resolution = 1;
    this._viewport = null;
    this._scissor = null;
    this.isPassNode = true;
    this.updateBeforeType = NodeUpdateType.FRAME;
    this.global = true;
  }
  /**
   * Sets the resolution for the pass.
   * The resolution is a factor that is multiplied with the renderer's width and height.
   *
   * @param {number} resolution - The resolution to set. A value of `1` means full resolution.
   * @return {PassNode} A reference to this pass.
   */
  setResolution(resolution2) {
    this._resolution = resolution2;
    return this;
  }
  /**
   * Gets the current resolution of the pass.
   *
   * @return {number} The current resolution. A value of `1` means full resolution.
   */
  getResolution() {
    return this._resolution;
  }
  /**
   * Sets the layer configuration that should be used when rendering the pass.
   *
   * @param {Layers} layers - The layers object to set.
   * @return {PassNode} A reference to this pass.
   */
  setLayers(layers2) {
    this._layers = layers2;
    return this;
  }
  /**
   * Gets the current layer configuration of the pass.
   *
   * @return {?Layers} .
   */
  getLayers() {
    return this._layers;
  }
  /**
   * Sets the given MRT node to setup MRT for this pass.
   *
   * @param {MRTNode} mrt - The MRT object.
   * @return {PassNode} A reference to this pass.
   */
  setMRT(mrt3) {
    this._mrt = mrt3;
    return this;
  }
  /**
   * Returns the current MRT node.
   *
   * @return {MRTNode} The current MRT node.
   */
  getMRT() {
    return this._mrt;
  }
  /**
   * Returns the texture for the given output name.
   *
   * @param {string} name - The output name to get the texture for.
   * @return {Texture} The texture.
   */
  getTexture(name) {
    let texture3 = this._textures[name];
    if (texture3 === void 0) {
      const refTexture = this.renderTarget.texture;
      texture3 = refTexture.clone();
      texture3.name = name;
      this._textures[name] = texture3;
      this.renderTarget.textures.push(texture3);
    }
    return texture3;
  }
  /**
   * Returns the texture holding the data of the previous frame for the given output name.
   *
   * @param {string} name - The output name to get the texture for.
   * @return {Texture} The texture holding the data of the previous frame.
   */
  getPreviousTexture(name) {
    let texture3 = this._previousTextures[name];
    if (texture3 === void 0) {
      texture3 = this.getTexture(name).clone();
      this._previousTextures[name] = texture3;
    }
    return texture3;
  }
  /**
   * Switches current and previous textures for the given output name.
   *
   * @param {string} name - The output name.
   */
  toggleTexture(name) {
    const prevTexture = this._previousTextures[name];
    if (prevTexture !== void 0) {
      const texture3 = this._textures[name];
      const index5 = this.renderTarget.textures.indexOf(texture3);
      this.renderTarget.textures[index5] = prevTexture;
      this._textures[name] = prevTexture;
      this._previousTextures[name] = texture3;
      this._textureNodes[name].updateTexture();
      this._previousTextureNodes[name].updateTexture();
    }
  }
  /**
   * Returns the texture node for the given output name.
   *
   * @param {string} [name='output'] - The output name to get the texture node for.
   * @return {TextureNode} The texture node.
   */
  getTextureNode(name = "output") {
    let textureNode = this._textureNodes[name];
    if (textureNode === void 0) {
      textureNode = nodeObject(new PassMultipleTextureNode(this, name));
      textureNode.updateTexture();
      this._textureNodes[name] = textureNode;
    }
    return textureNode;
  }
  /**
   * Returns the previous texture node for the given output name.
   *
   * @param {string} [name='output'] - The output name to get the previous texture node for.
   * @return {TextureNode} The previous texture node.
   */
  getPreviousTextureNode(name = "output") {
    let textureNode = this._previousTextureNodes[name];
    if (textureNode === void 0) {
      if (this._textureNodes[name] === void 0) this.getTextureNode(name);
      textureNode = nodeObject(new PassMultipleTextureNode(this, name, true));
      textureNode.updateTexture();
      this._previousTextureNodes[name] = textureNode;
    }
    return textureNode;
  }
  /**
   * Returns a viewZ node of this pass.
   *
   * @param {string} [name='depth'] - The output name to get the viewZ node for. In most cases the default `'depth'` can be used however the parameter exists for custom depth outputs.
   * @return {Node} The viewZ node.
   */
  getViewZNode(name = "depth") {
    let viewZNode = this._viewZNodes[name];
    if (viewZNode === void 0) {
      const cameraNear3 = this._cameraNear;
      const cameraFar3 = this._cameraFar;
      this._viewZNodes[name] = viewZNode = perspectiveDepthToViewZ(this.getTextureNode(name), cameraNear3, cameraFar3);
    }
    return viewZNode;
  }
  /**
   * Returns a linear depth node of this pass.
   *
   * @param {string} [name='depth'] - The output name to get the linear depth node for. In most cases the default `'depth'` can be used however the parameter exists for custom depth outputs.
   * @return {Node} The linear depth node.
   */
  getLinearDepthNode(name = "depth") {
    let linearDepthNode = this._linearDepthNodes[name];
    if (linearDepthNode === void 0) {
      const cameraNear3 = this._cameraNear;
      const cameraFar3 = this._cameraFar;
      const viewZNode = this.getViewZNode(name);
      this._linearDepthNodes[name] = linearDepthNode = viewZToOrthographicDepth(viewZNode, cameraNear3, cameraFar3);
    }
    return linearDepthNode;
  }
  /**
   * Precompiles the pass.
   *
   * Note that this method must be called after the pass configuration is complete.
   * So calls like `setMRT()` and `getTextureNode()` must proceed the precompilation.
   *
   * @async
   * @param {Renderer} renderer - The renderer.
   * @return {Promise} A Promise that resolves when the compile has been finished.
   * @see {@link Renderer#compileAsync}
   */
  async compileAsync(renderer) {
    const currentRenderTarget = renderer.getRenderTarget();
    const currentMRT = renderer.getMRT();
    renderer.setRenderTarget(this.renderTarget);
    renderer.setMRT(this._mrt);
    await renderer.compileAsync(this.scene, this.camera);
    renderer.setRenderTarget(currentRenderTarget);
    renderer.setMRT(currentMRT);
  }
  setup({ renderer }) {
    this.renderTarget.samples = this.options.samples === void 0 ? renderer.samples : this.options.samples;
    this.renderTarget.texture.type = renderer.getColorBufferType();
    return this.scope === _PassNode.COLOR ? this.getTextureNode() : this.getLinearDepthNode();
  }
  updateBefore(frame) {
    const { renderer } = frame;
    const { scene } = this;
    let camera;
    let pixelRatio;
    const outputRenderTarget = renderer.getOutputRenderTarget();
    if (outputRenderTarget && outputRenderTarget.isXRRenderTarget === true) {
      pixelRatio = 1;
      camera = renderer.xr.getCamera();
      renderer.xr.updateCamera(camera);
      _size.set(outputRenderTarget.width, outputRenderTarget.height);
    } else {
      camera = this.camera;
      pixelRatio = renderer.getPixelRatio();
      renderer.getSize(_size);
    }
    this._pixelRatio = pixelRatio;
    this.setSize(_size.width, _size.height);
    const currentRenderTarget = renderer.getRenderTarget();
    const currentMRT = renderer.getMRT();
    const currentMask = camera.layers.mask;
    this._cameraNear.value = camera.near;
    this._cameraFar.value = camera.far;
    if (this._layers !== null) {
      camera.layers.mask = this._layers.mask;
    }
    for (const name in this._previousTextures) {
      this.toggleTexture(name);
    }
    renderer.setRenderTarget(this.renderTarget);
    renderer.setMRT(this._mrt);
    renderer.render(scene, camera);
    renderer.setRenderTarget(currentRenderTarget);
    renderer.setMRT(currentMRT);
    camera.layers.mask = currentMask;
  }
  /**
   * Sets the size of the pass's render target. Honors the pixel ratio.
   *
   * @param {number} width - The width to set.
   * @param {number} height - The height to set.
   */
  setSize(width, height) {
    this._width = width;
    this._height = height;
    const effectiveWidth = this._width * this._pixelRatio * this._resolution;
    const effectiveHeight = this._height * this._pixelRatio * this._resolution;
    this.renderTarget.setSize(effectiveWidth, effectiveHeight);
    if (this._scissor !== null) this.renderTarget.scissor.copy(this._scissor);
    if (this._viewport !== null) this.renderTarget.viewport.copy(this._viewport);
  }
  /**
   * This method allows to define the pass's scissor rectangle. By default, the scissor rectangle is kept
   * in sync with the pass's dimensions. To reverse the process and use auto-sizing again, call the method
   * with `null` as the single argument.
   *
   * @param {?(number | Vector4)} x - The horizontal coordinate for the lower left corner of the box in logical pixel unit.
   * Instead of passing four arguments, the method also works with a single four-dimensional vector.
   * @param {number} y - The vertical coordinate for the lower left corner of the box in logical pixel unit.
   * @param {number} width - The width of the scissor box in logical pixel unit.
   * @param {number} height - The height of the scissor box in logical pixel unit.
   */
  setScissor(x, y, width, height) {
    if (x === null) {
      this._scissor = null;
    } else {
      if (this._scissor === null) this._scissor = new Vector4();
      if (x.isVector4) {
        this._scissor.copy(x);
      } else {
        this._scissor.set(x, y, width, height);
      }
      this._scissor.multiplyScalar(this._pixelRatio * this._resolution).floor();
    }
  }
  /**
   * This method allows to define the pass's viewport. By default, the viewport is kept in sync
   * with the pass's dimensions. To reverse the process and use auto-sizing again, call the method
   * with `null` as the single argument.
   *
   * @param {number | Vector4} x - The horizontal coordinate for the lower left corner of the viewport origin in logical pixel unit.
   * @param {number} y - The vertical coordinate for the lower left corner of the viewport origin  in logical pixel unit.
   * @param {number} width - The width of the viewport in logical pixel unit.
   * @param {number} height - The height of the viewport in logical pixel unit.
   */
  setViewport(x, y, width, height) {
    if (x === null) {
      this._viewport = null;
    } else {
      if (this._viewport === null) this._viewport = new Vector4();
      if (x.isVector4) {
        this._viewport.copy(x);
      } else {
        this._viewport.set(x, y, width, height);
      }
      this._viewport.multiplyScalar(this._pixelRatio * this._resolution).floor();
    }
  }
  /**
   * Sets the pixel ratio the pass's render target and updates the size.
   *
   * @param {number} pixelRatio - The pixel ratio to set.
   */
  setPixelRatio(pixelRatio) {
    this._pixelRatio = pixelRatio;
    this.setSize(this._width, this._height);
  }
  /**
   * Frees internal resources. Should be called when the node is no longer in use.
   */
  dispose() {
    this.renderTarget.dispose();
  }
};
PassNode.COLOR = "color";
PassNode.DEPTH = "depth";
var pass = (scene, camera, options) => nodeObject(new PassNode(PassNode.COLOR, scene, camera, options));
var passTexture = (pass3, texture3) => nodeObject(new PassTextureNode(pass3, texture3));
var depthPass = (scene, camera, options) => nodeObject(new PassNode(PassNode.DEPTH, scene, camera, options));
var ToonOutlinePassNode = class extends PassNode {
  static get type() {
    return "ToonOutlinePassNode";
  }
  /**
   * Constructs a new outline pass node.
   *
   * @param {Scene} scene - A reference to the scene.
   * @param {Camera} camera - A reference to the camera.
   * @param {Node} colorNode - Defines the outline's color.
   * @param {Node} thicknessNode - Defines the outline's thickness.
   * @param {Node} alphaNode - Defines the outline's alpha.
   */
  constructor(scene, camera, colorNode, thicknessNode, alphaNode) {
    super(PassNode.COLOR, scene, camera);
    this.colorNode = colorNode;
    this.thicknessNode = thicknessNode;
    this.alphaNode = alphaNode;
    this._materialCache = /* @__PURE__ */ new WeakMap();
  }
  updateBefore(frame) {
    const { renderer } = frame;
    const currentRenderObjectFunction = renderer.getRenderObjectFunction();
    renderer.setRenderObjectFunction((object2, scene, camera, geometry, material, group2, lightsNode, clippingContext) => {
      if (material.isMeshToonMaterial || material.isMeshToonNodeMaterial) {
        if (material.wireframe === false) {
          const outlineMaterial = this._getOutlineMaterial(material);
          renderer.renderObject(object2, scene, camera, geometry, outlineMaterial, group2, lightsNode, clippingContext);
        }
      }
      renderer.renderObject(object2, scene, camera, geometry, material, group2, lightsNode, clippingContext);
    });
    super.updateBefore(frame);
    renderer.setRenderObjectFunction(currentRenderObjectFunction);
  }
  /**
   * Creates the material used for outline rendering.
   *
   * @private
   * @return {NodeMaterial} The outline material.
   */
  _createMaterial() {
    const material = new NodeMaterial();
    material.isMeshToonOutlineMaterial = true;
    material.name = "Toon_Outline";
    material.side = BackSide;
    const outlineNormal = normalLocal.negate();
    const mvp = cameraProjectionMatrix.mul(modelViewMatrix);
    const ratio = float(1);
    const pos = mvp.mul(vec4(positionLocal, 1));
    const pos2 = mvp.mul(vec4(positionLocal.add(outlineNormal), 1));
    const norm = normalize2(pos.sub(pos2));
    material.vertexNode = pos.add(norm.mul(this.thicknessNode).mul(pos.w).mul(ratio));
    material.colorNode = vec4(this.colorNode, this.alphaNode);
    return material;
  }
  /**
   * For the given toon material, this method returns a corresponding
   * outline material.
   *
   * @private
   * @param {(MeshToonMaterial|MeshToonNodeMaterial)} originalMaterial - The toon material.
   * @return {NodeMaterial} The outline material.
   */
  _getOutlineMaterial(originalMaterial) {
    let outlineMaterial = this._materialCache.get(originalMaterial);
    if (outlineMaterial === void 0) {
      outlineMaterial = this._createMaterial();
      this._materialCache.set(originalMaterial, outlineMaterial);
    }
    return outlineMaterial;
  }
};
var toonOutlinePass = (scene, camera, color4 = new Color(0, 0, 0), thickness3 = 3e-3, alpha = 1) => nodeObject(new ToonOutlinePassNode(scene, camera, nodeObject(color4), nodeObject(thickness3), nodeObject(alpha)));
var linearToneMapping = Fn(([color4, exposure]) => {
  return color4.mul(exposure).clamp();
}).setLayout({
  name: "linearToneMapping",
  type: "vec3",
  inputs: [
    { name: "color", type: "vec3" },
    { name: "exposure", type: "float" }
  ]
});
var reinhardToneMapping = Fn(([color4, exposure]) => {
  color4 = color4.mul(exposure);
  return color4.div(color4.add(1)).clamp();
}).setLayout({
  name: "reinhardToneMapping",
  type: "vec3",
  inputs: [
    { name: "color", type: "vec3" },
    { name: "exposure", type: "float" }
  ]
});
var cineonToneMapping = Fn(([color4, exposure]) => {
  color4 = color4.mul(exposure);
  color4 = color4.sub(4e-3).max(0);
  const a = color4.mul(color4.mul(6.2).add(0.5));
  const b = color4.mul(color4.mul(6.2).add(1.7)).add(0.06);
  return a.div(b).pow(2.2);
}).setLayout({
  name: "cineonToneMapping",
  type: "vec3",
  inputs: [
    { name: "color", type: "vec3" },
    { name: "exposure", type: "float" }
  ]
});
var RRTAndODTFit = Fn(([color4]) => {
  const a = color4.mul(color4.add(0.0245786)).sub(90537e-9);
  const b = color4.mul(color4.add(0.432951).mul(0.983729)).add(0.238081);
  return a.div(b);
});
var acesFilmicToneMapping = Fn(([color4, exposure]) => {
  const ACESInputMat = mat3(
    0.59719,
    0.35458,
    0.04823,
    0.076,
    0.90834,
    0.01566,
    0.0284,
    0.13383,
    0.83777
  );
  const ACESOutputMat = mat3(
    1.60475,
    -0.53108,
    -0.07367,
    -0.10208,
    1.10813,
    -605e-5,
    -327e-5,
    -0.07276,
    1.07602
  );
  color4 = color4.mul(exposure).div(0.6);
  color4 = ACESInputMat.mul(color4);
  color4 = RRTAndODTFit(color4);
  color4 = ACESOutputMat.mul(color4);
  return color4.clamp();
}).setLayout({
  name: "acesFilmicToneMapping",
  type: "vec3",
  inputs: [
    { name: "color", type: "vec3" },
    { name: "exposure", type: "float" }
  ]
});
var LINEAR_REC2020_TO_LINEAR_SRGB = mat3(vec3(1.6605, -0.1246, -0.0182), vec3(-0.5876, 1.1329, -0.1006), vec3(-0.0728, -83e-4, 1.1187));
var LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(vec3(0.6274, 0.0691, 0.0164), vec3(0.3293, 0.9195, 0.088), vec3(0.0433, 0.0113, 0.8956));
var agxDefaultContrastApprox = Fn(([x_immutable]) => {
  const x = vec3(x_immutable).toVar();
  const x2 = vec3(x.mul(x)).toVar();
  const x4 = vec3(x2.mul(x2)).toVar();
  return float(15.5).mul(x4.mul(x2)).sub(mul(40.14, x4.mul(x))).add(mul(31.96, x4).sub(mul(6.868, x2.mul(x))).add(mul(0.4298, x2).add(mul(0.1191, x).sub(232e-5))));
});
var agxToneMapping = Fn(([color4, exposure]) => {
  const colortone = vec3(color4).toVar();
  const AgXInsetMatrix = mat3(vec3(0.856627153315983, 0.137318972929847, 0.11189821299995), vec3(0.0951212405381588, 0.761241990602591, 0.0767994186031903), vec3(0.0482516061458583, 0.101439036467562, 0.811302368396859));
  const AgXOutsetMatrix = mat3(vec3(1.1271005818144368, -0.1413297634984383, -0.14132976349843826), vec3(-0.11060664309660323, 1.157823702216272, -0.11060664309660294), vec3(-0.016493938717834573, -0.016493938717834257, 1.2519364065950405));
  const AgxMinEv = float(-12.47393);
  const AgxMaxEv = float(4.026069);
  colortone.mulAssign(exposure);
  colortone.assign(LINEAR_SRGB_TO_LINEAR_REC2020.mul(colortone));
  colortone.assign(AgXInsetMatrix.mul(colortone));
  colortone.assign(max$1(colortone, 1e-10));
  colortone.assign(log22(colortone));
  colortone.assign(colortone.sub(AgxMinEv).div(AgxMaxEv.sub(AgxMinEv)));
  colortone.assign(clamp(colortone, 0, 1));
  colortone.assign(agxDefaultContrastApprox(colortone));
  colortone.assign(AgXOutsetMatrix.mul(colortone));
  colortone.assign(pow4(max$1(vec3(0), colortone), vec3(2.2)));
  colortone.assign(LINEAR_REC2020_TO_LINEAR_SRGB.mul(colortone));
  colortone.assign(clamp(colortone, 0, 1));
  return colortone;
}).setLayout({
  name: "agxToneMapping",
  type: "vec3",
  inputs: [
    { name: "color", type: "vec3" },
    { name: "exposure", type: "float" }
  ]
});
var neutralToneMapping = Fn(([color4, exposure]) => {
  const StartCompression = float(0.8 - 0.04);
  const Desaturation = float(0.15);
  color4 = color4.mul(exposure);
  const x = min$1(color4.r, min$1(color4.g, color4.b));
  const offset = select(x.lessThan(0.08), x.sub(mul(6.25, x.mul(x))), 0.04);
  color4.subAssign(offset);
  const peak = max$1(color4.r, max$1(color4.g, color4.b));
  If(peak.lessThan(StartCompression), () => {
    return color4;
  });
  const d = sub(1, StartCompression);
  const newPeak = sub(1, d.mul(d).div(peak.add(d.sub(StartCompression))));
  color4.mulAssign(newPeak.div(peak));
  const g = sub(1, div(1, Desaturation.mul(peak.sub(newPeak)).add(1)));
  return mix(color4, vec3(newPeak), g);
}).setLayout({
  name: "neutralToneMapping",
  type: "vec3",
  inputs: [
    { name: "color", type: "vec3" },
    { name: "exposure", type: "float" }
  ]
});
var CodeNode = class extends Node {
  static get type() {
    return "CodeNode";
  }
  /**
   * Constructs a new code node.
   *
   * @param {string} [code=''] - The native code.
   * @param {Array<Node>} [includes=[]] - An array of includes.
   * @param {('js'|'wgsl'|'glsl')} [language=''] - The used language.
   */
  constructor(code3 = "", includes = [], language = "") {
    super("code");
    this.isCodeNode = true;
    this.global = true;
    this.code = code3;
    this.includes = includes;
    this.language = language;
  }
  /**
   * Sets the includes of this code node.
   *
   * @param {Array<Node>} includes - The includes to set.
   * @return {CodeNode} A reference to this node.
   */
  setIncludes(includes) {
    this.includes = includes;
    return this;
  }
  /**
   * Returns the includes of this code node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {Array<Node>} The includes.
   */
  getIncludes() {
    return this.includes;
  }
  generate(builder) {
    const includes = this.getIncludes(builder);
    for (const include of includes) {
      include.build(builder);
    }
    const nodeCode = builder.getCodeFromNode(this, this.getNodeType(builder));
    nodeCode.code = this.code;
    return nodeCode.code;
  }
  serialize(data) {
    super.serialize(data);
    data.code = this.code;
    data.language = this.language;
  }
  deserialize(data) {
    super.deserialize(data);
    this.code = data.code;
    this.language = data.language;
  }
};
var code = nodeProxy(CodeNode).setParameterLength(1, 3);
var js = (src, includes) => code(src, includes, "js");
var wgsl = (src, includes) => code(src, includes, "wgsl");
var glsl = (src, includes) => code(src, includes, "glsl");
var FunctionNode = class extends CodeNode {
  static get type() {
    return "FunctionNode";
  }
  /**
   * Constructs a new function node.
   *
   * @param {string} [code=''] - The native code.
   * @param {Array<Node>} [includes=[]] - An array of includes.
   * @param {('js'|'wgsl'|'glsl')} [language=''] - The used language.
   */
  constructor(code3 = "", includes = [], language = "") {
    super(code3, includes, language);
  }
  /**
   * Returns the type of this function node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The type.
   */
  getNodeType(builder) {
    return this.getNodeFunction(builder).type;
  }
  /**
   * Returns the type of a member of this function node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {string} name - The name of the member.
   * @return {string} The type of the member.
   */
  getMemberType(builder, name) {
    const type = this.getNodeType(builder);
    const structType = builder.getStructTypeNode(type);
    return structType.getMemberType(builder, name);
  }
  /**
   * Returns the inputs of this function node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {Array<NodeFunctionInput>} The inputs.
   */
  getInputs(builder) {
    return this.getNodeFunction(builder).inputs;
  }
  /**
   * Returns the node function for this function node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {NodeFunction} The node function.
   */
  getNodeFunction(builder) {
    const nodeData = builder.getDataFromNode(this);
    let nodeFunction = nodeData.nodeFunction;
    if (nodeFunction === void 0) {
      nodeFunction = builder.parser.parseFunction(this.code);
      nodeData.nodeFunction = nodeFunction;
    }
    return nodeFunction;
  }
  generate(builder, output3) {
    super.generate(builder);
    const nodeFunction = this.getNodeFunction(builder);
    const name = nodeFunction.name;
    const type = nodeFunction.type;
    const nodeCode = builder.getCodeFromNode(this, type);
    if (name !== "") {
      nodeCode.name = name;
    }
    const propertyName = builder.getPropertyName(nodeCode);
    const code3 = this.getNodeFunction(builder).getCode(propertyName);
    nodeCode.code = code3 + "\n";
    if (output3 === "property") {
      return propertyName;
    } else {
      return builder.format(`${propertyName}()`, type, output3);
    }
  }
};
var nativeFn = (code3, includes = [], language = "") => {
  for (let i = 0; i < includes.length; i++) {
    const include = includes[i];
    if (typeof include === "function") {
      includes[i] = include.functionNode;
    }
  }
  const functionNode = nodeObject(new FunctionNode(code3, includes, language));
  const fn = (...params) => functionNode.call(...params);
  fn.functionNode = functionNode;
  return fn;
};
var glslFn = (code3, includes) => nativeFn(code3, includes, "glsl");
var wgslFn = (code3, includes) => nativeFn(code3, includes, "wgsl");
var ScriptableValueNode = class extends Node {
  static get type() {
    return "ScriptableValueNode";
  }
  /**
   * Constructs a new scriptable node.
   *
   * @param {any} [value=null] - The value.
   */
  constructor(value = null) {
    super();
    this._value = value;
    this._cache = null;
    this.inputType = null;
    this.outputType = null;
    this.events = new EventDispatcher();
    this.isScriptableValueNode = true;
  }
  /**
   * Whether this node represents an output or not.
   *
   * @type {boolean}
   * @readonly
   * @default true
   */
  get isScriptableOutputNode() {
    return this.outputType !== null;
  }
  set value(val) {
    if (this._value === val) return;
    if (this._cache && this.inputType === "URL" && this.value.value instanceof ArrayBuffer) {
      URL.revokeObjectURL(this._cache);
      this._cache = null;
    }
    this._value = val;
    this.events.dispatchEvent({ type: "change" });
    this.refresh();
  }
  /**
   * The node's value.
   *
   * @type {any}
   */
  get value() {
    return this._value;
  }
  /**
   * Dispatches the `refresh` event.
   */
  refresh() {
    this.events.dispatchEvent({ type: "refresh" });
  }
  /**
   * The `value` property usually represents a node or even binary data in form of array buffers.
   * In this case, this method tries to return the actual value behind the complex type.
   *
   * @return {any} The value.
   */
  getValue() {
    const value = this.value;
    if (value && this._cache === null && this.inputType === "URL" && value.value instanceof ArrayBuffer) {
      this._cache = URL.createObjectURL(new Blob([value.value]));
    } else if (value && value.value !== null && value.value !== void 0 && ((this.inputType === "URL" || this.inputType === "String") && typeof value.value === "string" || this.inputType === "Number" && typeof value.value === "number" || this.inputType === "Vector2" && value.value.isVector2 || this.inputType === "Vector3" && value.value.isVector3 || this.inputType === "Vector4" && value.value.isVector4 || this.inputType === "Color" && value.value.isColor || this.inputType === "Matrix3" && value.value.isMatrix3 || this.inputType === "Matrix4" && value.value.isMatrix4)) {
      return value.value;
    }
    return this._cache || value;
  }
  /**
   * Overwritten since the node type is inferred from the value.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node type.
   */
  getNodeType(builder) {
    return this.value && this.value.isNode ? this.value.getNodeType(builder) : "float";
  }
  setup() {
    return this.value && this.value.isNode ? this.value : float();
  }
  serialize(data) {
    super.serialize(data);
    if (this.value !== null) {
      if (this.inputType === "ArrayBuffer") {
        data.value = arrayBufferToBase64(this.value);
      } else {
        data.value = this.value ? this.value.toJSON(data.meta).uuid : null;
      }
    } else {
      data.value = null;
    }
    data.inputType = this.inputType;
    data.outputType = this.outputType;
  }
  deserialize(data) {
    super.deserialize(data);
    let value = null;
    if (data.value !== null) {
      if (data.inputType === "ArrayBuffer") {
        value = base64ToArrayBuffer(data.value);
      } else if (data.inputType === "Texture") {
        value = data.meta.textures[data.value];
      } else {
        value = data.meta.nodes[data.value] || null;
      }
    }
    this.value = value;
    this.inputType = data.inputType;
    this.outputType = data.outputType;
  }
};
var scriptableValue = nodeProxy(ScriptableValueNode).setParameterLength(1);
var Resources = class extends Map {
  get(key, callback = null, ...params) {
    if (this.has(key)) return super.get(key);
    if (callback !== null) {
      const value = callback(...params);
      this.set(key, value);
      return value;
    }
  }
};
var Parameters = class {
  constructor(scriptableNode) {
    this.scriptableNode = scriptableNode;
  }
  get parameters() {
    return this.scriptableNode.parameters;
  }
  get layout() {
    return this.scriptableNode.getLayout();
  }
  getInputLayout(id) {
    return this.scriptableNode.getInputLayout(id);
  }
  get(name) {
    const param = this.parameters[name];
    const value = param ? param.getValue() : null;
    return value;
  }
};
var ScriptableNodeResources = new Resources();
var ScriptableNode = class extends Node {
  static get type() {
    return "ScriptableNode";
  }
  /**
   * Constructs a new scriptable node.
   *
   * @param {?CodeNode} [codeNode=null] - The code node.
   * @param {Object} [parameters={}] - The parameters definition.
   */
  constructor(codeNode = null, parameters = {}) {
    super();
    this.codeNode = codeNode;
    this.parameters = parameters;
    this._local = new Resources();
    this._output = scriptableValue(null);
    this._outputs = {};
    this._source = this.source;
    this._method = null;
    this._object = null;
    this._value = null;
    this._needsOutputUpdate = true;
    this.onRefresh = this.onRefresh.bind(this);
    this.isScriptableNode = true;
  }
  /**
   * The source code of the scriptable node.
   *
   * @type {string}
   */
  get source() {
    return this.codeNode ? this.codeNode.code : "";
  }
  /**
   * Sets the reference of a local script variable.
   *
   * @param {string} name - The variable name.
   * @param {Object} value - The reference to set.
   * @return {Resources} The resource map
   */
  setLocal(name, value) {
    return this._local.set(name, value);
  }
  /**
   * Gets the value of a local script variable.
   *
   * @param {string} name - The variable name.
   * @return {Object} The value.
   */
  getLocal(name) {
    return this._local.get(name);
  }
  /**
   * Event listener for the `refresh` event.
   */
  onRefresh() {
    this._refresh();
  }
  /**
   * Returns an input from the layout with the given id/name.
   *
   * @param {string} id - The id/name of the input.
   * @return {Object} The element entry.
   */
  getInputLayout(id) {
    for (const element3 of this.getLayout()) {
      if (element3.inputType && (element3.id === id || element3.name === id)) {
        return element3;
      }
    }
  }
  /**
   * Returns an output from the layout with the given id/name.
   *
   * @param {string} id - The id/name of the output.
   * @return {Object} The element entry.
   */
  getOutputLayout(id) {
    for (const element3 of this.getLayout()) {
      if (element3.outputType && (element3.id === id || element3.name === id)) {
        return element3;
      }
    }
  }
  /**
   * Defines a script output for the given name and value.
   *
   * @param {string} name - The name of the output.
   * @param {Node} value - The node value.
   * @return {ScriptableNode} A reference to this node.
   */
  setOutput(name, value) {
    const outputs = this._outputs;
    if (outputs[name] === void 0) {
      outputs[name] = scriptableValue(value);
    } else {
      outputs[name].value = value;
    }
    return this;
  }
  /**
   * Returns a script output for the given name.
   *
   * @param {string} name - The name of the output.
   * @return {ScriptableValueNode} The node value.
   */
  getOutput(name) {
    return this._outputs[name];
  }
  /**
   * Returns a parameter for the given name
   *
   * @param {string} name - The name of the parameter.
   * @return {ScriptableValueNode} The node value.
   */
  getParameter(name) {
    return this.parameters[name];
  }
  /**
   * Sets a value for the given parameter name.
   *
   * @param {string} name - The parameter name.
   * @param {any} value - The parameter value.
   * @return {ScriptableNode} A reference to this node.
   */
  setParameter(name, value) {
    const parameters = this.parameters;
    if (value && value.isScriptableNode) {
      this.deleteParameter(name);
      parameters[name] = value;
      parameters[name].getDefaultOutput().events.addEventListener("refresh", this.onRefresh);
    } else if (value && value.isScriptableValueNode) {
      this.deleteParameter(name);
      parameters[name] = value;
      parameters[name].events.addEventListener("refresh", this.onRefresh);
    } else if (parameters[name] === void 0) {
      parameters[name] = scriptableValue(value);
      parameters[name].events.addEventListener("refresh", this.onRefresh);
    } else {
      parameters[name].value = value;
    }
    return this;
  }
  /**
   * Returns the value of this node which is the value of
   * the default output.
   *
   * @return {Node} The value.
   */
  getValue() {
    return this.getDefaultOutput().getValue();
  }
  /**
   * Deletes a parameter from the script.
   *
   * @param {string} name - The parameter to remove.
   * @return {ScriptableNode} A reference to this node.
   */
  deleteParameter(name) {
    let valueNode = this.parameters[name];
    if (valueNode) {
      if (valueNode.isScriptableNode) valueNode = valueNode.getDefaultOutput();
      valueNode.events.removeEventListener("refresh", this.onRefresh);
    }
    return this;
  }
  /**
   * Deletes all parameters from the script.
   *
   * @return {ScriptableNode} A reference to this node.
   */
  clearParameters() {
    for (const name of Object.keys(this.parameters)) {
      this.deleteParameter(name);
    }
    this.needsUpdate = true;
    return this;
  }
  /**
   * Calls a function from the script.
   *
   * @param {string} name - The function name.
   * @param {...any} params - A list of parameters.
   * @return {any} The result of the function call.
   */
  call(name, ...params) {
    const object2 = this.getObject();
    const method = object2[name];
    if (typeof method === "function") {
      return method(...params);
    }
  }
  /**
   * Asynchronously calls a function from the script.
   *
   * @param {string} name - The function name.
   * @param {...any} params - A list of parameters.
   * @return {Promise<any>} The result of the function call.
   */
  async callAsync(name, ...params) {
    const object2 = this.getObject();
    const method = object2[name];
    if (typeof method === "function") {
      return method.constructor.name === "AsyncFunction" ? await method(...params) : method(...params);
    }
  }
  /**
   * Overwritten since the node types is inferred from the script's output.
   *
   * @param {NodeBuilder} builder - The current node builder
   * @return {string} The node type.
   */
  getNodeType(builder) {
    return this.getDefaultOutputNode().getNodeType(builder);
  }
  /**
   * Refreshes the script node.
   *
   * @param {?string} [output=null] - An optional output.
   */
  refresh(output3 = null) {
    if (output3 !== null) {
      this.getOutput(output3).refresh();
    } else {
      this._refresh();
    }
  }
  /**
   * Returns an object representation of the script.
   *
   * @return {Object} The result object.
   */
  getObject() {
    if (this.needsUpdate) this.dispose();
    if (this._object !== null) return this._object;
    const refresh = () => this.refresh();
    const setOutput = (id, value) => this.setOutput(id, value);
    const parameters = new Parameters(this);
    const THREE4 = ScriptableNodeResources.get("THREE");
    const TSL2 = ScriptableNodeResources.get("TSL");
    const method = this.getMethod();
    const params = [parameters, this._local, ScriptableNodeResources, refresh, setOutput, THREE4, TSL2];
    this._object = method(...params);
    const layout = this._object.layout;
    if (layout) {
      if (layout.cache === false) {
        this._local.clear();
      }
      this._output.outputType = layout.outputType || null;
      if (Array.isArray(layout.elements)) {
        for (const element3 of layout.elements) {
          const id = element3.id || element3.name;
          if (element3.inputType) {
            if (this.getParameter(id) === void 0) this.setParameter(id, null);
            this.getParameter(id).inputType = element3.inputType;
          }
          if (element3.outputType) {
            if (this.getOutput(id) === void 0) this.setOutput(id, null);
            this.getOutput(id).outputType = element3.outputType;
          }
        }
      }
    }
    return this._object;
  }
  deserialize(data) {
    super.deserialize(data);
    for (const name in this.parameters) {
      let valueNode = this.parameters[name];
      if (valueNode.isScriptableNode) valueNode = valueNode.getDefaultOutput();
      valueNode.events.addEventListener("refresh", this.onRefresh);
    }
  }
  /**
   * Returns the layout of the script.
   *
   * @return {Object} The script's layout.
   */
  getLayout() {
    return this.getObject().layout;
  }
  /**
   * Returns default node output of the script.
   *
   * @return {Node} The default node output.
   */
  getDefaultOutputNode() {
    const output3 = this.getDefaultOutput().value;
    if (output3 && output3.isNode) {
      return output3;
    }
    return float();
  }
  /**
   * Returns default output of the script.
   *
   * @return {ScriptableValueNode} The default output.
   */
  getDefaultOutput() {
    return this._exec()._output;
  }
  /**
   * Returns a function created from the node's script.
   *
   * @return {Function} The function representing the node's code.
   */
  getMethod() {
    if (this.needsUpdate) this.dispose();
    if (this._method !== null) return this._method;
    const parametersProps = ["parameters", "local", "global", "refresh", "setOutput", "THREE", "TSL"];
    const interfaceProps = ["layout", "init", "main", "dispose"];
    const properties = interfaceProps.join(", ");
    const declarations = "var " + properties + "; var output = {};\n";
    const returns = "\nreturn { ...output, " + properties + " };";
    const code3 = declarations + this.codeNode.code + returns;
    this._method = new Function(...parametersProps, code3);
    return this._method;
  }
  /**
   * Frees all internal resources.
   */
  dispose() {
    if (this._method === null) return;
    if (this._object && typeof this._object.dispose === "function") {
      this._object.dispose();
    }
    this._method = null;
    this._object = null;
    this._source = null;
    this._value = null;
    this._needsOutputUpdate = true;
    this._output.value = null;
    this._outputs = {};
  }
  setup() {
    return this.getDefaultOutputNode();
  }
  getCacheKey(force) {
    const values = [hashString(this.source), this.getDefaultOutputNode().getCacheKey(force)];
    for (const param in this.parameters) {
      values.push(this.parameters[param].getCacheKey(force));
    }
    return hashArray(values);
  }
  set needsUpdate(value) {
    if (value === true) this.dispose();
  }
  get needsUpdate() {
    return this.source !== this._source;
  }
  /**
   * Executes the `main` function of the script.
   *
   * @private
   * @return {ScriptableNode} A reference to this node.
   */
  _exec() {
    if (this.codeNode === null) return this;
    if (this._needsOutputUpdate === true) {
      this._value = this.call("main");
      this._needsOutputUpdate = false;
    }
    this._output.value = this._value;
    return this;
  }
  /**
   * Executes the refresh.
   *
   * @private
   */
  _refresh() {
    this.needsUpdate = true;
    this._exec();
    this._output.refresh();
  }
};
var scriptable = nodeProxy(ScriptableNode).setParameterLength(1, 2);
function getViewZNode(builder) {
  let viewZ;
  const getViewZ = builder.context.getViewZ;
  if (getViewZ !== void 0) {
    viewZ = getViewZ(this);
  }
  return (viewZ || positionView.z).negate();
}
var rangeFogFactor = Fn(([near, far], builder) => {
  const viewZ = getViewZNode(builder);
  return smoothstep(near, far, viewZ);
});
var densityFogFactor = Fn(([density], builder) => {
  const viewZ = getViewZNode(builder);
  return density.mul(density, viewZ, viewZ).negate().exp().oneMinus();
});
var fog = Fn(([color4, factor]) => {
  return vec4(factor.toFloat().mix(output.rgb, color4.toVec3()), output.a);
});
function rangeFog(color4, near, far) {
  console.warn('THREE.TSL: "rangeFog( color, near, far )" is deprecated. Use "fog( color, rangeFogFactor( near, far ) )" instead.');
  return fog(color4, rangeFogFactor(near, far));
}
function densityFog(color4, density) {
  console.warn('THREE.TSL: "densityFog( color, density )" is deprecated. Use "fog( color, densityFogFactor( density ) )" instead.');
  return fog(color4, densityFogFactor(density));
}
var min3 = null;
var max3 = null;
var RangeNode = class extends Node {
  static get type() {
    return "RangeNode";
  }
  /**
   * Constructs a new range node.
   *
   * @param {Node<any>} [minNode=float()] - A node defining the lower bound of the range.
   * @param {Node<any>} [maxNode=float()] - A node defining the upper bound of the range.
   */
  constructor(minNode = float(), maxNode = float()) {
    super();
    this.minNode = minNode;
    this.maxNode = maxNode;
  }
  /**
   * Returns the vector length which is computed based on the range definition.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {number} The vector length.
   */
  getVectorLength(builder) {
    const minLength = builder.getTypeLength(getValueType(this.minNode.value));
    const maxLength = builder.getTypeLength(getValueType(this.maxNode.value));
    return minLength > maxLength ? minLength : maxLength;
  }
  /**
   * This method is overwritten since the node type is inferred from range definition.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node type.
   */
  getNodeType(builder) {
    return builder.object.count > 1 ? builder.getTypeFromLength(this.getVectorLength(builder)) : "float";
  }
  setup(builder) {
    const object2 = builder.object;
    let output3 = null;
    if (object2.count > 1) {
      const minValue = this.minNode.value;
      const maxValue = this.maxNode.value;
      const minLength = builder.getTypeLength(getValueType(minValue));
      const maxLength = builder.getTypeLength(getValueType(maxValue));
      min3 = min3 || new Vector4();
      max3 = max3 || new Vector4();
      min3.setScalar(0);
      max3.setScalar(0);
      if (minLength === 1) min3.setScalar(minValue);
      else if (minValue.isColor) min3.set(minValue.r, minValue.g, minValue.b, 1);
      else min3.set(minValue.x, minValue.y, minValue.z || 0, minValue.w || 0);
      if (maxLength === 1) max3.setScalar(maxValue);
      else if (maxValue.isColor) max3.set(maxValue.r, maxValue.g, maxValue.b, 1);
      else max3.set(maxValue.x, maxValue.y, maxValue.z || 0, maxValue.w || 0);
      const stride = 4;
      const length3 = stride * object2.count;
      const array4 = new Float32Array(length3);
      for (let i = 0; i < length3; i++) {
        const index5 = i % stride;
        const minElementValue = min3.getComponent(index5);
        const maxElementValue = max3.getComponent(index5);
        array4[i] = MathUtils.lerp(minElementValue, maxElementValue, Math.random());
      }
      const nodeType = this.getNodeType(builder);
      if (object2.count <= 4096) {
        output3 = buffer(array4, "vec4", object2.count).element(instanceIndex).convert(nodeType);
      } else {
        const bufferAttribute3 = new InstancedBufferAttribute(array4, 4);
        builder.geometry.setAttribute("__range" + this.id, bufferAttribute3);
        output3 = instancedBufferAttribute(bufferAttribute3).convert(nodeType);
      }
    } else {
      output3 = float(0);
    }
    return output3;
  }
};
var range3 = nodeProxy(RangeNode).setParameterLength(2);
var ComputeBuiltinNode = class extends Node {
  static get type() {
    return "ComputeBuiltinNode";
  }
  /**
   * Constructs a new compute builtin node.
   *
   * @param {string} builtinName - The built-in name.
   * @param {string} nodeType - The node type.
   */
  constructor(builtinName, nodeType) {
    super(nodeType);
    this._builtinName = builtinName;
  }
  /**
   * This method is overwritten since hash is derived from the built-in name.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The hash.
   */
  getHash(builder) {
    return this.getBuiltinName(builder);
  }
  /**
   * This method is overwritten since the node type is simply derived from `nodeType`..
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node type.
   */
  getNodeType() {
    return this.nodeType;
  }
  /**
   * Sets the builtin name.
   *
   * @param {string} builtinName - The built-in name.
   * @return {ComputeBuiltinNode} A reference to this node.
   */
  setBuiltinName(builtinName) {
    this._builtinName = builtinName;
    return this;
  }
  /**
   * Returns the builtin name.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The builtin name.
   */
  getBuiltinName() {
    return this._builtinName;
  }
  /**
   * Whether the current node builder has the builtin or not.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {boolean} Whether the builder has the builtin or not.
   */
  hasBuiltin(builder) {
    return builder.hasBuiltin(this._builtinName);
  }
  generate(builder, output3) {
    const builtinName = this.getBuiltinName(builder);
    const nodeType = this.getNodeType(builder);
    if (builder.shaderStage === "compute") {
      return builder.format(builtinName, nodeType, output3);
    } else {
      console.warn(`ComputeBuiltinNode: Compute built-in value ${builtinName} can not be accessed in the ${builder.shaderStage} stage`);
      return builder.generateConst(nodeType);
    }
  }
  serialize(data) {
    super.serialize(data);
    data.global = this.global;
    data._builtinName = this._builtinName;
  }
  deserialize(data) {
    super.deserialize(data);
    this.global = data.global;
    this._builtinName = data._builtinName;
  }
};
var computeBuiltin = (name, nodeType) => nodeObject(new ComputeBuiltinNode(name, nodeType));
var numWorkgroups = computeBuiltin("numWorkgroups", "uvec3");
var workgroupId = computeBuiltin("workgroupId", "uvec3");
var globalId = computeBuiltin("globalId", "uvec3");
var localId = computeBuiltin("localId", "uvec3");
var subgroupSize = computeBuiltin("subgroupSize", "uint");
var BarrierNode = class extends Node {
  /**
   * Constructs a new barrier node.
   *
   * @param {string} scope - The scope defines the behavior of the node.
   */
  constructor(scope) {
    super();
    this.scope = scope;
  }
  generate(builder) {
    const { scope } = this;
    const { renderer } = builder;
    if (renderer.backend.isWebGLBackend === true) {
      builder.addFlowCode(`	// ${scope}Barrier 
`);
    } else {
      builder.addLineFlowCode(`${scope}Barrier()`, this);
    }
  }
};
var barrier = nodeProxy(BarrierNode);
var workgroupBarrier = () => barrier("workgroup").toStack();
var storageBarrier = () => barrier("storage").toStack();
var textureBarrier = () => barrier("texture").toStack();
var WorkgroupInfoElementNode = class extends ArrayElementNode {
  /**
   * Constructs a new workgroup info element node.
   *
   * @param {Node} workgroupInfoNode - The workgroup info node.
   * @param {Node} indexNode - The index node that defines the element access.
   */
  constructor(workgroupInfoNode, indexNode) {
    super(workgroupInfoNode, indexNode);
    this.isWorkgroupInfoElementNode = true;
  }
  generate(builder, output3) {
    let snippet;
    const isAssignContext = builder.context.assign;
    snippet = super.generate(builder);
    if (isAssignContext !== true) {
      const type = this.getNodeType(builder);
      snippet = builder.format(snippet, type, output3);
    }
    return snippet;
  }
};
var WorkgroupInfoNode = class extends Node {
  /**
   * Constructs a new buffer scoped to type scope.
   *
   * @param {string} scope - TODO.
   * @param {string} bufferType - The data type of a 'workgroup' scoped buffer element.
   * @param {number} [bufferCount=0] - The number of elements in the buffer.
   */
  constructor(scope, bufferType, bufferCount = 0) {
    super(bufferType);
    this.bufferType = bufferType;
    this.bufferCount = bufferCount;
    this.isWorkgroupInfoNode = true;
    this.elementType = bufferType;
    this.scope = scope;
    this.name = "";
  }
  /**
   * Sets the name of this node.
   *
   * @param {string} name - The name to set.
   * @return {WorkgroupInfoNode} A reference to this node.
   */
  setName(name) {
    this.name = name;
    return this;
  }
  /**
   * Sets the name/label of this node.
   *
   * @deprecated
   * @param {string} name - The name to set.
   * @return {WorkgroupInfoNode} A reference to this node.
   */
  label(name) {
    console.warn('THREE.TSL: "label()" has been deprecated. Use "setName()" instead.');
    return this.setName(name);
  }
  /**
   * Sets the scope of this node.
   *
   * @param {string} scope - The scope to set.
   * @return {WorkgroupInfoNode} A reference to this node.
   */
  setScope(scope) {
    this.scope = scope;
    return this;
  }
  /**
   * The data type of the array buffer.
   *
   * @return {string} The element type.
   */
  getElementType() {
    return this.elementType;
  }
  /**
   * Overwrites the default implementation since the input type
   * is inferred from the scope.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The input type.
   */
  getInputType() {
    return `${this.scope}Array`;
  }
  /**
   * This method can be used to access elements via an index node.
   *
   * @param {IndexNode} indexNode - indexNode.
   * @return {WorkgroupInfoElementNode} A reference to an element.
   */
  element(indexNode) {
    return nodeObject(new WorkgroupInfoElementNode(this, indexNode));
  }
  generate(builder) {
    const name = this.name !== "" ? this.name : `${this.scope}Array_${this.id}`;
    return builder.getScopedArray(name, this.scope.toLowerCase(), this.bufferType, this.bufferCount);
  }
};
var workgroupArray = (type, count2) => nodeObject(new WorkgroupInfoNode("Workgroup", type, count2));
var AtomicFunctionNode = class extends Node {
  static get type() {
    return "AtomicFunctionNode";
  }
  /**
   * Constructs a new atomic function node.
   *
   * @param {string} method - The signature of the atomic function to construct.
   * @param {Node} pointerNode - An atomic variable or element of an atomic buffer.
   * @param {Node} valueNode - The value that mutates the atomic variable.
   */
  constructor(method, pointerNode, valueNode) {
    super("uint");
    this.method = method;
    this.pointerNode = pointerNode;
    this.valueNode = valueNode;
    this.parents = true;
  }
  /**
   * Overwrites the default implementation to return the type of
   * the pointer node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The input type.
   */
  getInputType(builder) {
    return this.pointerNode.getNodeType(builder);
  }
  /**
   * Overwritten since the node type is inferred from the input type.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node type.
   */
  getNodeType(builder) {
    return this.getInputType(builder);
  }
  generate(builder) {
    const properties = builder.getNodeProperties(this);
    const parents = properties.parents;
    const method = this.method;
    const type = this.getNodeType(builder);
    const inputType = this.getInputType(builder);
    const a = this.pointerNode;
    const b = this.valueNode;
    const params = [];
    params.push(`&${a.build(builder, inputType)}`);
    if (b !== null) {
      params.push(b.build(builder, inputType));
    }
    const methodSnippet = `${builder.getMethod(method, type)}( ${params.join(", ")} )`;
    const isVoid = parents ? parents.length === 1 && parents[0].isStackNode === true : false;
    if (isVoid) {
      builder.addLineFlowCode(methodSnippet, this);
    } else {
      if (properties.constNode === void 0) {
        properties.constNode = expression(methodSnippet, type).toConst();
      }
      return properties.constNode.build(builder);
    }
  }
};
AtomicFunctionNode.ATOMIC_LOAD = "atomicLoad";
AtomicFunctionNode.ATOMIC_STORE = "atomicStore";
AtomicFunctionNode.ATOMIC_ADD = "atomicAdd";
AtomicFunctionNode.ATOMIC_SUB = "atomicSub";
AtomicFunctionNode.ATOMIC_MAX = "atomicMax";
AtomicFunctionNode.ATOMIC_MIN = "atomicMin";
AtomicFunctionNode.ATOMIC_AND = "atomicAnd";
AtomicFunctionNode.ATOMIC_OR = "atomicOr";
AtomicFunctionNode.ATOMIC_XOR = "atomicXor";
var atomicNode = nodeProxy(AtomicFunctionNode);
var atomicFunc = (method, pointerNode, valueNode) => {
  return atomicNode(method, pointerNode, valueNode).toStack();
};
var atomicLoad = (pointerNode) => atomicFunc(AtomicFunctionNode.ATOMIC_LOAD, pointerNode, null);
var atomicStore = (pointerNode, valueNode) => atomicFunc(AtomicFunctionNode.ATOMIC_STORE, pointerNode, valueNode);
var atomicAdd = (pointerNode, valueNode) => atomicFunc(AtomicFunctionNode.ATOMIC_ADD, pointerNode, valueNode);
var atomicSub = (pointerNode, valueNode) => atomicFunc(AtomicFunctionNode.ATOMIC_SUB, pointerNode, valueNode);
var atomicMax = (pointerNode, valueNode) => atomicFunc(AtomicFunctionNode.ATOMIC_MAX, pointerNode, valueNode);
var atomicMin = (pointerNode, valueNode) => atomicFunc(AtomicFunctionNode.ATOMIC_MIN, pointerNode, valueNode);
var atomicAnd = (pointerNode, valueNode) => atomicFunc(AtomicFunctionNode.ATOMIC_AND, pointerNode, valueNode);
var atomicOr = (pointerNode, valueNode) => atomicFunc(AtomicFunctionNode.ATOMIC_OR, pointerNode, valueNode);
var atomicXor = (pointerNode, valueNode) => atomicFunc(AtomicFunctionNode.ATOMIC_XOR, pointerNode, valueNode);
var SubgroupFunctionNode = class _SubgroupFunctionNode extends TempNode {
  static get type() {
    return "SubgroupFunctionNode";
  }
  /**
   * Constructs a new function node.
   *
   * @param {string} method - The subgroup/wave intrinsic method to construct.
   * @param {Node} [aNode=null] - The method's first argument.
   * @param {Node} [bNode=null] - The method's second argument.
   */
  constructor(method, aNode = null, bNode = null) {
    super();
    this.method = method;
    this.aNode = aNode;
    this.bNode = bNode;
  }
  getInputType(builder) {
    const aType = this.aNode ? this.aNode.getNodeType(builder) : null;
    const bType = this.bNode ? this.bNode.getNodeType(builder) : null;
    const aLen = builder.isMatrix(aType) ? 0 : builder.getTypeLength(aType);
    const bLen = builder.isMatrix(bType) ? 0 : builder.getTypeLength(bType);
    if (aLen > bLen) {
      return aType;
    } else {
      return bType;
    }
  }
  getNodeType(builder) {
    const method = this.method;
    if (method === _SubgroupFunctionNode.SUBGROUP_ELECT) {
      return "bool";
    } else if (method === _SubgroupFunctionNode.SUBGROUP_BALLOT) {
      return "uvec4";
    } else {
      return this.getInputType(builder);
    }
  }
  generate(builder, output3) {
    const method = this.method;
    const type = this.getNodeType(builder);
    const inputType = this.getInputType(builder);
    const a = this.aNode;
    const b = this.bNode;
    const params = [];
    if (method === _SubgroupFunctionNode.SUBGROUP_BROADCAST || method === _SubgroupFunctionNode.SUBGROUP_SHUFFLE || method === _SubgroupFunctionNode.QUAD_BROADCAST) {
      const bType = b.getNodeType(builder);
      params.push(
        a.build(builder, type),
        b.build(builder, bType === "float" ? "int" : type)
      );
    } else if (method === _SubgroupFunctionNode.SUBGROUP_SHUFFLE_XOR || method === _SubgroupFunctionNode.SUBGROUP_SHUFFLE_DOWN || method === _SubgroupFunctionNode.SUBGROUP_SHUFFLE_UP) {
      params.push(
        a.build(builder, type),
        b.build(builder, "uint")
      );
    } else {
      if (a !== null) params.push(a.build(builder, inputType));
      if (b !== null) params.push(b.build(builder, inputType));
    }
    const paramsString = params.length === 0 ? "()" : `( ${params.join(", ")} )`;
    return builder.format(`${builder.getMethod(method, type)}${paramsString}`, type, output3);
  }
  serialize(data) {
    super.serialize(data);
    data.method = this.method;
  }
  deserialize(data) {
    super.deserialize(data);
    this.method = data.method;
  }
};
SubgroupFunctionNode.SUBGROUP_ELECT = "subgroupElect";
SubgroupFunctionNode.SUBGROUP_BALLOT = "subgroupBallot";
SubgroupFunctionNode.SUBGROUP_ADD = "subgroupAdd";
SubgroupFunctionNode.SUBGROUP_INCLUSIVE_ADD = "subgroupInclusiveAdd";
SubgroupFunctionNode.SUBGROUP_EXCLUSIVE_AND = "subgroupExclusiveAdd";
SubgroupFunctionNode.SUBGROUP_MUL = "subgroupMul";
SubgroupFunctionNode.SUBGROUP_INCLUSIVE_MUL = "subgroupInclusiveMul";
SubgroupFunctionNode.SUBGROUP_EXCLUSIVE_MUL = "subgroupExclusiveMul";
SubgroupFunctionNode.SUBGROUP_AND = "subgroupAnd";
SubgroupFunctionNode.SUBGROUP_OR = "subgroupOr";
SubgroupFunctionNode.SUBGROUP_XOR = "subgroupXor";
SubgroupFunctionNode.SUBGROUP_MIN = "subgroupMin";
SubgroupFunctionNode.SUBGROUP_MAX = "subgroupMax";
SubgroupFunctionNode.SUBGROUP_ALL = "subgroupAll";
SubgroupFunctionNode.SUBGROUP_ANY = "subgroupAny";
SubgroupFunctionNode.SUBGROUP_BROADCAST_FIRST = "subgroupBroadcastFirst";
SubgroupFunctionNode.QUAD_SWAP_X = "quadSwapX";
SubgroupFunctionNode.QUAD_SWAP_Y = "quadSwapY";
SubgroupFunctionNode.QUAD_SWAP_DIAGONAL = "quadSwapDiagonal";
SubgroupFunctionNode.SUBGROUP_BROADCAST = "subgroupBroadcast";
SubgroupFunctionNode.SUBGROUP_SHUFFLE = "subgroupShuffle";
SubgroupFunctionNode.SUBGROUP_SHUFFLE_XOR = "subgroupShuffleXor";
SubgroupFunctionNode.SUBGROUP_SHUFFLE_UP = "subgroupShuffleUp";
SubgroupFunctionNode.SUBGROUP_SHUFFLE_DOWN = "subgroupShuffleDown";
SubgroupFunctionNode.QUAD_BROADCAST = "quadBroadcast";
var subgroupElect = nodeProxyIntent(SubgroupFunctionNode, SubgroupFunctionNode.SUBGROUP_ELECT).setParameterLength(0);
var subgroupBallot = nodeProxyIntent(SubgroupFunctionNode, SubgroupFunctionNode.SUBGROUP_BALLOT).setParameterLength(1);
var subgroupAdd = nodeProxyIntent(SubgroupFunctionNode, SubgroupFunctionNode.SUBGROUP_ADD).setParameterLength(1);
var subgroupInclusiveAdd = nodeProxyIntent(SubgroupFunctionNode, SubgroupFunctionNode.SUBGROUP_INCLUSIVE_ADD).setParameterLength(1);
var subgroupExclusiveAdd = nodeProxyIntent(SubgroupFunctionNode, SubgroupFunctionNode.SUBGROUP_EXCLUSIVE_AND).setParameterLength(1);
var subgroupMul = nodeProxyIntent(SubgroupFunctionNode, SubgroupFunctionNode.SUBGROUP_MUL).setParameterLength(1);
var subgroupInclusiveMul = nodeProxyIntent(SubgroupFunctionNode, SubgroupFunctionNode.SUBGROUP_INCLUSIVE_MUL).setParameterLength(1);
var subgroupExclusiveMul = nodeProxyIntent(SubgroupFunctionNode, SubgroupFunctionNode.SUBGROUP_EXCLUSIVE_MUL).setParameterLength(1);
var subgroupAnd = nodeProxyIntent(SubgroupFunctionNode, SubgroupFunctionNode.SUBGROUP_AND).setParameterLength(1);
var subgroupOr = nodeProxyIntent(SubgroupFunctionNode, SubgroupFunctionNode.SUBGROUP_OR).setParameterLength(1);
var subgroupXor = nodeProxyIntent(SubgroupFunctionNode, SubgroupFunctionNode.SUBGROUP_XOR).setParameterLength(1);
var subgroupMin = nodeProxyIntent(SubgroupFunctionNode, SubgroupFunctionNode.SUBGROUP_MIN).setParameterLength(1);
var subgroupMax = nodeProxyIntent(SubgroupFunctionNode, SubgroupFunctionNode.SUBGROUP_MAX).setParameterLength(1);
var subgroupAll = nodeProxyIntent(SubgroupFunctionNode, SubgroupFunctionNode.SUBGROUP_ALL).setParameterLength(0);
var subgroupAny = nodeProxyIntent(SubgroupFunctionNode, SubgroupFunctionNode.SUBGROUP_ANY).setParameterLength(0);
var subgroupBroadcastFirst = nodeProxyIntent(SubgroupFunctionNode, SubgroupFunctionNode.SUBGROUP_BROADCAST_FIRST).setParameterLength(2);
var quadSwapX = nodeProxyIntent(SubgroupFunctionNode, SubgroupFunctionNode.QUAD_SWAP_X).setParameterLength(1);
var quadSwapY = nodeProxyIntent(SubgroupFunctionNode, SubgroupFunctionNode.QUAD_SWAP_Y).setParameterLength(1);
var quadSwapDiagonal = nodeProxyIntent(SubgroupFunctionNode, SubgroupFunctionNode.QUAD_SWAP_DIAGONAL).setParameterLength(1);
var subgroupBroadcast = nodeProxyIntent(SubgroupFunctionNode, SubgroupFunctionNode.SUBGROUP_BROADCAST).setParameterLength(2);
var subgroupShuffle = nodeProxyIntent(SubgroupFunctionNode, SubgroupFunctionNode.SUBGROUP_SHUFFLE).setParameterLength(2);
var subgroupShuffleXor = nodeProxyIntent(SubgroupFunctionNode, SubgroupFunctionNode.SUBGROUP_SHUFFLE_XOR).setParameterLength(2);
var subgroupShuffleUp = nodeProxyIntent(SubgroupFunctionNode, SubgroupFunctionNode.SUBGROUP_SHUFFLE_UP).setParameterLength(2);
var subgroupShuffleDown = nodeProxyIntent(SubgroupFunctionNode, SubgroupFunctionNode.SUBGROUP_SHUFFLE_DOWN).setParameterLength(2);
var quadBroadcast = nodeProxyIntent(SubgroupFunctionNode, SubgroupFunctionNode.QUAD_BROADCAST).setParameterLength(1);
var uniformsLib;
function getLightData(light) {
  uniformsLib = uniformsLib || /* @__PURE__ */ new WeakMap();
  let uniforms = uniformsLib.get(light);
  if (uniforms === void 0) uniformsLib.set(light, uniforms = {});
  return uniforms;
}
function lightShadowMatrix(light) {
  const data = getLightData(light);
  return data.shadowMatrix || (data.shadowMatrix = uniform("mat4").setGroup(renderGroup).onRenderUpdate((frame) => {
    if (light.castShadow !== true || frame.renderer.shadowMap.enabled === false) {
      light.shadow.updateMatrices(light);
    }
    return light.shadow.matrix;
  }));
}
function lightProjectionUV(light, position = positionWorld) {
  const spotLightCoord = lightShadowMatrix(light).mul(position);
  const projectionUV = spotLightCoord.xyz.div(spotLightCoord.w);
  return projectionUV;
}
function lightPosition(light) {
  const data = getLightData(light);
  return data.position || (data.position = uniform(new Vector3()).setGroup(renderGroup).onRenderUpdate((_, self2) => self2.value.setFromMatrixPosition(light.matrixWorld)));
}
function lightTargetPosition(light) {
  const data = getLightData(light);
  return data.targetPosition || (data.targetPosition = uniform(new Vector3()).setGroup(renderGroup).onRenderUpdate((_, self2) => self2.value.setFromMatrixPosition(light.target.matrixWorld)));
}
function lightViewPosition(light) {
  const data = getLightData(light);
  return data.viewPosition || (data.viewPosition = uniform(new Vector3()).setGroup(renderGroup).onRenderUpdate(({ camera }, self2) => {
    self2.value = self2.value || new Vector3();
    self2.value.setFromMatrixPosition(light.matrixWorld);
    self2.value.applyMatrix4(camera.matrixWorldInverse);
  }));
}
var lightTargetDirection = (light) => cameraViewMatrix.transformDirection(lightPosition(light).sub(lightTargetPosition(light)));
var sortLights = (lights3) => {
  return lights3.sort((a, b) => a.id - b.id);
};
var getLightNodeById = (id, lightNodes) => {
  for (const lightNode of lightNodes) {
    if (lightNode.isAnalyticLightNode && lightNode.light.id === id) {
      return lightNode;
    }
  }
  return null;
};
var _lightsNodeRef = /* @__PURE__ */ new WeakMap();
var _hashData = [];
var LightsNode = class extends Node {
  static get type() {
    return "LightsNode";
  }
  /**
   * Constructs a new lights node.
   */
  constructor() {
    super("vec3");
    this.totalDiffuseNode = property("vec3", "totalDiffuse");
    this.totalSpecularNode = property("vec3", "totalSpecular");
    this.outgoingLightNode = property("vec3", "outgoingLight");
    this._lights = [];
    this._lightNodes = null;
    this._lightNodesHash = null;
    this.global = true;
  }
  /**
   * Overwrites the default {@link Node#customCacheKey} implementation by including
   * light data into the cache key.
   *
   * @return {number} The custom cache key.
   */
  customCacheKey() {
    const lights3 = this._lights;
    for (let i = 0; i < lights3.length; i++) {
      const light = lights3[i];
      _hashData.push(light.id);
      _hashData.push(light.castShadow ? 1 : 0);
      if (light.isSpotLight === true) {
        const hashMap = light.map !== null ? light.map.id : -1;
        const hashColorNode = light.colorNode ? light.colorNode.getCacheKey() : -1;
        _hashData.push(hashMap, hashColorNode);
      }
    }
    const cacheKey = hashArray(_hashData);
    _hashData.length = 0;
    return cacheKey;
  }
  /**
   * Computes a hash value for identifying the current light nodes setup.
   *
   * @param {NodeBuilder} builder - A reference to the current node builder.
   * @return {string} The computed hash.
   */
  getHash(builder) {
    if (this._lightNodesHash === null) {
      if (this._lightNodes === null) this.setupLightsNode(builder);
      const hash3 = [];
      for (const lightNode of this._lightNodes) {
        hash3.push(lightNode.getHash());
      }
      this._lightNodesHash = "lights-" + hash3.join(",");
    }
    return this._lightNodesHash;
  }
  analyze(builder) {
    const properties = builder.getNodeProperties(this);
    for (const node of properties.nodes) {
      node.build(builder);
    }
    properties.outputNode.build(builder);
  }
  /**
   * Creates lighting nodes for each scene light. This makes it possible to further
   * process lights in the node system.
   *
   * @param {NodeBuilder} builder - A reference to the current node builder.
   */
  setupLightsNode(builder) {
    const lightNodes = [];
    const previousLightNodes = this._lightNodes;
    const lights3 = sortLights(this._lights);
    const nodeLibrary = builder.renderer.library;
    for (const light of lights3) {
      if (light.isNode) {
        lightNodes.push(nodeObject(light));
      } else {
        let lightNode = null;
        if (previousLightNodes !== null) {
          lightNode = getLightNodeById(light.id, previousLightNodes);
        }
        if (lightNode === null) {
          const lightNodeClass = nodeLibrary.getLightNodeClass(light.constructor);
          if (lightNodeClass === null) {
            console.warn(`LightsNode.setupNodeLights: Light node not found for ${light.constructor.name}`);
            continue;
          }
          let lightNode2 = null;
          if (!_lightsNodeRef.has(light)) {
            lightNode2 = nodeObject(new lightNodeClass(light));
            _lightsNodeRef.set(light, lightNode2);
          } else {
            lightNode2 = _lightsNodeRef.get(light);
          }
          lightNodes.push(lightNode2);
        }
      }
    }
    this._lightNodes = lightNodes;
  }
  /**
   * Sets up a direct light in the lighting model.
   *
   * @param {Object} builder - The builder object containing the context and stack.
   * @param {Object} lightNode - The light node.
   * @param {Object} lightData - The light object containing color and direction properties.
   */
  setupDirectLight(builder, lightNode, lightData) {
    const { lightingModel, reflectedLight } = builder.context;
    lightingModel.direct({
      ...lightData,
      lightNode,
      reflectedLight
    }, builder);
  }
  setupDirectRectAreaLight(builder, lightNode, lightData) {
    const { lightingModel, reflectedLight } = builder.context;
    lightingModel.directRectArea({
      ...lightData,
      lightNode,
      reflectedLight
    }, builder);
  }
  /**
   * Setups the internal lights by building all respective
   * light nodes.
   *
   * @param {NodeBuilder} builder - A reference to the current node builder.
   * @param {Array<LightingNode>} lightNodes - An array of lighting nodes.
   */
  setupLights(builder, lightNodes) {
    for (const lightNode of lightNodes) {
      lightNode.build(builder);
    }
  }
  getLightNodes(builder) {
    if (this._lightNodes === null) this.setupLightsNode(builder);
    return this._lightNodes;
  }
  /**
   * The implementation makes sure that for each light in the scene
   * there is a corresponding light node. By building the light nodes
   * and evaluating the lighting model the outgoing light is computed.
   *
   * @param {NodeBuilder} builder - A reference to the current node builder.
   * @return {Node<vec3>} A node representing the outgoing light.
   */
  setup(builder) {
    const currentLightsNode = builder.lightsNode;
    builder.lightsNode = this;
    let outgoingLightNode = this.outgoingLightNode;
    const context3 = builder.context;
    const lightingModel = context3.lightingModel;
    const properties = builder.getNodeProperties(this);
    if (lightingModel) {
      const { totalDiffuseNode, totalSpecularNode } = this;
      context3.outgoingLight = outgoingLightNode;
      const stack3 = builder.addStack();
      properties.nodes = stack3.nodes;
      lightingModel.start(builder);
      const { backdrop, backdropAlpha } = context3;
      const { directDiffuse, directSpecular, indirectDiffuse, indirectSpecular } = context3.reflectedLight;
      let totalDiffuse = directDiffuse.add(indirectDiffuse);
      if (backdrop !== null) {
        if (backdropAlpha !== null) {
          totalDiffuse = vec3(backdropAlpha.mix(totalDiffuse, backdrop));
        } else {
          totalDiffuse = vec3(backdrop);
        }
        context3.material.transparent = true;
      }
      totalDiffuseNode.assign(totalDiffuse);
      totalSpecularNode.assign(directSpecular.add(indirectSpecular));
      outgoingLightNode.assign(totalDiffuseNode.add(totalSpecularNode));
      lightingModel.finish(builder);
      outgoingLightNode = outgoingLightNode.bypass(builder.removeStack());
    } else {
      properties.nodes = [];
    }
    builder.lightsNode = currentLightsNode;
    return outgoingLightNode;
  }
  /**
   * Configures this node with an array of lights.
   *
   * @param {Array<Light>} lights - An array of lights.
   * @return {LightsNode} A reference to this node.
   */
  setLights(lights3) {
    this._lights = lights3;
    this._lightNodes = null;
    this._lightNodesHash = null;
    return this;
  }
  /**
   * Returns an array of the scene's lights.
   *
   * @return {Array<Light>} The scene's lights.
   */
  getLights() {
    return this._lights;
  }
  /**
   * Whether the scene has lights or not.
   *
   * @type {boolean}
   */
  get hasLights() {
    return this._lights.length > 0;
  }
};
var lights = (lights3 = []) => nodeObject(new LightsNode()).setLights(lights3);
var ShadowBaseNode = class extends Node {
  static get type() {
    return "ShadowBaseNode";
  }
  /**
   * Constructs a new shadow base node.
   *
   * @param {Light} light - The shadow casting light.
   */
  constructor(light) {
    super();
    this.light = light;
    this.updateBeforeType = NodeUpdateType.RENDER;
    this.isShadowBaseNode = true;
  }
  /**
   * Setups the shadow position node which is by default the predefined TSL node object `shadowPositionWorld`.
   *
   * @param {NodeBuilder} object - A configuration object that must at least hold a material reference.
   */
  setupShadowPosition({ context: context3, material }) {
    shadowPositionWorld.assign(material.receivedShadowPositionNode || context3.shadowPositionWorld || positionWorld);
  }
};
var shadowPositionWorld = property("vec3", "shadowPositionWorld");
function saveRendererState(renderer, state = {}) {
  state.toneMapping = renderer.toneMapping;
  state.toneMappingExposure = renderer.toneMappingExposure;
  state.outputColorSpace = renderer.outputColorSpace;
  state.renderTarget = renderer.getRenderTarget();
  state.activeCubeFace = renderer.getActiveCubeFace();
  state.activeMipmapLevel = renderer.getActiveMipmapLevel();
  state.renderObjectFunction = renderer.getRenderObjectFunction();
  state.pixelRatio = renderer.getPixelRatio();
  state.mrt = renderer.getMRT();
  state.clearColor = renderer.getClearColor(state.clearColor || new Color());
  state.clearAlpha = renderer.getClearAlpha();
  state.autoClear = renderer.autoClear;
  state.scissorTest = renderer.getScissorTest();
  return state;
}
function resetRendererState(renderer, state) {
  state = saveRendererState(renderer, state);
  renderer.setMRT(null);
  renderer.setRenderObjectFunction(null);
  renderer.setClearColor(0, 1);
  renderer.autoClear = true;
  return state;
}
function restoreRendererState(renderer, state) {
  renderer.toneMapping = state.toneMapping;
  renderer.toneMappingExposure = state.toneMappingExposure;
  renderer.outputColorSpace = state.outputColorSpace;
  renderer.setRenderTarget(state.renderTarget, state.activeCubeFace, state.activeMipmapLevel);
  renderer.setRenderObjectFunction(state.renderObjectFunction);
  renderer.setPixelRatio(state.pixelRatio);
  renderer.setMRT(state.mrt);
  renderer.setClearColor(state.clearColor, state.clearAlpha);
  renderer.autoClear = state.autoClear;
  renderer.setScissorTest(state.scissorTest);
}
function saveSceneState(scene, state = {}) {
  state.background = scene.background;
  state.backgroundNode = scene.backgroundNode;
  state.overrideMaterial = scene.overrideMaterial;
  return state;
}
function resetSceneState(scene, state) {
  state = saveSceneState(scene, state);
  scene.background = null;
  scene.backgroundNode = null;
  scene.overrideMaterial = null;
  return state;
}
function restoreSceneState(scene, state) {
  scene.background = state.background;
  scene.backgroundNode = state.backgroundNode;
  scene.overrideMaterial = state.overrideMaterial;
}
function saveRendererAndSceneState(renderer, scene, state = {}) {
  state = saveRendererState(renderer, state);
  state = saveSceneState(scene, state);
  return state;
}
function resetRendererAndSceneState(renderer, scene, state) {
  state = resetRendererState(renderer, state);
  state = resetSceneState(scene, state);
  return state;
}
function restoreRendererAndSceneState(renderer, scene, state) {
  restoreRendererState(renderer, state);
  restoreSceneState(scene, state);
}
var RendererUtils = Object.freeze({
  __proto__: null,
  resetRendererAndSceneState,
  resetRendererState,
  resetSceneState,
  restoreRendererAndSceneState,
  restoreRendererState,
  restoreSceneState,
  saveRendererAndSceneState,
  saveRendererState,
  saveSceneState
});
var shadowMaterialLib = /* @__PURE__ */ new WeakMap();
var BasicShadowFilter = Fn(({ depthTexture, shadowCoord, depthLayer }) => {
  let basic = texture(depthTexture, shadowCoord.xy).setName("t_basic");
  if (depthTexture.isArrayTexture) {
    basic = basic.depth(depthLayer);
  }
  return basic.compare(shadowCoord.z);
});
var PCFShadowFilter = Fn(({ depthTexture, shadowCoord, shadow: shadow3, depthLayer }) => {
  const depthCompare = (uv3, compare) => {
    let depth3 = texture(depthTexture, uv3);
    if (depthTexture.isArrayTexture) {
      depth3 = depth3.depth(depthLayer);
    }
    return depth3.compare(compare);
  };
  const mapSize = reference("mapSize", "vec2", shadow3).setGroup(renderGroup);
  const radius = reference("radius", "float", shadow3).setGroup(renderGroup);
  const texelSize = vec2(1).div(mapSize);
  const dx0 = texelSize.x.negate().mul(radius);
  const dy0 = texelSize.y.negate().mul(radius);
  const dx1 = texelSize.x.mul(radius);
  const dy1 = texelSize.y.mul(radius);
  const dx2 = dx0.div(2);
  const dy2 = dy0.div(2);
  const dx3 = dx1.div(2);
  const dy3 = dy1.div(2);
  return add3(
    depthCompare(shadowCoord.xy.add(vec2(dx0, dy0)), shadowCoord.z),
    depthCompare(shadowCoord.xy.add(vec2(0, dy0)), shadowCoord.z),
    depthCompare(shadowCoord.xy.add(vec2(dx1, dy0)), shadowCoord.z),
    depthCompare(shadowCoord.xy.add(vec2(dx2, dy2)), shadowCoord.z),
    depthCompare(shadowCoord.xy.add(vec2(0, dy2)), shadowCoord.z),
    depthCompare(shadowCoord.xy.add(vec2(dx3, dy2)), shadowCoord.z),
    depthCompare(shadowCoord.xy.add(vec2(dx0, 0)), shadowCoord.z),
    depthCompare(shadowCoord.xy.add(vec2(dx2, 0)), shadowCoord.z),
    depthCompare(shadowCoord.xy, shadowCoord.z),
    depthCompare(shadowCoord.xy.add(vec2(dx3, 0)), shadowCoord.z),
    depthCompare(shadowCoord.xy.add(vec2(dx1, 0)), shadowCoord.z),
    depthCompare(shadowCoord.xy.add(vec2(dx2, dy3)), shadowCoord.z),
    depthCompare(shadowCoord.xy.add(vec2(0, dy3)), shadowCoord.z),
    depthCompare(shadowCoord.xy.add(vec2(dx3, dy3)), shadowCoord.z),
    depthCompare(shadowCoord.xy.add(vec2(dx0, dy1)), shadowCoord.z),
    depthCompare(shadowCoord.xy.add(vec2(0, dy1)), shadowCoord.z),
    depthCompare(shadowCoord.xy.add(vec2(dx1, dy1)), shadowCoord.z)
  ).mul(1 / 17);
});
var PCFSoftShadowFilter = Fn(({ depthTexture, shadowCoord, shadow: shadow3, depthLayer }) => {
  const depthCompare = (uv4, compare) => {
    let depth3 = texture(depthTexture, uv4);
    if (depthTexture.isArrayTexture) {
      depth3 = depth3.depth(depthLayer);
    }
    return depth3.compare(compare);
  };
  const mapSize = reference("mapSize", "vec2", shadow3).setGroup(renderGroup);
  const texelSize = vec2(1).div(mapSize);
  const dx = texelSize.x;
  const dy = texelSize.y;
  const uv3 = shadowCoord.xy;
  const f = fract(uv3.mul(mapSize).add(0.5));
  uv3.subAssign(f.mul(texelSize));
  return add3(
    depthCompare(uv3, shadowCoord.z),
    depthCompare(uv3.add(vec2(dx, 0)), shadowCoord.z),
    depthCompare(uv3.add(vec2(0, dy)), shadowCoord.z),
    depthCompare(uv3.add(texelSize), shadowCoord.z),
    mix(
      depthCompare(uv3.add(vec2(dx.negate(), 0)), shadowCoord.z),
      depthCompare(uv3.add(vec2(dx.mul(2), 0)), shadowCoord.z),
      f.x
    ),
    mix(
      depthCompare(uv3.add(vec2(dx.negate(), dy)), shadowCoord.z),
      depthCompare(uv3.add(vec2(dx.mul(2), dy)), shadowCoord.z),
      f.x
    ),
    mix(
      depthCompare(uv3.add(vec2(0, dy.negate())), shadowCoord.z),
      depthCompare(uv3.add(vec2(0, dy.mul(2))), shadowCoord.z),
      f.y
    ),
    mix(
      depthCompare(uv3.add(vec2(dx, dy.negate())), shadowCoord.z),
      depthCompare(uv3.add(vec2(dx, dy.mul(2))), shadowCoord.z),
      f.y
    ),
    mix(
      mix(
        depthCompare(uv3.add(vec2(dx.negate(), dy.negate())), shadowCoord.z),
        depthCompare(uv3.add(vec2(dx.mul(2), dy.negate())), shadowCoord.z),
        f.x
      ),
      mix(
        depthCompare(uv3.add(vec2(dx.negate(), dy.mul(2))), shadowCoord.z),
        depthCompare(uv3.add(vec2(dx.mul(2), dy.mul(2))), shadowCoord.z),
        f.x
      ),
      f.y
    )
  ).mul(1 / 9);
});
var VSMShadowFilter = Fn(({ depthTexture, shadowCoord, depthLayer }) => {
  const occlusion = float(1).toVar();
  let distribution = texture(depthTexture).sample(shadowCoord.xy);
  if (depthTexture.isArrayTexture) {
    distribution = distribution.depth(depthLayer);
  }
  distribution = distribution.rg;
  const hardShadow = step(shadowCoord.z, distribution.x);
  If(hardShadow.notEqual(float(1)), () => {
    const distance4 = shadowCoord.z.sub(distribution.x);
    const variance2 = max$1(0, distribution.y.mul(distribution.y));
    let softnessProbability = variance2.div(variance2.add(distance4.mul(distance4)));
    softnessProbability = clamp(sub(softnessProbability, 0.3).div(0.95 - 0.3));
    occlusion.assign(clamp(max$1(hardShadow, softnessProbability)));
  });
  return occlusion;
});
var linearDistance = Fn(([position, cameraNear3, cameraFar3]) => {
  let dist2 = positionWorld.sub(position).length();
  dist2 = dist2.sub(cameraNear3).div(cameraFar3.sub(cameraNear3));
  dist2 = dist2.saturate();
  return dist2;
});
var linearShadowDistance = (light) => {
  const camera = light.shadow.camera;
  const nearDistance = reference("near", "float", camera).setGroup(renderGroup);
  const farDistance = reference("far", "float", camera).setGroup(renderGroup);
  const referencePosition = objectPosition(light);
  return linearDistance(referencePosition, nearDistance, farDistance);
};
var getShadowMaterial = (light) => {
  let material = shadowMaterialLib.get(light);
  if (material === void 0) {
    const depthNode = light.isPointLight ? linearShadowDistance(light) : null;
    material = new NodeMaterial();
    material.colorNode = vec4(0, 0, 0, 1);
    material.depthNode = depthNode;
    material.isShadowPassMaterial = true;
    material.name = "ShadowMaterial";
    material.fog = false;
    shadowMaterialLib.set(light, material);
  }
  return material;
};
var _shadowRenderObjectLibrary = new ChainMap();
var _shadowRenderObjectKeys = [];
var getShadowRenderObjectFunction = (renderer, shadow3, shadowType, useVelocity) => {
  _shadowRenderObjectKeys[0] = renderer;
  _shadowRenderObjectKeys[1] = shadow3;
  let renderObjectFunction = _shadowRenderObjectLibrary.get(_shadowRenderObjectKeys);
  if (renderObjectFunction === void 0 || (renderObjectFunction.shadowType !== shadowType || renderObjectFunction.useVelocity !== useVelocity)) {
    renderObjectFunction = (object2, scene, _camera3, geometry, material, group2, ...params) => {
      if (object2.castShadow === true || object2.receiveShadow && shadowType === VSMShadowMap) {
        if (useVelocity) {
          getDataFromObject(object2).useVelocity = true;
        }
        object2.onBeforeShadow(renderer, object2, _camera3, shadow3.camera, geometry, scene.overrideMaterial, group2);
        renderer.renderObject(object2, scene, _camera3, geometry, material, group2, ...params);
        object2.onAfterShadow(renderer, object2, _camera3, shadow3.camera, geometry, scene.overrideMaterial, group2);
      }
    };
    renderObjectFunction.shadowType = shadowType;
    renderObjectFunction.useVelocity = useVelocity;
    _shadowRenderObjectLibrary.set(_shadowRenderObjectKeys, renderObjectFunction);
  }
  _shadowRenderObjectKeys[0] = null;
  _shadowRenderObjectKeys[1] = null;
  return renderObjectFunction;
};
var VSMPassVertical = Fn(({ samples, radius, size, shadowPass, depthLayer }) => {
  const mean2 = float(0).toVar("meanVertical");
  const squaredMean = float(0).toVar("squareMeanVertical");
  const uvStride = samples.lessThanEqual(float(1)).select(float(0), float(2).div(samples.sub(1)));
  const uvStart = samples.lessThanEqual(float(1)).select(float(0), float(-1));
  Loop({ start: int(0), end: int(samples), type: "int", condition: "<" }, ({ i }) => {
    const uvOffset = uvStart.add(float(i).mul(uvStride));
    let depth3 = shadowPass.sample(add3(screenCoordinate.xy, vec2(0, uvOffset).mul(radius)).div(size));
    if (shadowPass.value.isArrayTexture) {
      depth3 = depth3.depth(depthLayer);
    }
    depth3 = depth3.x;
    mean2.addAssign(depth3);
    squaredMean.addAssign(depth3.mul(depth3));
  });
  mean2.divAssign(samples);
  squaredMean.divAssign(samples);
  const std_dev = sqrt4(squaredMean.sub(mean2.mul(mean2)));
  return vec2(mean2, std_dev);
});
var VSMPassHorizontal = Fn(({ samples, radius, size, shadowPass, depthLayer }) => {
  const mean2 = float(0).toVar("meanHorizontal");
  const squaredMean = float(0).toVar("squareMeanHorizontal");
  const uvStride = samples.lessThanEqual(float(1)).select(float(0), float(2).div(samples.sub(1)));
  const uvStart = samples.lessThanEqual(float(1)).select(float(0), float(-1));
  Loop({ start: int(0), end: int(samples), type: "int", condition: "<" }, ({ i }) => {
    const uvOffset = uvStart.add(float(i).mul(uvStride));
    let distribution = shadowPass.sample(add3(screenCoordinate.xy, vec2(uvOffset, 0).mul(radius)).div(size));
    if (shadowPass.value.isArrayTexture) {
      distribution = distribution.depth(depthLayer);
    }
    mean2.addAssign(distribution.x);
    squaredMean.addAssign(add3(distribution.y.mul(distribution.y), distribution.x.mul(distribution.x)));
  });
  mean2.divAssign(samples);
  squaredMean.divAssign(samples);
  const std_dev = sqrt4(squaredMean.sub(mean2.mul(mean2)));
  return vec2(mean2, std_dev);
});
var _shadowFilterLib = [BasicShadowFilter, PCFShadowFilter, PCFSoftShadowFilter, VSMShadowFilter];
var _rendererState;
var _quadMesh = new QuadMesh();
var ShadowNode = class extends ShadowBaseNode {
  static get type() {
    return "ShadowNode";
  }
  /**
   * Constructs a new shadow node.
   *
   * @param {Light} light - The shadow casting light.
   * @param {?LightShadow} [shadow=null] - An optional light shadow.
   */
  constructor(light, shadow3 = null) {
    super(light);
    this.shadow = shadow3 || light.shadow;
    this.shadowMap = null;
    this.vsmShadowMapVertical = null;
    this.vsmShadowMapHorizontal = null;
    this.vsmMaterialVertical = null;
    this.vsmMaterialHorizontal = null;
    this._node = null;
    this._cameraFrameId = /* @__PURE__ */ new WeakMap();
    this.isShadowNode = true;
    this.depthLayer = 0;
  }
  /**
   * Setups the shadow filtering.
   *
   * @param {NodeBuilder} builder - A reference to the current node builder.
   * @param {Object} inputs - A configuration object that defines the shadow filtering.
   * @param {Function} inputs.filterFn - This function defines the filtering type of the shadow map e.g. PCF.
   * @param {DepthTexture} inputs.depthTexture - A reference to the shadow map's texture data.
   * @param {Node<vec3>} inputs.shadowCoord - Shadow coordinates which are used to sample from the shadow map.
   * @param {LightShadow} inputs.shadow - The light shadow.
   * @return {Node<float>} The result node of the shadow filtering.
   */
  setupShadowFilter(builder, { filterFn, depthTexture, shadowCoord, shadow: shadow3, depthLayer }) {
    const frustumTest = shadowCoord.x.greaterThanEqual(0).and(shadowCoord.x.lessThanEqual(1)).and(shadowCoord.y.greaterThanEqual(0)).and(shadowCoord.y.lessThanEqual(1)).and(shadowCoord.z.lessThanEqual(1));
    const shadowNode = filterFn({ depthTexture, shadowCoord, shadow: shadow3, depthLayer });
    return frustumTest.select(shadowNode, float(1));
  }
  /**
   * Setups the shadow coordinates.
   *
   * @param {NodeBuilder} builder - A reference to the current node builder.
   * @param {Node<vec3>} shadowPosition - A node representing the shadow position.
   * @return {Node<vec3>} The shadow coordinates.
   */
  setupShadowCoord(builder, shadowPosition) {
    const { shadow: shadow3 } = this;
    const { renderer } = builder;
    const bias = reference("bias", "float", shadow3).setGroup(renderGroup);
    let shadowCoord = shadowPosition;
    let coordZ;
    if (shadow3.camera.isOrthographicCamera || renderer.logarithmicDepthBuffer !== true) {
      shadowCoord = shadowCoord.xyz.div(shadowCoord.w);
      coordZ = shadowCoord.z;
      if (renderer.coordinateSystem === WebGPUCoordinateSystem) {
        coordZ = coordZ.mul(2).sub(1);
      }
    } else {
      const w = shadowCoord.w;
      shadowCoord = shadowCoord.xy.div(w);
      const cameraNearLocal = reference("near", "float", shadow3.camera).setGroup(renderGroup);
      const cameraFarLocal = reference("far", "float", shadow3.camera).setGroup(renderGroup);
      coordZ = viewZToLogarithmicDepth(w.negate(), cameraNearLocal, cameraFarLocal);
    }
    shadowCoord = vec3(
      shadowCoord.x,
      shadowCoord.y.oneMinus(),
      // follow webgpu standards
      coordZ.add(bias)
    );
    return shadowCoord;
  }
  /**
   * Returns the shadow filtering function for the given shadow type.
   *
   * @param {number} type - The shadow type.
   * @return {Function} The filtering function.
   */
  getShadowFilterFn(type) {
    return _shadowFilterLib[type];
  }
  setupRenderTarget(shadow3, builder) {
    const depthTexture = new DepthTexture(shadow3.mapSize.width, shadow3.mapSize.height);
    depthTexture.name = "ShadowDepthTexture";
    depthTexture.compareFunction = LessCompare;
    const shadowMap = builder.createRenderTarget(shadow3.mapSize.width, shadow3.mapSize.height);
    shadowMap.texture.name = "ShadowMap";
    shadowMap.texture.type = shadow3.mapType;
    shadowMap.depthTexture = depthTexture;
    return { shadowMap, depthTexture };
  }
  /**
   * Setups the shadow output node.
   *
   * @param {NodeBuilder} builder - A reference to the current node builder.
   * @return {Node<vec3>} The shadow output node.
   */
  setupShadow(builder) {
    const { renderer } = builder;
    const { light, shadow: shadow3 } = this;
    const shadowMapType = renderer.shadowMap.type;
    const { depthTexture, shadowMap } = this.setupRenderTarget(shadow3, builder);
    shadow3.camera.updateProjectionMatrix();
    if (shadowMapType === VSMShadowMap && shadow3.isPointLightShadow !== true) {
      depthTexture.compareFunction = null;
      if (shadowMap.depth > 1) {
        if (!shadowMap._vsmShadowMapVertical) {
          shadowMap._vsmShadowMapVertical = builder.createRenderTarget(shadow3.mapSize.width, shadow3.mapSize.height, { format: RGFormat, type: HalfFloatType, depth: shadowMap.depth, depthBuffer: false });
          shadowMap._vsmShadowMapVertical.texture.name = "VSMVertical";
        }
        this.vsmShadowMapVertical = shadowMap._vsmShadowMapVertical;
        if (!shadowMap._vsmShadowMapHorizontal) {
          shadowMap._vsmShadowMapHorizontal = builder.createRenderTarget(shadow3.mapSize.width, shadow3.mapSize.height, { format: RGFormat, type: HalfFloatType, depth: shadowMap.depth, depthBuffer: false });
          shadowMap._vsmShadowMapHorizontal.texture.name = "VSMHorizontal";
        }
        this.vsmShadowMapHorizontal = shadowMap._vsmShadowMapHorizontal;
      } else {
        this.vsmShadowMapVertical = builder.createRenderTarget(shadow3.mapSize.width, shadow3.mapSize.height, { format: RGFormat, type: HalfFloatType, depthBuffer: false });
        this.vsmShadowMapHorizontal = builder.createRenderTarget(shadow3.mapSize.width, shadow3.mapSize.height, { format: RGFormat, type: HalfFloatType, depthBuffer: false });
      }
      let shadowPassVertical = texture(depthTexture);
      if (depthTexture.isArrayTexture) {
        shadowPassVertical = shadowPassVertical.depth(this.depthLayer);
      }
      let shadowPassHorizontal = texture(this.vsmShadowMapVertical.texture);
      if (depthTexture.isArrayTexture) {
        shadowPassHorizontal = shadowPassHorizontal.depth(this.depthLayer);
      }
      const samples = reference("blurSamples", "float", shadow3).setGroup(renderGroup);
      const radius = reference("radius", "float", shadow3).setGroup(renderGroup);
      const size = reference("mapSize", "vec2", shadow3).setGroup(renderGroup);
      let material = this.vsmMaterialVertical || (this.vsmMaterialVertical = new NodeMaterial());
      material.fragmentNode = VSMPassVertical({ samples, radius, size, shadowPass: shadowPassVertical, depthLayer: this.depthLayer }).context(builder.getSharedContext());
      material.name = "VSMVertical";
      material = this.vsmMaterialHorizontal || (this.vsmMaterialHorizontal = new NodeMaterial());
      material.fragmentNode = VSMPassHorizontal({ samples, radius, size, shadowPass: shadowPassHorizontal, depthLayer: this.depthLayer }).context(builder.getSharedContext());
      material.name = "VSMHorizontal";
    }
    const shadowIntensity = reference("intensity", "float", shadow3).setGroup(renderGroup);
    const normalBias = reference("normalBias", "float", shadow3).setGroup(renderGroup);
    const shadowPosition = lightShadowMatrix(light).mul(shadowPositionWorld.add(normalWorld.mul(normalBias)));
    const shadowCoord = this.setupShadowCoord(builder, shadowPosition);
    const filterFn = shadow3.filterNode || this.getShadowFilterFn(renderer.shadowMap.type) || null;
    if (filterFn === null) {
      throw new Error("THREE.WebGPURenderer: Shadow map type not supported yet.");
    }
    const shadowDepthTexture = shadowMapType === VSMShadowMap && shadow3.isPointLightShadow !== true ? this.vsmShadowMapHorizontal.texture : depthTexture;
    const shadowNode = this.setupShadowFilter(builder, { filterFn, shadowTexture: shadowMap.texture, depthTexture: shadowDepthTexture, shadowCoord, shadow: shadow3, depthLayer: this.depthLayer });
    let shadowColor = texture(shadowMap.texture, shadowCoord);
    if (depthTexture.isArrayTexture) {
      shadowColor = shadowColor.depth(this.depthLayer);
    }
    const shadowOutput = mix(1, shadowNode.rgb.mix(shadowColor, 1), shadowIntensity.mul(shadowColor.a)).toVar();
    this.shadowMap = shadowMap;
    this.shadow.map = shadowMap;
    return shadowOutput;
  }
  /**
   * The implementation performs the setup of the output node. An output is only
   * produces if shadow mapping is globally enabled in the renderer.
   *
   * @param {NodeBuilder} builder - A reference to the current node builder.
   * @return {ShaderCallNodeInternal} The output node.
   */
  setup(builder) {
    if (builder.renderer.shadowMap.enabled === false) return;
    return Fn(() => {
      let node = this._node;
      this.setupShadowPosition(builder);
      if (node === null) {
        this._node = node = this.setupShadow(builder);
      }
      if (builder.material.shadowNode) {
        console.warn('THREE.NodeMaterial: ".shadowNode" is deprecated. Use ".castShadowNode" instead.');
      }
      if (builder.material.receivedShadowNode) {
        node = builder.material.receivedShadowNode(node);
      }
      return node;
    })();
  }
  /**
   * Renders the shadow. The logic of this function could be included
   * into {@link ShadowNode#updateShadow} however more specialized shadow
   * nodes might require a custom shadow map rendering. By having a
   * dedicated method, it's easier to overwrite the default behavior.
   *
   * @param {NodeFrame} frame - A reference to the current node frame.
   */
  renderShadow(frame) {
    const { shadow: shadow3, shadowMap, light } = this;
    const { renderer, scene } = frame;
    shadow3.updateMatrices(light);
    shadowMap.setSize(shadow3.mapSize.width, shadow3.mapSize.height, shadowMap.depth);
    renderer.render(scene, shadow3.camera);
  }
  /**
   * Updates the shadow.
   *
   * @param {NodeFrame} frame - A reference to the current node frame.
   */
  updateShadow(frame) {
    const { shadowMap, light, shadow: shadow3 } = this;
    const { renderer, scene, camera } = frame;
    const shadowType = renderer.shadowMap.type;
    const depthVersion = shadowMap.depthTexture.version;
    this._depthVersionCached = depthVersion;
    const _shadowCameraLayer = shadow3.camera.layers.mask;
    if ((shadow3.camera.layers.mask & 4294967294) === 0) {
      shadow3.camera.layers.mask = camera.layers.mask;
    }
    const currentRenderObjectFunction = renderer.getRenderObjectFunction();
    const currentMRT = renderer.getMRT();
    const useVelocity = currentMRT ? currentMRT.has("velocity") : false;
    _rendererState = resetRendererAndSceneState(renderer, scene, _rendererState);
    scene.overrideMaterial = getShadowMaterial(light);
    renderer.setRenderObjectFunction(getShadowRenderObjectFunction(renderer, shadow3, shadowType, useVelocity));
    renderer.setClearColor(0, 0);
    renderer.setRenderTarget(shadowMap);
    this.renderShadow(frame);
    renderer.setRenderObjectFunction(currentRenderObjectFunction);
    if (shadowType === VSMShadowMap && shadow3.isPointLightShadow !== true) {
      this.vsmPass(renderer);
    }
    shadow3.camera.layers.mask = _shadowCameraLayer;
    restoreRendererAndSceneState(renderer, scene, _rendererState);
  }
  /**
   * For VSM additional render passes are required.
   *
   * @param {Renderer} renderer - A reference to the current renderer.
   */
  vsmPass(renderer) {
    const { shadow: shadow3 } = this;
    const depth3 = this.shadowMap.depth;
    this.vsmShadowMapVertical.setSize(shadow3.mapSize.width, shadow3.mapSize.height, depth3);
    this.vsmShadowMapHorizontal.setSize(shadow3.mapSize.width, shadow3.mapSize.height, depth3);
    renderer.setRenderTarget(this.vsmShadowMapVertical);
    _quadMesh.material = this.vsmMaterialVertical;
    _quadMesh.render(renderer);
    renderer.setRenderTarget(this.vsmShadowMapHorizontal);
    _quadMesh.material = this.vsmMaterialHorizontal;
    _quadMesh.render(renderer);
  }
  /**
   * Frees the internal resources of this shadow node.
   */
  dispose() {
    this.shadowMap.dispose();
    this.shadowMap = null;
    if (this.vsmShadowMapVertical !== null) {
      this.vsmShadowMapVertical.dispose();
      this.vsmShadowMapVertical = null;
      this.vsmMaterialVertical.dispose();
      this.vsmMaterialVertical = null;
    }
    if (this.vsmShadowMapHorizontal !== null) {
      this.vsmShadowMapHorizontal.dispose();
      this.vsmShadowMapHorizontal = null;
      this.vsmMaterialHorizontal.dispose();
      this.vsmMaterialHorizontal = null;
    }
    super.dispose();
  }
  /**
   * The implementation performs the update of the shadow map if necessary.
   *
   * @param {NodeFrame} frame - A reference to the current node frame.
   */
  updateBefore(frame) {
    const { shadow: shadow3 } = this;
    let needsUpdate = shadow3.needsUpdate || shadow3.autoUpdate;
    if (needsUpdate) {
      if (this._cameraFrameId[frame.camera] === frame.frameId) {
        needsUpdate = false;
      }
      this._cameraFrameId[frame.camera] = frame.frameId;
    }
    if (needsUpdate) {
      this.updateShadow(frame);
      if (this.shadowMap.depthTexture.version === this._depthVersionCached) {
        shadow3.needsUpdate = false;
      }
    }
  }
};
var shadow = (light, shadow3) => nodeObject(new ShadowNode(light, shadow3));
var _clearColor$1 = new Color();
var cubeToUV = Fn(([pos, texelSizeY]) => {
  const v2 = pos.toVar();
  const absV = abs2(v2);
  const scaleToCube = div(1, max$1(absV.x, max$1(absV.y, absV.z)));
  absV.mulAssign(scaleToCube);
  v2.mulAssign(scaleToCube.mul(texelSizeY.mul(2).oneMinus()));
  const planar = vec2(v2.xy).toVar();
  const almostATexel = texelSizeY.mul(1.5);
  const almostOne = almostATexel.oneMinus();
  If(absV.z.greaterThanEqual(almostOne), () => {
    If(v2.z.greaterThan(0), () => {
      planar.x.assign(sub(4, v2.x));
    });
  }).ElseIf(absV.x.greaterThanEqual(almostOne), () => {
    const signX = sign4(v2.x);
    planar.x.assign(v2.z.mul(signX).add(signX.mul(2)));
  }).ElseIf(absV.y.greaterThanEqual(almostOne), () => {
    const signY = sign4(v2.y);
    planar.x.assign(v2.x.add(signY.mul(2)).add(2));
    planar.y.assign(v2.z.mul(signY).sub(2));
  });
  return vec2(0.125, 0.25).mul(planar).add(vec2(0.375, 0.75)).flipY();
}).setLayout({
  name: "cubeToUV",
  type: "vec2",
  inputs: [
    { name: "pos", type: "vec3" },
    { name: "texelSizeY", type: "float" }
  ]
});
var BasicPointShadowFilter = Fn(({ depthTexture, bd3D, dp, texelSize }) => {
  return texture(depthTexture, cubeToUV(bd3D, texelSize.y)).compare(dp);
});
var PointShadowFilter = Fn(({ depthTexture, bd3D, dp, texelSize, shadow: shadow3 }) => {
  const radius = reference("radius", "float", shadow3).setGroup(renderGroup);
  const offset = vec2(-1, 1).mul(radius).mul(texelSize.y);
  return texture(depthTexture, cubeToUV(bd3D.add(offset.xyy), texelSize.y)).compare(dp).add(texture(depthTexture, cubeToUV(bd3D.add(offset.yyy), texelSize.y)).compare(dp)).add(texture(depthTexture, cubeToUV(bd3D.add(offset.xyx), texelSize.y)).compare(dp)).add(texture(depthTexture, cubeToUV(bd3D.add(offset.yyx), texelSize.y)).compare(dp)).add(texture(depthTexture, cubeToUV(bd3D, texelSize.y)).compare(dp)).add(texture(depthTexture, cubeToUV(bd3D.add(offset.xxy), texelSize.y)).compare(dp)).add(texture(depthTexture, cubeToUV(bd3D.add(offset.yxy), texelSize.y)).compare(dp)).add(texture(depthTexture, cubeToUV(bd3D.add(offset.xxx), texelSize.y)).compare(dp)).add(texture(depthTexture, cubeToUV(bd3D.add(offset.yxx), texelSize.y)).compare(dp)).mul(1 / 9);
});
var pointShadowFilter = Fn(({ filterFn, depthTexture, shadowCoord, shadow: shadow3 }) => {
  const lightToPosition = shadowCoord.xyz.toVar();
  const lightToPositionLength = lightToPosition.length();
  const cameraNearLocal = uniform("float").setGroup(renderGroup).onRenderUpdate(() => shadow3.camera.near);
  const cameraFarLocal = uniform("float").setGroup(renderGroup).onRenderUpdate(() => shadow3.camera.far);
  const bias = reference("bias", "float", shadow3).setGroup(renderGroup);
  const mapSize = uniform(shadow3.mapSize).setGroup(renderGroup);
  const result = float(1).toVar();
  If(lightToPositionLength.sub(cameraFarLocal).lessThanEqual(0).and(lightToPositionLength.sub(cameraNearLocal).greaterThanEqual(0)), () => {
    const dp = lightToPositionLength.sub(cameraNearLocal).div(cameraFarLocal.sub(cameraNearLocal)).toVar();
    dp.addAssign(bias);
    const bd3D = lightToPosition.normalize();
    const texelSize = vec2(1).div(mapSize.mul(vec2(4, 2)));
    result.assign(filterFn({ depthTexture, bd3D, dp, texelSize, shadow: shadow3 }));
  });
  return result;
});
var _viewport = new Vector4();
var _viewportSize = new Vector2();
var _shadowMapSize = new Vector2();
var PointShadowNode = class extends ShadowNode {
  static get type() {
    return "PointShadowNode";
  }
  /**
   * Constructs a new point shadow node.
   *
   * @param {PointLight} light - The shadow casting point light.
   * @param {?PointLightShadow} [shadow=null] - An optional point light shadow.
   */
  constructor(light, shadow3 = null) {
    super(light, shadow3);
  }
  /**
   * Overwrites the default implementation to return point light shadow specific
   * filtering functions.
   *
   * @param {number} type - The shadow type.
   * @return {Function} The filtering function.
   */
  getShadowFilterFn(type) {
    return type === BasicShadowMap ? BasicPointShadowFilter : PointShadowFilter;
  }
  /**
   * Overwrites the default implementation so the unaltered shadow position is used.
   *
   * @param {NodeBuilder} builder - A reference to the current node builder.
   * @param {Node<vec3>} shadowPosition - A node representing the shadow position.
   * @return {Node<vec3>} The shadow coordinates.
   */
  setupShadowCoord(builder, shadowPosition) {
    return shadowPosition;
  }
  /**
   * Overwrites the default implementation to only use point light specific
   * shadow filter functions.
   *
   * @param {NodeBuilder} builder - A reference to the current node builder.
   * @param {Object} inputs - A configuration object that defines the shadow filtering.
   * @param {Function} inputs.filterFn - This function defines the filtering type of the shadow map e.g. PCF.
   * @param {Texture} inputs.shadowTexture - A reference to the shadow map's texture.
   * @param {DepthTexture} inputs.depthTexture - A reference to the shadow map's texture data.
   * @param {Node<vec3>} inputs.shadowCoord - Shadow coordinates which are used to sample from the shadow map.
   * @param {LightShadow} inputs.shadow - The light shadow.
   * @return {Node<float>} The result node of the shadow filtering.
   */
  setupShadowFilter(builder, { filterFn, shadowTexture, depthTexture, shadowCoord, shadow: shadow3 }) {
    return pointShadowFilter({ filterFn, shadowTexture, depthTexture, shadowCoord, shadow: shadow3 });
  }
  /**
   * Overwrites the default implementation with point light specific
   * rendering code.
   *
   * @param {NodeFrame} frame - A reference to the current node frame.
   */
  renderShadow(frame) {
    const { shadow: shadow3, shadowMap, light } = this;
    const { renderer, scene } = frame;
    const shadowFrameExtents = shadow3.getFrameExtents();
    _shadowMapSize.copy(shadow3.mapSize);
    _shadowMapSize.multiply(shadowFrameExtents);
    shadowMap.setSize(_shadowMapSize.width, _shadowMapSize.height);
    _viewportSize.copy(shadow3.mapSize);
    const previousAutoClear = renderer.autoClear;
    const previousClearColor = renderer.getClearColor(_clearColor$1);
    const previousClearAlpha = renderer.getClearAlpha();
    renderer.autoClear = false;
    renderer.setClearColor(shadow3.clearColor, shadow3.clearAlpha);
    renderer.clear();
    const viewportCount = shadow3.getViewportCount();
    for (let vp = 0; vp < viewportCount; vp++) {
      const viewport3 = shadow3.getViewport(vp);
      const x = _viewportSize.x * viewport3.x;
      const y = _shadowMapSize.y - _viewportSize.y - _viewportSize.y * viewport3.y;
      _viewport.set(
        x,
        y,
        _viewportSize.x * viewport3.z,
        _viewportSize.y * viewport3.w
      );
      shadowMap.viewport.copy(_viewport);
      shadow3.updateMatrices(light, vp);
      renderer.render(scene, shadow3.camera);
    }
    renderer.autoClear = previousAutoClear;
    renderer.setClearColor(previousClearColor, previousClearAlpha);
  }
};
var pointShadow = (light, shadow3) => nodeObject(new PointShadowNode(light, shadow3));
var AnalyticLightNode = class extends LightingNode {
  static get type() {
    return "AnalyticLightNode";
  }
  /**
   * Constructs a new analytic light node.
   *
   * @param {?Light} [light=null] - The light source.
   */
  constructor(light = null) {
    super();
    this.light = light;
    this.color = new Color();
    this.colorNode = light && light.colorNode || uniform(this.color).setGroup(renderGroup);
    this.baseColorNode = null;
    this.shadowNode = null;
    this.shadowColorNode = null;
    this.isAnalyticLightNode = true;
    this.updateType = NodeUpdateType.FRAME;
  }
  getHash() {
    return this.light.uuid;
  }
  /**
   * Returns a node representing a direction vector which points from the current
   * position in view space to the light's position in view space.
   *
   * @param {NodeBuilder} builder - The builder object used for setting up the light.
   * @return {Node<vec3>} The light vector node.
   */
  getLightVector(builder) {
    return lightViewPosition(this.light).sub(builder.context.positionView || positionView);
  }
  /**
   * Sets up the direct lighting for the analytic light node.
   *
   * @abstract
   * @param {NodeBuilder} builder - The builder object used for setting up the light.
   * @return {Object|undefined} The direct light data (color and direction).
   */
  setupDirect() {
  }
  /**
   * Sets up the direct rect area lighting for the analytic light node.
   *
   * @abstract
   * @param {NodeBuilder} builder - The builder object used for setting up the light.
   * @return {Object|undefined} The direct rect area light data.
   */
  setupDirectRectArea() {
  }
  /**
   * Setups the shadow node for this light. The method exists so concrete light classes
   * can setup different types of shadow nodes.
   *
   * @return {ShadowNode} The created shadow node.
   */
  setupShadowNode() {
    return shadow(this.light);
  }
  /**
   * Setups the shadow for this light. This method is only executed if the light
   * cast shadows and the current build object receives shadows. It incorporates
   * shadows into the lighting computation.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  setupShadow(builder) {
    const { renderer } = builder;
    if (renderer.shadowMap.enabled === false) return;
    let shadowColorNode = this.shadowColorNode;
    if (shadowColorNode === null) {
      const customShadowNode = this.light.shadow.shadowNode;
      let shadowNode;
      if (customShadowNode !== void 0) {
        shadowNode = nodeObject(customShadowNode);
      } else {
        shadowNode = this.setupShadowNode();
      }
      this.shadowNode = shadowNode;
      this.shadowColorNode = shadowColorNode = this.colorNode.mul(shadowNode);
      this.baseColorNode = this.colorNode;
    }
    this.colorNode = shadowColorNode;
  }
  /**
   * Unlike most other nodes, lighting nodes do not return a output node in {@link Node#setup}.
   * The main purpose of lighting nodes is to configure the current {@link LightingModel} and/or
   * invocate the respective interface methods.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  setup(builder) {
    this.colorNode = this.baseColorNode || this.colorNode;
    if (this.light.castShadow) {
      if (builder.object.receiveShadow) {
        this.setupShadow(builder);
      }
    } else if (this.shadowNode !== null) {
      this.shadowNode.dispose();
      this.shadowNode = null;
      this.shadowColorNode = null;
    }
    const directLightData = this.setupDirect(builder);
    const directRectAreaLightData = this.setupDirectRectArea(builder);
    if (directLightData) {
      builder.lightsNode.setupDirectLight(builder, this, directLightData);
    }
    if (directRectAreaLightData) {
      builder.lightsNode.setupDirectRectAreaLight(builder, this, directRectAreaLightData);
    }
  }
  /**
   * The update method is used to update light uniforms per frame.
   * Potentially overwritten in concrete light nodes to update light
   * specific uniforms.
   *
   * @param {NodeFrame} frame - A reference to the current node frame.
   */
  update() {
    const { light } = this;
    this.color.copy(light.color).multiplyScalar(light.intensity);
  }
};
var getDistanceAttenuation = Fn(({ lightDistance, cutoffDistance, decayExponent }) => {
  const distanceFalloff = lightDistance.pow(decayExponent).max(0.01).reciprocal();
  return cutoffDistance.greaterThan(0).select(
    distanceFalloff.mul(lightDistance.div(cutoffDistance).pow4().oneMinus().clamp().pow2()),
    distanceFalloff
  );
});
var directPointLight = ({ color: color4, lightVector, cutoffDistance, decayExponent }) => {
  const lightDirection = lightVector.normalize();
  const lightDistance = lightVector.length();
  const attenuation = getDistanceAttenuation({
    lightDistance,
    cutoffDistance,
    decayExponent
  });
  const lightColor = color4.mul(attenuation);
  return { lightDirection, lightColor };
};
var PointLightNode = class extends AnalyticLightNode {
  static get type() {
    return "PointLightNode";
  }
  /**
   * Constructs a new point light node.
   *
   * @param {?PointLight} [light=null] - The point light source.
   */
  constructor(light = null) {
    super(light);
    this.cutoffDistanceNode = uniform(0).setGroup(renderGroup);
    this.decayExponentNode = uniform(2).setGroup(renderGroup);
  }
  /**
   * Overwritten to updated point light specific uniforms.
   *
   * @param {NodeFrame} frame - A reference to the current node frame.
   */
  update(frame) {
    const { light } = this;
    super.update(frame);
    this.cutoffDistanceNode.value = light.distance;
    this.decayExponentNode.value = light.decay;
  }
  /**
   * Overwritten to setup point light specific shadow.
   *
   * @return {PointShadowNode}
   */
  setupShadowNode() {
    return pointShadow(this.light);
  }
  setupDirect(builder) {
    return directPointLight({
      color: this.colorNode,
      lightVector: this.getLightVector(builder),
      cutoffDistance: this.cutoffDistanceNode,
      decayExponent: this.decayExponentNode
    });
  }
};
var checker = Fn(([coord = uv$1()]) => {
  const uv3 = coord.mul(2);
  const cx = uv3.x.floor();
  const cy = uv3.y.floor();
  const result = cx.add(cy).mod(2);
  return result.sign();
});
var shapeCircle = Fn(([coord = uv$1()], { renderer, material }) => {
  const len2 = lengthSq(coord.mul(2).sub(1));
  let alpha;
  if (material.alphaToCoverage && renderer.samples > 1) {
    const dlen = float(len2.fwidth()).toVar();
    alpha = smoothstep(dlen.oneMinus(), dlen.add(1), len2).oneMinus();
  } else {
    alpha = select(len2.greaterThan(1), 0, 1);
  }
  return alpha;
});
var mx_select = Fn(([b_immutable, t_immutable, f_immutable]) => {
  const f = float(f_immutable).toVar();
  const t = float(t_immutable).toVar();
  const b = bool(b_immutable).toVar();
  return select(b, t, f);
}).setLayout({
  name: "mx_select",
  type: "float",
  inputs: [
    { name: "b", type: "bool" },
    { name: "t", type: "float" },
    { name: "f", type: "float" }
  ]
});
var mx_negate_if = Fn(([val_immutable, b_immutable]) => {
  const b = bool(b_immutable).toVar();
  const val = float(val_immutable).toVar();
  return select(b, val.negate(), val);
}).setLayout({
  name: "mx_negate_if",
  type: "float",
  inputs: [
    { name: "val", type: "float" },
    { name: "b", type: "bool" }
  ]
});
var mx_floor = Fn(([x_immutable]) => {
  const x = float(x_immutable).toVar();
  return int(floor(x));
}).setLayout({
  name: "mx_floor",
  type: "int",
  inputs: [
    { name: "x", type: "float" }
  ]
});
var mx_floorfrac = Fn(([x_immutable, i]) => {
  const x = float(x_immutable).toVar();
  i.assign(mx_floor(x));
  return x.sub(float(i));
});
var mx_bilerp_0 = Fn(([v0_immutable, v1_immutable, v2_immutable, v3_immutable, s_immutable, t_immutable]) => {
  const t = float(t_immutable).toVar();
  const s = float(s_immutable).toVar();
  const v3 = float(v3_immutable).toVar();
  const v2 = float(v2_immutable).toVar();
  const v1 = float(v1_immutable).toVar();
  const v0 = float(v0_immutable).toVar();
  const s1 = float(sub(1, s)).toVar();
  return sub(1, t).mul(v0.mul(s1).add(v1.mul(s))).add(t.mul(v2.mul(s1).add(v3.mul(s))));
}).setLayout({
  name: "mx_bilerp_0",
  type: "float",
  inputs: [
    { name: "v0", type: "float" },
    { name: "v1", type: "float" },
    { name: "v2", type: "float" },
    { name: "v3", type: "float" },
    { name: "s", type: "float" },
    { name: "t", type: "float" }
  ]
});
var mx_bilerp_1 = Fn(([v0_immutable, v1_immutable, v2_immutable, v3_immutable, s_immutable, t_immutable]) => {
  const t = float(t_immutable).toVar();
  const s = float(s_immutable).toVar();
  const v3 = vec3(v3_immutable).toVar();
  const v2 = vec3(v2_immutable).toVar();
  const v1 = vec3(v1_immutable).toVar();
  const v0 = vec3(v0_immutable).toVar();
  const s1 = float(sub(1, s)).toVar();
  return sub(1, t).mul(v0.mul(s1).add(v1.mul(s))).add(t.mul(v2.mul(s1).add(v3.mul(s))));
}).setLayout({
  name: "mx_bilerp_1",
  type: "vec3",
  inputs: [
    { name: "v0", type: "vec3" },
    { name: "v1", type: "vec3" },
    { name: "v2", type: "vec3" },
    { name: "v3", type: "vec3" },
    { name: "s", type: "float" },
    { name: "t", type: "float" }
  ]
});
var mx_bilerp = overloadingFn([mx_bilerp_0, mx_bilerp_1]);
var mx_trilerp_0 = Fn(([v0_immutable, v1_immutable, v2_immutable, v3_immutable, v4_immutable, v5_immutable, v6_immutable, v7_immutable, s_immutable, t_immutable, r_immutable]) => {
  const r = float(r_immutable).toVar();
  const t = float(t_immutable).toVar();
  const s = float(s_immutable).toVar();
  const v7 = float(v7_immutable).toVar();
  const v6 = float(v6_immutable).toVar();
  const v5 = float(v5_immutable).toVar();
  const v4 = float(v4_immutable).toVar();
  const v3 = float(v3_immutable).toVar();
  const v2 = float(v2_immutable).toVar();
  const v1 = float(v1_immutable).toVar();
  const v0 = float(v0_immutable).toVar();
  const s1 = float(sub(1, s)).toVar();
  const t13 = float(sub(1, t)).toVar();
  const r1 = float(sub(1, r)).toVar();
  return r1.mul(t13.mul(v0.mul(s1).add(v1.mul(s))).add(t.mul(v2.mul(s1).add(v3.mul(s))))).add(r.mul(t13.mul(v4.mul(s1).add(v5.mul(s))).add(t.mul(v6.mul(s1).add(v7.mul(s))))));
}).setLayout({
  name: "mx_trilerp_0",
  type: "float",
  inputs: [
    { name: "v0", type: "float" },
    { name: "v1", type: "float" },
    { name: "v2", type: "float" },
    { name: "v3", type: "float" },
    { name: "v4", type: "float" },
    { name: "v5", type: "float" },
    { name: "v6", type: "float" },
    { name: "v7", type: "float" },
    { name: "s", type: "float" },
    { name: "t", type: "float" },
    { name: "r", type: "float" }
  ]
});
var mx_trilerp_1 = Fn(([v0_immutable, v1_immutable, v2_immutable, v3_immutable, v4_immutable, v5_immutable, v6_immutable, v7_immutable, s_immutable, t_immutable, r_immutable]) => {
  const r = float(r_immutable).toVar();
  const t = float(t_immutable).toVar();
  const s = float(s_immutable).toVar();
  const v7 = vec3(v7_immutable).toVar();
  const v6 = vec3(v6_immutable).toVar();
  const v5 = vec3(v5_immutable).toVar();
  const v4 = vec3(v4_immutable).toVar();
  const v3 = vec3(v3_immutable).toVar();
  const v2 = vec3(v2_immutable).toVar();
  const v1 = vec3(v1_immutable).toVar();
  const v0 = vec3(v0_immutable).toVar();
  const s1 = float(sub(1, s)).toVar();
  const t13 = float(sub(1, t)).toVar();
  const r1 = float(sub(1, r)).toVar();
  return r1.mul(t13.mul(v0.mul(s1).add(v1.mul(s))).add(t.mul(v2.mul(s1).add(v3.mul(s))))).add(r.mul(t13.mul(v4.mul(s1).add(v5.mul(s))).add(t.mul(v6.mul(s1).add(v7.mul(s))))));
}).setLayout({
  name: "mx_trilerp_1",
  type: "vec3",
  inputs: [
    { name: "v0", type: "vec3" },
    { name: "v1", type: "vec3" },
    { name: "v2", type: "vec3" },
    { name: "v3", type: "vec3" },
    { name: "v4", type: "vec3" },
    { name: "v5", type: "vec3" },
    { name: "v6", type: "vec3" },
    { name: "v7", type: "vec3" },
    { name: "s", type: "float" },
    { name: "t", type: "float" },
    { name: "r", type: "float" }
  ]
});
var mx_trilerp = overloadingFn([mx_trilerp_0, mx_trilerp_1]);
var mx_gradient_float_0 = Fn(([hash_immutable, x_immutable, y_immutable]) => {
  const y = float(y_immutable).toVar();
  const x = float(x_immutable).toVar();
  const hash3 = uint(hash_immutable).toVar();
  const h = uint(hash3.bitAnd(uint(7))).toVar();
  const u4 = float(mx_select(h.lessThan(uint(4)), x, y)).toVar();
  const v2 = float(mul(2, mx_select(h.lessThan(uint(4)), y, x))).toVar();
  return mx_negate_if(u4, bool(h.bitAnd(uint(1)))).add(mx_negate_if(v2, bool(h.bitAnd(uint(2)))));
}).setLayout({
  name: "mx_gradient_float_0",
  type: "float",
  inputs: [
    { name: "hash", type: "uint" },
    { name: "x", type: "float" },
    { name: "y", type: "float" }
  ]
});
var mx_gradient_float_1 = Fn(([hash_immutable, x_immutable, y_immutable, z_immutable]) => {
  const z = float(z_immutable).toVar();
  const y = float(y_immutable).toVar();
  const x = float(x_immutable).toVar();
  const hash3 = uint(hash_immutable).toVar();
  const h = uint(hash3.bitAnd(uint(15))).toVar();
  const u4 = float(mx_select(h.lessThan(uint(8)), x, y)).toVar();
  const v2 = float(mx_select(h.lessThan(uint(4)), y, mx_select(h.equal(uint(12)).or(h.equal(uint(14))), x, z))).toVar();
  return mx_negate_if(u4, bool(h.bitAnd(uint(1)))).add(mx_negate_if(v2, bool(h.bitAnd(uint(2)))));
}).setLayout({
  name: "mx_gradient_float_1",
  type: "float",
  inputs: [
    { name: "hash", type: "uint" },
    { name: "x", type: "float" },
    { name: "y", type: "float" },
    { name: "z", type: "float" }
  ]
});
var mx_gradient_float = overloadingFn([mx_gradient_float_0, mx_gradient_float_1]);
var mx_gradient_vec3_0 = Fn(([hash_immutable, x_immutable, y_immutable]) => {
  const y = float(y_immutable).toVar();
  const x = float(x_immutable).toVar();
  const hash3 = uvec3(hash_immutable).toVar();
  return vec3(mx_gradient_float(hash3.x, x, y), mx_gradient_float(hash3.y, x, y), mx_gradient_float(hash3.z, x, y));
}).setLayout({
  name: "mx_gradient_vec3_0",
  type: "vec3",
  inputs: [
    { name: "hash", type: "uvec3" },
    { name: "x", type: "float" },
    { name: "y", type: "float" }
  ]
});
var mx_gradient_vec3_1 = Fn(([hash_immutable, x_immutable, y_immutable, z_immutable]) => {
  const z = float(z_immutable).toVar();
  const y = float(y_immutable).toVar();
  const x = float(x_immutable).toVar();
  const hash3 = uvec3(hash_immutable).toVar();
  return vec3(mx_gradient_float(hash3.x, x, y, z), mx_gradient_float(hash3.y, x, y, z), mx_gradient_float(hash3.z, x, y, z));
}).setLayout({
  name: "mx_gradient_vec3_1",
  type: "vec3",
  inputs: [
    { name: "hash", type: "uvec3" },
    { name: "x", type: "float" },
    { name: "y", type: "float" },
    { name: "z", type: "float" }
  ]
});
var mx_gradient_vec3 = overloadingFn([mx_gradient_vec3_0, mx_gradient_vec3_1]);
var mx_gradient_scale2d_0 = Fn(([v_immutable]) => {
  const v2 = float(v_immutable).toVar();
  return mul(0.6616, v2);
}).setLayout({
  name: "mx_gradient_scale2d_0",
  type: "float",
  inputs: [
    { name: "v", type: "float" }
  ]
});
var mx_gradient_scale3d_0 = Fn(([v_immutable]) => {
  const v2 = float(v_immutable).toVar();
  return mul(0.982, v2);
}).setLayout({
  name: "mx_gradient_scale3d_0",
  type: "float",
  inputs: [
    { name: "v", type: "float" }
  ]
});
var mx_gradient_scale2d_1 = Fn(([v_immutable]) => {
  const v2 = vec3(v_immutable).toVar();
  return mul(0.6616, v2);
}).setLayout({
  name: "mx_gradient_scale2d_1",
  type: "vec3",
  inputs: [
    { name: "v", type: "vec3" }
  ]
});
var mx_gradient_scale2d = overloadingFn([mx_gradient_scale2d_0, mx_gradient_scale2d_1]);
var mx_gradient_scale3d_1 = Fn(([v_immutable]) => {
  const v2 = vec3(v_immutable).toVar();
  return mul(0.982, v2);
}).setLayout({
  name: "mx_gradient_scale3d_1",
  type: "vec3",
  inputs: [
    { name: "v", type: "vec3" }
  ]
});
var mx_gradient_scale3d = overloadingFn([mx_gradient_scale3d_0, mx_gradient_scale3d_1]);
var mx_rotl32 = Fn(([x_immutable, k_immutable]) => {
  const k = int(k_immutable).toVar();
  const x = uint(x_immutable).toVar();
  return x.shiftLeft(k).bitOr(x.shiftRight(int(32).sub(k)));
}).setLayout({
  name: "mx_rotl32",
  type: "uint",
  inputs: [
    { name: "x", type: "uint" },
    { name: "k", type: "int" }
  ]
});
var mx_bjmix = Fn(([a, b, c3]) => {
  a.subAssign(c3);
  a.bitXorAssign(mx_rotl32(c3, int(4)));
  c3.addAssign(b);
  b.subAssign(a);
  b.bitXorAssign(mx_rotl32(a, int(6)));
  a.addAssign(c3);
  c3.subAssign(b);
  c3.bitXorAssign(mx_rotl32(b, int(8)));
  b.addAssign(a);
  a.subAssign(c3);
  a.bitXorAssign(mx_rotl32(c3, int(16)));
  c3.addAssign(b);
  b.subAssign(a);
  b.bitXorAssign(mx_rotl32(a, int(19)));
  a.addAssign(c3);
  c3.subAssign(b);
  c3.bitXorAssign(mx_rotl32(b, int(4)));
  b.addAssign(a);
});
var mx_bjfinal = Fn(([a_immutable, b_immutable, c_immutable]) => {
  const c3 = uint(c_immutable).toVar();
  const b = uint(b_immutable).toVar();
  const a = uint(a_immutable).toVar();
  c3.bitXorAssign(b);
  c3.subAssign(mx_rotl32(b, int(14)));
  a.bitXorAssign(c3);
  a.subAssign(mx_rotl32(c3, int(11)));
  b.bitXorAssign(a);
  b.subAssign(mx_rotl32(a, int(25)));
  c3.bitXorAssign(b);
  c3.subAssign(mx_rotl32(b, int(16)));
  a.bitXorAssign(c3);
  a.subAssign(mx_rotl32(c3, int(4)));
  b.bitXorAssign(a);
  b.subAssign(mx_rotl32(a, int(14)));
  c3.bitXorAssign(b);
  c3.subAssign(mx_rotl32(b, int(24)));
  return c3;
}).setLayout({
  name: "mx_bjfinal",
  type: "uint",
  inputs: [
    { name: "a", type: "uint" },
    { name: "b", type: "uint" },
    { name: "c", type: "uint" }
  ]
});
var mx_bits_to_01 = Fn(([bits_immutable]) => {
  const bits = uint(bits_immutable).toVar();
  return float(bits).div(float(uint(int(4294967295))));
}).setLayout({
  name: "mx_bits_to_01",
  type: "float",
  inputs: [
    { name: "bits", type: "uint" }
  ]
});
var mx_fade = Fn(([t_immutable]) => {
  const t = float(t_immutable).toVar();
  return t.mul(t).mul(t).mul(t.mul(t.mul(6).sub(15)).add(10));
}).setLayout({
  name: "mx_fade",
  type: "float",
  inputs: [
    { name: "t", type: "float" }
  ]
});
var mx_hash_int_0 = Fn(([x_immutable]) => {
  const x = int(x_immutable).toVar();
  const len = uint(uint(1)).toVar();
  const seed = uint(uint(int(3735928559)).add(len.shiftLeft(uint(2))).add(uint(13))).toVar();
  return mx_bjfinal(seed.add(uint(x)), seed, seed);
}).setLayout({
  name: "mx_hash_int_0",
  type: "uint",
  inputs: [
    { name: "x", type: "int" }
  ]
});
var mx_hash_int_1 = Fn(([x_immutable, y_immutable]) => {
  const y = int(y_immutable).toVar();
  const x = int(x_immutable).toVar();
  const len = uint(uint(2)).toVar();
  const a = uint().toVar(), b = uint().toVar(), c3 = uint().toVar();
  a.assign(b.assign(c3.assign(uint(int(3735928559)).add(len.shiftLeft(uint(2))).add(uint(13)))));
  a.addAssign(uint(x));
  b.addAssign(uint(y));
  return mx_bjfinal(a, b, c3);
}).setLayout({
  name: "mx_hash_int_1",
  type: "uint",
  inputs: [
    { name: "x", type: "int" },
    { name: "y", type: "int" }
  ]
});
var mx_hash_int_2 = Fn(([x_immutable, y_immutable, z_immutable]) => {
  const z = int(z_immutable).toVar();
  const y = int(y_immutable).toVar();
  const x = int(x_immutable).toVar();
  const len = uint(uint(3)).toVar();
  const a = uint().toVar(), b = uint().toVar(), c3 = uint().toVar();
  a.assign(b.assign(c3.assign(uint(int(3735928559)).add(len.shiftLeft(uint(2))).add(uint(13)))));
  a.addAssign(uint(x));
  b.addAssign(uint(y));
  c3.addAssign(uint(z));
  return mx_bjfinal(a, b, c3);
}).setLayout({
  name: "mx_hash_int_2",
  type: "uint",
  inputs: [
    { name: "x", type: "int" },
    { name: "y", type: "int" },
    { name: "z", type: "int" }
  ]
});
var mx_hash_int_3 = Fn(([x_immutable, y_immutable, z_immutable, xx_immutable]) => {
  const xx = int(xx_immutable).toVar();
  const z = int(z_immutable).toVar();
  const y = int(y_immutable).toVar();
  const x = int(x_immutable).toVar();
  const len = uint(uint(4)).toVar();
  const a = uint().toVar(), b = uint().toVar(), c3 = uint().toVar();
  a.assign(b.assign(c3.assign(uint(int(3735928559)).add(len.shiftLeft(uint(2))).add(uint(13)))));
  a.addAssign(uint(x));
  b.addAssign(uint(y));
  c3.addAssign(uint(z));
  mx_bjmix(a, b, c3);
  a.addAssign(uint(xx));
  return mx_bjfinal(a, b, c3);
}).setLayout({
  name: "mx_hash_int_3",
  type: "uint",
  inputs: [
    { name: "x", type: "int" },
    { name: "y", type: "int" },
    { name: "z", type: "int" },
    { name: "xx", type: "int" }
  ]
});
var mx_hash_int_4 = Fn(([x_immutable, y_immutable, z_immutable, xx_immutable, yy_immutable]) => {
  const yy = int(yy_immutable).toVar();
  const xx = int(xx_immutable).toVar();
  const z = int(z_immutable).toVar();
  const y = int(y_immutable).toVar();
  const x = int(x_immutable).toVar();
  const len = uint(uint(5)).toVar();
  const a = uint().toVar(), b = uint().toVar(), c3 = uint().toVar();
  a.assign(b.assign(c3.assign(uint(int(3735928559)).add(len.shiftLeft(uint(2))).add(uint(13)))));
  a.addAssign(uint(x));
  b.addAssign(uint(y));
  c3.addAssign(uint(z));
  mx_bjmix(a, b, c3);
  a.addAssign(uint(xx));
  b.addAssign(uint(yy));
  return mx_bjfinal(a, b, c3);
}).setLayout({
  name: "mx_hash_int_4",
  type: "uint",
  inputs: [
    { name: "x", type: "int" },
    { name: "y", type: "int" },
    { name: "z", type: "int" },
    { name: "xx", type: "int" },
    { name: "yy", type: "int" }
  ]
});
var mx_hash_int = overloadingFn([mx_hash_int_0, mx_hash_int_1, mx_hash_int_2, mx_hash_int_3, mx_hash_int_4]);
var mx_hash_vec3_0 = Fn(([x_immutable, y_immutable]) => {
  const y = int(y_immutable).toVar();
  const x = int(x_immutable).toVar();
  const h = uint(mx_hash_int(x, y)).toVar();
  const result = uvec3().toVar();
  result.x.assign(h.bitAnd(int(255)));
  result.y.assign(h.shiftRight(int(8)).bitAnd(int(255)));
  result.z.assign(h.shiftRight(int(16)).bitAnd(int(255)));
  return result;
}).setLayout({
  name: "mx_hash_vec3_0",
  type: "uvec3",
  inputs: [
    { name: "x", type: "int" },
    { name: "y", type: "int" }
  ]
});
var mx_hash_vec3_1 = Fn(([x_immutable, y_immutable, z_immutable]) => {
  const z = int(z_immutable).toVar();
  const y = int(y_immutable).toVar();
  const x = int(x_immutable).toVar();
  const h = uint(mx_hash_int(x, y, z)).toVar();
  const result = uvec3().toVar();
  result.x.assign(h.bitAnd(int(255)));
  result.y.assign(h.shiftRight(int(8)).bitAnd(int(255)));
  result.z.assign(h.shiftRight(int(16)).bitAnd(int(255)));
  return result;
}).setLayout({
  name: "mx_hash_vec3_1",
  type: "uvec3",
  inputs: [
    { name: "x", type: "int" },
    { name: "y", type: "int" },
    { name: "z", type: "int" }
  ]
});
var mx_hash_vec3 = overloadingFn([mx_hash_vec3_0, mx_hash_vec3_1]);
var mx_perlin_noise_float_0 = Fn(([p_immutable]) => {
  const p = vec2(p_immutable).toVar();
  const X = int().toVar(), Y = int().toVar();
  const fx = float(mx_floorfrac(p.x, X)).toVar();
  const fy = float(mx_floorfrac(p.y, Y)).toVar();
  const u4 = float(mx_fade(fx)).toVar();
  const v2 = float(mx_fade(fy)).toVar();
  const result = float(mx_bilerp(mx_gradient_float(mx_hash_int(X, Y), fx, fy), mx_gradient_float(mx_hash_int(X.add(int(1)), Y), fx.sub(1), fy), mx_gradient_float(mx_hash_int(X, Y.add(int(1))), fx, fy.sub(1)), mx_gradient_float(mx_hash_int(X.add(int(1)), Y.add(int(1))), fx.sub(1), fy.sub(1)), u4, v2)).toVar();
  return mx_gradient_scale2d(result);
}).setLayout({
  name: "mx_perlin_noise_float_0",
  type: "float",
  inputs: [
    { name: "p", type: "vec2" }
  ]
});
var mx_perlin_noise_float_1 = Fn(([p_immutable]) => {
  const p = vec3(p_immutable).toVar();
  const X = int().toVar(), Y = int().toVar(), Z = int().toVar();
  const fx = float(mx_floorfrac(p.x, X)).toVar();
  const fy = float(mx_floorfrac(p.y, Y)).toVar();
  const fz = float(mx_floorfrac(p.z, Z)).toVar();
  const u4 = float(mx_fade(fx)).toVar();
  const v2 = float(mx_fade(fy)).toVar();
  const w = float(mx_fade(fz)).toVar();
  const result = float(mx_trilerp(mx_gradient_float(mx_hash_int(X, Y, Z), fx, fy, fz), mx_gradient_float(mx_hash_int(X.add(int(1)), Y, Z), fx.sub(1), fy, fz), mx_gradient_float(mx_hash_int(X, Y.add(int(1)), Z), fx, fy.sub(1), fz), mx_gradient_float(mx_hash_int(X.add(int(1)), Y.add(int(1)), Z), fx.sub(1), fy.sub(1), fz), mx_gradient_float(mx_hash_int(X, Y, Z.add(int(1))), fx, fy, fz.sub(1)), mx_gradient_float(mx_hash_int(X.add(int(1)), Y, Z.add(int(1))), fx.sub(1), fy, fz.sub(1)), mx_gradient_float(mx_hash_int(X, Y.add(int(1)), Z.add(int(1))), fx, fy.sub(1), fz.sub(1)), mx_gradient_float(mx_hash_int(X.add(int(1)), Y.add(int(1)), Z.add(int(1))), fx.sub(1), fy.sub(1), fz.sub(1)), u4, v2, w)).toVar();
  return mx_gradient_scale3d(result);
}).setLayout({
  name: "mx_perlin_noise_float_1",
  type: "float",
  inputs: [
    { name: "p", type: "vec3" }
  ]
});
var mx_perlin_noise_float = overloadingFn([mx_perlin_noise_float_0, mx_perlin_noise_float_1]);
var mx_perlin_noise_vec3_0 = Fn(([p_immutable]) => {
  const p = vec2(p_immutable).toVar();
  const X = int().toVar(), Y = int().toVar();
  const fx = float(mx_floorfrac(p.x, X)).toVar();
  const fy = float(mx_floorfrac(p.y, Y)).toVar();
  const u4 = float(mx_fade(fx)).toVar();
  const v2 = float(mx_fade(fy)).toVar();
  const result = vec3(mx_bilerp(mx_gradient_vec3(mx_hash_vec3(X, Y), fx, fy), mx_gradient_vec3(mx_hash_vec3(X.add(int(1)), Y), fx.sub(1), fy), mx_gradient_vec3(mx_hash_vec3(X, Y.add(int(1))), fx, fy.sub(1)), mx_gradient_vec3(mx_hash_vec3(X.add(int(1)), Y.add(int(1))), fx.sub(1), fy.sub(1)), u4, v2)).toVar();
  return mx_gradient_scale2d(result);
}).setLayout({
  name: "mx_perlin_noise_vec3_0",
  type: "vec3",
  inputs: [
    { name: "p", type: "vec2" }
  ]
});
var mx_perlin_noise_vec3_1 = Fn(([p_immutable]) => {
  const p = vec3(p_immutable).toVar();
  const X = int().toVar(), Y = int().toVar(), Z = int().toVar();
  const fx = float(mx_floorfrac(p.x, X)).toVar();
  const fy = float(mx_floorfrac(p.y, Y)).toVar();
  const fz = float(mx_floorfrac(p.z, Z)).toVar();
  const u4 = float(mx_fade(fx)).toVar();
  const v2 = float(mx_fade(fy)).toVar();
  const w = float(mx_fade(fz)).toVar();
  const result = vec3(mx_trilerp(mx_gradient_vec3(mx_hash_vec3(X, Y, Z), fx, fy, fz), mx_gradient_vec3(mx_hash_vec3(X.add(int(1)), Y, Z), fx.sub(1), fy, fz), mx_gradient_vec3(mx_hash_vec3(X, Y.add(int(1)), Z), fx, fy.sub(1), fz), mx_gradient_vec3(mx_hash_vec3(X.add(int(1)), Y.add(int(1)), Z), fx.sub(1), fy.sub(1), fz), mx_gradient_vec3(mx_hash_vec3(X, Y, Z.add(int(1))), fx, fy, fz.sub(1)), mx_gradient_vec3(mx_hash_vec3(X.add(int(1)), Y, Z.add(int(1))), fx.sub(1), fy, fz.sub(1)), mx_gradient_vec3(mx_hash_vec3(X, Y.add(int(1)), Z.add(int(1))), fx, fy.sub(1), fz.sub(1)), mx_gradient_vec3(mx_hash_vec3(X.add(int(1)), Y.add(int(1)), Z.add(int(1))), fx.sub(1), fy.sub(1), fz.sub(1)), u4, v2, w)).toVar();
  return mx_gradient_scale3d(result);
}).setLayout({
  name: "mx_perlin_noise_vec3_1",
  type: "vec3",
  inputs: [
    { name: "p", type: "vec3" }
  ]
});
var mx_perlin_noise_vec3 = overloadingFn([mx_perlin_noise_vec3_0, mx_perlin_noise_vec3_1]);
var mx_cell_noise_float_0 = Fn(([p_immutable]) => {
  const p = float(p_immutable).toVar();
  const ix = int(mx_floor(p)).toVar();
  return mx_bits_to_01(mx_hash_int(ix));
}).setLayout({
  name: "mx_cell_noise_float_0",
  type: "float",
  inputs: [
    { name: "p", type: "float" }
  ]
});
var mx_cell_noise_float_1 = Fn(([p_immutable]) => {
  const p = vec2(p_immutable).toVar();
  const ix = int(mx_floor(p.x)).toVar();
  const iy = int(mx_floor(p.y)).toVar();
  return mx_bits_to_01(mx_hash_int(ix, iy));
}).setLayout({
  name: "mx_cell_noise_float_1",
  type: "float",
  inputs: [
    { name: "p", type: "vec2" }
  ]
});
var mx_cell_noise_float_2 = Fn(([p_immutable]) => {
  const p = vec3(p_immutable).toVar();
  const ix = int(mx_floor(p.x)).toVar();
  const iy = int(mx_floor(p.y)).toVar();
  const iz = int(mx_floor(p.z)).toVar();
  return mx_bits_to_01(mx_hash_int(ix, iy, iz));
}).setLayout({
  name: "mx_cell_noise_float_2",
  type: "float",
  inputs: [
    { name: "p", type: "vec3" }
  ]
});
var mx_cell_noise_float_3 = Fn(([p_immutable]) => {
  const p = vec4(p_immutable).toVar();
  const ix = int(mx_floor(p.x)).toVar();
  const iy = int(mx_floor(p.y)).toVar();
  const iz = int(mx_floor(p.z)).toVar();
  const iw = int(mx_floor(p.w)).toVar();
  return mx_bits_to_01(mx_hash_int(ix, iy, iz, iw));
}).setLayout({
  name: "mx_cell_noise_float_3",
  type: "float",
  inputs: [
    { name: "p", type: "vec4" }
  ]
});
var mx_cell_noise_float$1 = overloadingFn([mx_cell_noise_float_0, mx_cell_noise_float_1, mx_cell_noise_float_2, mx_cell_noise_float_3]);
var mx_cell_noise_vec3_0 = Fn(([p_immutable]) => {
  const p = float(p_immutable).toVar();
  const ix = int(mx_floor(p)).toVar();
  return vec3(mx_bits_to_01(mx_hash_int(ix, int(0))), mx_bits_to_01(mx_hash_int(ix, int(1))), mx_bits_to_01(mx_hash_int(ix, int(2))));
}).setLayout({
  name: "mx_cell_noise_vec3_0",
  type: "vec3",
  inputs: [
    { name: "p", type: "float" }
  ]
});
var mx_cell_noise_vec3_1 = Fn(([p_immutable]) => {
  const p = vec2(p_immutable).toVar();
  const ix = int(mx_floor(p.x)).toVar();
  const iy = int(mx_floor(p.y)).toVar();
  return vec3(mx_bits_to_01(mx_hash_int(ix, iy, int(0))), mx_bits_to_01(mx_hash_int(ix, iy, int(1))), mx_bits_to_01(mx_hash_int(ix, iy, int(2))));
}).setLayout({
  name: "mx_cell_noise_vec3_1",
  type: "vec3",
  inputs: [
    { name: "p", type: "vec2" }
  ]
});
var mx_cell_noise_vec3_2 = Fn(([p_immutable]) => {
  const p = vec3(p_immutable).toVar();
  const ix = int(mx_floor(p.x)).toVar();
  const iy = int(mx_floor(p.y)).toVar();
  const iz = int(mx_floor(p.z)).toVar();
  return vec3(mx_bits_to_01(mx_hash_int(ix, iy, iz, int(0))), mx_bits_to_01(mx_hash_int(ix, iy, iz, int(1))), mx_bits_to_01(mx_hash_int(ix, iy, iz, int(2))));
}).setLayout({
  name: "mx_cell_noise_vec3_2",
  type: "vec3",
  inputs: [
    { name: "p", type: "vec3" }
  ]
});
var mx_cell_noise_vec3_3 = Fn(([p_immutable]) => {
  const p = vec4(p_immutable).toVar();
  const ix = int(mx_floor(p.x)).toVar();
  const iy = int(mx_floor(p.y)).toVar();
  const iz = int(mx_floor(p.z)).toVar();
  const iw = int(mx_floor(p.w)).toVar();
  return vec3(mx_bits_to_01(mx_hash_int(ix, iy, iz, iw, int(0))), mx_bits_to_01(mx_hash_int(ix, iy, iz, iw, int(1))), mx_bits_to_01(mx_hash_int(ix, iy, iz, iw, int(2))));
}).setLayout({
  name: "mx_cell_noise_vec3_3",
  type: "vec3",
  inputs: [
    { name: "p", type: "vec4" }
  ]
});
var mx_cell_noise_vec3 = overloadingFn([mx_cell_noise_vec3_0, mx_cell_noise_vec3_1, mx_cell_noise_vec3_2, mx_cell_noise_vec3_3]);
var mx_fractal_noise_float$1 = Fn(([p_immutable, octaves_immutable, lacunarity_immutable, diminish_immutable]) => {
  const diminish = float(diminish_immutable).toVar();
  const lacunarity = float(lacunarity_immutable).toVar();
  const octaves = int(octaves_immutable).toVar();
  const p = vec3(p_immutable).toVar();
  const result = float(0).toVar();
  const amplitude = float(1).toVar();
  Loop(octaves, () => {
    result.addAssign(amplitude.mul(mx_perlin_noise_float(p)));
    amplitude.mulAssign(diminish);
    p.mulAssign(lacunarity);
  });
  return result;
}).setLayout({
  name: "mx_fractal_noise_float",
  type: "float",
  inputs: [
    { name: "p", type: "vec3" },
    { name: "octaves", type: "int" },
    { name: "lacunarity", type: "float" },
    { name: "diminish", type: "float" }
  ]
});
var mx_fractal_noise_vec3$1 = Fn(([p_immutable, octaves_immutable, lacunarity_immutable, diminish_immutable]) => {
  const diminish = float(diminish_immutable).toVar();
  const lacunarity = float(lacunarity_immutable).toVar();
  const octaves = int(octaves_immutable).toVar();
  const p = vec3(p_immutable).toVar();
  const result = vec3(0).toVar();
  const amplitude = float(1).toVar();
  Loop(octaves, () => {
    result.addAssign(amplitude.mul(mx_perlin_noise_vec3(p)));
    amplitude.mulAssign(diminish);
    p.mulAssign(lacunarity);
  });
  return result;
}).setLayout({
  name: "mx_fractal_noise_vec3",
  type: "vec3",
  inputs: [
    { name: "p", type: "vec3" },
    { name: "octaves", type: "int" },
    { name: "lacunarity", type: "float" },
    { name: "diminish", type: "float" }
  ]
});
var mx_fractal_noise_vec2$1 = Fn(([p_immutable, octaves_immutable, lacunarity_immutable, diminish_immutable]) => {
  const diminish = float(diminish_immutable).toVar();
  const lacunarity = float(lacunarity_immutable).toVar();
  const octaves = int(octaves_immutable).toVar();
  const p = vec3(p_immutable).toVar();
  return vec2(mx_fractal_noise_float$1(p, octaves, lacunarity, diminish), mx_fractal_noise_float$1(p.add(vec3(int(19), int(193), int(17))), octaves, lacunarity, diminish));
}).setLayout({
  name: "mx_fractal_noise_vec2",
  type: "vec2",
  inputs: [
    { name: "p", type: "vec3" },
    { name: "octaves", type: "int" },
    { name: "lacunarity", type: "float" },
    { name: "diminish", type: "float" }
  ]
});
var mx_fractal_noise_vec4$1 = Fn(([p_immutable, octaves_immutable, lacunarity_immutable, diminish_immutable]) => {
  const diminish = float(diminish_immutable).toVar();
  const lacunarity = float(lacunarity_immutable).toVar();
  const octaves = int(octaves_immutable).toVar();
  const p = vec3(p_immutable).toVar();
  const c3 = vec3(mx_fractal_noise_vec3$1(p, octaves, lacunarity, diminish)).toVar();
  const f = float(mx_fractal_noise_float$1(p.add(vec3(int(19), int(193), int(17))), octaves, lacunarity, diminish)).toVar();
  return vec4(c3, f);
}).setLayout({
  name: "mx_fractal_noise_vec4",
  type: "vec4",
  inputs: [
    { name: "p", type: "vec3" },
    { name: "octaves", type: "int" },
    { name: "lacunarity", type: "float" },
    { name: "diminish", type: "float" }
  ]
});
var mx_worley_distance_0 = Fn(([p_immutable, x_immutable, y_immutable, xoff_immutable, yoff_immutable, jitter_immutable, metric_immutable]) => {
  const metric = int(metric_immutable).toVar();
  const jitter2 = float(jitter_immutable).toVar();
  const yoff = int(yoff_immutable).toVar();
  const xoff = int(xoff_immutable).toVar();
  const y = int(y_immutable).toVar();
  const x = int(x_immutable).toVar();
  const p = vec2(p_immutable).toVar();
  const tmp = vec3(mx_cell_noise_vec3(vec2(x.add(xoff), y.add(yoff)))).toVar();
  const off = vec2(tmp.x, tmp.y).toVar();
  off.subAssign(0.5);
  off.mulAssign(jitter2);
  off.addAssign(0.5);
  const cellpos = vec2(vec2(float(x), float(y)).add(off)).toVar();
  const diff = vec2(cellpos.sub(p)).toVar();
  If(metric.equal(int(2)), () => {
    return abs2(diff.x).add(abs2(diff.y));
  });
  If(metric.equal(int(3)), () => {
    return max$1(abs2(diff.x), abs2(diff.y));
  });
  return dot(diff, diff);
}).setLayout({
  name: "mx_worley_distance_0",
  type: "float",
  inputs: [
    { name: "p", type: "vec2" },
    { name: "x", type: "int" },
    { name: "y", type: "int" },
    { name: "xoff", type: "int" },
    { name: "yoff", type: "int" },
    { name: "jitter", type: "float" },
    { name: "metric", type: "int" }
  ]
});
var mx_worley_distance_1 = Fn(([p_immutable, x_immutable, y_immutable, z_immutable, xoff_immutable, yoff_immutable, zoff_immutable, jitter_immutable, metric_immutable]) => {
  const metric = int(metric_immutable).toVar();
  const jitter2 = float(jitter_immutable).toVar();
  const zoff = int(zoff_immutable).toVar();
  const yoff = int(yoff_immutable).toVar();
  const xoff = int(xoff_immutable).toVar();
  const z = int(z_immutable).toVar();
  const y = int(y_immutable).toVar();
  const x = int(x_immutable).toVar();
  const p = vec3(p_immutable).toVar();
  const off = vec3(mx_cell_noise_vec3(vec3(x.add(xoff), y.add(yoff), z.add(zoff)))).toVar();
  off.subAssign(0.5);
  off.mulAssign(jitter2);
  off.addAssign(0.5);
  const cellpos = vec3(vec3(float(x), float(y), float(z)).add(off)).toVar();
  const diff = vec3(cellpos.sub(p)).toVar();
  If(metric.equal(int(2)), () => {
    return abs2(diff.x).add(abs2(diff.y)).add(abs2(diff.z));
  });
  If(metric.equal(int(3)), () => {
    return max$1(abs2(diff.x), abs2(diff.y), abs2(diff.z));
  });
  return dot(diff, diff);
}).setLayout({
  name: "mx_worley_distance_1",
  type: "float",
  inputs: [
    { name: "p", type: "vec3" },
    { name: "x", type: "int" },
    { name: "y", type: "int" },
    { name: "z", type: "int" },
    { name: "xoff", type: "int" },
    { name: "yoff", type: "int" },
    { name: "zoff", type: "int" },
    { name: "jitter", type: "float" },
    { name: "metric", type: "int" }
  ]
});
var mx_worley_distance = overloadingFn([mx_worley_distance_0, mx_worley_distance_1]);
var mx_worley_noise_float_0 = Fn(([p_immutable, jitter_immutable, metric_immutable]) => {
  const metric = int(metric_immutable).toVar();
  const jitter2 = float(jitter_immutable).toVar();
  const p = vec2(p_immutable).toVar();
  const X = int().toVar(), Y = int().toVar();
  const localpos = vec2(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y)).toVar();
  const sqdist = float(1e6).toVar();
  Loop({ start: -1, end: int(1), name: "x", condition: "<=" }, ({ x }) => {
    Loop({ start: -1, end: int(1), name: "y", condition: "<=" }, ({ y }) => {
      const dist2 = float(mx_worley_distance(localpos, x, y, X, Y, jitter2, metric)).toVar();
      sqdist.assign(min$1(sqdist, dist2));
    });
  });
  If(metric.equal(int(0)), () => {
    sqdist.assign(sqrt4(sqdist));
  });
  return sqdist;
}).setLayout({
  name: "mx_worley_noise_float_0",
  type: "float",
  inputs: [
    { name: "p", type: "vec2" },
    { name: "jitter", type: "float" },
    { name: "metric", type: "int" }
  ]
});
var mx_worley_noise_vec2_0 = Fn(([p_immutable, jitter_immutable, metric_immutable]) => {
  const metric = int(metric_immutable).toVar();
  const jitter2 = float(jitter_immutable).toVar();
  const p = vec2(p_immutable).toVar();
  const X = int().toVar(), Y = int().toVar();
  const localpos = vec2(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y)).toVar();
  const sqdist = vec2(1e6, 1e6).toVar();
  Loop({ start: -1, end: int(1), name: "x", condition: "<=" }, ({ x }) => {
    Loop({ start: -1, end: int(1), name: "y", condition: "<=" }, ({ y }) => {
      const dist2 = float(mx_worley_distance(localpos, x, y, X, Y, jitter2, metric)).toVar();
      If(dist2.lessThan(sqdist.x), () => {
        sqdist.y.assign(sqdist.x);
        sqdist.x.assign(dist2);
      }).ElseIf(dist2.lessThan(sqdist.y), () => {
        sqdist.y.assign(dist2);
      });
    });
  });
  If(metric.equal(int(0)), () => {
    sqdist.assign(sqrt4(sqdist));
  });
  return sqdist;
}).setLayout({
  name: "mx_worley_noise_vec2_0",
  type: "vec2",
  inputs: [
    { name: "p", type: "vec2" },
    { name: "jitter", type: "float" },
    { name: "metric", type: "int" }
  ]
});
var mx_worley_noise_vec3_0 = Fn(([p_immutable, jitter_immutable, metric_immutable]) => {
  const metric = int(metric_immutable).toVar();
  const jitter2 = float(jitter_immutable).toVar();
  const p = vec2(p_immutable).toVar();
  const X = int().toVar(), Y = int().toVar();
  const localpos = vec2(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y)).toVar();
  const sqdist = vec3(1e6, 1e6, 1e6).toVar();
  Loop({ start: -1, end: int(1), name: "x", condition: "<=" }, ({ x }) => {
    Loop({ start: -1, end: int(1), name: "y", condition: "<=" }, ({ y }) => {
      const dist2 = float(mx_worley_distance(localpos, x, y, X, Y, jitter2, metric)).toVar();
      If(dist2.lessThan(sqdist.x), () => {
        sqdist.z.assign(sqdist.y);
        sqdist.y.assign(sqdist.x);
        sqdist.x.assign(dist2);
      }).ElseIf(dist2.lessThan(sqdist.y), () => {
        sqdist.z.assign(sqdist.y);
        sqdist.y.assign(dist2);
      }).ElseIf(dist2.lessThan(sqdist.z), () => {
        sqdist.z.assign(dist2);
      });
    });
  });
  If(metric.equal(int(0)), () => {
    sqdist.assign(sqrt4(sqdist));
  });
  return sqdist;
}).setLayout({
  name: "mx_worley_noise_vec3_0",
  type: "vec3",
  inputs: [
    { name: "p", type: "vec2" },
    { name: "jitter", type: "float" },
    { name: "metric", type: "int" }
  ]
});
var mx_worley_noise_float_1 = Fn(([p_immutable, jitter_immutable, metric_immutable]) => {
  const metric = int(metric_immutable).toVar();
  const jitter2 = float(jitter_immutable).toVar();
  const p = vec3(p_immutable).toVar();
  const X = int().toVar(), Y = int().toVar(), Z = int().toVar();
  const localpos = vec3(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y), mx_floorfrac(p.z, Z)).toVar();
  const sqdist = float(1e6).toVar();
  Loop({ start: -1, end: int(1), name: "x", condition: "<=" }, ({ x }) => {
    Loop({ start: -1, end: int(1), name: "y", condition: "<=" }, ({ y }) => {
      Loop({ start: -1, end: int(1), name: "z", condition: "<=" }, ({ z }) => {
        const dist2 = float(mx_worley_distance(localpos, x, y, z, X, Y, Z, jitter2, metric)).toVar();
        sqdist.assign(min$1(sqdist, dist2));
      });
    });
  });
  If(metric.equal(int(0)), () => {
    sqdist.assign(sqrt4(sqdist));
  });
  return sqdist;
}).setLayout({
  name: "mx_worley_noise_float_1",
  type: "float",
  inputs: [
    { name: "p", type: "vec3" },
    { name: "jitter", type: "float" },
    { name: "metric", type: "int" }
  ]
});
var mx_worley_noise_float$1 = overloadingFn([mx_worley_noise_float_0, mx_worley_noise_float_1]);
var mx_worley_noise_vec2_1 = Fn(([p_immutable, jitter_immutable, metric_immutable]) => {
  const metric = int(metric_immutable).toVar();
  const jitter2 = float(jitter_immutable).toVar();
  const p = vec3(p_immutable).toVar();
  const X = int().toVar(), Y = int().toVar(), Z = int().toVar();
  const localpos = vec3(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y), mx_floorfrac(p.z, Z)).toVar();
  const sqdist = vec2(1e6, 1e6).toVar();
  Loop({ start: -1, end: int(1), name: "x", condition: "<=" }, ({ x }) => {
    Loop({ start: -1, end: int(1), name: "y", condition: "<=" }, ({ y }) => {
      Loop({ start: -1, end: int(1), name: "z", condition: "<=" }, ({ z }) => {
        const dist2 = float(mx_worley_distance(localpos, x, y, z, X, Y, Z, jitter2, metric)).toVar();
        If(dist2.lessThan(sqdist.x), () => {
          sqdist.y.assign(sqdist.x);
          sqdist.x.assign(dist2);
        }).ElseIf(dist2.lessThan(sqdist.y), () => {
          sqdist.y.assign(dist2);
        });
      });
    });
  });
  If(metric.equal(int(0)), () => {
    sqdist.assign(sqrt4(sqdist));
  });
  return sqdist;
}).setLayout({
  name: "mx_worley_noise_vec2_1",
  type: "vec2",
  inputs: [
    { name: "p", type: "vec3" },
    { name: "jitter", type: "float" },
    { name: "metric", type: "int" }
  ]
});
var mx_worley_noise_vec2$1 = overloadingFn([mx_worley_noise_vec2_0, mx_worley_noise_vec2_1]);
var mx_worley_noise_vec3_1 = Fn(([p_immutable, jitter_immutable, metric_immutable]) => {
  const metric = int(metric_immutable).toVar();
  const jitter2 = float(jitter_immutable).toVar();
  const p = vec3(p_immutable).toVar();
  const X = int().toVar(), Y = int().toVar(), Z = int().toVar();
  const localpos = vec3(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y), mx_floorfrac(p.z, Z)).toVar();
  const sqdist = vec3(1e6, 1e6, 1e6).toVar();
  Loop({ start: -1, end: int(1), name: "x", condition: "<=" }, ({ x }) => {
    Loop({ start: -1, end: int(1), name: "y", condition: "<=" }, ({ y }) => {
      Loop({ start: -1, end: int(1), name: "z", condition: "<=" }, ({ z }) => {
        const dist2 = float(mx_worley_distance(localpos, x, y, z, X, Y, Z, jitter2, metric)).toVar();
        If(dist2.lessThan(sqdist.x), () => {
          sqdist.z.assign(sqdist.y);
          sqdist.y.assign(sqdist.x);
          sqdist.x.assign(dist2);
        }).ElseIf(dist2.lessThan(sqdist.y), () => {
          sqdist.z.assign(sqdist.y);
          sqdist.y.assign(dist2);
        }).ElseIf(dist2.lessThan(sqdist.z), () => {
          sqdist.z.assign(dist2);
        });
      });
    });
  });
  If(metric.equal(int(0)), () => {
    sqdist.assign(sqrt4(sqdist));
  });
  return sqdist;
}).setLayout({
  name: "mx_worley_noise_vec3_1",
  type: "vec3",
  inputs: [
    { name: "p", type: "vec3" },
    { name: "jitter", type: "float" },
    { name: "metric", type: "int" }
  ]
});
var mx_worley_noise_vec3$1 = overloadingFn([mx_worley_noise_vec3_0, mx_worley_noise_vec3_1]);
var mx_unifiednoise2d$1 = Fn(([
  noiseType_immutable,
  texcoord_immutable,
  freq_immutable,
  offset_immutable,
  jitter_immutable,
  outmin_immutable,
  outmax_immutable,
  clampoutput_immutable,
  octaves_immutable,
  lacunarity_immutable,
  diminish_immutable
]) => {
  const noiseType = int(noiseType_immutable).toVar();
  const texcoord = vec2(texcoord_immutable).toVar();
  const freq = vec2(freq_immutable).toVar();
  const offset = vec2(offset_immutable).toVar();
  const jitter2 = float(jitter_immutable).toVar();
  const outmin = float(outmin_immutable).toVar();
  const outmax = float(outmax_immutable).toVar();
  const clampoutput = bool(clampoutput_immutable).toVar();
  const octaves = int(octaves_immutable).toVar();
  const lacunarity = float(lacunarity_immutable).toVar();
  const diminish = float(diminish_immutable).toVar();
  const p = texcoord.mul(freq).add(offset);
  const result = float(0).toVar();
  If(noiseType.equal(int(0)), () => {
    result.assign(mx_perlin_noise_vec3(p));
  });
  If(noiseType.equal(int(1)), () => {
    result.assign(mx_cell_noise_vec3(p));
  });
  If(noiseType.equal(int(2)), () => {
    result.assign(mx_worley_noise_vec3$1(p, jitter2, int(0)));
  });
  If(noiseType.equal(int(3)), () => {
    result.assign(mx_fractal_noise_vec3$1(vec3(p, 0), octaves, lacunarity, diminish));
  });
  result.assign(result.mul(outmax.sub(outmin)).add(outmin));
  If(clampoutput, () => {
    result.assign(clamp(result, outmin, outmax));
  });
  return result;
}).setLayout({
  name: "mx_unifiednoise2d",
  type: "float",
  inputs: [
    { name: "noiseType", type: "int" },
    { name: "texcoord", type: "vec2" },
    { name: "freq", type: "vec2" },
    { name: "offset", type: "vec2" },
    { name: "jitter", type: "float" },
    { name: "outmin", type: "float" },
    { name: "outmax", type: "float" },
    { name: "clampoutput", type: "bool" },
    { name: "octaves", type: "int" },
    { name: "lacunarity", type: "float" },
    { name: "diminish", type: "float" }
  ]
});
var mx_unifiednoise3d$1 = Fn(([
  noiseType_immutable,
  position_immutable,
  freq_immutable,
  offset_immutable,
  jitter_immutable,
  outmin_immutable,
  outmax_immutable,
  clampoutput_immutable,
  octaves_immutable,
  lacunarity_immutable,
  diminish_immutable
]) => {
  const noiseType = int(noiseType_immutable).toVar();
  const position = vec3(position_immutable).toVar();
  const freq = vec3(freq_immutable).toVar();
  const offset = vec3(offset_immutable).toVar();
  const jitter2 = float(jitter_immutable).toVar();
  const outmin = float(outmin_immutable).toVar();
  const outmax = float(outmax_immutable).toVar();
  const clampoutput = bool(clampoutput_immutable).toVar();
  const octaves = int(octaves_immutable).toVar();
  const lacunarity = float(lacunarity_immutable).toVar();
  const diminish = float(diminish_immutable).toVar();
  const p = position.mul(freq).add(offset);
  const result = float(0).toVar();
  If(noiseType.equal(int(0)), () => {
    result.assign(mx_perlin_noise_vec3(p));
  });
  If(noiseType.equal(int(1)), () => {
    result.assign(mx_cell_noise_vec3(p));
  });
  If(noiseType.equal(int(2)), () => {
    result.assign(mx_worley_noise_vec3$1(p, jitter2, int(0)));
  });
  If(noiseType.equal(int(3)), () => {
    result.assign(mx_fractal_noise_vec3$1(p, octaves, lacunarity, diminish));
  });
  result.assign(result.mul(outmax.sub(outmin)).add(outmin));
  If(clampoutput, () => {
    result.assign(clamp(result, outmin, outmax));
  });
  return result;
}).setLayout({
  name: "mx_unifiednoise3d",
  type: "float",
  inputs: [
    { name: "noiseType", type: "int" },
    { name: "position", type: "vec3" },
    { name: "freq", type: "vec3" },
    { name: "offset", type: "vec3" },
    { name: "jitter", type: "float" },
    { name: "outmin", type: "float" },
    { name: "outmax", type: "float" },
    { name: "clampoutput", type: "bool" },
    { name: "octaves", type: "int" },
    { name: "lacunarity", type: "float" },
    { name: "diminish", type: "float" }
  ]
});
var mx_hsvtorgb = Fn(([hsv]) => {
  const s = hsv.y;
  const v2 = hsv.z;
  const result = vec3().toVar();
  If(s.lessThan(1e-4), () => {
    result.assign(vec3(v2, v2, v2));
  }).Else(() => {
    let h = hsv.x;
    h = h.sub(floor(h)).mul(6).toVar();
    const hi = int(trunc(h));
    const f = h.sub(float(hi));
    const p = v2.mul(s.oneMinus());
    const q = v2.mul(s.mul(f).oneMinus());
    const t = v2.mul(s.mul(f.oneMinus()).oneMinus());
    If(hi.equal(int(0)), () => {
      result.assign(vec3(v2, t, p));
    }).ElseIf(hi.equal(int(1)), () => {
      result.assign(vec3(q, v2, p));
    }).ElseIf(hi.equal(int(2)), () => {
      result.assign(vec3(p, v2, t));
    }).ElseIf(hi.equal(int(3)), () => {
      result.assign(vec3(p, q, v2));
    }).ElseIf(hi.equal(int(4)), () => {
      result.assign(vec3(t, p, v2));
    }).Else(() => {
      result.assign(vec3(v2, p, q));
    });
  });
  return result;
}).setLayout({
  name: "mx_hsvtorgb",
  type: "vec3",
  inputs: [
    { name: "hsv", type: "vec3" }
  ]
});
var mx_rgbtohsv = Fn(([c_immutable]) => {
  const c3 = vec3(c_immutable).toVar();
  const r = float(c3.x).toVar();
  const g = float(c3.y).toVar();
  const b = float(c3.z).toVar();
  const mincomp = float(min$1(r, min$1(g, b))).toVar();
  const maxcomp = float(max$1(r, max$1(g, b))).toVar();
  const delta = float(maxcomp.sub(mincomp)).toVar();
  const h = float().toVar(), s = float().toVar(), v2 = float().toVar();
  v2.assign(maxcomp);
  If(maxcomp.greaterThan(0), () => {
    s.assign(delta.div(maxcomp));
  }).Else(() => {
    s.assign(0);
  });
  If(s.lessThanEqual(0), () => {
    h.assign(0);
  }).Else(() => {
    If(r.greaterThanEqual(maxcomp), () => {
      h.assign(g.sub(b).div(delta));
    }).ElseIf(g.greaterThanEqual(maxcomp), () => {
      h.assign(add3(2, b.sub(r).div(delta)));
    }).Else(() => {
      h.assign(add3(4, r.sub(g).div(delta)));
    });
    h.mulAssign(1 / 6);
    If(h.lessThan(0), () => {
      h.addAssign(1);
    });
  });
  return vec3(h, s, v2);
}).setLayout({
  name: "mx_rgbtohsv",
  type: "vec3",
  inputs: [
    { name: "c", type: "vec3" }
  ]
});
var mx_srgb_texture_to_lin_rec709 = Fn(([color_immutable]) => {
  const color4 = vec3(color_immutable).toVar();
  const isAbove = bvec3(greaterThan(color4, vec3(0.04045))).toVar();
  const linSeg = vec3(color4.div(12.92)).toVar();
  const powSeg = vec3(pow4(max$1(color4.add(vec3(0.055)), vec3(0)).div(1.055), vec3(2.4))).toVar();
  return mix(linSeg, powSeg, isAbove);
}).setLayout({
  name: "mx_srgb_texture_to_lin_rec709",
  type: "vec3",
  inputs: [
    { name: "color", type: "vec3" }
  ]
});
var mx_aastep = (threshold2, value) => {
  threshold2 = float(threshold2);
  value = float(value);
  const afwidth = vec2(value.dFdx(), value.dFdy()).length().mul(0.7071067811865476);
  return smoothstep(threshold2.sub(afwidth), threshold2.add(afwidth), value);
};
var _ramp = (a, b, uv3, p) => mix(a, b, uv3[p].clamp());
var mx_ramplr = (valuel, valuer, texcoord = uv$1()) => _ramp(valuel, valuer, texcoord, "x");
var mx_ramptb = (valuet, valueb, texcoord = uv$1()) => _ramp(valuet, valueb, texcoord, "y");
var mx_ramp4 = (valuetl, valuetr, valuebl, valuebr, texcoord = uv$1()) => {
  const u4 = texcoord.x.clamp();
  const v2 = texcoord.y.clamp();
  const top = mix(valuetl, valuetr, u4);
  const bottom = mix(valuebl, valuebr, u4);
  return mix(top, bottom, v2);
};
var _split = (a, b, center, uv3, p) => mix(a, b, mx_aastep(center, uv3[p]));
var mx_splitlr = (valuel, valuer, center, texcoord = uv$1()) => _split(valuel, valuer, center, texcoord, "x");
var mx_splittb = (valuet, valueb, center, texcoord = uv$1()) => _split(valuet, valueb, center, texcoord, "y");
var mx_transform_uv = (uv_scale = 1, uv_offset = 0, uv_geo = uv$1()) => uv_geo.mul(uv_scale).add(uv_offset);
var mx_safepower = (in1, in2 = 1) => {
  in1 = float(in1);
  return in1.abs().pow(in2).mul(in1.sign());
};
var mx_contrast = (input, amount = 1, pivot = 0.5) => float(input).sub(pivot).mul(amount).add(pivot);
var mx_noise_float = (texcoord = uv$1(), amplitude = 1, pivot = 0) => mx_perlin_noise_float(texcoord.convert("vec2|vec3")).mul(amplitude).add(pivot);
var mx_noise_vec3 = (texcoord = uv$1(), amplitude = 1, pivot = 0) => mx_perlin_noise_vec3(texcoord.convert("vec2|vec3")).mul(amplitude).add(pivot);
var mx_noise_vec4 = (texcoord = uv$1(), amplitude = 1, pivot = 0) => {
  texcoord = texcoord.convert("vec2|vec3");
  const noise_vec4 = vec4(mx_perlin_noise_vec3(texcoord), mx_perlin_noise_float(texcoord.add(vec2(19, 73))));
  return noise_vec4.mul(amplitude).add(pivot);
};
var mx_unifiednoise2d = (noiseType, texcoord = uv$1(), freq = vec2(1, 1), offset = vec2(0, 0), jitter2 = 1, outmin = 0, outmax = 1, clampoutput = false, octaves = 1, lacunarity = 2, diminish = 0.5) => mx_unifiednoise2d$1(noiseType, texcoord.convert("vec2|vec3"), freq, offset, jitter2, outmin, outmax, clampoutput, octaves, lacunarity, diminish);
var mx_unifiednoise3d = (noiseType, texcoord = uv$1(), freq = vec2(1, 1), offset = vec2(0, 0), jitter2 = 1, outmin = 0, outmax = 1, clampoutput = false, octaves = 1, lacunarity = 2, diminish = 0.5) => mx_unifiednoise3d$1(noiseType, texcoord.convert("vec2|vec3"), freq, offset, jitter2, outmin, outmax, clampoutput, octaves, lacunarity, diminish);
var mx_worley_noise_float = (texcoord = uv$1(), jitter2 = 1) => mx_worley_noise_float$1(texcoord.convert("vec2|vec3"), jitter2, int(1));
var mx_worley_noise_vec2 = (texcoord = uv$1(), jitter2 = 1) => mx_worley_noise_vec2$1(texcoord.convert("vec2|vec3"), jitter2, int(1));
var mx_worley_noise_vec3 = (texcoord = uv$1(), jitter2 = 1) => mx_worley_noise_vec3$1(texcoord.convert("vec2|vec3"), jitter2, int(1));
var mx_cell_noise_float = (texcoord = uv$1()) => mx_cell_noise_float$1(texcoord.convert("vec2|vec3"));
var mx_fractal_noise_float = (position = uv$1(), octaves = 3, lacunarity = 2, diminish = 0.5, amplitude = 1) => mx_fractal_noise_float$1(position, int(octaves), lacunarity, diminish).mul(amplitude);
var mx_fractal_noise_vec2 = (position = uv$1(), octaves = 3, lacunarity = 2, diminish = 0.5, amplitude = 1) => mx_fractal_noise_vec2$1(position, int(octaves), lacunarity, diminish).mul(amplitude);
var mx_fractal_noise_vec3 = (position = uv$1(), octaves = 3, lacunarity = 2, diminish = 0.5, amplitude = 1) => mx_fractal_noise_vec3$1(position, int(octaves), lacunarity, diminish).mul(amplitude);
var mx_fractal_noise_vec4 = (position = uv$1(), octaves = 3, lacunarity = 2, diminish = 0.5, amplitude = 1) => mx_fractal_noise_vec4$1(position, int(octaves), lacunarity, diminish).mul(amplitude);
var mx_add = (in1, in2 = float(0)) => add3(in1, in2);
var mx_subtract = (in1, in2 = float(0)) => sub(in1, in2);
var mx_multiply = (in1, in2 = float(1)) => mul(in1, in2);
var mx_divide = (in1, in2 = float(1)) => div(in1, in2);
var mx_modulo = (in1, in2 = float(1)) => mod(in1, in2);
var mx_power = (in1, in2 = float(1)) => pow4(in1, in2);
var mx_atan2 = (in1 = float(0), in2 = float(1)) => atan3(in1, in2);
var mx_timer = () => time2;
var mx_frame = () => frameId;
var mx_invert = (in1, amount = float(1)) => sub(amount, in1);
var mx_ifgreater = (value1, value2, in1, in2) => value1.greaterThan(value2).mix(in1, in2);
var mx_ifgreatereq = (value1, value2, in1, in2) => value1.greaterThanEqual(value2).mix(in1, in2);
var mx_ifequal = (value1, value2, in1, in2) => value1.equal(value2).mix(in1, in2);
var mx_separate = (in1, channelOrOut = null) => {
  if (typeof channelOrOut === "string") {
    const map4 = { x: 0, r: 0, y: 1, g: 1, z: 2, b: 2, w: 3, a: 3 };
    const c3 = channelOrOut.replace(/^out/, "").toLowerCase();
    if (map4[c3] !== void 0) return in1.element(map4[c3]);
  }
  if (typeof channelOrOut === "number") {
    return in1.element(channelOrOut);
  }
  if (typeof channelOrOut === "string" && channelOrOut.length === 1) {
    const map4 = { x: 0, r: 0, y: 1, g: 1, z: 2, b: 2, w: 3, a: 3 };
    if (map4[channelOrOut] !== void 0) return in1.element(map4[channelOrOut]);
  }
  return in1;
};
var mx_place2d = (texcoord, pivot = vec2(0.5, 0.5), scale3 = vec2(1, 1), rotate3 = float(0), offset = vec2(0, 0)) => {
  let uv3 = texcoord;
  if (pivot) uv3 = uv3.sub(pivot);
  if (scale3) uv3 = uv3.mul(scale3);
  if (rotate3) {
    const rad = rotate3.mul(Math.PI / 180);
    const cosR = rad.cos();
    const sinR = rad.sin();
    uv3 = vec2(
      uv3.x.mul(cosR).sub(uv3.y.mul(sinR)),
      uv3.x.mul(sinR).add(uv3.y.mul(cosR))
    );
  }
  if (pivot) uv3 = uv3.add(pivot);
  if (offset) uv3 = uv3.add(offset);
  return uv3;
};
var mx_rotate2d = (input, amount) => {
  input = vec2(input);
  amount = float(amount);
  const radians6 = amount.mul(Math.PI / 180);
  return rotate(input, radians6);
};
var mx_rotate3d = (input, amount, axis) => {
  input = vec3(input);
  amount = float(amount);
  axis = vec3(axis);
  const radians6 = amount.mul(Math.PI / 180);
  const nAxis = axis.normalize();
  const cosA = radians6.cos();
  const sinA = radians6.sin();
  const oneMinusCosA = float(1).sub(cosA);
  const rot = input.mul(cosA).add(nAxis.cross(input).mul(sinA)).add(nAxis.mul(nAxis.dot(input)).mul(oneMinusCosA));
  return rot;
};
var mx_heighttonormal = (input, scale3) => {
  input = vec3(input);
  scale3 = float(scale3);
  return bumpMap(input, scale3);
};
var getParallaxCorrectNormal = Fn(([normal2, cubeSize, cubePos]) => {
  const nDir = normalize2(normal2).toVar();
  const rbmax = sub(float(0.5).mul(cubeSize.sub(cubePos)), positionWorld).div(nDir).toVar();
  const rbmin = sub(float(-0.5).mul(cubeSize.sub(cubePos)), positionWorld).div(nDir).toVar();
  const rbminmax = vec3().toVar();
  rbminmax.x = nDir.x.greaterThan(float(0)).select(rbmax.x, rbmin.x);
  rbminmax.y = nDir.y.greaterThan(float(0)).select(rbmax.y, rbmin.y);
  rbminmax.z = nDir.z.greaterThan(float(0)).select(rbmax.z, rbmin.z);
  const correction = min$1(rbminmax.x, rbminmax.y, rbminmax.z).toVar();
  const boxIntersection = positionWorld.add(nDir.mul(correction)).toVar();
  return boxIntersection.sub(cubePos);
});
var getShIrradianceAt = Fn(([normal2, shCoefficients]) => {
  const x = normal2.x, y = normal2.y, z = normal2.z;
  let result = shCoefficients.element(0).mul(0.886227);
  result = result.add(shCoefficients.element(1).mul(2 * 0.511664).mul(y));
  result = result.add(shCoefficients.element(2).mul(2 * 0.511664).mul(z));
  result = result.add(shCoefficients.element(3).mul(2 * 0.511664).mul(x));
  result = result.add(shCoefficients.element(4).mul(2 * 0.429043).mul(x).mul(y));
  result = result.add(shCoefficients.element(5).mul(2 * 0.429043).mul(y).mul(z));
  result = result.add(shCoefficients.element(6).mul(z.mul(z).mul(0.743125).sub(0.247708)));
  result = result.add(shCoefficients.element(7).mul(2 * 0.429043).mul(x).mul(z));
  result = result.add(shCoefficients.element(8).mul(0.429043).mul(mul(x, x).sub(mul(y, y))));
  return result;
});
var TSL = Object.freeze({
  __proto__: null,
  BRDF_GGX,
  BRDF_Lambert,
  BasicPointShadowFilter,
  BasicShadowFilter,
  Break,
  Const,
  Continue,
  DFGApprox,
  D_GGX,
  Discard,
  EPSILON: EPSILON2,
  F_Schlick,
  Fn,
  INFINITY,
  If,
  Loop,
  NodeAccess,
  NodeShaderStage,
  NodeType,
  NodeUpdateType,
  OnMaterialUpdate,
  OnObjectUpdate,
  PCFShadowFilter,
  PCFSoftShadowFilter,
  PI,
  PI2,
  PointShadowFilter,
  Return,
  Schlick_to_F0,
  ScriptableNodeResources,
  ShaderNode,
  Stack,
  Switch,
  TBNViewMatrix,
  VSMShadowFilter,
  V_GGX_SmithCorrelated,
  Var,
  VarIntent,
  abs: abs2,
  acesFilmicToneMapping,
  acos: acos2,
  add: add3,
  addMethodChaining,
  addNodeElement,
  agxToneMapping,
  all,
  alphaT,
  and,
  anisotropy,
  anisotropyB,
  anisotropyT,
  any,
  append,
  array: array2,
  arrayBuffer,
  asin: asin3,
  assign,
  atan: atan3,
  atan2: atan23,
  atomicAdd,
  atomicAnd,
  atomicFunc,
  atomicLoad,
  atomicMax,
  atomicMin,
  atomicOr,
  atomicStore,
  atomicSub,
  atomicXor,
  attenuationColor,
  attenuationDistance,
  attribute,
  attributeArray,
  backgroundBlurriness,
  backgroundIntensity,
  backgroundRotation,
  batch,
  bentNormalView,
  billboarding,
  bitAnd,
  bitNot,
  bitOr,
  bitXor,
  bitangentGeometry,
  bitangentLocal,
  bitangentView,
  bitangentWorld,
  bitcast,
  blendBurn,
  blendColor,
  blendDodge,
  blendOverlay,
  blendScreen,
  blur: blur3,
  bool,
  buffer,
  bufferAttribute,
  builtin,
  bumpMap,
  burn,
  bvec2,
  bvec3,
  bvec4,
  bypass,
  cache,
  call,
  cameraFar,
  cameraIndex,
  cameraNear,
  cameraNormalMatrix,
  cameraPosition,
  cameraProjectionMatrix,
  cameraProjectionMatrixInverse,
  cameraViewMatrix,
  cameraViewport,
  cameraWorldMatrix,
  cbrt,
  cdl,
  ceil: ceil2,
  checker,
  cineonToneMapping,
  clamp,
  clearcoat,
  clearcoatNormalView,
  clearcoatRoughness,
  code,
  color: color2,
  colorSpaceToWorking,
  colorToDirection,
  compute,
  computeKernel,
  computeSkinning,
  context,
  convert,
  convertColorSpace,
  convertToTexture,
  cos: cos3,
  cross: cross2,
  cubeTexture,
  cubeTextureBase,
  cubeToUV,
  dFdx,
  dFdy,
  dashSize,
  debug,
  decrement,
  decrementBefore,
  defaultBuildStages,
  defaultShaderStages,
  defined,
  degrees: degrees5,
  deltaTime,
  densityFog,
  densityFogFactor,
  depth,
  depthPass,
  determinant,
  difference: difference2,
  diffuseColor,
  directPointLight,
  directionToColor,
  directionToFaceDirection,
  dispersion,
  distance: distance2,
  div,
  dodge,
  dot,
  drawIndex,
  dynamicBufferAttribute,
  element,
  emissive,
  equal,
  equals: equals2,
  equirectUV,
  exp: exp2,
  exp2: exp22,
  expression,
  faceDirection,
  faceForward,
  faceforward,
  float,
  floatBitsToInt,
  floatBitsToUint,
  floor,
  fog,
  fract,
  frameGroup,
  frameId,
  frontFacing,
  fwidth,
  gain,
  gapSize,
  getConstNodeType,
  getCurrentStack,
  getDirection,
  getDistanceAttenuation,
  getGeometryRoughness,
  getNormalFromDepth,
  getParallaxCorrectNormal,
  getRoughness,
  getScreenPosition,
  getShIrradianceAt,
  getShadowMaterial,
  getShadowRenderObjectFunction,
  getTextureIndex,
  getViewPosition,
  globalId,
  glsl,
  glslFn,
  grayscale,
  greaterThan,
  greaterThanEqual,
  hash,
  highpModelNormalViewMatrix,
  highpModelViewMatrix,
  hue: hue2,
  increment,
  incrementBefore,
  instance,
  instanceIndex,
  instancedArray,
  instancedBufferAttribute,
  instancedDynamicBufferAttribute,
  instancedMesh,
  int,
  intBitsToFloat,
  inverse,
  inverseSqrt,
  inversesqrt,
  invocationLocalIndex,
  invocationSubgroupIndex,
  ior,
  iridescence,
  iridescenceIOR,
  iridescenceThickness,
  ivec2,
  ivec3,
  ivec4,
  js,
  label,
  length,
  lengthSq,
  lessThan,
  lessThanEqual,
  lightPosition,
  lightProjectionUV,
  lightShadowMatrix,
  lightTargetDirection,
  lightTargetPosition,
  lightViewPosition,
  lightingContext,
  lights,
  linearDepth,
  linearToneMapping,
  localId,
  log: log3,
  log2: log22,
  logarithmicDepthToViewZ,
  luminance,
  mat2,
  mat3,
  mat4,
  matcapUV,
  materialAO,
  materialAlphaTest,
  materialAnisotropy,
  materialAnisotropyVector,
  materialAttenuationColor,
  materialAttenuationDistance,
  materialClearcoat,
  materialClearcoatNormal,
  materialClearcoatRoughness,
  materialColor,
  materialDispersion,
  materialEmissive,
  materialEnvIntensity,
  materialEnvRotation,
  materialIOR,
  materialIridescence,
  materialIridescenceIOR,
  materialIridescenceThickness,
  materialLightMap,
  materialLineDashOffset,
  materialLineDashSize,
  materialLineGapSize,
  materialLineScale,
  materialLineWidth,
  materialMetalness,
  materialNormal,
  materialOpacity,
  materialPointSize,
  materialReference,
  materialReflectivity,
  materialRefractionRatio,
  materialRotation,
  materialRoughness,
  materialSheen,
  materialSheenRoughness,
  materialShininess,
  materialSpecular,
  materialSpecularColor,
  materialSpecularIntensity,
  materialSpecularStrength,
  materialThickness,
  materialTransmission,
  max: max$1,
  maxMipLevel,
  mediumpModelViewMatrix,
  metalness,
  min: min$1,
  mix,
  mixElement,
  mod,
  modInt,
  modelDirection,
  modelNormalMatrix,
  modelPosition,
  modelRadius,
  modelScale,
  modelViewMatrix,
  modelViewPosition,
  modelViewProjection,
  modelWorldMatrix,
  modelWorldMatrixInverse,
  morphReference,
  mrt,
  mul,
  mx_aastep,
  mx_add,
  mx_atan2,
  mx_cell_noise_float,
  mx_contrast,
  mx_divide,
  mx_fractal_noise_float,
  mx_fractal_noise_vec2,
  mx_fractal_noise_vec3,
  mx_fractal_noise_vec4,
  mx_frame,
  mx_heighttonormal,
  mx_hsvtorgb,
  mx_ifequal,
  mx_ifgreater,
  mx_ifgreatereq,
  mx_invert,
  mx_modulo,
  mx_multiply,
  mx_noise_float,
  mx_noise_vec3,
  mx_noise_vec4,
  mx_place2d,
  mx_power,
  mx_ramp4,
  mx_ramplr,
  mx_ramptb,
  mx_rgbtohsv,
  mx_rotate2d,
  mx_rotate3d,
  mx_safepower,
  mx_separate,
  mx_splitlr,
  mx_splittb,
  mx_srgb_texture_to_lin_rec709,
  mx_subtract,
  mx_timer,
  mx_transform_uv,
  mx_unifiednoise2d,
  mx_unifiednoise3d,
  mx_worley_noise_float,
  mx_worley_noise_vec2,
  mx_worley_noise_vec3,
  negate: negate2,
  neutralToneMapping,
  nodeArray,
  nodeImmutable,
  nodeObject,
  nodeObjectIntent,
  nodeObjects,
  nodeProxy,
  nodeProxyIntent,
  normalFlat,
  normalGeometry,
  normalLocal,
  normalMap,
  normalView,
  normalViewGeometry,
  normalWorld,
  normalWorldGeometry,
  normalize: normalize2,
  not,
  notEqual,
  numWorkgroups,
  objectDirection,
  objectGroup,
  objectPosition,
  objectRadius,
  objectScale,
  objectViewPosition,
  objectWorldMatrix,
  oneMinus,
  or,
  orthographicDepthToViewZ,
  oscSawtooth,
  oscSine,
  oscSquare,
  oscTriangle,
  output,
  outputStruct,
  overlay,
  overloadingFn,
  parabola,
  parallaxDirection,
  parallaxUV,
  parameter,
  pass,
  passTexture,
  pcurve,
  perspectiveDepthToViewZ,
  pmremTexture,
  pointShadow,
  pointUV,
  pointWidth,
  positionGeometry,
  positionLocal,
  positionPrevious,
  positionView,
  positionViewDirection,
  positionWorld,
  positionWorldDirection,
  posterize,
  pow: pow4,
  pow2: pow22,
  pow3: pow32,
  pow4: pow42,
  premultiplyAlpha,
  property,
  quadBroadcast,
  quadSwapDiagonal,
  quadSwapX,
  quadSwapY,
  radians: radians4,
  rand,
  range: range3,
  rangeFog,
  rangeFogFactor,
  reciprocal,
  reference,
  referenceBuffer,
  reflect,
  reflectVector,
  reflectView,
  reflector,
  refract,
  refractVector,
  refractView,
  reinhardToneMapping,
  remap,
  remapClamp,
  renderGroup,
  renderOutput,
  rendererReference,
  rotate,
  rotateUV,
  roughness,
  round,
  rtt,
  sRGBTransferEOTF,
  sRGBTransferOETF,
  sample,
  sampler,
  samplerComparison,
  saturate: saturate2,
  saturation,
  screen,
  screenCoordinate,
  screenDPR,
  screenSize,
  screenUV,
  scriptable,
  scriptableValue,
  select,
  setCurrentStack,
  setName,
  shaderStages,
  shadow,
  shadowPositionWorld,
  shapeCircle,
  sharedUniformGroup,
  sheen,
  sheenRoughness,
  shiftLeft,
  shiftRight,
  shininess,
  sign: sign4,
  sin: sin3,
  sinc,
  skinning,
  smoothstep,
  smoothstepElement,
  specularColor,
  specularF90,
  spherizeUV,
  split,
  spritesheetUV,
  sqrt: sqrt4,
  stack,
  step,
  stepElement,
  storage,
  storageBarrier,
  storageObject,
  storageTexture,
  string,
  struct,
  sub,
  subBuild,
  subgroupAdd,
  subgroupAll,
  subgroupAnd,
  subgroupAny,
  subgroupBallot,
  subgroupBroadcast,
  subgroupBroadcastFirst,
  subgroupElect,
  subgroupExclusiveAdd,
  subgroupExclusiveMul,
  subgroupInclusiveAdd,
  subgroupInclusiveMul,
  subgroupIndex,
  subgroupMax,
  subgroupMin,
  subgroupMul,
  subgroupOr,
  subgroupShuffle,
  subgroupShuffleDown,
  subgroupShuffleUp,
  subgroupShuffleXor,
  subgroupSize,
  subgroupXor,
  tan: tan2,
  tangentGeometry,
  tangentLocal,
  tangentView,
  tangentWorld,
  texture,
  texture3D,
  textureBarrier,
  textureBicubic,
  textureBicubicLevel,
  textureCubeUV,
  textureLoad,
  textureSize,
  textureStore,
  thickness,
  time: time2,
  toneMapping,
  toneMappingExposure,
  toonOutlinePass,
  transformDirection,
  transformNormal,
  transformNormalToView,
  transformedClearcoatNormalView,
  transformedNormalView,
  transformedNormalWorld,
  transmission,
  transpose: transpose2,
  triNoise3D,
  triplanarTexture,
  triplanarTextures,
  trunc,
  uint,
  uintBitsToFloat,
  uniform,
  uniformArray,
  uniformCubeTexture,
  uniformFlow,
  uniformGroup,
  uniformTexture,
  unpremultiplyAlpha,
  userData,
  uv: uv$1,
  uvec2,
  uvec3,
  uvec4,
  varying,
  varyingProperty,
  vec2,
  vec3,
  vec4,
  vectorComponents,
  velocity,
  vertexColor,
  vertexIndex,
  vertexStage,
  vibrance,
  viewZToLogarithmicDepth,
  viewZToOrthographicDepth,
  viewZToPerspectiveDepth,
  viewport,
  viewportCoordinate,
  viewportDepthTexture,
  viewportLinearDepth,
  viewportMipTexture,
  viewportResolution,
  viewportSafeUV,
  viewportSharedTexture,
  viewportSize,
  viewportTexture,
  viewportUV,
  wgsl,
  wgslFn,
  workgroupArray,
  workgroupBarrier,
  workgroupId,
  workingToColorSpace,
  xor
});
var _clearColor = new Color4();
var Background = class extends DataMap {
  /**
   * Constructs a new background management component.
   *
   * @param {Renderer} renderer - The renderer.
   * @param {Nodes} nodes - Renderer component for managing nodes related logic.
   */
  constructor(renderer, nodes) {
    super();
    this.renderer = renderer;
    this.nodes = nodes;
  }
  /**
   * Updates the background for the given scene. Depending on how `Scene.background`
   * or `Scene.backgroundNode` are configured, this method might configure a simple clear
   * or add a mesh to the render list for rendering the background as a textured plane
   * or skybox.
   *
   * @param {Scene} scene - The scene.
   * @param {RenderList} renderList - The current render list.
   * @param {RenderContext} renderContext - The current render context.
   */
  update(scene, renderList, renderContext) {
    const renderer = this.renderer;
    const background = this.nodes.getBackgroundNode(scene) || scene.background;
    let forceClear = false;
    if (background === null) {
      renderer._clearColor.getRGB(_clearColor);
      _clearColor.a = renderer._clearColor.a;
    } else if (background.isColor === true) {
      background.getRGB(_clearColor);
      _clearColor.a = 1;
      forceClear = true;
    } else if (background.isNode === true) {
      const sceneData = this.get(scene);
      const backgroundNode = background;
      _clearColor.copy(renderer._clearColor);
      let backgroundMesh = sceneData.backgroundMesh;
      if (backgroundMesh === void 0) {
        let onBackgroundDispose = function() {
          background.removeEventListener("dispose", onBackgroundDispose);
          backgroundMesh.material.dispose();
          backgroundMesh.geometry.dispose();
        };
        const backgroundMeshNode = context(vec4(backgroundNode).mul(backgroundIntensity), {
          // @TODO: Add Texture2D support using node context
          getUV: () => backgroundRotation.mul(normalWorldGeometry),
          getTextureLevel: () => backgroundBlurriness
        });
        let viewProj = modelViewProjection;
        viewProj = viewProj.setZ(viewProj.w);
        const nodeMaterial = new NodeMaterial();
        nodeMaterial.name = "Background.material";
        nodeMaterial.side = BackSide;
        nodeMaterial.depthTest = false;
        nodeMaterial.depthWrite = false;
        nodeMaterial.allowOverride = false;
        nodeMaterial.fog = false;
        nodeMaterial.lights = false;
        nodeMaterial.vertexNode = viewProj;
        nodeMaterial.colorNode = backgroundMeshNode;
        sceneData.backgroundMeshNode = backgroundMeshNode;
        sceneData.backgroundMesh = backgroundMesh = new Mesh(new SphereGeometry(1, 32, 32), nodeMaterial);
        backgroundMesh.frustumCulled = false;
        backgroundMesh.name = "Background.mesh";
        backgroundMesh.onBeforeRender = function(renderer2, scene2, camera) {
          this.matrixWorld.copyPosition(camera.matrixWorld);
        };
        background.addEventListener("dispose", onBackgroundDispose);
      }
      const backgroundCacheKey = backgroundNode.getCacheKey();
      if (sceneData.backgroundCacheKey !== backgroundCacheKey) {
        sceneData.backgroundMeshNode.node = vec4(backgroundNode).mul(backgroundIntensity);
        sceneData.backgroundMeshNode.needsUpdate = true;
        backgroundMesh.material.needsUpdate = true;
        sceneData.backgroundCacheKey = backgroundCacheKey;
      }
      renderList.unshift(backgroundMesh, backgroundMesh.geometry, backgroundMesh.material, 0, 0, null, null);
    } else {
      console.error("THREE.Renderer: Unsupported background configuration.", background);
    }
    const environmentBlendMode = renderer.xr.getEnvironmentBlendMode();
    if (environmentBlendMode === "additive") {
      _clearColor.set(0, 0, 0, 1);
    } else if (environmentBlendMode === "alpha-blend") {
      _clearColor.set(0, 0, 0, 0);
    }
    if (renderer.autoClear === true || forceClear === true) {
      const clearColorValue = renderContext.clearColorValue;
      clearColorValue.r = _clearColor.r;
      clearColorValue.g = _clearColor.g;
      clearColorValue.b = _clearColor.b;
      clearColorValue.a = _clearColor.a;
      if (renderer.backend.isWebGLBackend === true || renderer.alpha === true) {
        clearColorValue.r *= clearColorValue.a;
        clearColorValue.g *= clearColorValue.a;
        clearColorValue.b *= clearColorValue.a;
      }
      renderContext.depthClearValue = renderer._clearDepth;
      renderContext.stencilClearValue = renderer._clearStencil;
      renderContext.clearColor = renderer.autoClearColor === true;
      renderContext.clearDepth = renderer.autoClearDepth === true;
      renderContext.clearStencil = renderer.autoClearStencil === true;
    } else {
      renderContext.clearColor = false;
      renderContext.clearDepth = false;
      renderContext.clearStencil = false;
    }
  }
};
var _id$6 = 0;
var BindGroup = class {
  /**
   * Constructs a new bind group.
   *
   * @param {string} name - The bind group's name.
   * @param {Array<Binding>} bindings - An array of bindings.
   * @param {number} index - The group index.
   * @param {Array<Binding>} bindingsReference - An array of reference bindings.
   */
  constructor(name = "", bindings = [], index5 = 0, bindingsReference = []) {
    this.name = name;
    this.bindings = bindings;
    this.index = index5;
    this.bindingsReference = bindingsReference;
    this.id = _id$6++;
  }
};
var NodeBuilderState = class {
  /**
   * Constructs a new node builder state.
   *
   * @param {string} vertexShader - The native vertex shader code.
   * @param {string} fragmentShader - The native fragment shader code.
   * @param {string} computeShader - The native compute shader code.
   * @param {Array<NodeAttribute>} nodeAttributes - An array of node attributes.
   * @param {Array<BindGroup>} bindings - An array of bind groups.
   * @param {Array<Node>} updateNodes - An array of nodes that implement their `update()` method.
   * @param {Array<Node>} updateBeforeNodes - An array of nodes that implement their `updateBefore()` method.
   * @param {Array<Node>} updateAfterNodes - An array of nodes that implement their `updateAfter()` method.
   * @param {NodeMaterialObserver} observer - A node material observer.
   * @param {Array<Object>} transforms - An array with transform attribute objects. Only relevant when using compute shaders with WebGL 2.
   */
  constructor(vertexShader2, fragmentShader2, computeShader, nodeAttributes, bindings, updateNodes, updateBeforeNodes, updateAfterNodes, observer, transforms = []) {
    this.vertexShader = vertexShader2;
    this.fragmentShader = fragmentShader2;
    this.computeShader = computeShader;
    this.transforms = transforms;
    this.nodeAttributes = nodeAttributes;
    this.bindings = bindings;
    this.updateNodes = updateNodes;
    this.updateBeforeNodes = updateBeforeNodes;
    this.updateAfterNodes = updateAfterNodes;
    this.observer = observer;
    this.usedTimes = 0;
  }
  /**
   * This method is used to create a array of bind groups based
   * on the existing bind groups of this state. Shared groups are
   * not cloned.
   *
   * @return {Array<BindGroup>} A array of bind groups.
   */
  createBindings() {
    const bindings = [];
    for (const instanceGroup of this.bindings) {
      const shared = instanceGroup.bindings[0].groupNode.shared;
      if (shared !== true) {
        const bindingsGroup = new BindGroup(instanceGroup.name, [], instanceGroup.index, instanceGroup.bindingsReference);
        bindings.push(bindingsGroup);
        for (const instanceBinding of instanceGroup.bindings) {
          bindingsGroup.bindings.push(instanceBinding.clone());
        }
      } else {
        bindings.push(instanceGroup);
      }
    }
    return bindings;
  }
};
var NodeAttribute = class {
  /**
   * Constructs a new node attribute.
   *
   * @param {string} name - The name of the attribute.
   * @param {string} type - The type of the attribute.
   * @param {?Node} node - An optional reference to the node.
   */
  constructor(name, type, node = null) {
    this.isNodeAttribute = true;
    this.name = name;
    this.type = type;
    this.node = node;
  }
};
var NodeUniform = class {
  /**
   * Constructs a new node uniform.
   *
   * @param {string} name - The name of the uniform.
   * @param {string} type - The type of the uniform.
   * @param {UniformNode} node - An reference to the node.
   */
  constructor(name, type, node) {
    this.isNodeUniform = true;
    this.name = name;
    this.type = type;
    this.node = node;
  }
  /**
   * The value of the uniform node.
   *
   * @type {any}
   */
  get value() {
    return this.node.value;
  }
  set value(val) {
    this.node.value = val;
  }
  /**
   * The id of the uniform node.
   *
   * @type {number}
   */
  get id() {
    return this.node.id;
  }
  /**
   * The uniform node's group.
   *
   * @type {UniformGroupNode}
   */
  get groupNode() {
    return this.node.groupNode;
  }
};
var NodeVar = class {
  /**
   * Constructs a new node variable.
   *
   * @param {string} name - The name of the variable.
   * @param {string} type - The type of the variable.
   * @param {boolean} [readOnly=false] - The read-only flag.
   * @param {?number} [count=null] - The size.
   */
  constructor(name, type, readOnly = false, count2 = null) {
    this.isNodeVar = true;
    this.name = name;
    this.type = type;
    this.readOnly = readOnly;
    this.count = count2;
  }
};
var NodeVarying = class extends NodeVar {
  /**
   * Constructs a new node varying.
   *
   * @param {string} name - The name of the varying.
   * @param {string} type - The type of the varying.
   * @param {?string} interpolationType - The interpolation type of the varying.
   * @param {?string} interpolationSampling - The interpolation sampling type of the varying.
   */
  constructor(name, type, interpolationType = null, interpolationSampling = null) {
    super(name, type);
    this.needsInterpolation = false;
    this.isNodeVarying = true;
    this.interpolationType = interpolationType;
    this.interpolationSampling = interpolationSampling;
  }
};
var NodeCode = class {
  /**
   * Constructs a new code node.
   *
   * @param {string} name - The name of the code.
   * @param {string} type - The node type.
   * @param {string} [code=''] - The native shader code.
   */
  constructor(name, type, code3 = "") {
    this.name = name;
    this.type = type;
    this.code = code3;
    Object.defineProperty(this, "isNodeCode", { value: true });
  }
};
var _id$5 = 0;
var NodeCache = class {
  /**
   * Constructs a new node cache.
   *
   * @param {?NodeCache} parent - A reference to a parent cache.
   */
  constructor(parent = null) {
    this.id = _id$5++;
    this.nodesData = /* @__PURE__ */ new WeakMap();
    this.parent = parent;
  }
  /**
   * Returns the data for the given node.
   *
   * @param {Node} node - The node.
   * @return {?Object} The data for the node.
   */
  getData(node) {
    let data = this.nodesData.get(node);
    if (data === void 0 && this.parent !== null) {
      data = this.parent.getData(node);
    }
    return data;
  }
  /**
   * Sets the data for a given node.
   *
   * @param {Node} node - The node.
   * @param {Object} data - The data that should be cached.
   */
  setData(node, data) {
    this.nodesData.set(node, data);
  }
};
var StructType = class {
  constructor(name, members) {
    this.name = name;
    this.members = members;
    this.output = false;
  }
};
var Uniform2 = class {
  /**
   * Constructs a new uniform.
   *
   * @param {string} name - The uniform's name.
   * @param {any} value - The uniform's value.
   */
  constructor(name, value) {
    this.name = name;
    this.value = value;
    this.boundary = 0;
    this.itemSize = 0;
    this.offset = 0;
  }
  /**
   * Sets the uniform's value.
   *
   * @param {any} value - The value to set.
   */
  setValue(value) {
    this.value = value;
  }
  /**
   * Returns the uniform's value.
   *
   * @return {any} The value.
   */
  getValue() {
    return this.value;
  }
};
var NumberUniform = class extends Uniform2 {
  /**
   * Constructs a new Number uniform.
   *
   * @param {string} name - The uniform's name.
   * @param {number} value - The uniform's value.
   */
  constructor(name, value = 0) {
    super(name, value);
    this.isNumberUniform = true;
    this.boundary = 4;
    this.itemSize = 1;
  }
};
var Vector2Uniform = class extends Uniform2 {
  /**
   * Constructs a new Number uniform.
   *
   * @param {string} name - The uniform's name.
   * @param {Vector2} value - The uniform's value.
   */
  constructor(name, value = new Vector2()) {
    super(name, value);
    this.isVector2Uniform = true;
    this.boundary = 8;
    this.itemSize = 2;
  }
};
var Vector3Uniform = class extends Uniform2 {
  /**
   * Constructs a new Number uniform.
   *
   * @param {string} name - The uniform's name.
   * @param {Vector3} value - The uniform's value.
   */
  constructor(name, value = new Vector3()) {
    super(name, value);
    this.isVector3Uniform = true;
    this.boundary = 16;
    this.itemSize = 3;
  }
};
var Vector4Uniform = class extends Uniform2 {
  /**
   * Constructs a new Number uniform.
   *
   * @param {string} name - The uniform's name.
   * @param {Vector4} value - The uniform's value.
   */
  constructor(name, value = new Vector4()) {
    super(name, value);
    this.isVector4Uniform = true;
    this.boundary = 16;
    this.itemSize = 4;
  }
};
var ColorUniform = class extends Uniform2 {
  /**
   * Constructs a new Number uniform.
   *
   * @param {string} name - The uniform's name.
   * @param {Color} value - The uniform's value.
   */
  constructor(name, value = new Color()) {
    super(name, value);
    this.isColorUniform = true;
    this.boundary = 16;
    this.itemSize = 3;
  }
};
var Matrix2Uniform = class extends Uniform2 {
  /**
   * Constructs a new Number uniform.
   *
   * @param {string} name - The uniform's name.
   * @param {Matrix2} value - The uniform's value.
   */
  constructor(name, value = new Matrix2()) {
    super(name, value);
    this.isMatrix2Uniform = true;
    this.boundary = 8;
    this.itemSize = 4;
  }
};
var Matrix3Uniform = class extends Uniform2 {
  /**
   * Constructs a new Number uniform.
   *
   * @param {string} name - The uniform's name.
   * @param {Matrix3} value - The uniform's value.
   */
  constructor(name, value = new Matrix3()) {
    super(name, value);
    this.isMatrix3Uniform = true;
    this.boundary = 48;
    this.itemSize = 12;
  }
};
var Matrix4Uniform = class extends Uniform2 {
  /**
   * Constructs a new Number uniform.
   *
   * @param {string} name - The uniform's name.
   * @param {Matrix4} value - The uniform's value.
   */
  constructor(name, value = new Matrix4()) {
    super(name, value);
    this.isMatrix4Uniform = true;
    this.boundary = 64;
    this.itemSize = 16;
  }
};
var NumberNodeUniform = class extends NumberUniform {
  /**
   * Constructs a new node-based Number uniform.
   *
   * @param {NodeUniform} nodeUniform - The node uniform.
   */
  constructor(nodeUniform) {
    super(nodeUniform.name, nodeUniform.value);
    this.nodeUniform = nodeUniform;
  }
  /**
   * Overwritten to return the value of the node uniform.
   *
   * @return {number} The value.
   */
  getValue() {
    return this.nodeUniform.value;
  }
  /**
   * Returns the node uniform data type.
   *
   * @return {string} The data type.
   */
  getType() {
    return this.nodeUniform.type;
  }
};
var Vector2NodeUniform = class extends Vector2Uniform {
  /**
   * Constructs a new node-based Vector2 uniform.
   *
   * @param {NodeUniform} nodeUniform - The node uniform.
   */
  constructor(nodeUniform) {
    super(nodeUniform.name, nodeUniform.value);
    this.nodeUniform = nodeUniform;
  }
  /**
   * Overwritten to return the value of the node uniform.
   *
   * @return {Vector2} The value.
   */
  getValue() {
    return this.nodeUniform.value;
  }
  /**
   * Returns the node uniform data type.
   *
   * @return {string} The data type.
   */
  getType() {
    return this.nodeUniform.type;
  }
};
var Vector3NodeUniform = class extends Vector3Uniform {
  /**
   * Constructs a new node-based Vector3 uniform.
   *
   * @param {NodeUniform} nodeUniform - The node uniform.
   */
  constructor(nodeUniform) {
    super(nodeUniform.name, nodeUniform.value);
    this.nodeUniform = nodeUniform;
  }
  /**
   * Overwritten to return the value of the node uniform.
   *
   * @return {Vector3} The value.
   */
  getValue() {
    return this.nodeUniform.value;
  }
  /**
   * Returns the node uniform data type.
   *
   * @return {string} The data type.
   */
  getType() {
    return this.nodeUniform.type;
  }
};
var Vector4NodeUniform = class extends Vector4Uniform {
  /**
   * Constructs a new node-based Vector4 uniform.
   *
   * @param {NodeUniform} nodeUniform - The node uniform.
   */
  constructor(nodeUniform) {
    super(nodeUniform.name, nodeUniform.value);
    this.nodeUniform = nodeUniform;
  }
  /**
   * Overwritten to return the value of the node uniform.
   *
   * @return {Vector4} The value.
   */
  getValue() {
    return this.nodeUniform.value;
  }
  /**
   * Returns the node uniform data type.
   *
   * @return {string} The data type.
   */
  getType() {
    return this.nodeUniform.type;
  }
};
var ColorNodeUniform = class extends ColorUniform {
  /**
   * Constructs a new node-based Color uniform.
   *
   * @param {NodeUniform} nodeUniform - The node uniform.
   */
  constructor(nodeUniform) {
    super(nodeUniform.name, nodeUniform.value);
    this.nodeUniform = nodeUniform;
  }
  /**
   * Overwritten to return the value of the node uniform.
   *
   * @return {Color} The value.
   */
  getValue() {
    return this.nodeUniform.value;
  }
  /**
   * Returns the node uniform data type.
   *
   * @return {string} The data type.
   */
  getType() {
    return this.nodeUniform.type;
  }
};
var Matrix2NodeUniform = class extends Matrix2Uniform {
  /**
   * Constructs a new node-based Matrix2 uniform.
   *
   * @param {NodeUniform} nodeUniform - The node uniform.
   */
  constructor(nodeUniform) {
    super(nodeUniform.name, nodeUniform.value);
    this.nodeUniform = nodeUniform;
  }
  /**
   * Overwritten to return the value of the node uniform.
   *
   * @return {Matrix2} The value.
   */
  getValue() {
    return this.nodeUniform.value;
  }
  /**
   * Returns the node uniform data type.
   *
   * @return {string} The data type.
   */
  getType() {
    return this.nodeUniform.type;
  }
};
var Matrix3NodeUniform = class extends Matrix3Uniform {
  /**
   * Constructs a new node-based Matrix3 uniform.
   *
   * @param {NodeUniform} nodeUniform - The node uniform.
   */
  constructor(nodeUniform) {
    super(nodeUniform.name, nodeUniform.value);
    this.nodeUniform = nodeUniform;
  }
  /**
   * Overwritten to return the value of the node uniform.
   *
   * @return {Matrix3} The value.
   */
  getValue() {
    return this.nodeUniform.value;
  }
  /**
   * Returns the node uniform data type.
   *
   * @return {string} The data type.
   */
  getType() {
    return this.nodeUniform.type;
  }
};
var Matrix4NodeUniform = class extends Matrix4Uniform {
  /**
   * Constructs a new node-based Matrix4 uniform.
   *
   * @param {NodeUniform} nodeUniform - The node uniform.
   */
  constructor(nodeUniform) {
    super(nodeUniform.name, nodeUniform.value);
    this.nodeUniform = nodeUniform;
  }
  /**
   * Overwritten to return the value of the node uniform.
   *
   * @return {Matrix4} The value.
   */
  getValue() {
    return this.nodeUniform.value;
  }
  /**
   * Returns the node uniform data type.
   *
   * @return {string} The data type.
   */
  getType() {
    return this.nodeUniform.type;
  }
};
var rendererCache = /* @__PURE__ */ new WeakMap();
var typeFromArray = /* @__PURE__ */ new Map([
  [Int8Array, "int"],
  [Int16Array, "int"],
  [Int32Array, "int"],
  [Uint8Array, "uint"],
  [Uint16Array, "uint"],
  [Uint32Array, "uint"],
  [Float32Array, "float"]
]);
var toFloat = (value) => {
  if (/e/g.test(value)) {
    return String(value).replace(/\+/g, "");
  } else {
    value = Number(value);
    return value + (value % 1 ? "" : ".0");
  }
};
var NodeBuilder = class {
  /**
   * Constructs a new node builder.
   *
   * @param {Object3D} object - The 3D object.
   * @param {Renderer} renderer - The current renderer.
   * @param {NodeParser} parser - A reference to a node parser.
   */
  constructor(object2, renderer, parser) {
    this.object = object2;
    this.material = object2 && object2.material || null;
    this.geometry = object2 && object2.geometry || null;
    this.renderer = renderer;
    this.parser = parser;
    this.scene = null;
    this.camera = null;
    this.nodes = [];
    this.sequentialNodes = [];
    this.updateNodes = [];
    this.updateBeforeNodes = [];
    this.updateAfterNodes = [];
    this.hashNodes = {};
    this.observer = null;
    this.lightsNode = null;
    this.environmentNode = null;
    this.fogNode = null;
    this.clippingContext = null;
    this.vertexShader = null;
    this.fragmentShader = null;
    this.computeShader = null;
    this.flowNodes = { vertex: [], fragment: [], compute: [] };
    this.flowCode = { vertex: "", fragment: "", compute: "" };
    this.uniforms = { vertex: [], fragment: [], compute: [], index: 0 };
    this.structs = { vertex: [], fragment: [], compute: [], index: 0 };
    this.types = { vertex: [], fragment: [], compute: [], index: 0 };
    this.bindings = { vertex: {}, fragment: {}, compute: {} };
    this.bindingsIndexes = {};
    this.bindGroups = null;
    this.attributes = [];
    this.bufferAttributes = [];
    this.varyings = [];
    this.codes = {};
    this.vars = {};
    this.declarations = {};
    this.flow = { code: "" };
    this.chaining = [];
    this.stack = stack();
    this.stacks = [];
    this.tab = "	";
    this.currentFunctionNode = null;
    this.context = {
      material: this.material
    };
    this.cache = new NodeCache();
    this.globalCache = this.cache;
    this.flowsData = /* @__PURE__ */ new WeakMap();
    this.shaderStage = null;
    this.buildStage = null;
    this.subBuildLayers = [];
    this.currentStack = null;
    this.subBuildFn = null;
  }
  /**
   * Returns the bind groups of the current renderer.
   *
   * @return {ChainMap} The cache.
   */
  getBindGroupsCache() {
    let bindGroupsCache = rendererCache.get(this.renderer);
    if (bindGroupsCache === void 0) {
      bindGroupsCache = new ChainMap();
      rendererCache.set(this.renderer, bindGroupsCache);
    }
    return bindGroupsCache;
  }
  /**
   * Factory method for creating an instance of {@link RenderTarget} with the given
   * dimensions and options.
   *
   * @param {number} width - The width of the render target.
   * @param {number} height - The height of the render target.
   * @param {Object} options - The options of the render target.
   * @return {RenderTarget} The render target.
   */
  createRenderTarget(width, height, options) {
    return new RenderTarget(width, height, options);
  }
  /**
   * Factory method for creating an instance of {@link CubeRenderTarget} with the given
   * dimensions and options.
   *
   * @param {number} size - The size of the cube render target.
   * @param {Object} options - The options of the cube render target.
   * @return {CubeRenderTarget} The cube render target.
   */
  createCubeRenderTarget(size, options) {
    return new CubeRenderTarget(size, options);
  }
  /**
   * Whether the given node is included in the internal array of nodes or not.
   *
   * @param {Node} node - The node to test.
   * @return {boolean} Whether the given node is included in the internal array of nodes or not.
   */
  includes(node) {
    return this.nodes.includes(node);
  }
  /**
   * Returns the output struct name which is required by
   * {@link OutputStructNode}.
   *
   * @abstract
   * @return {string} The name of the output struct.
   */
  getOutputStructName() {
  }
  /**
   * Returns a bind group for the given group name and binding.
   *
   * @private
   * @param {string} groupName - The group name.
   * @param {Array<NodeUniformsGroup>} bindings - List of bindings.
   * @return {BindGroup} The bind group
   */
  _getBindGroup(groupName, bindings) {
    const bindGroupsCache = this.getBindGroupsCache();
    const bindingsArray = [];
    let sharedGroup = true;
    for (const binding of bindings) {
      bindingsArray.push(binding);
      sharedGroup = sharedGroup && binding.groupNode.shared !== true;
    }
    let bindGroup;
    if (sharedGroup) {
      bindGroup = bindGroupsCache.get(bindingsArray);
      if (bindGroup === void 0) {
        bindGroup = new BindGroup(groupName, bindingsArray, this.bindingsIndexes[groupName].group, bindingsArray);
        bindGroupsCache.set(bindingsArray, bindGroup);
      }
    } else {
      bindGroup = new BindGroup(groupName, bindingsArray, this.bindingsIndexes[groupName].group, bindingsArray);
    }
    return bindGroup;
  }
  /**
   * Returns an array of node uniform groups for the given group name and shader stage.
   *
   * @param {string} groupName - The group name.
   * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.
   * @return {Array<NodeUniformsGroup>} The array of node uniform groups.
   */
  getBindGroupArray(groupName, shaderStage) {
    const bindings = this.bindings[shaderStage];
    let bindGroup = bindings[groupName];
    if (bindGroup === void 0) {
      if (this.bindingsIndexes[groupName] === void 0) {
        this.bindingsIndexes[groupName] = { binding: 0, group: Object.keys(this.bindingsIndexes).length };
      }
      bindings[groupName] = bindGroup = [];
    }
    return bindGroup;
  }
  /**
   * Returns a list bindings of all shader stages separated by groups.
   *
   * @return {Array<BindGroup>} The list of bindings.
   */
  getBindings() {
    let bindingsGroups = this.bindGroups;
    if (bindingsGroups === null) {
      const groups2 = {};
      const bindings = this.bindings;
      for (const shaderStage of shaderStages) {
        for (const groupName in bindings[shaderStage]) {
          const uniforms = bindings[shaderStage][groupName];
          const groupUniforms = groups2[groupName] || (groups2[groupName] = []);
          groupUniforms.push(...uniforms);
        }
      }
      bindingsGroups = [];
      for (const groupName in groups2) {
        const group2 = groups2[groupName];
        const bindingsGroup = this._getBindGroup(groupName, group2);
        bindingsGroups.push(bindingsGroup);
      }
      this.bindGroups = bindingsGroups;
    }
    return bindingsGroups;
  }
  /**
   * Sorts the bind groups and updates {@link NodeBuilder#bindingsIndexes}.
   */
  sortBindingGroups() {
    const bindingsGroups = this.getBindings();
    bindingsGroups.sort((a, b) => a.bindings[0].groupNode.order - b.bindings[0].groupNode.order);
    for (let i = 0; i < bindingsGroups.length; i++) {
      const bindingGroup = bindingsGroups[i];
      this.bindingsIndexes[bindingGroup.name].group = i;
      bindingGroup.index = i;
    }
  }
  /**
   * The builder maintains each node in a hash-based dictionary.
   * This method sets the given node (value) with the given hash (key) into this dictionary.
   *
   * @param {Node} node - The node to add.
   * @param {number} hash - The hash of the node.
   */
  setHashNode(node, hash3) {
    this.hashNodes[hash3] = node;
  }
  /**
   * Adds a node to this builder.
   *
   * @param {Node} node - The node to add.
   */
  addNode(node) {
    if (this.nodes.includes(node) === false) {
      this.nodes.push(node);
      this.setHashNode(node, node.getHash(this));
    }
  }
  /**
   * It is used to add Nodes that will be used as FRAME and RENDER events,
   * and need to follow a certain sequence in the calls to work correctly.
   * This function should be called after 'setup()' in the 'build()' process to ensure that the child nodes are processed first.
   *
   * @param {Node} node - The node to add.
   */
  addSequentialNode(node) {
    if (this.sequentialNodes.includes(node) === false) {
      this.sequentialNodes.push(node);
    }
  }
  /**
   * Checks the update types of nodes
   */
  buildUpdateNodes() {
    for (const node of this.nodes) {
      const updateType = node.getUpdateType();
      if (updateType !== NodeUpdateType.NONE) {
        this.updateNodes.push(node);
      }
    }
    for (const node of this.sequentialNodes) {
      const updateBeforeType = node.getUpdateBeforeType();
      const updateAfterType = node.getUpdateAfterType();
      if (updateBeforeType !== NodeUpdateType.NONE) {
        this.updateBeforeNodes.push(node);
      }
      if (updateAfterType !== NodeUpdateType.NONE) {
        this.updateAfterNodes.push(node);
      }
    }
  }
  /**
   * A reference the current node which is the
   * last node in the chain of nodes.
   *
   * @type {Node}
   */
  get currentNode() {
    return this.chaining[this.chaining.length - 1];
  }
  /**
   * Whether the given texture is filtered or not.
   *
   * @param {Texture} texture - The texture to check.
   * @return {boolean} Whether the given texture is filtered or not.
   */
  isFilteredTexture(texture3) {
    return texture3.magFilter === LinearFilter || texture3.magFilter === LinearMipmapNearestFilter || texture3.magFilter === NearestMipmapLinearFilter || texture3.magFilter === LinearMipmapLinearFilter || texture3.minFilter === LinearFilter || texture3.minFilter === LinearMipmapNearestFilter || texture3.minFilter === NearestMipmapLinearFilter || texture3.minFilter === LinearMipmapLinearFilter;
  }
  /**
   * Adds the given node to the internal node chain.
   * This is used to check recursive calls in node-graph.
   *
   * @param {Node} node - The node to add.
   */
  addChain(node) {
    this.chaining.push(node);
  }
  /**
   * Removes the given node from the internal node chain.
   *
   * @param {Node} node - The node to remove.
   */
  removeChain(node) {
    const lastChain = this.chaining.pop();
    if (lastChain !== node) {
      throw new Error("NodeBuilder: Invalid node chaining!");
    }
  }
  /**
   * Returns the native shader method name for a given generic name. E.g.
   * the method name `textureDimensions` matches the WGSL name but must be
   * resolved to `textureSize` in GLSL.
   *
   * @abstract
   * @param {string} method - The method name to resolve.
   * @return {string} The resolved method name.
   */
  getMethod(method) {
    return method;
  }
  /**
   * Returns the native snippet for a ternary operation. E.g. GLSL would output
   * a ternary op as `cond ? x : y` whereas WGSL would output it as `select(y, x, cond)`
   *
   * @abstract
   * @param {string} condSnippet - The condition determining which expression gets resolved.
   * @param {string} ifSnippet - The expression to resolve to if the condition is true.
   * @param {string} elseSnippet - The expression to resolve to if the condition is false.
   * @return {string} The resolved method name.
   */
  getTernary() {
    return null;
  }
  /**
   * Returns a node for the given hash, see {@link NodeBuilder#setHashNode}.
   *
   * @param {number} hash - The hash of the node.
   * @return {Node} The found node.
   */
  getNodeFromHash(hash3) {
    return this.hashNodes[hash3];
  }
  /**
   * Adds the Node to a target flow so that it can generate code in the 'generate' process.
   *
   * @param {('vertex'|'fragment'|'compute')} shaderStage - The shader stage.
   * @param {Node} node - The node to add.
   * @return {Node} The node.
   */
  addFlow(shaderStage, node) {
    this.flowNodes[shaderStage].push(node);
    return node;
  }
  /**
   * Sets builder's context.
   *
   * @param {Object} context - The context to set.
   */
  setContext(context3) {
    this.context = context3;
  }
  /**
   * Returns the builder's current context.
   *
   * @return {Object} The builder's current context.
   */
  getContext() {
    return this.context;
  }
  /**
   * Gets a context used in shader construction that can be shared across different materials.
   * This is necessary since the renderer cache can reuse shaders generated in one material and use them in another.
   *
   * @return {Object} The builder's current context without material.
   */
  getSharedContext() {
    ({ ...this.context });
    return this.context;
  }
  /**
   * Sets builder's cache.
   *
   * @param {NodeCache} cache - The cache to set.
   */
  setCache(cache3) {
    this.cache = cache3;
  }
  /**
   * Returns the builder's current cache.
   *
   * @return {NodeCache} The builder's current cache.
   */
  getCache() {
    return this.cache;
  }
  /**
   * Returns a cache for the given node.
   *
   * @param {Node} node - The node.
   * @param {boolean} [parent=true] - Whether this node refers to a shared parent cache or not.
   * @return {NodeCache} The cache.
   */
  getCacheFromNode(node, parent = true) {
    const data = this.getDataFromNode(node);
    if (data.cache === void 0) data.cache = new NodeCache(parent ? this.getCache() : null);
    return data.cache;
  }
  /**
   * Whether the requested feature is available or not.
   *
   * @abstract
   * @param {string} name - The requested feature.
   * @return {boolean} Whether the requested feature is supported or not.
   */
  isAvailable() {
    return false;
  }
  /**
   * Returns the vertexIndex input variable as a native shader string.
   *
   * @abstract
   * @return {string} The instanceIndex shader string.
   */
  getVertexIndex() {
    console.warn("Abstract function.");
  }
  /**
   * Returns the instanceIndex input variable as a native shader string.
   *
   * @abstract
   * @return {string} The instanceIndex shader string.
   */
  getInstanceIndex() {
    console.warn("Abstract function.");
  }
  /**
   * Returns the drawIndex input variable as a native shader string.
   * Only relevant for WebGL and its `WEBGL_multi_draw` extension.
   *
   * @abstract
   * @return {?string} The drawIndex shader string.
   */
  getDrawIndex() {
    console.warn("Abstract function.");
  }
  /**
   * Returns the frontFacing input variable as a native shader string.
   *
   * @abstract
   * @return {string} The frontFacing shader string.
   */
  getFrontFacing() {
    console.warn("Abstract function.");
  }
  /**
   * Returns the fragCoord input variable as a native shader string.
   *
   * @abstract
   * @return {string} The fragCoord shader string.
   */
  getFragCoord() {
    console.warn("Abstract function.");
  }
  /**
   * Whether to flip texture data along its vertical axis or not. WebGL needs
   * this method evaluate to `true`, WebGPU to `false`.
   *
   * @abstract
   * @return {boolean} Whether to flip texture data along its vertical axis or not.
   */
  isFlipY() {
    return false;
  }
  /**
   * Calling this method increases the usage count for the given node by one.
   *
   * @param {Node} node - The node to increase the usage count for.
   * @return {number} The updated usage count.
   */
  increaseUsage(node) {
    const nodeData = this.getDataFromNode(node);
    nodeData.usageCount = nodeData.usageCount === void 0 ? 1 : nodeData.usageCount + 1;
    return nodeData.usageCount;
  }
  /**
   * Generates a texture sample shader string for the given texture data.
   *
   * @abstract
   * @param {Texture} texture - The texture.
   * @param {string} textureProperty - The texture property name.
   * @param {string} uvSnippet - Snippet defining the texture coordinates.
   * @return {string} The generated shader string.
   */
  generateTexture() {
    console.warn("Abstract function.");
  }
  /**
   * Generates a texture LOD shader string for the given texture data.
   *
   * @abstract
   * @param {Texture} texture - The texture.
   * @param {string} textureProperty - The texture property name.
   * @param {string} uvSnippet - Snippet defining the texture coordinates.
   * @param {?string} depthSnippet - Snippet defining the 0-based texture array index to sample.
   * @param {string} levelSnippet - Snippet defining the mip level.
   * @return {string} The generated shader string.
   */
  generateTextureLod() {
    console.warn("Abstract function.");
  }
  /**
   * Generates the array declaration string.
   *
   * @param {string} type - The type.
   * @param {?number} [count] - The count.
   * @return {string} The generated value as a shader string.
   */
  generateArrayDeclaration(type, count2) {
    return this.getType(type) + "[ " + count2 + " ]";
  }
  /**
   * Generates the array shader string for the given type and value.
   *
   * @param {string} type - The type.
   * @param {?number} [count] - The count.
   * @param {?Array<Node>} [values=null] - The default values.
   * @return {string} The generated value as a shader string.
   */
  generateArray(type, count2, values = null) {
    let snippet = this.generateArrayDeclaration(type, count2) + "( ";
    for (let i = 0; i < count2; i++) {
      const value = values ? values[i] : null;
      if (value !== null) {
        snippet += value.build(this, type);
      } else {
        snippet += this.generateConst(type);
      }
      if (i < count2 - 1) snippet += ", ";
    }
    snippet += " )";
    return snippet;
  }
  /**
   * Generates the struct shader string.
   *
   * @param {string} type - The type.
   * @param {Array<Object>} [membersLayout] - The count.
   * @param {?Array<Node>} [values=null] - The default values.
   * @return {string} The generated value as a shader string.
   */
  generateStruct(type, membersLayout, values = null) {
    const snippets = [];
    for (const member of membersLayout) {
      const { name, type: type2 } = member;
      if (values && values[name] && values[name].isNode) {
        snippets.push(values[name].build(this, type2));
      } else {
        snippets.push(this.generateConst(type2));
      }
    }
    return type + "( " + snippets.join(", ") + " )";
  }
  /**
   * Generates the shader string for the given type and value.
   *
   * @param {string} type - The type.
   * @param {?any} [value=null] - The value.
   * @return {string} The generated value as a shader string.
   */
  generateConst(type, value = null) {
    if (value === null) {
      if (type === "float" || type === "int" || type === "uint") value = 0;
      else if (type === "bool") value = false;
      else if (type === "color") value = new Color();
      else if (type === "vec2") value = new Vector2();
      else if (type === "vec3") value = new Vector3();
      else if (type === "vec4") value = new Vector4();
    }
    if (type === "float") return toFloat(value);
    if (type === "int") return `${Math.round(value)}`;
    if (type === "uint") return value >= 0 ? `${Math.round(value)}u` : "0u";
    if (type === "bool") return value ? "true" : "false";
    if (type === "color") return `${this.getType("vec3")}( ${toFloat(value.r)}, ${toFloat(value.g)}, ${toFloat(value.b)} )`;
    const typeLength = this.getTypeLength(type);
    const componentType = this.getComponentType(type);
    const generateConst = (value2) => this.generateConst(componentType, value2);
    if (typeLength === 2) {
      return `${this.getType(type)}( ${generateConst(value.x)}, ${generateConst(value.y)} )`;
    } else if (typeLength === 3) {
      return `${this.getType(type)}( ${generateConst(value.x)}, ${generateConst(value.y)}, ${generateConst(value.z)} )`;
    } else if (typeLength === 4 && type !== "mat2") {
      return `${this.getType(type)}( ${generateConst(value.x)}, ${generateConst(value.y)}, ${generateConst(value.z)}, ${generateConst(value.w)} )`;
    } else if (typeLength >= 4 && value && (value.isMatrix2 || value.isMatrix3 || value.isMatrix4)) {
      return `${this.getType(type)}( ${value.elements.map(generateConst).join(", ")} )`;
    } else if (typeLength > 4) {
      return `${this.getType(type)}()`;
    }
    throw new Error(`NodeBuilder: Type '${type}' not found in generate constant attempt.`);
  }
  /**
   * It might be necessary to convert certain data types to different ones
   * so this method can be used to hide the conversion.
   *
   * @param {string} type - The type.
   * @return {string} The updated type.
   */
  getType(type) {
    if (type === "color") return "vec3";
    return type;
  }
  /**
   * Whether the given attribute name is defined in the geometry or not.
   *
   * @param {string} name - The attribute name.
   * @return {boolean} Whether the given attribute name is defined in the geometry.
   */
  hasGeometryAttribute(name) {
    return this.geometry && this.geometry.getAttribute(name) !== void 0;
  }
  /**
   * Returns a node attribute for the given name and type.
   *
   * @param {string} name - The attribute's name.
   * @param {string} type - The attribute's type.
   * @return {NodeAttribute} The node attribute.
   */
  getAttribute(name, type) {
    const attributes = this.attributes;
    for (const attribute4 of attributes) {
      if (attribute4.name === name) {
        return attribute4;
      }
    }
    const attribute3 = new NodeAttribute(name, type);
    this.registerDeclaration(attribute3);
    attributes.push(attribute3);
    return attribute3;
  }
  /**
   * Returns for the given node and shader stage the property name for the shader.
   *
   * @param {Node} node - The node.
   * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.
   * @return {string} The property name.
   */
  getPropertyName(node) {
    return node.name;
  }
  /**
   * Whether the given type is a vector type or not.
   *
   * @param {string} type - The type to check.
   * @return {boolean} Whether the given type is a vector type or not.
   */
  isVector(type) {
    return /vec\d/.test(type);
  }
  /**
   * Whether the given type is a matrix type or not.
   *
   * @param {string} type - The type to check.
   * @return {boolean} Whether the given type is a matrix type or not.
   */
  isMatrix(type) {
    return /mat\d/.test(type);
  }
  /**
   * Whether the given type is a reference type or not.
   *
   * @param {string} type - The type to check.
   * @return {boolean} Whether the given type is a reference type or not.
   */
  isReference(type) {
    return type === "void" || type === "property" || type === "sampler" || type === "samplerComparison" || type === "texture" || type === "cubeTexture" || type === "storageTexture" || type === "depthTexture" || type === "texture3D";
  }
  /**
   * Checks if the given texture requires a manual conversion to the working color space.
   *
   * @abstract
   * @param {Texture} texture - The texture to check.
   * @return {boolean} Whether the given texture requires a conversion to working color space or not.
   */
  needsToWorkingColorSpace() {
    return false;
  }
  /**
   * Returns the component type of a given texture.
   *
   * @param {Texture} texture - The texture.
   * @return {string} The component type.
   */
  getComponentTypeFromTexture(texture3) {
    const type = texture3.type;
    if (texture3.isDataTexture) {
      if (type === IntType) return "int";
      if (type === UnsignedIntType) return "uint";
    }
    return "float";
  }
  /**
   * Returns the element type for a given type.
   *
   * @param {string} type - The type.
   * @return {string} The element type.
   */
  getElementType(type) {
    if (type === "mat2") return "vec2";
    if (type === "mat3") return "vec3";
    if (type === "mat4") return "vec4";
    return this.getComponentType(type);
  }
  /**
   * Returns the component type for a given type.
   *
   * @param {string} type - The type.
   * @return {string} The component type.
   */
  getComponentType(type) {
    type = this.getVectorType(type);
    if (type === "float" || type === "bool" || type === "int" || type === "uint") return type;
    const componentType = /(b|i|u|)(vec|mat)([2-4])/.exec(type);
    if (componentType === null) return null;
    if (componentType[1] === "b") return "bool";
    if (componentType[1] === "i") return "int";
    if (componentType[1] === "u") return "uint";
    return "float";
  }
  /**
   * Returns the vector type for a given type.
   *
   * @param {string} type - The type.
   * @return {string} The vector type.
   */
  getVectorType(type) {
    if (type === "color") return "vec3";
    if (type === "texture" || type === "cubeTexture" || type === "storageTexture" || type === "texture3D") return "vec4";
    return type;
  }
  /**
   * Returns the data type for the given the length and component type.
   *
   * @param {number} length - The length.
   * @param {string} [componentType='float'] - The component type.
   * @return {string} The type.
   */
  getTypeFromLength(length3, componentType = "float") {
    if (length3 === 1) return componentType;
    let baseType = getTypeFromLength(length3);
    const prefix = componentType === "float" ? "" : componentType[0];
    if (/mat2/.test(componentType) === true) {
      baseType = baseType.replace("vec", "mat");
    }
    return prefix + baseType;
  }
  /**
   * Returns the type for a given typed array.
   *
   * @param {TypedArray} array - The typed array.
   * @return {string} The type.
   */
  getTypeFromArray(array4) {
    return typeFromArray.get(array4.constructor);
  }
  /**
   * Returns the type is an integer type.
   *
   * @param {string} type - The type.
   * @return {boolean} Whether the type is an integer type or not.
   */
  isInteger(type) {
    return /int|uint|(i|u)vec/.test(type);
  }
  /**
   * Returns the type for a given buffer attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute.
   * @return {string} The type.
   */
  getTypeFromAttribute(attribute3) {
    let dataAttribute = attribute3;
    if (attribute3.isInterleavedBufferAttribute) dataAttribute = attribute3.data;
    const array4 = dataAttribute.array;
    const itemSize = attribute3.itemSize;
    const normalized = attribute3.normalized;
    let arrayType;
    if (!(attribute3 instanceof Float16BufferAttribute) && normalized !== true) {
      arrayType = this.getTypeFromArray(array4);
    }
    return this.getTypeFromLength(itemSize, arrayType);
  }
  /**
   * Returns the length for the given data type.
   *
   * @param {string} type - The data type.
   * @return {number} The length.
   */
  getTypeLength(type) {
    const vecType = this.getVectorType(type);
    const vecNum = /vec([2-4])/.exec(vecType);
    if (vecNum !== null) return Number(vecNum[1]);
    if (vecType === "float" || vecType === "bool" || vecType === "int" || vecType === "uint") return 1;
    if (/mat2/.test(type) === true) return 4;
    if (/mat3/.test(type) === true) return 9;
    if (/mat4/.test(type) === true) return 16;
    return 0;
  }
  /**
   * Returns the vector type for a given matrix type.
   *
   * @param {string} type - The matrix type.
   * @return {string} The vector type.
   */
  getVectorFromMatrix(type) {
    return type.replace("mat", "vec");
  }
  /**
   * For a given type this method changes the component type to the
   * given value. E.g. `vec4` should be changed to the new component type
   * `uint` which results in `uvec4`.
   *
   * @param {string} type - The type.
   * @param {string} newComponentType - The new component type.
   * @return {string} The new type.
   */
  changeComponentType(type, newComponentType) {
    return this.getTypeFromLength(this.getTypeLength(type), newComponentType);
  }
  /**
   * Returns the integer type pendant for the given type.
   *
   * @param {string} type - The type.
   * @return {string} The integer type.
   */
  getIntegerType(type) {
    const componentType = this.getComponentType(type);
    if (componentType === "int" || componentType === "uint") return type;
    return this.changeComponentType(type, "int");
  }
  /**
   * Adds a stack node to the internal stack.
   *
   * @return {StackNode} The added stack node.
   */
  addStack() {
    this.stack = stack(this.stack);
    const previousStack = getCurrentStack();
    this.stacks.push(previousStack);
    setCurrentStack(this.stack);
    return this.stack;
  }
  /**
   * Removes the last stack node from the internal stack.
   *
   * @return {StackNode} The removed stack node.
   */
  removeStack() {
    const lastStack = this.stack;
    this.stack = lastStack.parent;
    setCurrentStack(this.stacks.pop());
    return lastStack;
  }
  /**
   * The builder maintains (cached) data for each node during the building process. This method
   * can be used to get these data for a specific shader stage and cache.
   *
   * @param {Node} node - The node to get the data for.
   * @param {('vertex'|'fragment'|'compute'|'any')} [shaderStage=this.shaderStage] - The shader stage.
   * @param {?NodeCache} cache - An optional cache.
   * @return {Object} The node data.
   */
  getDataFromNode(node, shaderStage = this.shaderStage, cache3 = null) {
    cache3 = cache3 === null ? node.isGlobal(this) ? this.globalCache : this.cache : cache3;
    let nodeData = cache3.getData(node);
    if (nodeData === void 0) {
      nodeData = {};
      cache3.setData(node, nodeData);
    }
    if (nodeData[shaderStage] === void 0) nodeData[shaderStage] = {};
    let data = nodeData[shaderStage];
    const subBuilds = nodeData.any ? nodeData.any.subBuilds : null;
    const subBuild3 = this.getClosestSubBuild(subBuilds);
    if (subBuild3) {
      if (data.subBuildsCache === void 0) data.subBuildsCache = {};
      data = data.subBuildsCache[subBuild3] || (data.subBuildsCache[subBuild3] = {});
      data.subBuilds = subBuilds;
    }
    return data;
  }
  /**
   * Returns the properties for the given node and shader stage.
   *
   * @param {Node} node - The node to get the properties for.
   * @param {('vertex'|'fragment'|'compute'|'any')} [shaderStage='any'] - The shader stage.
   * @return {Object} The node properties.
   */
  getNodeProperties(node, shaderStage = "any") {
    const nodeData = this.getDataFromNode(node, shaderStage);
    return nodeData.properties || (nodeData.properties = { outputNode: null });
  }
  /**
   * Returns an instance of {@link NodeAttribute} for the given buffer attribute node.
   *
   * @param {BufferAttributeNode} node - The buffer attribute node.
   * @param {string} type - The node type.
   * @return {NodeAttribute} The node attribute.
   */
  getBufferAttributeFromNode(node, type) {
    const nodeData = this.getDataFromNode(node);
    let bufferAttribute3 = nodeData.bufferAttribute;
    if (bufferAttribute3 === void 0) {
      const index5 = this.uniforms.index++;
      bufferAttribute3 = new NodeAttribute("nodeAttribute" + index5, type, node);
      this.bufferAttributes.push(bufferAttribute3);
      nodeData.bufferAttribute = bufferAttribute3;
    }
    return bufferAttribute3;
  }
  /**
   * Returns an instance of {@link StructType} for the given struct name and shader stage
   * or null if not found.
   *
   * @param {string} name - The name of the struct.
   * @param {('vertex'|'fragment'|'compute'|'any')} [shaderStage=this.shaderStage] - The shader stage.
   * @return {?StructType} The struct type or null if not found.
   */
  getStructTypeNode(name, shaderStage = this.shaderStage) {
    return this.types[shaderStage][name] || null;
  }
  /**
   * Returns an instance of {@link StructType} for the given output struct node.
   *
   * @param {OutputStructNode} node - The output struct node.
   * @param {Array<Object>} membersLayout - The output struct types.
   * @param {?string} [name=null] - The name of the struct.
   * @param {('vertex'|'fragment'|'compute'|'any')} [shaderStage=this.shaderStage] - The shader stage.
   * @return {StructType} The struct type attribute.
   */
  getStructTypeFromNode(node, membersLayout, name = null, shaderStage = this.shaderStage) {
    const nodeData = this.getDataFromNode(node, shaderStage, this.globalCache);
    let structType = nodeData.structType;
    if (structType === void 0) {
      const index5 = this.structs.index++;
      if (name === null) name = "StructType" + index5;
      structType = new StructType(name, membersLayout);
      this.structs[shaderStage].push(structType);
      this.types[shaderStage][name] = node;
      nodeData.structType = structType;
    }
    return structType;
  }
  /**
   * Returns an instance of {@link StructType} for the given output struct node.
   *
   * @param {OutputStructNode} node - The output struct node.
   * @param {Array<Object>} membersLayout - The output struct types.
   * @return {StructType} The struct type attribute.
   */
  getOutputStructTypeFromNode(node, membersLayout) {
    const structType = this.getStructTypeFromNode(node, membersLayout, "OutputType", "fragment");
    structType.output = true;
    return structType;
  }
  /**
   * Returns an instance of {@link NodeUniform} for the given uniform node.
   *
   * @param {UniformNode} node - The uniform node.
   * @param {string} type - The uniform type.
   * @param {('vertex'|'fragment'|'compute'|'any')} [shaderStage=this.shaderStage] - The shader stage.
   * @param {?string} name - The name of the uniform.
   * @return {NodeUniform} The node uniform.
   */
  getUniformFromNode(node, type, shaderStage = this.shaderStage, name = null) {
    const nodeData = this.getDataFromNode(node, shaderStage, this.globalCache);
    let nodeUniform = nodeData.uniform;
    if (nodeUniform === void 0) {
      const index5 = this.uniforms.index++;
      nodeUniform = new NodeUniform(name || "nodeUniform" + index5, type, node);
      this.uniforms[shaderStage].push(nodeUniform);
      this.registerDeclaration(nodeUniform);
      nodeData.uniform = nodeUniform;
    }
    return nodeUniform;
  }
  /**
   * Returns an instance of {@link NodeVar} for the given variable node.
   *
   * @param {VarNode} node - The variable node.
   * @param {?string} name - The variable's name.
   * @param {string} [type=node.getNodeType( this )] - The variable's type.
   * @param {('vertex'|'fragment'|'compute'|'any')} [shaderStage=this.shaderStage] - The shader stage.
   * @param {boolean} [readOnly=false] - Whether the variable is read-only or not.
   *
   * @return {NodeVar} The node variable.
   */
  getVarFromNode(node, name = null, type = node.getNodeType(this), shaderStage = this.shaderStage, readOnly = false) {
    const nodeData = this.getDataFromNode(node, shaderStage);
    const subBuildVariable = this.getSubBuildProperty("variable", nodeData.subBuilds);
    let nodeVar = nodeData[subBuildVariable];
    if (nodeVar === void 0) {
      const idNS = readOnly ? "_const" : "_var";
      const vars = this.vars[shaderStage] || (this.vars[shaderStage] = []);
      const id = this.vars[idNS] || (this.vars[idNS] = 0);
      if (name === null) {
        name = (readOnly ? "nodeConst" : "nodeVar") + id;
        this.vars[idNS]++;
      }
      if (subBuildVariable !== "variable") {
        name = this.getSubBuildProperty(name, nodeData.subBuilds);
      }
      const count2 = node.getArrayCount(this);
      nodeVar = new NodeVar(name, type, readOnly, count2);
      if (!readOnly) {
        vars.push(nodeVar);
      }
      this.registerDeclaration(nodeVar);
      nodeData[subBuildVariable] = nodeVar;
    }
    return nodeVar;
  }
  /**
   * Returns whether a Node or its flow is deterministic, useful for use in `const`.
   *
   * @param {Node} node - The varying node.
   * @return {boolean} Returns true if deterministic.
   */
  isDeterministic(node) {
    if (node.isMathNode) {
      return this.isDeterministic(node.aNode) && (node.bNode ? this.isDeterministic(node.bNode) : true) && (node.cNode ? this.isDeterministic(node.cNode) : true);
    } else if (node.isOperatorNode) {
      return this.isDeterministic(node.aNode) && (node.bNode ? this.isDeterministic(node.bNode) : true);
    } else if (node.isArrayNode) {
      if (node.values !== null) {
        for (const n of node.values) {
          if (!this.isDeterministic(n)) {
            return false;
          }
        }
      }
      return true;
    } else if (node.isConstNode) {
      return true;
    }
    return false;
  }
  /**
   * Returns an instance of {@link NodeVarying} for the given varying node.
   *
   * @param {(VaryingNode|PropertyNode)} node - The varying node.
   * @param {?string} name - The varying's name.
   * @param {string} [type=node.getNodeType( this )] - The varying's type.
   * @param {?string} interpolationType - The interpolation type of the varying.
   * @param {?string} interpolationSampling - The interpolation sampling type of the varying.
   * @return {NodeVar} The node varying.
   */
  getVaryingFromNode(node, name = null, type = node.getNodeType(this), interpolationType = null, interpolationSampling = null) {
    const nodeData = this.getDataFromNode(node, "any");
    const subBuildVarying = this.getSubBuildProperty("varying", nodeData.subBuilds);
    let nodeVarying = nodeData[subBuildVarying];
    if (nodeVarying === void 0) {
      const varyings = this.varyings;
      const index5 = varyings.length;
      if (name === null) name = "nodeVarying" + index5;
      if (subBuildVarying !== "varying") {
        name = this.getSubBuildProperty(name, nodeData.subBuilds);
      }
      nodeVarying = new NodeVarying(name, type, interpolationType, interpolationSampling);
      varyings.push(nodeVarying);
      this.registerDeclaration(nodeVarying);
      nodeData[subBuildVarying] = nodeVarying;
    }
    return nodeVarying;
  }
  /**
   * Registers a node declaration in the current shader stage.
   *
   * @param {Object} node - The node to be registered.
   */
  registerDeclaration(node) {
    const shaderStage = this.shaderStage;
    const declarations = this.declarations[shaderStage] || (this.declarations[shaderStage] = {});
    const property3 = this.getPropertyName(node);
    let index5 = 1;
    let name = property3;
    while (declarations[name] !== void 0) {
      name = property3 + "_" + index5++;
    }
    if (index5 > 1) {
      node.name = name;
      console.warn(`THREE.TSL: Declaration name '${property3}' of '${node.type}' already in use. Renamed to '${name}'.`);
    }
    declarations[name] = node;
  }
  /**
   * Returns an instance of {@link NodeCode} for the given code node.
   *
   * @param {CodeNode} node - The code node.
   * @param {string} type - The node type.
   * @param {('vertex'|'fragment'|'compute'|'any')} [shaderStage=this.shaderStage] - The shader stage.
   * @return {NodeCode} The node code.
   */
  getCodeFromNode(node, type, shaderStage = this.shaderStage) {
    const nodeData = this.getDataFromNode(node);
    let nodeCode = nodeData.code;
    if (nodeCode === void 0) {
      const codes = this.codes[shaderStage] || (this.codes[shaderStage] = []);
      const index5 = codes.length;
      nodeCode = new NodeCode("nodeCode" + index5, type);
      codes.push(nodeCode);
      nodeData.code = nodeCode;
    }
    return nodeCode;
  }
  /**
  	 * Adds a code flow based on the code-block hierarchy.
  
  	 * This is used so that code-blocks like If,Else create their variables locally if the Node
  	 * is only used inside one of these conditionals in the current shader stage.
  	 *
  	 * @param {Node} node - The node to add.
  	 * @param {Node} nodeBlock - Node-based code-block. Usually 'ConditionalNode'.
  	 */
  addFlowCodeHierarchy(node, nodeBlock) {
    const { flowCodes, flowCodeBlock } = this.getDataFromNode(node);
    let needsFlowCode = true;
    let nodeBlockHierarchy = nodeBlock;
    while (nodeBlockHierarchy) {
      if (flowCodeBlock.get(nodeBlockHierarchy) === true) {
        needsFlowCode = false;
        break;
      }
      nodeBlockHierarchy = this.getDataFromNode(nodeBlockHierarchy).parentNodeBlock;
    }
    if (needsFlowCode) {
      for (const flowCode of flowCodes) {
        this.addLineFlowCode(flowCode);
      }
    }
  }
  /**
   * Add a inline-code to the current flow code-block.
   *
   * @param {Node} node - The node to add.
   * @param {string} code - The code to add.
   * @param {Node} nodeBlock - Current ConditionalNode
   */
  addLineFlowCodeBlock(node, code3, nodeBlock) {
    const nodeData = this.getDataFromNode(node);
    const flowCodes = nodeData.flowCodes || (nodeData.flowCodes = []);
    const codeBlock = nodeData.flowCodeBlock || (nodeData.flowCodeBlock = /* @__PURE__ */ new WeakMap());
    flowCodes.push(code3);
    codeBlock.set(nodeBlock, true);
  }
  /**
   * Add a inline-code to the current flow.
   *
   * @param {string} code - The code to add.
   * @param {?Node} [node= null] - Optional Node, can help the system understand if the Node is part of a code-block.
   * @return {NodeBuilder} A reference to this node builder.
   */
  addLineFlowCode(code3, node = null) {
    if (code3 === "") return this;
    if (node !== null && this.context.nodeBlock) {
      this.addLineFlowCodeBlock(node, code3, this.context.nodeBlock);
    }
    code3 = this.tab + code3;
    if (!/;\s*$/.test(code3)) {
      code3 = code3 + ";\n";
    }
    this.flow.code += code3;
    return this;
  }
  /**
   * Adds a code to the current code flow.
   *
   * @param {string} code - Shader code.
   * @return {NodeBuilder} A reference to this node builder.
   */
  addFlowCode(code3) {
    this.flow.code += code3;
    return this;
  }
  /**
   * Add tab in the code that will be generated so that other snippets respect the current tabulation.
   * Typically used in codes with If,Else.
   *
   * @return {NodeBuilder} A reference to this node builder.
   */
  addFlowTab() {
    this.tab += "	";
    return this;
  }
  /**
   * Removes a tab.
   *
   * @return {NodeBuilder} A reference to this node builder.
   */
  removeFlowTab() {
    this.tab = this.tab.slice(0, -1);
    return this;
  }
  /**
   * Gets the current flow data based on a Node.
   *
   * @param {Node} node - Node that the flow was started.
   * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.
   * @return {Object} The flow data.
   */
  getFlowData(node) {
    return this.flowsData.get(node);
  }
  /**
   * Executes the node flow based on a root node to generate the final shader code.
   *
   * @param {Node} node - The node to execute.
   * @return {Object} The code flow.
   */
  flowNode(node) {
    const output3 = node.getNodeType(this);
    const flowData = this.flowChildNode(node, output3);
    this.flowsData.set(node, flowData);
    return flowData;
  }
  /**
   * Includes a node in the current function node.
   *
   * @param {Node} node - The node to include.
   * @returns {void}
   */
  addInclude(node) {
    if (this.currentFunctionNode !== null) {
      this.currentFunctionNode.includes.push(node);
    }
  }
  /**
   * Returns the native shader operator name for a given generic name.
   * It is a similar type of method like {@link NodeBuilder#getMethod}.
   *
   * @param {ShaderNodeInternal} shaderNode - The shader node to build the function node with.
   * @return {FunctionNode} The build function node.
   */
  buildFunctionNode(shaderNode) {
    const fn = new FunctionNode();
    const previous = this.currentFunctionNode;
    this.currentFunctionNode = fn;
    fn.code = this.buildFunctionCode(shaderNode);
    this.currentFunctionNode = previous;
    return fn;
  }
  /**
   * Generates a code flow based on a TSL function: Fn().
   *
   * @param {ShaderNodeInternal} shaderNode - A function code will be generated based on the input.
   * @return {Object}
   */
  flowShaderNode(shaderNode) {
    const layout = shaderNode.layout;
    const inputs = {
      [Symbol.iterator]() {
        let index5 = 0;
        const values = Object.values(this);
        return {
          next: () => ({
            value: values[index5],
            done: index5++ >= values.length
          })
        };
      }
    };
    for (const input of layout.inputs) {
      inputs[input.name] = new ParameterNode(input.type, input.name);
    }
    shaderNode.layout = null;
    const callNode = shaderNode.call(inputs);
    const flowData = this.flowStagesNode(callNode, layout.type);
    shaderNode.layout = layout;
    return flowData;
  }
  /**
   * Executes the node in a specific build stage.
   *
   * @param {Node} node - The node to execute.
   * @param {string} buildStage - The build stage to execute the node in.
   * @param {?(Node|string)} [output=null] - Expected output type. For example 'vec3'.
   * @return {?(Node|string)} The result of the node build.
   */
  flowBuildStage(node, buildStage, output3 = null) {
    const previousBuildStage = this.getBuildStage();
    this.setBuildStage(buildStage);
    const result = node.build(this, output3);
    this.setBuildStage(previousBuildStage);
    return result;
  }
  /**
   * Runs the node flow through all the steps of creation, 'setup', 'analyze', 'generate'.
   *
   * @param {Node} node - The node to execute.
   * @param {?string} output - Expected output type. For example 'vec3'.
   * @return {Object}
   */
  flowStagesNode(node, output3 = null) {
    const previousFlow = this.flow;
    const previousVars = this.vars;
    const previousDeclarations = this.declarations;
    const previousCache = this.cache;
    const previousBuildStage = this.buildStage;
    const previousStack = this.stack;
    const flow = {
      code: ""
    };
    this.flow = flow;
    this.vars = {};
    this.declarations = {};
    this.cache = new NodeCache();
    this.stack = stack();
    for (const buildStage of defaultBuildStages) {
      this.setBuildStage(buildStage);
      flow.result = node.build(this, output3);
    }
    flow.vars = this.getVars(this.shaderStage);
    this.flow = previousFlow;
    this.vars = previousVars;
    this.declarations = previousDeclarations;
    this.cache = previousCache;
    this.stack = previousStack;
    this.setBuildStage(previousBuildStage);
    return flow;
  }
  /**
   * Returns the native shader operator name for a given generic name.
   * It is a similar type of method like {@link NodeBuilder#getMethod}.
   *
   * @abstract
   * @param {string} op - The operator name to resolve.
   * @return {?string} The resolved operator name.
   */
  getFunctionOperator() {
    return null;
  }
  /**
   * Builds the given shader node.
   *
   * @abstract
   * @param {ShaderNodeInternal} shaderNode - The shader node.
   * @return {string} The function code.
   */
  buildFunctionCode() {
    console.warn("Abstract function.");
  }
  /**
   * Generates a code flow based on a child Node.
   *
   * @param {Node} node - The node to execute.
   * @param {?string} output - Expected output type. For example 'vec3'.
   * @return {Object} The code flow.
   */
  flowChildNode(node, output3 = null) {
    const previousFlow = this.flow;
    const flow = {
      code: ""
    };
    this.flow = flow;
    flow.result = node.build(this, output3);
    this.flow = previousFlow;
    return flow;
  }
  /**
   * Executes a flow of code in a different stage.
   *
   * Some nodes like `varying()` have the ability to compute code in vertex-stage and
   * return the value in fragment-stage even if it is being executed in an input fragment.
   *
   * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.
   * @param {Node} node - The node to execute.
   * @param {?string} output - Expected output type. For example 'vec3'.
   * @param {?string} propertyName - The property name to assign the result.
   * @return {?(Object|Node)} The code flow or node.build() result.
   */
  flowNodeFromShaderStage(shaderStage, node, output3 = null, propertyName = null) {
    const previousTab = this.tab;
    const previousCache = this.cache;
    const previousShaderStage = this.shaderStage;
    const previousContext = this.context;
    this.setShaderStage(shaderStage);
    const context3 = { ...this.context };
    delete context3.nodeBlock;
    this.cache = this.globalCache;
    this.tab = "	";
    this.context = context3;
    let result = null;
    if (this.buildStage === "generate") {
      const flowData = this.flowChildNode(node, output3);
      if (propertyName !== null) {
        flowData.code += `${this.tab + propertyName} = ${flowData.result};
`;
      }
      this.flowCode[shaderStage] = this.flowCode[shaderStage] + flowData.code;
      result = flowData;
    } else {
      result = node.build(this);
    }
    this.setShaderStage(previousShaderStage);
    this.cache = previousCache;
    this.tab = previousTab;
    this.context = previousContext;
    return result;
  }
  /**
   * Returns an array holding all node attributes of this node builder.
   *
   * @return {Array<NodeAttribute>} The node attributes of this builder.
   */
  getAttributesArray() {
    return this.attributes.concat(this.bufferAttributes);
  }
  /**
   * Returns the attribute definitions as a shader string for the given shader stage.
   *
   * @abstract
   * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.
   * @return {string} The attribute code section.
   */
  getAttributes() {
    console.warn("Abstract function.");
  }
  /**
   * Returns the varying definitions as a shader string for the given shader stage.
   *
   * @abstract
   * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.
   * @return {string} The varying code section.
   */
  getVaryings() {
    console.warn("Abstract function.");
  }
  /**
   * Returns a single variable definition as a shader string for the given variable type and name.
   *
   * @param {string} type - The variable's type.
   * @param {string} name - The variable's name.
   * @param {?number} [count=null] - The array length.
   * @return {string} The shader string.
   */
  getVar(type, name, count2 = null) {
    return `${count2 !== null ? this.generateArrayDeclaration(type, count2) : this.getType(type)} ${name}`;
  }
  /**
   * Returns the variable definitions as a shader string for the given shader stage.
   *
   * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.
   * @return {string} The variable code section.
   */
  getVars(shaderStage) {
    let snippet = "";
    const vars = this.vars[shaderStage];
    if (vars !== void 0) {
      for (const variable of vars) {
        snippet += `${this.getVar(variable.type, variable.name)}; `;
      }
    }
    return snippet;
  }
  /**
   * Returns the uniform definitions as a shader string for the given shader stage.
   *
   * @abstract
   * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.
   * @return {string} The uniform code section.
   */
  getUniforms() {
    console.warn("Abstract function.");
  }
  /**
   * Returns the native code definitions as a shader string for the given shader stage.
   *
   * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.
   * @return {string} The native code section.
   */
  getCodes(shaderStage) {
    const codes = this.codes[shaderStage];
    let code3 = "";
    if (codes !== void 0) {
      for (const nodeCode of codes) {
        code3 += nodeCode.code + "\n";
      }
    }
    return code3;
  }
  /**
   * Returns the hash of this node builder.
   *
   * @return {string} The hash.
   */
  getHash() {
    return this.vertexShader + this.fragmentShader + this.computeShader;
  }
  /**
   * Sets the current shader stage.
   *
   * @param {?('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage to set.
   */
  setShaderStage(shaderStage) {
    this.shaderStage = shaderStage;
  }
  /**
   * Returns the current shader stage.
   *
   * @return {?('vertex'|'fragment'|'compute'|'any')} The current shader stage.
   */
  getShaderStage() {
    return this.shaderStage;
  }
  /**
   * Sets the current build stage.
   *
   * @param {?('setup'|'analyze'|'generate')} buildStage - The build stage to set.
   */
  setBuildStage(buildStage) {
    this.buildStage = buildStage;
  }
  /**
   * Returns the current build stage.
   *
   * @return {?('setup'|'analyze'|'generate')} The current build stage.
   */
  getBuildStage() {
    return this.buildStage;
  }
  /**
   * Controls the code build of the shader stages.
   *
   * @abstract
   */
  buildCode() {
    console.warn("Abstract function.");
  }
  /**
   * Returns the current sub-build layer.
   *
   * @return {SubBuildNode} The current sub-build layers.
   */
  get subBuild() {
    return this.subBuildLayers[this.subBuildLayers.length - 1] || null;
  }
  /**
   * Adds a sub-build layer to the node builder.
   *
   * @param {SubBuildNode} subBuild - The sub-build layer to add.
   */
  addSubBuild(subBuild3) {
    this.subBuildLayers.push(subBuild3);
  }
  /**
   * Removes the last sub-build layer from the node builder.
   *
   * @return {SubBuildNode} The removed sub-build layer.
   */
  removeSubBuild() {
    return this.subBuildLayers.pop();
  }
  /**
   * Returns the closest sub-build layer for the given data.
   *
   * @param {Node|Set<string>|Array<string>} data - The data to get the closest sub-build layer from.
   * @return {?string} The closest sub-build name or null if none found.
   */
  getClosestSubBuild(data) {
    let subBuilds;
    if (data && data.isNode) {
      if (data.isShaderCallNodeInternal) {
        subBuilds = data.shaderNode.subBuilds;
      } else if (data.isStackNode) {
        subBuilds = [data.subBuild];
      } else {
        subBuilds = this.getDataFromNode(data, "any").subBuilds;
      }
    } else if (data instanceof Set) {
      subBuilds = [...data];
    } else {
      subBuilds = data;
    }
    if (!subBuilds) return null;
    const subBuildLayers = this.subBuildLayers;
    for (let i = subBuilds.length - 1; i >= 0; i--) {
      const subBuild3 = subBuilds[i];
      if (subBuildLayers.includes(subBuild3)) {
        return subBuild3;
      }
    }
    return null;
  }
  /**
   * Returns the output node of a sub-build layer.
   *
   * @param {Node} node - The node to get the output from.
   * @return {string} The output node name.
   */
  getSubBuildOutput(node) {
    return this.getSubBuildProperty("outputNode", node);
  }
  /**
   * Returns the sub-build property name for the given property and node.
   *
   * @param {string} [property=''] - The property name.
   * @param {?Node} [node=null] - The node to get the sub-build from.
   * @return {string} The sub-build property name.
   */
  getSubBuildProperty(property3 = "", node = null) {
    let subBuild3;
    if (node !== null) {
      subBuild3 = this.getClosestSubBuild(node);
    } else {
      subBuild3 = this.subBuildFn;
    }
    let result;
    if (subBuild3) {
      result = property3 ? subBuild3 + "_" + property3 : subBuild3;
    } else {
      result = property3;
    }
    return result;
  }
  /**
   * Central build method which controls the build for the given object.
   *
   * @return {NodeBuilder} A reference to this node builder.
   */
  build() {
    const { object: object2, material, renderer } = this;
    if (material !== null) {
      let nodeMaterial = renderer.library.fromMaterial(material);
      if (nodeMaterial === null) {
        console.error(`NodeMaterial: Material "${material.type}" is not compatible.`);
        nodeMaterial = new NodeMaterial();
      }
      nodeMaterial.build(this);
    } else {
      this.addFlow("compute", object2);
    }
    for (const buildStage of defaultBuildStages) {
      this.setBuildStage(buildStage);
      if (this.context.vertex && this.context.vertex.isNode) {
        this.flowNodeFromShaderStage("vertex", this.context.vertex);
      }
      for (const shaderStage of shaderStages) {
        this.setShaderStage(shaderStage);
        const flowNodes = this.flowNodes[shaderStage];
        for (const node of flowNodes) {
          if (buildStage === "generate") {
            this.flowNode(node);
          } else {
            node.build(this);
          }
        }
      }
    }
    this.setBuildStage(null);
    this.setShaderStage(null);
    this.buildCode();
    this.buildUpdateNodes();
    return this;
  }
  /**
   * Returns a uniform representation which is later used for UBO generation and rendering.
   *
   * @param {NodeUniform} uniformNode - The uniform node.
   * @param {string} type - The requested type.
   * @return {Uniform} The uniform.
   */
  getNodeUniform(uniformNode, type) {
    if (type === "float" || type === "int" || type === "uint") return new NumberNodeUniform(uniformNode);
    if (type === "vec2" || type === "ivec2" || type === "uvec2") return new Vector2NodeUniform(uniformNode);
    if (type === "vec3" || type === "ivec3" || type === "uvec3") return new Vector3NodeUniform(uniformNode);
    if (type === "vec4" || type === "ivec4" || type === "uvec4") return new Vector4NodeUniform(uniformNode);
    if (type === "color") return new ColorNodeUniform(uniformNode);
    if (type === "mat2") return new Matrix2NodeUniform(uniformNode);
    if (type === "mat3") return new Matrix3NodeUniform(uniformNode);
    if (type === "mat4") return new Matrix4NodeUniform(uniformNode);
    throw new Error(`Uniform "${type}" not declared.`);
  }
  /**
   * Formats the given shader snippet from a given type into another one. E.g.
   * this method might be used to convert a simple float string `"1.0"` into a
   * `vec3` representation: `"vec3<f32>( 1.0 )"`.
   *
   * @param {string} snippet - The shader snippet.
   * @param {string} fromType - The source type.
   * @param {string} toType - The target type.
   * @return {string} The updated shader string.
   */
  format(snippet, fromType, toType) {
    fromType = this.getVectorType(fromType);
    toType = this.getVectorType(toType);
    if (fromType === toType || toType === null || this.isReference(toType)) {
      return snippet;
    }
    const fromTypeLength = this.getTypeLength(fromType);
    const toTypeLength = this.getTypeLength(toType);
    if (fromTypeLength === 16 && toTypeLength === 9) {
      return `${this.getType(toType)}( ${snippet}[ 0 ].xyz, ${snippet}[ 1 ].xyz, ${snippet}[ 2 ].xyz )`;
    }
    if (fromTypeLength === 9 && toTypeLength === 4) {
      return `${this.getType(toType)}( ${snippet}[ 0 ].xy, ${snippet}[ 1 ].xy )`;
    }
    if (fromTypeLength > 4) {
      return snippet;
    }
    if (toTypeLength > 4 || toTypeLength === 0) {
      return snippet;
    }
    if (fromTypeLength === toTypeLength) {
      return `${this.getType(toType)}( ${snippet} )`;
    }
    if (fromTypeLength > toTypeLength) {
      snippet = toType === "bool" ? `all( ${snippet} )` : `${snippet}.${"xyz".slice(0, toTypeLength)}`;
      return this.format(snippet, this.getTypeFromLength(toTypeLength, this.getComponentType(fromType)), toType);
    }
    if (toTypeLength === 4 && fromTypeLength > 1) {
      return `${this.getType(toType)}( ${this.format(snippet, fromType, "vec3")}, 1.0 )`;
    }
    if (fromTypeLength === 2) {
      return `${this.getType(toType)}( ${this.format(snippet, fromType, "vec2")}, 0.0 )`;
    }
    if (fromTypeLength === 1 && toTypeLength > 1 && fromType !== this.getComponentType(toType)) {
      snippet = `${this.getType(this.getComponentType(toType))}( ${snippet} )`;
    }
    return `${this.getType(toType)}( ${snippet} )`;
  }
  /**
   * Returns a signature with the engine's current revision.
   *
   * @return {string} The signature.
   */
  getSignature() {
    return `// Three.js r${REVISION} - Node System
`;
  }
};
var NodeFrame = class {
  /**
   * Constructs a new node fame.
   */
  constructor() {
    this.time = 0;
    this.deltaTime = 0;
    this.frameId = 0;
    this.renderId = 0;
    this.updateMap = /* @__PURE__ */ new WeakMap();
    this.updateBeforeMap = /* @__PURE__ */ new WeakMap();
    this.updateAfterMap = /* @__PURE__ */ new WeakMap();
    this.renderer = null;
    this.material = null;
    this.camera = null;
    this.object = null;
    this.scene = null;
  }
  /**
   * Returns a dictionary for a given node and update map which
   * is used to correctly call node update methods per frame or render.
   *
   * @private
   * @param {WeakMap<Node, Object>} referenceMap - The reference weak map.
   * @param {Node} nodeRef - The reference to the current node.
   * @return {Object<string,WeakMap<Object, number>>} The dictionary.
   */
  _getMaps(referenceMap, nodeRef) {
    let maps = referenceMap.get(nodeRef);
    if (maps === void 0) {
      maps = {
        renderMap: /* @__PURE__ */ new WeakMap(),
        frameMap: /* @__PURE__ */ new WeakMap()
      };
      referenceMap.set(nodeRef, maps);
    }
    return maps;
  }
  /**
   * This method executes the {@link Node#updateBefore} for the given node.
   * It makes sure {@link Node#updateBeforeType} is honored meaning the update
   * is only executed once per frame, render or object depending on the update
   * type.
   *
   * @param {Node} node - The node that should be updated.
   */
  updateBeforeNode(node) {
    const updateType = node.getUpdateBeforeType();
    const reference3 = node.updateReference(this);
    if (updateType === NodeUpdateType.FRAME) {
      const { frameMap } = this._getMaps(this.updateBeforeMap, reference3);
      if (frameMap.get(reference3) !== this.frameId) {
        if (node.updateBefore(this) !== false) {
          frameMap.set(reference3, this.frameId);
        }
      }
    } else if (updateType === NodeUpdateType.RENDER) {
      const { renderMap } = this._getMaps(this.updateBeforeMap, reference3);
      if (renderMap.get(reference3) !== this.renderId) {
        if (node.updateBefore(this) !== false) {
          renderMap.set(reference3, this.renderId);
        }
      }
    } else if (updateType === NodeUpdateType.OBJECT) {
      node.updateBefore(this);
    }
  }
  /**
   * This method executes the {@link Node#updateAfter} for the given node.
   * It makes sure {@link Node#updateAfterType} is honored meaning the update
   * is only executed once per frame, render or object depending on the update
   * type.
   *
   * @param {Node} node - The node that should be updated.
   */
  updateAfterNode(node) {
    const updateType = node.getUpdateAfterType();
    const reference3 = node.updateReference(this);
    if (updateType === NodeUpdateType.FRAME) {
      const { frameMap } = this._getMaps(this.updateAfterMap, reference3);
      if (frameMap.get(reference3) !== this.frameId) {
        if (node.updateAfter(this) !== false) {
          frameMap.set(reference3, this.frameId);
        }
      }
    } else if (updateType === NodeUpdateType.RENDER) {
      const { renderMap } = this._getMaps(this.updateAfterMap, reference3);
      if (renderMap.get(reference3) !== this.renderId) {
        if (node.updateAfter(this) !== false) {
          renderMap.set(reference3, this.renderId);
        }
      }
    } else if (updateType === NodeUpdateType.OBJECT) {
      node.updateAfter(this);
    }
  }
  /**
   * This method executes the {@link Node#update} for the given node.
   * It makes sure {@link Node#updateType} is honored meaning the update
   * is only executed once per frame, render or object depending on the update
   * type.
   *
   * @param {Node} node - The node that should be updated.
   */
  updateNode(node) {
    const updateType = node.getUpdateType();
    const reference3 = node.updateReference(this);
    if (updateType === NodeUpdateType.FRAME) {
      const { frameMap } = this._getMaps(this.updateMap, reference3);
      if (frameMap.get(reference3) !== this.frameId) {
        if (node.update(this) !== false) {
          frameMap.set(reference3, this.frameId);
        }
      }
    } else if (updateType === NodeUpdateType.RENDER) {
      const { renderMap } = this._getMaps(this.updateMap, reference3);
      if (renderMap.get(reference3) !== this.renderId) {
        if (node.update(this) !== false) {
          renderMap.set(reference3, this.renderId);
        }
      }
    } else if (updateType === NodeUpdateType.OBJECT) {
      node.update(this);
    }
  }
  /**
   * Updates the internal state of the node frame. This method is
   * called by the renderer in its internal animation loop.
   */
  update() {
    this.frameId++;
    if (this.lastTime === void 0) this.lastTime = performance.now();
    this.deltaTime = (performance.now() - this.lastTime) / 1e3;
    this.lastTime = performance.now();
    this.time += this.deltaTime;
  }
};
var NodeFunctionInput = class {
  /**
   * Constructs a new node function input.
   *
   * @param {string} type - The input type.
   * @param {string} name - The input name.
   * @param {?number} [count=null] - If the input is an Array, count will be the length.
   * @param {('in'|'out'|'inout')} [qualifier=''] - The parameter qualifier (only relevant for GLSL).
   * @param {boolean} [isConst=false] - Whether the input uses a const qualifier or not (only relevant for GLSL).
   */
  constructor(type, name, count2 = null, qualifier = "", isConst = false) {
    this.type = type;
    this.name = name;
    this.count = count2;
    this.qualifier = qualifier;
    this.isConst = isConst;
  }
};
NodeFunctionInput.isNodeFunctionInput = true;
var DirectionalLightNode = class extends AnalyticLightNode {
  static get type() {
    return "DirectionalLightNode";
  }
  /**
   * Constructs a new directional light node.
   *
   * @param {?DirectionalLight} [light=null] - The directional light source.
   */
  constructor(light = null) {
    super(light);
  }
  setupDirect() {
    const lightColor = this.colorNode;
    const lightDirection = lightTargetDirection(this.light);
    return { lightDirection, lightColor };
  }
};
var _matrix41 = new Matrix4();
var _matrix42 = new Matrix4();
var _ltcLib = null;
var RectAreaLightNode = class extends AnalyticLightNode {
  static get type() {
    return "RectAreaLightNode";
  }
  /**
   * Constructs a new rect area light node.
   *
   * @param {?RectAreaLight} [light=null] - The rect area light source.
   */
  constructor(light = null) {
    super(light);
    this.halfHeight = uniform(new Vector3()).setGroup(renderGroup);
    this.halfWidth = uniform(new Vector3()).setGroup(renderGroup);
    this.updateType = NodeUpdateType.RENDER;
  }
  /**
   * Overwritten to updated rect area light specific uniforms.
   *
   * @param {NodeFrame} frame - A reference to the current node frame.
   */
  update(frame) {
    super.update(frame);
    const { light } = this;
    const viewMatrix = frame.camera.matrixWorldInverse;
    _matrix42.identity();
    _matrix41.copy(light.matrixWorld);
    _matrix41.premultiply(viewMatrix);
    _matrix42.extractRotation(_matrix41);
    this.halfWidth.value.set(light.width * 0.5, 0, 0);
    this.halfHeight.value.set(0, light.height * 0.5, 0);
    this.halfWidth.value.applyMatrix4(_matrix42);
    this.halfHeight.value.applyMatrix4(_matrix42);
  }
  setupDirectRectArea(builder) {
    let ltc_1, ltc_2;
    if (builder.isAvailable("float32Filterable")) {
      ltc_1 = texture(_ltcLib.LTC_FLOAT_1);
      ltc_2 = texture(_ltcLib.LTC_FLOAT_2);
    } else {
      ltc_1 = texture(_ltcLib.LTC_HALF_1);
      ltc_2 = texture(_ltcLib.LTC_HALF_2);
    }
    const { colorNode, light } = this;
    const lightPosition3 = lightViewPosition(light);
    return {
      lightColor: colorNode,
      lightPosition: lightPosition3,
      halfWidth: this.halfWidth,
      halfHeight: this.halfHeight,
      ltc_1,
      ltc_2
    };
  }
  /**
   * Used to configure the internal BRDF approximation texture data.
   *
   * @param {RectAreaLightTexturesLib} ltc - The BRDF approximation texture data.
   */
  static setLTC(ltc) {
    _ltcLib = ltc;
  }
};
var SpotLightNode = class extends AnalyticLightNode {
  static get type() {
    return "SpotLightNode";
  }
  /**
   * Constructs a new spot light node.
   *
   * @param {?SpotLight} [light=null] - The spot light source.
   */
  constructor(light = null) {
    super(light);
    this.coneCosNode = uniform(0).setGroup(renderGroup);
    this.penumbraCosNode = uniform(0).setGroup(renderGroup);
    this.cutoffDistanceNode = uniform(0).setGroup(renderGroup);
    this.decayExponentNode = uniform(0).setGroup(renderGroup);
    this.colorNode = uniform(this.color).setGroup(renderGroup);
  }
  /**
   * Overwritten to updated spot light specific uniforms.
   *
   * @param {NodeFrame} frame - A reference to the current node frame.
   */
  update(frame) {
    super.update(frame);
    const { light } = this;
    this.coneCosNode.value = Math.cos(light.angle);
    this.penumbraCosNode.value = Math.cos(light.angle * (1 - light.penumbra));
    this.cutoffDistanceNode.value = light.distance;
    this.decayExponentNode.value = light.decay;
  }
  /**
   * Computes the spot attenuation for the given angle.
   *
   * @param {NodeBuilder} builder - The node builder.
   * @param {Node<float>} angleCosine - The angle to compute the spot attenuation for.
   * @return {Node<float>} The spot attenuation.
   */
  getSpotAttenuation(builder, angleCosine) {
    const { coneCosNode, penumbraCosNode } = this;
    return smoothstep(coneCosNode, penumbraCosNode, angleCosine);
  }
  getLightCoord(builder) {
    const properties = builder.getNodeProperties(this);
    let projectionUV = properties.projectionUV;
    if (projectionUV === void 0) {
      projectionUV = lightProjectionUV(this.light, builder.context.positionWorld);
      properties.projectionUV = projectionUV;
    }
    return projectionUV;
  }
  setupDirect(builder) {
    const { colorNode, cutoffDistanceNode, decayExponentNode, light } = this;
    const lightVector = this.getLightVector(builder);
    const lightDirection = lightVector.normalize();
    const angleCos = lightDirection.dot(lightTargetDirection(light));
    const spotAttenuation = this.getSpotAttenuation(builder, angleCos);
    const lightDistance = lightVector.length();
    const lightAttenuation = getDistanceAttenuation({
      lightDistance,
      cutoffDistance: cutoffDistanceNode,
      decayExponent: decayExponentNode
    });
    let lightColor = colorNode.mul(spotAttenuation).mul(lightAttenuation);
    let projected, lightCoord;
    if (light.colorNode) {
      lightCoord = this.getLightCoord(builder);
      projected = light.colorNode(lightCoord);
    } else if (light.map) {
      lightCoord = this.getLightCoord(builder);
      projected = texture(light.map, lightCoord.xy).onRenderUpdate(() => light.map);
    }
    if (projected) {
      const inSpotLightMap = lightCoord.mul(2).sub(1).abs().lessThan(1).all();
      lightColor = inSpotLightMap.select(lightColor.mul(projected), lightColor);
    }
    return { lightColor, lightDirection };
  }
};
var IESSpotLightNode = class extends SpotLightNode {
  static get type() {
    return "IESSpotLightNode";
  }
  /**
   * Overwrites the default implementation to compute an IES conform spot attenuation.
   *
   * @param {NodeBuilder} builder - The node builder.
   * @param {Node<float>} angleCosine - The angle to compute the spot attenuation for.
   * @return {Node<float>} The spot attenuation.
   */
  getSpotAttenuation(builder, angleCosine) {
    const iesMap = this.light.iesMap;
    let spotAttenuation = null;
    if (iesMap && iesMap.isTexture === true) {
      const angle2 = angleCosine.acos().mul(1 / Math.PI);
      spotAttenuation = texture(iesMap, vec2(angle2, 0), 0).r;
    } else {
      spotAttenuation = super.getSpotAttenuation(angleCosine);
    }
    return spotAttenuation;
  }
};
var sdBox = Fn(([p, b]) => {
  const d = p.abs().sub(b);
  return length(max$1(d, 0)).add(min$1(max$1(d.x, d.y), 0));
});
var ProjectorLightNode = class extends SpotLightNode {
  static get type() {
    return "ProjectorLightNode";
  }
  update(frame) {
    super.update(frame);
    const light = this.light;
    this.penumbraCosNode.value = Math.min(Math.cos(light.angle * (1 - light.penumbra)), 0.99999);
    if (light.aspect === null) {
      let aspect = 1;
      if (light.map !== null) {
        aspect = light.map.width / light.map.height;
      }
      light.shadow.aspect = aspect;
    } else {
      light.shadow.aspect = light.aspect;
    }
  }
  /**
   * Overwrites the default implementation to compute projection attenuation.
   *
   * @param {NodeBuilder} builder - The node builder.
   * @return {Node<float>} The spot attenuation.
   */
  getSpotAttenuation(builder) {
    const attenuation = float(0);
    const penumbraCos = this.penumbraCosNode;
    const spotLightCoord = lightShadowMatrix(this.light).mul(builder.context.positionWorld || positionWorld);
    If(spotLightCoord.w.greaterThan(0), () => {
      const projectionUV = spotLightCoord.xyz.div(spotLightCoord.w);
      const boxDist = sdBox(projectionUV.xy.sub(vec2(0.5)), vec2(0.5));
      const angleFactor = div(-1, sub(1, acos2(penumbraCos)).sub(1));
      attenuation.assign(saturate2(boxDist.mul(-2).mul(angleFactor)));
    });
    return attenuation;
  }
};
var AmbientLightNode = class extends AnalyticLightNode {
  static get type() {
    return "AmbientLightNode";
  }
  /**
   * Constructs a new ambient light node.
   *
   * @param {?AmbientLight} [light=null] - The ambient light source.
   */
  constructor(light = null) {
    super(light);
  }
  setup({ context: context3 }) {
    context3.irradiance.addAssign(this.colorNode);
  }
};
var HemisphereLightNode = class extends AnalyticLightNode {
  static get type() {
    return "HemisphereLightNode";
  }
  /**
   * Constructs a new hemisphere light node.
   *
   * @param {?HemisphereLight} [light=null] - The hemisphere light source.
   */
  constructor(light = null) {
    super(light);
    this.lightPositionNode = lightPosition(light);
    this.lightDirectionNode = this.lightPositionNode.normalize();
    this.groundColorNode = uniform(new Color()).setGroup(renderGroup);
  }
  /**
   * Overwritten to updated hemisphere light specific uniforms.
   *
   * @param {NodeFrame} frame - A reference to the current node frame.
   */
  update(frame) {
    const { light } = this;
    super.update(frame);
    this.lightPositionNode.object3d = light;
    this.groundColorNode.value.copy(light.groundColor).multiplyScalar(light.intensity);
  }
  setup(builder) {
    const { colorNode, groundColorNode, lightDirectionNode } = this;
    const dotNL = normalWorld.dot(lightDirectionNode);
    const hemiDiffuseWeight = dotNL.mul(0.5).add(0.5);
    const irradiance = mix(groundColorNode, colorNode, hemiDiffuseWeight);
    builder.context.irradiance.addAssign(irradiance);
  }
};
var LightProbeNode = class extends AnalyticLightNode {
  static get type() {
    return "LightProbeNode";
  }
  /**
   * Constructs a new light probe node.
   *
   * @param {?LightProbe} [light=null] - The light probe.
   */
  constructor(light = null) {
    super(light);
    const array4 = [];
    for (let i = 0; i < 9; i++) array4.push(new Vector3());
    this.lightProbe = uniformArray(array4);
  }
  /**
   * Overwritten to updated light probe specific uniforms.
   *
   * @param {NodeFrame} frame - A reference to the current node frame.
   */
  update(frame) {
    const { light } = this;
    super.update(frame);
    for (let i = 0; i < 9; i++) {
      this.lightProbe.array[i].copy(light.sh.coefficients[i]).multiplyScalar(light.intensity);
    }
  }
  setup(builder) {
    const irradiance = getShIrradianceAt(normalWorld, this.lightProbe);
    builder.context.irradiance.addAssign(irradiance);
  }
};
var NodeParser = class {
  /**
   * The method parses the given native code an returns a node function.
   *
   * @abstract
   * @param {string} source - The native shader code.
   * @return {NodeFunction} A node function.
   */
  parseFunction() {
    console.warn("Abstract function.");
  }
};
var NodeFunction = class {
  /**
   * Constructs a new node function.
   *
   * @param {string} type - The node type. This type is the return type of the node function.
   * @param {Array<NodeFunctionInput>} inputs - The function's inputs.
   * @param {string} [name=''] - The function's name.
   * @param {string} [precision=''] - The precision qualifier.
   */
  constructor(type, inputs, name = "", precision = "") {
    this.type = type;
    this.inputs = inputs;
    this.name = name;
    this.precision = precision;
  }
  /**
   * This method returns the native code of the node function.
   *
   * @abstract
   * @param {string} name - The function's name.
   * @return {string} A shader code.
   */
  getCode() {
    console.warn("Abstract function.");
  }
};
NodeFunction.isNodeFunction = true;
var declarationRegexp$1 = /^\s*(highp|mediump|lowp)?\s*([a-z_0-9]+)\s*([a-z_0-9]+)?\s*\(([\s\S]*?)\)/i;
var propertiesRegexp$1 = /[a-z_0-9]+/ig;
var pragmaMain = "#pragma main";
var parse$1 = (source) => {
  source = source.trim();
  const pragmaMainIndex = source.indexOf(pragmaMain);
  const mainCode = pragmaMainIndex !== -1 ? source.slice(pragmaMainIndex + pragmaMain.length) : source;
  const declaration = mainCode.match(declarationRegexp$1);
  if (declaration !== null && declaration.length === 5) {
    const inputsCode = declaration[4];
    const propsMatches = [];
    let nameMatch = null;
    while ((nameMatch = propertiesRegexp$1.exec(inputsCode)) !== null) {
      propsMatches.push(nameMatch);
    }
    const inputs = [];
    let i = 0;
    while (i < propsMatches.length) {
      const isConst = propsMatches[i][0] === "const";
      if (isConst === true) {
        i++;
      }
      let qualifier = propsMatches[i][0];
      if (qualifier === "in" || qualifier === "out" || qualifier === "inout") {
        i++;
      } else {
        qualifier = "";
      }
      const type2 = propsMatches[i++][0];
      let count2 = Number.parseInt(propsMatches[i][0]);
      if (Number.isNaN(count2) === false) i++;
      else count2 = null;
      const name2 = propsMatches[i++][0];
      inputs.push(new NodeFunctionInput(type2, name2, count2, qualifier, isConst));
    }
    const blockCode = mainCode.substring(declaration[0].length);
    const name = declaration[3] !== void 0 ? declaration[3] : "";
    const type = declaration[2];
    const precision = declaration[1] !== void 0 ? declaration[1] : "";
    const headerCode = pragmaMainIndex !== -1 ? source.slice(0, pragmaMainIndex) : "";
    return {
      type,
      inputs,
      name,
      precision,
      inputsCode,
      blockCode,
      headerCode
    };
  } else {
    throw new Error("FunctionNode: Function is not a GLSL code.");
  }
};
var GLSLNodeFunction = class extends NodeFunction {
  /**
   * Constructs a new GLSL node function.
   *
   * @param {string} source - The GLSL source.
   */
  constructor(source) {
    const { type, inputs, name, precision, inputsCode, blockCode, headerCode } = parse$1(source);
    super(type, inputs, name, precision);
    this.inputsCode = inputsCode;
    this.blockCode = blockCode;
    this.headerCode = headerCode;
  }
  /**
   * This method returns the GLSL code of the node function.
   *
   * @param {string} [name=this.name] - The function's name.
   * @return {string} The shader code.
   */
  getCode(name = this.name) {
    let code3;
    const blockCode = this.blockCode;
    if (blockCode !== "") {
      const { type, inputsCode, headerCode, precision } = this;
      let declarationCode = `${type} ${name} ( ${inputsCode.trim()} )`;
      if (precision !== "") {
        declarationCode = `${precision} ${declarationCode}`;
      }
      code3 = headerCode + declarationCode + blockCode;
    } else {
      code3 = "";
    }
    return code3;
  }
};
var GLSLNodeParser = class extends NodeParser {
  /**
   * The method parses the given GLSL code an returns a node function.
   *
   * @param {string} source - The GLSL code.
   * @return {GLSLNodeFunction} A node function.
   */
  parseFunction(source) {
    return new GLSLNodeFunction(source);
  }
};
var _outputNodeMap = /* @__PURE__ */ new WeakMap();
var _chainKeys$2 = [];
var _cacheKeyValues = [];
var Nodes = class extends DataMap {
  /**
   * Constructs a new nodes management component.
   *
   * @param {Renderer} renderer - The renderer.
   * @param {Backend} backend - The renderer's backend.
   */
  constructor(renderer, backend) {
    super();
    this.renderer = renderer;
    this.backend = backend;
    this.nodeFrame = new NodeFrame();
    this.nodeBuilderCache = /* @__PURE__ */ new Map();
    this.callHashCache = new ChainMap();
    this.groupsData = new ChainMap();
    this.cacheLib = {};
  }
  /**
   * Returns `true` if the given node uniforms group must be updated or not.
   *
   * @param {NodeUniformsGroup} nodeUniformsGroup - The node uniforms group.
   * @return {boolean} Whether the node uniforms group requires an update or not.
   */
  updateGroup(nodeUniformsGroup) {
    const groupNode = nodeUniformsGroup.groupNode;
    const name = groupNode.name;
    if (name === objectGroup.name) return true;
    if (name === renderGroup.name) {
      const uniformsGroupData = this.get(nodeUniformsGroup);
      const renderId = this.nodeFrame.renderId;
      if (uniformsGroupData.renderId !== renderId) {
        uniformsGroupData.renderId = renderId;
        return true;
      }
      return false;
    }
    if (name === frameGroup.name) {
      const uniformsGroupData = this.get(nodeUniformsGroup);
      const frameId3 = this.nodeFrame.frameId;
      if (uniformsGroupData.frameId !== frameId3) {
        uniformsGroupData.frameId = frameId3;
        return true;
      }
      return false;
    }
    _chainKeys$2[0] = groupNode;
    _chainKeys$2[1] = nodeUniformsGroup;
    let groupData = this.groupsData.get(_chainKeys$2);
    if (groupData === void 0) this.groupsData.set(_chainKeys$2, groupData = {});
    _chainKeys$2.length = 0;
    if (groupData.version !== groupNode.version) {
      groupData.version = groupNode.version;
      return true;
    }
    return false;
  }
  /**
   * Returns the cache key for the given render object.
   *
   * @param {RenderObject} renderObject - The render object.
   * @return {number} The cache key.
   */
  getForRenderCacheKey(renderObject) {
    return renderObject.initialCacheKey;
  }
  /**
   * Returns a node builder state for the given render object.
   *
   * @param {RenderObject} renderObject - The render object.
   * @return {NodeBuilderState} The node builder state.
   */
  getForRender(renderObject) {
    const renderObjectData = this.get(renderObject);
    let nodeBuilderState = renderObjectData.nodeBuilderState;
    if (nodeBuilderState === void 0) {
      const { nodeBuilderCache } = this;
      const cacheKey = this.getForRenderCacheKey(renderObject);
      nodeBuilderState = nodeBuilderCache.get(cacheKey);
      if (nodeBuilderState === void 0) {
        const nodeBuilder = this.backend.createNodeBuilder(renderObject.object, this.renderer);
        nodeBuilder.scene = renderObject.scene;
        nodeBuilder.material = renderObject.material;
        nodeBuilder.camera = renderObject.camera;
        nodeBuilder.context.material = renderObject.material;
        nodeBuilder.lightsNode = renderObject.lightsNode;
        nodeBuilder.environmentNode = this.getEnvironmentNode(renderObject.scene);
        nodeBuilder.fogNode = this.getFogNode(renderObject.scene);
        nodeBuilder.clippingContext = renderObject.clippingContext;
        if (this.renderer.getOutputRenderTarget() ? this.renderer.getOutputRenderTarget().multiview : false) {
          nodeBuilder.enableMultiview();
        }
        nodeBuilder.build();
        nodeBuilderState = this._createNodeBuilderState(nodeBuilder);
        nodeBuilderCache.set(cacheKey, nodeBuilderState);
      }
      nodeBuilderState.usedTimes++;
      renderObjectData.nodeBuilderState = nodeBuilderState;
    }
    return nodeBuilderState;
  }
  /**
   * Deletes the given object from the internal data map
   *
   * @param {any} object - The object to delete.
   * @return {?Object} The deleted dictionary.
   */
  delete(object2) {
    if (object2.isRenderObject) {
      const nodeBuilderState = this.get(object2).nodeBuilderState;
      nodeBuilderState.usedTimes--;
      if (nodeBuilderState.usedTimes === 0) {
        this.nodeBuilderCache.delete(this.getForRenderCacheKey(object2));
      }
    }
    return super.delete(object2);
  }
  /**
   * Returns a node builder state for the given compute node.
   *
   * @param {Node} computeNode - The compute node.
   * @return {NodeBuilderState} The node builder state.
   */
  getForCompute(computeNode) {
    const computeData = this.get(computeNode);
    let nodeBuilderState = computeData.nodeBuilderState;
    if (nodeBuilderState === void 0) {
      const nodeBuilder = this.backend.createNodeBuilder(computeNode, this.renderer);
      nodeBuilder.build();
      nodeBuilderState = this._createNodeBuilderState(nodeBuilder);
      computeData.nodeBuilderState = nodeBuilderState;
    }
    return nodeBuilderState;
  }
  /**
   * Creates a node builder state for the given node builder.
   *
   * @private
   * @param {NodeBuilder} nodeBuilder - The node builder.
   * @return {NodeBuilderState} The node builder state.
   */
  _createNodeBuilderState(nodeBuilder) {
    return new NodeBuilderState(
      nodeBuilder.vertexShader,
      nodeBuilder.fragmentShader,
      nodeBuilder.computeShader,
      nodeBuilder.getAttributesArray(),
      nodeBuilder.getBindings(),
      nodeBuilder.updateNodes,
      nodeBuilder.updateBeforeNodes,
      nodeBuilder.updateAfterNodes,
      nodeBuilder.observer,
      nodeBuilder.transforms
    );
  }
  /**
   * Returns an environment node for the current configured
   * scene environment.
   *
   * @param {Scene} scene - The scene.
   * @return {Node} A node representing the current scene environment.
   */
  getEnvironmentNode(scene) {
    this.updateEnvironment(scene);
    let environmentNode = null;
    if (scene.environmentNode && scene.environmentNode.isNode) {
      environmentNode = scene.environmentNode;
    } else {
      const sceneData = this.get(scene);
      if (sceneData.environmentNode) {
        environmentNode = sceneData.environmentNode;
      }
    }
    return environmentNode;
  }
  /**
   * Returns a background node for the current configured
   * scene background.
   *
   * @param {Scene} scene - The scene.
   * @return {Node} A node representing the current scene background.
   */
  getBackgroundNode(scene) {
    this.updateBackground(scene);
    let backgroundNode = null;
    if (scene.backgroundNode && scene.backgroundNode.isNode) {
      backgroundNode = scene.backgroundNode;
    } else {
      const sceneData = this.get(scene);
      if (sceneData.backgroundNode) {
        backgroundNode = sceneData.backgroundNode;
      }
    }
    return backgroundNode;
  }
  /**
   * Returns a fog node for the current configured scene fog.
   *
   * @param {Scene} scene - The scene.
   * @return {Node} A node representing the current scene fog.
   */
  getFogNode(scene) {
    this.updateFog(scene);
    return scene.fogNode || this.get(scene).fogNode || null;
  }
  /**
   * Returns a cache key for the given scene and lights node.
   * This key is used by `RenderObject` as a part of the dynamic
   * cache key (a key that must be checked every time the render
   * objects is drawn).
   *
   * @param {Scene} scene - The scene.
   * @param {LightsNode} lightsNode - The lights node.
   * @return {number} The cache key.
   */
  getCacheKey(scene, lightsNode) {
    _chainKeys$2[0] = scene;
    _chainKeys$2[1] = lightsNode;
    const callId = this.renderer.info.calls;
    const cacheKeyData = this.callHashCache.get(_chainKeys$2) || {};
    if (cacheKeyData.callId !== callId) {
      const environmentNode = this.getEnvironmentNode(scene);
      const fogNode = this.getFogNode(scene);
      if (lightsNode) _cacheKeyValues.push(lightsNode.getCacheKey(true));
      if (environmentNode) _cacheKeyValues.push(environmentNode.getCacheKey());
      if (fogNode) _cacheKeyValues.push(fogNode.getCacheKey());
      _cacheKeyValues.push(this.renderer.getOutputRenderTarget() && this.renderer.getOutputRenderTarget().multiview ? 1 : 0);
      _cacheKeyValues.push(this.renderer.shadowMap.enabled ? 1 : 0);
      cacheKeyData.callId = callId;
      cacheKeyData.cacheKey = hashArray(_cacheKeyValues);
      this.callHashCache.set(_chainKeys$2, cacheKeyData);
      _cacheKeyValues.length = 0;
    }
    _chainKeys$2.length = 0;
    return cacheKeyData.cacheKey;
  }
  /**
   * A boolean that indicates whether tone mapping should be enabled
   * or not.
   *
   * @type {boolean}
   */
  get isToneMappingState() {
    return this.renderer.getRenderTarget() ? false : true;
  }
  /**
   * If a scene background is configured, this method makes sure to
   * represent the background with a corresponding node-based implementation.
   *
   * @param {Scene} scene - The scene.
   */
  updateBackground(scene) {
    const sceneData = this.get(scene);
    const background = scene.background;
    if (background) {
      const forceUpdate = scene.backgroundBlurriness === 0 && sceneData.backgroundBlurriness > 0 || scene.backgroundBlurriness > 0 && sceneData.backgroundBlurriness === 0;
      if (sceneData.background !== background || forceUpdate) {
        const backgroundNode = this.getCacheNode("background", background, () => {
          if (background.isCubeTexture === true || (background.mapping === EquirectangularReflectionMapping || background.mapping === EquirectangularRefractionMapping || background.mapping === CubeUVReflectionMapping)) {
            if (scene.backgroundBlurriness > 0 || background.mapping === CubeUVReflectionMapping) {
              return pmremTexture(background);
            } else {
              let envMap;
              if (background.isCubeTexture === true) {
                envMap = cubeTexture(background);
              } else {
                envMap = texture(background);
              }
              return cubeMapNode(envMap);
            }
          } else if (background.isTexture === true) {
            return texture(background, screenUV.flipY()).setUpdateMatrix(true);
          } else if (background.isColor !== true) {
            console.error("WebGPUNodes: Unsupported background configuration.", background);
          }
        }, forceUpdate);
        sceneData.backgroundNode = backgroundNode;
        sceneData.background = background;
        sceneData.backgroundBlurriness = scene.backgroundBlurriness;
      }
    } else if (sceneData.backgroundNode) {
      delete sceneData.backgroundNode;
      delete sceneData.background;
    }
  }
  /**
   * This method is part of the caching of nodes which are used to represents the
   * scene's background, fog or environment.
   *
   * @param {string} type - The type of object to cache.
   * @param {Object} object - The object.
   * @param {Function} callback - A callback that produces a node representation for the given object.
   * @param {boolean} [forceUpdate=false] - Whether an update should be enforced or not.
   * @return {Node} The node representation.
   */
  getCacheNode(type, object2, callback, forceUpdate = false) {
    const nodeCache = this.cacheLib[type] || (this.cacheLib[type] = /* @__PURE__ */ new WeakMap());
    let node = nodeCache.get(object2);
    if (node === void 0 || forceUpdate) {
      node = callback();
      nodeCache.set(object2, node);
    }
    return node;
  }
  /**
   * If a scene fog is configured, this method makes sure to
   * represent the fog with a corresponding node-based implementation.
   *
   * @param {Scene} scene - The scene.
   */
  updateFog(scene) {
    const sceneData = this.get(scene);
    const sceneFog = scene.fog;
    if (sceneFog) {
      if (sceneData.fog !== sceneFog) {
        const fogNode = this.getCacheNode("fog", sceneFog, () => {
          if (sceneFog.isFogExp2) {
            const color4 = reference("color", "color", sceneFog).setGroup(renderGroup);
            const density = reference("density", "float", sceneFog).setGroup(renderGroup);
            return fog(color4, densityFogFactor(density));
          } else if (sceneFog.isFog) {
            const color4 = reference("color", "color", sceneFog).setGroup(renderGroup);
            const near = reference("near", "float", sceneFog).setGroup(renderGroup);
            const far = reference("far", "float", sceneFog).setGroup(renderGroup);
            return fog(color4, rangeFogFactor(near, far));
          } else {
            console.error("THREE.Renderer: Unsupported fog configuration.", sceneFog);
          }
        });
        sceneData.fogNode = fogNode;
        sceneData.fog = sceneFog;
      }
    } else {
      delete sceneData.fogNode;
      delete sceneData.fog;
    }
  }
  /**
   * If a scene environment is configured, this method makes sure to
   * represent the environment with a corresponding node-based implementation.
   *
   * @param {Scene} scene - The scene.
   */
  updateEnvironment(scene) {
    const sceneData = this.get(scene);
    const environment = scene.environment;
    if (environment) {
      if (sceneData.environment !== environment) {
        const environmentNode = this.getCacheNode("environment", environment, () => {
          if (environment.isCubeTexture === true) {
            return cubeTexture(environment);
          } else if (environment.isTexture === true) {
            return texture(environment);
          } else {
            console.error("Nodes: Unsupported environment configuration.", environment);
          }
        });
        sceneData.environmentNode = environmentNode;
        sceneData.environment = environment;
      }
    } else if (sceneData.environmentNode) {
      delete sceneData.environmentNode;
      delete sceneData.environment;
    }
  }
  getNodeFrame(renderer = this.renderer, scene = null, object2 = null, camera = null, material = null) {
    const nodeFrame = this.nodeFrame;
    nodeFrame.renderer = renderer;
    nodeFrame.scene = scene;
    nodeFrame.object = object2;
    nodeFrame.camera = camera;
    nodeFrame.material = material;
    return nodeFrame;
  }
  getNodeFrameForRender(renderObject) {
    return this.getNodeFrame(renderObject.renderer, renderObject.scene, renderObject.object, renderObject.camera, renderObject.material);
  }
  /**
   * Returns the current output cache key.
   *
   * @return {string} The output cache key.
   */
  getOutputCacheKey() {
    const renderer = this.renderer;
    return renderer.toneMapping + "," + renderer.currentColorSpace + "," + renderer.xr.isPresenting;
  }
  /**
   * Checks if the output configuration (tone mapping and color space) for
   * the given target has changed.
   *
   * @param {Texture} outputTarget - The output target.
   * @return {boolean} Whether the output configuration has changed or not.
   */
  hasOutputChange(outputTarget) {
    const cacheKey = _outputNodeMap.get(outputTarget);
    return cacheKey !== this.getOutputCacheKey();
  }
  /**
   * Returns a node that represents the output configuration (tone mapping and
   * color space) for the current target.
   *
   * @param {Texture} outputTarget - The output target.
   * @return {Node} The output node.
   */
  getOutputNode(outputTarget) {
    const renderer = this.renderer;
    const cacheKey = this.getOutputCacheKey();
    const output3 = outputTarget.isArrayTexture ? texture3D(outputTarget, vec3(screenUV, builtin("gl_ViewID_OVR"))).renderOutput(renderer.toneMapping, renderer.currentColorSpace) : texture(outputTarget, screenUV).renderOutput(renderer.toneMapping, renderer.currentColorSpace);
    _outputNodeMap.set(outputTarget, cacheKey);
    return output3;
  }
  /**
   * Triggers the call of `updateBefore()` methods
   * for all nodes of the given render object.
   *
   * @param {RenderObject} renderObject - The render object.
   */
  updateBefore(renderObject) {
    const nodeBuilder = renderObject.getNodeBuilderState();
    for (const node of nodeBuilder.updateBeforeNodes) {
      this.getNodeFrameForRender(renderObject).updateBeforeNode(node);
    }
  }
  /**
   * Triggers the call of `updateAfter()` methods
   * for all nodes of the given render object.
   *
   * @param {RenderObject} renderObject - The render object.
   */
  updateAfter(renderObject) {
    const nodeBuilder = renderObject.getNodeBuilderState();
    for (const node of nodeBuilder.updateAfterNodes) {
      this.getNodeFrameForRender(renderObject).updateAfterNode(node);
    }
  }
  /**
   * Triggers the call of `update()` methods
   * for all nodes of the given compute node.
   *
   * @param {Node} computeNode - The compute node.
   */
  updateForCompute(computeNode) {
    const nodeFrame = this.getNodeFrame();
    const nodeBuilder = this.getForCompute(computeNode);
    for (const node of nodeBuilder.updateNodes) {
      nodeFrame.updateNode(node);
    }
  }
  /**
   * Triggers the call of `update()` methods
   * for all nodes of the given compute node.
   *
   * @param {RenderObject} renderObject - The render object.
   */
  updateForRender(renderObject) {
    const nodeFrame = this.getNodeFrameForRender(renderObject);
    const nodeBuilder = renderObject.getNodeBuilderState();
    for (const node of nodeBuilder.updateNodes) {
      nodeFrame.updateNode(node);
    }
  }
  /**
   * Returns `true` if the given render object requires a refresh.
   *
   * @param {RenderObject} renderObject - The render object.
   * @return {boolean} Whether the given render object requires a refresh or not.
   */
  needsRefresh(renderObject) {
    const nodeFrame = this.getNodeFrameForRender(renderObject);
    const monitor = renderObject.getMonitor();
    return monitor.needsRefresh(renderObject, nodeFrame);
  }
  /**
   * Frees the internal resources.
   */
  dispose() {
    super.dispose();
    this.nodeFrame = new NodeFrame();
    this.nodeBuilderCache = /* @__PURE__ */ new Map();
    this.cacheLib = {};
  }
};
var _plane = new Plane();
var ClippingContext = class _ClippingContext {
  /**
   * Constructs a new clipping context.
   *
   * @param {?ClippingContext} [parentContext=null] - A reference to the parent clipping context.
   */
  constructor(parentContext = null) {
    this.version = 0;
    this.clipIntersection = null;
    this.cacheKey = "";
    this.shadowPass = false;
    this.viewNormalMatrix = new Matrix3();
    this.clippingGroupContexts = /* @__PURE__ */ new WeakMap();
    this.intersectionPlanes = [];
    this.unionPlanes = [];
    this.parentVersion = null;
    if (parentContext !== null) {
      this.viewNormalMatrix = parentContext.viewNormalMatrix;
      this.clippingGroupContexts = parentContext.clippingGroupContexts;
      this.shadowPass = parentContext.shadowPass;
      this.viewMatrix = parentContext.viewMatrix;
    }
  }
  /**
   * Projects the given source clipping planes and writes the result into the
   * destination array.
   *
   * @param {Array<Plane>} source - The source clipping planes.
   * @param {Array<Vector4>} destination - The destination.
   * @param {number} offset - The offset.
   */
  projectPlanes(source, destination, offset) {
    const l = source.length;
    for (let i = 0; i < l; i++) {
      _plane.copy(source[i]).applyMatrix4(this.viewMatrix, this.viewNormalMatrix);
      const v2 = destination[offset + i];
      const normal2 = _plane.normal;
      v2.x = -normal2.x;
      v2.y = -normal2.y;
      v2.z = -normal2.z;
      v2.w = _plane.constant;
    }
  }
  /**
   * Updates the root clipping context of a scene.
   *
   * @param {Scene} scene - The scene.
   * @param {Camera} camera - The camera that is used to render the scene.
   */
  updateGlobal(scene, camera) {
    this.shadowPass = scene.overrideMaterial !== null && scene.overrideMaterial.isShadowPassMaterial;
    this.viewMatrix = camera.matrixWorldInverse;
    this.viewNormalMatrix.getNormalMatrix(this.viewMatrix);
  }
  /**
   * Updates the clipping context.
   *
   * @param {ClippingContext} parentContext - The parent context.
   * @param {ClippingGroup} clippingGroup - The clipping group this context belongs to.
   */
  update(parentContext, clippingGroup) {
    let update18 = false;
    if (parentContext.version !== this.parentVersion) {
      this.intersectionPlanes = Array.from(parentContext.intersectionPlanes);
      this.unionPlanes = Array.from(parentContext.unionPlanes);
      this.parentVersion = parentContext.version;
    }
    if (this.clipIntersection !== clippingGroup.clipIntersection) {
      this.clipIntersection = clippingGroup.clipIntersection;
      if (this.clipIntersection) {
        this.unionPlanes.length = parentContext.unionPlanes.length;
      } else {
        this.intersectionPlanes.length = parentContext.intersectionPlanes.length;
      }
    }
    const srcClippingPlanes = clippingGroup.clippingPlanes;
    const l = srcClippingPlanes.length;
    let dstClippingPlanes;
    let offset;
    if (this.clipIntersection) {
      dstClippingPlanes = this.intersectionPlanes;
      offset = parentContext.intersectionPlanes.length;
    } else {
      dstClippingPlanes = this.unionPlanes;
      offset = parentContext.unionPlanes.length;
    }
    if (dstClippingPlanes.length !== offset + l) {
      dstClippingPlanes.length = offset + l;
      for (let i = 0; i < l; i++) {
        dstClippingPlanes[offset + i] = new Vector4();
      }
      update18 = true;
    }
    this.projectPlanes(srcClippingPlanes, dstClippingPlanes, offset);
    if (update18) {
      this.version++;
      this.cacheKey = `${this.intersectionPlanes.length}:${this.unionPlanes.length}`;
    }
  }
  /**
   * Returns a clipping context for the given clipping group.
   *
   * @param {ClippingGroup} clippingGroup - The clipping group.
   * @return {ClippingContext} The clipping context.
   */
  getGroupContext(clippingGroup) {
    if (this.shadowPass && !clippingGroup.clipShadows) return this;
    let context3 = this.clippingGroupContexts.get(clippingGroup);
    if (context3 === void 0) {
      context3 = new _ClippingContext(this);
      this.clippingGroupContexts.set(clippingGroup, context3);
    }
    context3.update(this, clippingGroup);
    return context3;
  }
  /**
   * The count of union clipping planes.
   *
   * @type {number}
   * @readonly
   */
  get unionClippingCount() {
    return this.unionPlanes.length;
  }
};
var RenderBundle = class {
  /**
   * Constructs a new bundle group.
   *
   * @param {BundleGroup} bundleGroup - The bundle group.
   * @param {Camera} camera - The camera the bundle group is rendered with.
   */
  constructor(bundleGroup, camera) {
    this.bundleGroup = bundleGroup;
    this.camera = camera;
  }
};
var _chainKeys$1 = [];
var RenderBundles = class {
  /**
   * Constructs a new render bundle management component.
   */
  constructor() {
    this.bundles = new ChainMap();
  }
  /**
   * Returns a render bundle for the given bundle group and camera.
   *
   * @param {BundleGroup} bundleGroup - The bundle group.
   * @param {Camera} camera - The camera the bundle group is rendered with.
   * @return {RenderBundle} The render bundle.
   */
  get(bundleGroup, camera) {
    const bundles = this.bundles;
    _chainKeys$1[0] = bundleGroup;
    _chainKeys$1[1] = camera;
    let bundle = bundles.get(_chainKeys$1);
    if (bundle === void 0) {
      bundle = new RenderBundle(bundleGroup, camera);
      bundles.set(_chainKeys$1, bundle);
    }
    _chainKeys$1.length = 0;
    return bundle;
  }
  /**
   * Frees all internal resources.
   */
  dispose() {
    this.bundles = new ChainMap();
  }
};
var NodeLibrary = class {
  /**
   * Constructs a new node library.
   */
  constructor() {
    this.lightNodes = /* @__PURE__ */ new WeakMap();
    this.materialNodes = /* @__PURE__ */ new Map();
    this.toneMappingNodes = /* @__PURE__ */ new Map();
  }
  /**
   * Returns a matching node material instance for the given material object.
   *
   * This method also assigns/copies the properties of the given material object
   * to the node material. This is done to make sure the current material
   * configuration carries over to the node version.
   *
   * @param {Material} material - A material.
   * @return {NodeMaterial} The corresponding node material.
   */
  fromMaterial(material) {
    if (material.isNodeMaterial) return material;
    let nodeMaterial = null;
    const nodeMaterialClass = this.getMaterialNodeClass(material.type);
    if (nodeMaterialClass !== null) {
      nodeMaterial = new nodeMaterialClass();
      for (const key in material) {
        nodeMaterial[key] = material[key];
      }
    }
    return nodeMaterial;
  }
  /**
   * Adds a tone mapping node function for a tone mapping technique (constant).
   *
   * @param {Function} toneMappingNode - The tone mapping node function.
   * @param {number} toneMapping - The tone mapping.
   */
  addToneMapping(toneMappingNode, toneMapping3) {
    this.addType(toneMappingNode, toneMapping3, this.toneMappingNodes);
  }
  /**
   * Returns a tone mapping node function for a tone mapping technique (constant).
   *
   * @param {number} toneMapping - The tone mapping.
   * @return {?Function} The tone mapping node function. Returns `null` if no node function is found.
   */
  getToneMappingFunction(toneMapping3) {
    return this.toneMappingNodes.get(toneMapping3) || null;
  }
  /**
   * Returns a node material class definition for a material type.
   *
   * @param {string} materialType - The material type.
   * @return {?NodeMaterial.constructor} The node material class definition. Returns `null` if no node material is found.
   */
  getMaterialNodeClass(materialType) {
    return this.materialNodes.get(materialType) || null;
  }
  /**
   * Adds a node material class definition for a given material type.
   *
   * @param {NodeMaterial.constructor} materialNodeClass - The node material class definition.
   * @param {string} materialClassType - The material type.
   */
  addMaterial(materialNodeClass, materialClassType) {
    this.addType(materialNodeClass, materialClassType, this.materialNodes);
  }
  /**
   * Returns a light node class definition for a light class definition.
   *
   * @param {Light.constructor} light - The light class definition.
   * @return {?AnalyticLightNode.constructor} The light node class definition. Returns `null` if no light node is found.
   */
  getLightNodeClass(light) {
    return this.lightNodes.get(light) || null;
  }
  /**
   * Adds a light node class definition for a given light class definition.
   *
   * @param {AnalyticLightNode.constructor} lightNodeClass - The light node class definition.
   * @param {Light.constructor} lightClass - The light class definition.
   */
  addLight(lightNodeClass, lightClass) {
    this.addClass(lightNodeClass, lightClass, this.lightNodes);
  }
  /**
   * Adds a node class definition for the given type to the provided type library.
   *
   * @param {Node.constructor} nodeClass - The node class definition.
   * @param {number|string} type - The object type.
   * @param {Map<number|string,Node.constructor>} library - The type library.
   */
  addType(nodeClass, type, library) {
    if (library.has(type)) {
      console.warn(`Redefinition of node ${type}`);
      return;
    }
    if (typeof nodeClass !== "function") throw new Error(`Node class ${nodeClass.name} is not a class.`);
    if (typeof type === "function" || typeof type === "object") throw new Error(`Base class ${type} is not a class.`);
    library.set(type, nodeClass);
  }
  /**
   * Adds a node class definition for the given class definition to the provided type library.
   *
   * @param {Node.constructor} nodeClass - The node class definition.
   * @param {Node.constructor} baseClass - The class definition.
   * @param {WeakMap<Node.constructor, Node.constructor>} library - The type library.
   */
  addClass(nodeClass, baseClass, library) {
    if (library.has(baseClass)) {
      console.warn(`Redefinition of node ${baseClass.name}`);
      return;
    }
    if (typeof nodeClass !== "function") throw new Error(`Node class ${nodeClass.name} is not a class.`);
    if (typeof baseClass !== "function") throw new Error(`Base class ${baseClass.name} is not a class.`);
    library.set(baseClass, nodeClass);
  }
};
var _defaultLights = new LightsNode();
var _chainKeys = [];
var Lighting = class extends ChainMap {
  /**
   * Constructs a lighting management component.
   */
  constructor() {
    super();
  }
  /**
   * Creates a new lights node for the given array of lights.
   *
   * @param {Array<Light>} lights - The render object.
   * @return {LightsNode} The lights node.
   */
  createNode(lights3 = []) {
    return new LightsNode().setLights(lights3);
  }
  /**
   * Returns a lights node for the given scene and camera.
   *
   * @param {Scene} scene - The scene.
   * @param {Camera} camera - The camera.
   * @return {LightsNode} The lights node.
   */
  getNode(scene, camera) {
    if (scene.isQuadMesh) return _defaultLights;
    _chainKeys[0] = scene;
    _chainKeys[1] = camera;
    let node = this.get(_chainKeys);
    if (node === void 0) {
      node = this.createNode();
      this.set(_chainKeys, node);
    }
    _chainKeys.length = 0;
    return node;
  }
};
var XRRenderTarget = class extends RenderTarget {
  /**
   * Constructs a new XR render target.
   *
   * @param {number} [width=1] - The width of the render target.
   * @param {number} [height=1] - The height of the render target.
   * @param {Object} [options={}] - The configuration options.
   */
  constructor(width = 1, height = 1, options = {}) {
    super(width, height, options);
    this.isXRRenderTarget = true;
    this._hasExternalTextures = false;
    this._autoAllocateDepthBuffer = true;
    this._isOpaqueFramebuffer = false;
  }
  copy(source) {
    super.copy(source);
    this._hasExternalTextures = source._hasExternalTextures;
    this._autoAllocateDepthBuffer = source._autoAllocateDepthBuffer;
    this._isOpaqueFramebuffer = source._isOpaqueFramebuffer;
    return this;
  }
};
var _cameraLPos = new Vector3();
var _cameraRPos = new Vector3();
var XRManager = class extends EventDispatcher {
  /**
   * Constructs a new XR manager.
   *
   * @param {Renderer} renderer - The renderer.
   * @param {boolean} [multiview=false] - Enables multiview if the device supports it.
   */
  constructor(renderer, multiview = false) {
    super();
    this.enabled = false;
    this.isPresenting = false;
    this.cameraAutoUpdate = true;
    this._renderer = renderer;
    this._cameraL = new PerspectiveCamera();
    this._cameraL.viewport = new Vector4();
    this._cameraR = new PerspectiveCamera();
    this._cameraR.viewport = new Vector4();
    this._cameras = [this._cameraL, this._cameraR];
    this._cameraXR = new ArrayCamera();
    this._currentDepthNear = null;
    this._currentDepthFar = null;
    this._controllers = [];
    this._controllerInputSources = [];
    this._xrRenderTarget = null;
    this._layers = [];
    this._sessionUsesLayers = false;
    this._supportsGlBinding = typeof XRWebGLBinding !== "undefined";
    this._frameBufferTargets = null;
    this._createXRLayer = createXRLayer.bind(this);
    this._gl = null;
    this._currentAnimationContext = null;
    this._currentAnimationLoop = null;
    this._currentPixelRatio = null;
    this._currentSize = new Vector2();
    this._onSessionEvent = onSessionEvent.bind(this);
    this._onSessionEnd = onSessionEnd.bind(this);
    this._onInputSourcesChange = onInputSourcesChange.bind(this);
    this._onAnimationFrame = onAnimationFrame.bind(this);
    this._referenceSpace = null;
    this._referenceSpaceType = "local-floor";
    this._customReferenceSpace = null;
    this._framebufferScaleFactor = 1;
    this._foveation = 1;
    this._session = null;
    this._glBaseLayer = null;
    this._glBinding = null;
    this._glProjLayer = null;
    this._xrFrame = null;
    this._supportsLayers = this._supportsGlBinding && "createProjectionLayer" in XRWebGLBinding.prototype;
    this._useMultiviewIfPossible = multiview;
    this._useMultiview = false;
  }
  /**
   * Returns an instance of `THREE.Group` that represents the transformation
   * of a XR controller in target ray space. The requested controller is defined
   * by the given index.
   *
   * @param {number} index - The index of the XR controller.
   * @return {Group} A group that represents the controller's transformation.
   */
  getController(index5) {
    const controller = this._getController(index5);
    return controller.getTargetRaySpace();
  }
  /**
   * Returns an instance of `THREE.Group` that represents the transformation
   * of a XR controller in grip space. The requested controller is defined
   * by the given index.
   *
   * @param {number} index - The index of the XR controller.
   * @return {Group} A group that represents the controller's transformation.
   */
  getControllerGrip(index5) {
    const controller = this._getController(index5);
    return controller.getGripSpace();
  }
  /**
   * Returns an instance of `THREE.Group` that represents the transformation
   * of a XR controller in hand space. The requested controller is defined
   * by the given index.
   *
   * @param {number} index - The index of the XR controller.
   * @return {Group} A group that represents the controller's transformation.
   */
  getHand(index5) {
    const controller = this._getController(index5);
    return controller.getHandSpace();
  }
  /**
   * Returns the foveation value.
   *
   * @return {number|undefined} The foveation value. Returns `undefined` if no base or projection layer is defined.
   */
  getFoveation() {
    if (this._glProjLayer === null && this._glBaseLayer === null) {
      return void 0;
    }
    return this._foveation;
  }
  /**
   * Sets the foveation value.
   *
   * @param {number} foveation - A number in the range `[0,1]` where `0` means no foveation (full resolution)
   * and `1` means maximum foveation (the edges render at lower resolution).
   */
  setFoveation(foveation) {
    this._foveation = foveation;
    if (this._glProjLayer !== null) {
      this._glProjLayer.fixedFoveation = foveation;
    }
    if (this._glBaseLayer !== null && this._glBaseLayer.fixedFoveation !== void 0) {
      this._glBaseLayer.fixedFoveation = foveation;
    }
  }
  /**
   * Returns the framebuffer scale factor.
   *
   * @return {number} The framebuffer scale factor.
   */
  getFramebufferScaleFactor() {
    return this._framebufferScaleFactor;
  }
  /**
   * Sets the framebuffer scale factor.
   *
   * This method can not be used during a XR session.
   *
   * @param {number} factor - The framebuffer scale factor.
   */
  setFramebufferScaleFactor(factor) {
    this._framebufferScaleFactor = factor;
    if (this.isPresenting === true) {
      console.warn("THREE.XRManager: Cannot change framebuffer scale while presenting.");
    }
  }
  /**
   * Returns the reference space type.
   *
   * @return {XRReferenceSpaceType} The reference space type.
   */
  getReferenceSpaceType() {
    return this._referenceSpaceType;
  }
  /**
   * Sets the reference space type.
   *
   * This method can not be used during a XR session.
   *
   * @param {XRReferenceSpaceType} type - The reference space type.
   */
  setReferenceSpaceType(type) {
    this._referenceSpaceType = type;
    if (this.isPresenting === true) {
      console.warn("THREE.XRManager: Cannot change reference space type while presenting.");
    }
  }
  /**
   * Returns the XR reference space.
   *
   * @return {XRReferenceSpace} The XR reference space.
   */
  getReferenceSpace() {
    return this._customReferenceSpace || this._referenceSpace;
  }
  /**
   * Sets a custom XR reference space.
   *
   * @param {XRReferenceSpace} space - The XR reference space.
   */
  setReferenceSpace(space) {
    this._customReferenceSpace = space;
  }
  /**
   * Returns the XR camera.
   *
   * @return {ArrayCamera} The XR camera.
   */
  getCamera() {
    return this._cameraXR;
  }
  /**
   * Returns the environment blend mode from the current XR session.
   *
   * @return {'opaque'|'additive'|'alpha-blend'|undefined} The environment blend mode. Returns `undefined` when used outside of a XR session.
   */
  getEnvironmentBlendMode() {
    if (this._session !== null) {
      return this._session.environmentBlendMode;
    }
  }
  /**
   * Returns the current XR binding.
   *
   * Creates a new binding if needed and the browser is
   * capable of doing so.
   *
   * @return {?XRWebGLBinding} The XR binding. Returns `null` if one cannot be created.
   */
  getBinding() {
    if (this._glBinding === null && this._supportsGlBinding) {
      this._glBinding = new XRWebGLBinding(this._session, this._gl);
    }
    return this._glBinding;
  }
  /**
   * Returns the current XR frame.
   *
   * @return {?XRFrame} The XR frame. Returns `null` when used outside a XR session.
   */
  getFrame() {
    return this._xrFrame;
  }
  /**
   * Returns `true` if the engine renders to a multiview target.
   *
   * @return {boolean} Whether the engine renders to a multiview render target or not.
   */
  useMultiview() {
    return this._useMultiview;
  }
  /**
   * This method can be used in XR applications to create a quadratic layer that presents a separate
   * rendered scene.
   *
   * @param {number} width - The width of the layer plane in world units.
   * @param {number} height - The height of the layer plane in world units.
   * @param {Vector3} translation - The position/translation of the layer plane in world units.
   * @param {Quaternion} quaternion - The orientation of the layer plane expressed as a quaternion.
   * @param {number} pixelwidth - The width of the layer's render target in pixels.
   * @param {number} pixelheight - The height of the layer's render target in pixels.
   * @param {Function} rendercall - A callback function that renders the layer. Similar to code in
   * the default animation loop, this method can be used to update/transform 3D object in the layer's scene.
   * @param {Object} [attributes={}] - Allows to configure the layer's render target.
   * @return {Mesh} A mesh representing the quadratic XR layer. This mesh should be added to the XR scene.
   */
  createQuadLayer(width, height, translation, quaternion, pixelwidth, pixelheight, rendercall, attributes = {}) {
    const geometry = new PlaneGeometry(width, height);
    const renderTarget = new XRRenderTarget(
      pixelwidth,
      pixelheight,
      {
        format: RGBAFormat,
        type: UnsignedByteType,
        depthTexture: new DepthTexture(
          pixelwidth,
          pixelheight,
          attributes.stencil ? UnsignedInt248Type : UnsignedIntType,
          void 0,
          void 0,
          void 0,
          void 0,
          void 0,
          void 0,
          attributes.stencil ? DepthStencilFormat : DepthFormat
        ),
        stencilBuffer: attributes.stencil,
        resolveDepthBuffer: false,
        resolveStencilBuffer: false
      }
    );
    renderTarget._autoAllocateDepthBuffer = true;
    const material = new MeshBasicMaterial({ color: 16777215, side: FrontSide });
    material.map = renderTarget.texture;
    material.map.offset.y = 1;
    material.map.repeat.y = -1;
    const plane = new Mesh(geometry, material);
    plane.position.copy(translation);
    plane.quaternion.copy(quaternion);
    const layer = {
      type: "quad",
      width,
      height,
      translation,
      quaternion,
      pixelwidth,
      pixelheight,
      plane,
      material,
      rendercall,
      renderTarget
    };
    this._layers.push(layer);
    if (this._session !== null) {
      layer.plane.material = new MeshBasicMaterial({ color: 16777215, side: FrontSide });
      layer.plane.material.blending = CustomBlending;
      layer.plane.material.blendEquation = AddEquation;
      layer.plane.material.blendSrc = ZeroFactor;
      layer.plane.material.blendDst = ZeroFactor;
      layer.xrlayer = this._createXRLayer(layer);
      const xrlayers = this._session.renderState.layers;
      xrlayers.unshift(layer.xrlayer);
      this._session.updateRenderState({ layers: xrlayers });
    } else {
      renderTarget.isXRRenderTarget = false;
    }
    return plane;
  }
  /**
   * This method can be used in XR applications to create a cylindrical layer that presents a separate
   * rendered scene.
   *
   * @param {number} radius - The radius of the cylinder in world units.
   * @param {number} centralAngle - The central angle of the cylinder in radians.
   * @param {number} aspectratio - The aspect ratio.
   * @param {Vector3} translation - The position/translation of the layer plane in world units.
   * @param {Quaternion} quaternion - The orientation of the layer plane expressed as a quaternion.
   * @param {number} pixelwidth - The width of the layer's render target in pixels.
   * @param {number} pixelheight - The height of the layer's render target in pixels.
   * @param {Function} rendercall - A callback function that renders the layer. Similar to code in
   * the default animation loop, this method can be used to update/transform 3D object in the layer's scene.
   * @param {Object} [attributes={}] - Allows to configure the layer's render target.
   * @return {Mesh} A mesh representing the cylindrical XR layer. This mesh should be added to the XR scene.
   */
  createCylinderLayer(radius, centralAngle, aspectratio, translation, quaternion, pixelwidth, pixelheight, rendercall, attributes = {}) {
    const geometry = new CylinderGeometry(radius, radius, radius * centralAngle / aspectratio, 64, 64, true, Math.PI - centralAngle / 2, centralAngle);
    const renderTarget = new XRRenderTarget(
      pixelwidth,
      pixelheight,
      {
        format: RGBAFormat,
        type: UnsignedByteType,
        depthTexture: new DepthTexture(
          pixelwidth,
          pixelheight,
          attributes.stencil ? UnsignedInt248Type : UnsignedIntType,
          void 0,
          void 0,
          void 0,
          void 0,
          void 0,
          void 0,
          attributes.stencil ? DepthStencilFormat : DepthFormat
        ),
        stencilBuffer: attributes.stencil,
        resolveDepthBuffer: false,
        resolveStencilBuffer: false
      }
    );
    renderTarget._autoAllocateDepthBuffer = true;
    const material = new MeshBasicMaterial({ color: 16777215, side: BackSide });
    material.map = renderTarget.texture;
    material.map.offset.y = 1;
    material.map.repeat.y = -1;
    const plane = new Mesh(geometry, material);
    plane.position.copy(translation);
    plane.quaternion.copy(quaternion);
    const layer = {
      type: "cylinder",
      radius,
      centralAngle,
      aspectratio,
      translation,
      quaternion,
      pixelwidth,
      pixelheight,
      plane,
      material,
      rendercall,
      renderTarget
    };
    this._layers.push(layer);
    if (this._session !== null) {
      layer.plane.material = new MeshBasicMaterial({ color: 16777215, side: BackSide });
      layer.plane.material.blending = CustomBlending;
      layer.plane.material.blendEquation = AddEquation;
      layer.plane.material.blendSrc = ZeroFactor;
      layer.plane.material.blendDst = ZeroFactor;
      layer.xrlayer = this._createXRLayer(layer);
      const xrlayers = this._session.renderState.layers;
      xrlayers.unshift(layer.xrlayer);
      this._session.updateRenderState({ layers: xrlayers });
    } else {
      renderTarget.isXRRenderTarget = false;
    }
    return plane;
  }
  /**
   * Renders the XR layers that have been previously added to the scene.
   *
   * This method is usually called in your animation loop before rendering
   * the actual scene via `renderer.render( scene, camera );`.
   */
  renderLayers() {
    const translationObject = new Vector3();
    const quaternionObject = new Quaternion();
    const renderer = this._renderer;
    const wasPresenting = this.isPresenting;
    const rendererOutputTarget = renderer.getOutputRenderTarget();
    const rendererFramebufferTarget = renderer._frameBufferTarget;
    this.isPresenting = false;
    const rendererSize = new Vector2();
    renderer.getSize(rendererSize);
    const rendererQuad = renderer._quad;
    for (const layer of this._layers) {
      layer.renderTarget.isXRRenderTarget = this._session !== null;
      layer.renderTarget._hasExternalTextures = layer.renderTarget.isXRRenderTarget;
      if (layer.renderTarget.isXRRenderTarget && this._sessionUsesLayers) {
        layer.xrlayer.transform = new XRRigidTransform(layer.plane.getWorldPosition(translationObject), layer.plane.getWorldQuaternion(quaternionObject));
        const glSubImage = this._glBinding.getSubImage(layer.xrlayer, this._xrFrame);
        renderer.backend.setXRRenderTargetTextures(
          layer.renderTarget,
          glSubImage.colorTexture,
          void 0
        );
        renderer._setXRLayerSize(layer.renderTarget.width, layer.renderTarget.height);
        renderer.setOutputRenderTarget(layer.renderTarget);
        renderer.setRenderTarget(null);
        renderer._frameBufferTarget = null;
        this._frameBufferTargets || (this._frameBufferTargets = /* @__PURE__ */ new WeakMap());
        const { frameBufferTarget, quad } = this._frameBufferTargets.get(layer.renderTarget) || { frameBufferTarget: null, quad: null };
        if (!frameBufferTarget) {
          renderer._quad = new QuadMesh(new NodeMaterial());
          this._frameBufferTargets.set(layer.renderTarget, { frameBufferTarget: renderer._getFrameBufferTarget(), quad: renderer._quad });
        } else {
          renderer._frameBufferTarget = frameBufferTarget;
          renderer._quad = quad;
        }
        layer.rendercall();
        renderer._frameBufferTarget = null;
      } else {
        renderer.setRenderTarget(layer.renderTarget);
        layer.rendercall();
      }
    }
    renderer.setRenderTarget(null);
    renderer.setOutputRenderTarget(rendererOutputTarget);
    renderer._frameBufferTarget = rendererFramebufferTarget;
    renderer._setXRLayerSize(rendererSize.x, rendererSize.y);
    renderer._quad = rendererQuad;
    this.isPresenting = wasPresenting;
  }
  /**
   * Returns the current XR session.
   *
   * @return {?XRSession} The XR session. Returns `null` when used outside a XR session.
   */
  getSession() {
    return this._session;
  }
  /**
   * After a XR session has been requested usually with one of the `*Button` modules, it
   * is injected into the renderer with this method. This method triggers the start of
   * the actual XR rendering.
   *
   * @async
   * @param {XRSession} session - The XR session to set.
   * @return {Promise} A Promise that resolves when the session has been set.
   */
  async setSession(session) {
    const renderer = this._renderer;
    const backend = renderer.backend;
    this._gl = renderer.getContext();
    const gl = this._gl;
    const attributes = gl.getContextAttributes();
    this._session = session;
    if (session !== null) {
      if (backend.isWebGPUBackend === true) throw new Error('THREE.XRManager: XR is currently not supported with a WebGPU backend. Use WebGL by passing "{ forceWebGL: true }" to the constructor of the renderer.');
      session.addEventListener("select", this._onSessionEvent);
      session.addEventListener("selectstart", this._onSessionEvent);
      session.addEventListener("selectend", this._onSessionEvent);
      session.addEventListener("squeeze", this._onSessionEvent);
      session.addEventListener("squeezestart", this._onSessionEvent);
      session.addEventListener("squeezeend", this._onSessionEvent);
      session.addEventListener("end", this._onSessionEnd);
      session.addEventListener("inputsourceschange", this._onInputSourcesChange);
      await backend.makeXRCompatible();
      this._currentPixelRatio = renderer.getPixelRatio();
      renderer.getSize(this._currentSize);
      this._currentAnimationContext = renderer._animation.getContext();
      this._currentAnimationLoop = renderer._animation.getAnimationLoop();
      renderer._animation.stop();
      if (this._supportsLayers === true) {
        let depthFormat = null;
        let depthType = null;
        let glDepthFormat = null;
        if (renderer.depth) {
          glDepthFormat = renderer.stencil ? gl.DEPTH24_STENCIL8 : gl.DEPTH_COMPONENT24;
          depthFormat = renderer.stencil ? DepthStencilFormat : DepthFormat;
          depthType = renderer.stencil ? UnsignedInt248Type : UnsignedIntType;
        }
        const projectionlayerInit = {
          colorFormat: gl.RGBA8,
          depthFormat: glDepthFormat,
          scaleFactor: this._framebufferScaleFactor,
          clearOnAccess: false
        };
        if (this._useMultiviewIfPossible && renderer.hasFeature("OVR_multiview2")) {
          projectionlayerInit.textureType = "texture-array";
          this._useMultiview = true;
        }
        this._glBinding = this.getBinding();
        const glProjLayer = this._glBinding.createProjectionLayer(projectionlayerInit);
        const layersArray = [glProjLayer];
        this._glProjLayer = glProjLayer;
        renderer.setPixelRatio(1);
        renderer._setXRLayerSize(glProjLayer.textureWidth, glProjLayer.textureHeight);
        const depth3 = this._useMultiview ? 2 : 1;
        const depthTexture = new DepthTexture(glProjLayer.textureWidth, glProjLayer.textureHeight, depthType, void 0, void 0, void 0, void 0, void 0, void 0, depthFormat, depth3);
        this._xrRenderTarget = new XRRenderTarget(
          glProjLayer.textureWidth,
          glProjLayer.textureHeight,
          {
            format: RGBAFormat,
            type: UnsignedByteType,
            colorSpace: renderer.outputColorSpace,
            depthTexture,
            stencilBuffer: renderer.stencil,
            samples: attributes.antialias ? 4 : 0,
            resolveDepthBuffer: glProjLayer.ignoreDepthValues === false,
            resolveStencilBuffer: glProjLayer.ignoreDepthValues === false,
            depth: this._useMultiview ? 2 : 1,
            multiview: this._useMultiview
          }
        );
        this._xrRenderTarget._hasExternalTextures = true;
        this._xrRenderTarget.depth = this._useMultiview ? 2 : 1;
        this._sessionUsesLayers = session.enabledFeatures.includes("layers");
        this._referenceSpace = await session.requestReferenceSpace(this.getReferenceSpaceType());
        if (this._sessionUsesLayers) {
          for (const layer of this._layers) {
            layer.plane.material = new MeshBasicMaterial({ color: 16777215, side: layer.type === "cylinder" ? BackSide : FrontSide });
            layer.plane.material.blending = CustomBlending;
            layer.plane.material.blendEquation = AddEquation;
            layer.plane.material.blendSrc = ZeroFactor;
            layer.plane.material.blendDst = ZeroFactor;
            layer.xrlayer = this._createXRLayer(layer);
            layersArray.unshift(layer.xrlayer);
          }
        }
        session.updateRenderState({ layers: layersArray });
      } else {
        const layerInit = {
          antialias: renderer.samples > 0,
          alpha: true,
          depth: renderer.depth,
          stencil: renderer.stencil,
          framebufferScaleFactor: this.getFramebufferScaleFactor()
        };
        const glBaseLayer = new XRWebGLLayer(session, gl, layerInit);
        this._glBaseLayer = glBaseLayer;
        session.updateRenderState({ baseLayer: glBaseLayer });
        renderer.setPixelRatio(1);
        renderer._setXRLayerSize(glBaseLayer.framebufferWidth, glBaseLayer.framebufferHeight);
        this._xrRenderTarget = new XRRenderTarget(
          glBaseLayer.framebufferWidth,
          glBaseLayer.framebufferHeight,
          {
            format: RGBAFormat,
            type: UnsignedByteType,
            colorSpace: renderer.outputColorSpace,
            stencilBuffer: renderer.stencil,
            resolveDepthBuffer: glBaseLayer.ignoreDepthValues === false,
            resolveStencilBuffer: glBaseLayer.ignoreDepthValues === false
          }
        );
        this._xrRenderTarget._isOpaqueFramebuffer = true;
        this._referenceSpace = await session.requestReferenceSpace(this.getReferenceSpaceType());
      }
      this.setFoveation(this.getFoveation());
      renderer._animation.setAnimationLoop(this._onAnimationFrame);
      renderer._animation.setContext(session);
      renderer._animation.start();
      this.isPresenting = true;
      this.dispatchEvent({ type: "sessionstart" });
    }
  }
  /**
   * This method is called by the renderer per frame and updates the XR camera
   * and it sub cameras based on the given camera. The given camera is the "user"
   * camera created on application level and used for non-XR rendering.
   *
   * @param {PerspectiveCamera} camera - The camera.
   */
  updateCamera(camera) {
    const session = this._session;
    if (session === null) return;
    const depthNear = camera.near;
    const depthFar = camera.far;
    const cameraXR = this._cameraXR;
    const cameraL = this._cameraL;
    const cameraR = this._cameraR;
    cameraXR.near = cameraR.near = cameraL.near = depthNear;
    cameraXR.far = cameraR.far = cameraL.far = depthFar;
    cameraXR.isMultiViewCamera = this._useMultiview;
    if (this._currentDepthNear !== cameraXR.near || this._currentDepthFar !== cameraXR.far) {
      session.updateRenderState({
        depthNear: cameraXR.near,
        depthFar: cameraXR.far
      });
      this._currentDepthNear = cameraXR.near;
      this._currentDepthFar = cameraXR.far;
    }
    cameraXR.layers.mask = camera.layers.mask | 6;
    cameraL.layers.mask = cameraXR.layers.mask & 3;
    cameraR.layers.mask = cameraXR.layers.mask & 5;
    const parent = camera.parent;
    const cameras = cameraXR.cameras;
    updateCamera(cameraXR, parent);
    for (let i = 0; i < cameras.length; i++) {
      updateCamera(cameras[i], parent);
    }
    if (cameras.length === 2) {
      setProjectionFromUnion(cameraXR, cameraL, cameraR);
    } else {
      cameraXR.projectionMatrix.copy(cameraL.projectionMatrix);
    }
    updateUserCamera(camera, cameraXR, parent);
  }
  /**
   * Returns a WebXR controller for the given controller index.
   *
   * @private
   * @param {number} index - The controller index.
   * @return {WebXRController} The XR controller.
   */
  _getController(index5) {
    let controller = this._controllers[index5];
    if (controller === void 0) {
      controller = new WebXRController();
      this._controllers[index5] = controller;
    }
    return controller;
  }
};
function setProjectionFromUnion(camera, cameraL, cameraR) {
  _cameraLPos.setFromMatrixPosition(cameraL.matrixWorld);
  _cameraRPos.setFromMatrixPosition(cameraR.matrixWorld);
  const ipd = _cameraLPos.distanceTo(_cameraRPos);
  const projL = cameraL.projectionMatrix.elements;
  const projR = cameraR.projectionMatrix.elements;
  const near = projL[14] / (projL[10] - 1);
  const far = projL[14] / (projL[10] + 1);
  const topFov = (projL[9] + 1) / projL[5];
  const bottomFov = (projL[9] - 1) / projL[5];
  const leftFov = (projL[8] - 1) / projL[0];
  const rightFov = (projR[8] + 1) / projR[0];
  const left = near * leftFov;
  const right = near * rightFov;
  const zOffset = ipd / (-leftFov + rightFov);
  const xOffset = zOffset * -leftFov;
  cameraL.matrixWorld.decompose(camera.position, camera.quaternion, camera.scale);
  camera.translateX(xOffset);
  camera.translateZ(zOffset);
  camera.matrixWorld.compose(camera.position, camera.quaternion, camera.scale);
  camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
  if (projL[10] === -1) {
    camera.projectionMatrix.copy(cameraL.projectionMatrix);
    camera.projectionMatrixInverse.copy(cameraL.projectionMatrixInverse);
  } else {
    const near2 = near + zOffset;
    const far2 = far + zOffset;
    const left2 = left - xOffset;
    const right2 = right + (ipd - xOffset);
    const top2 = topFov * far / far2 * near2;
    const bottom2 = bottomFov * far / far2 * near2;
    camera.projectionMatrix.makePerspective(left2, right2, top2, bottom2, near2, far2);
    camera.projectionMatrixInverse.copy(camera.projectionMatrix).invert();
  }
}
function updateCamera(camera, parent) {
  if (parent === null) {
    camera.matrixWorld.copy(camera.matrix);
  } else {
    camera.matrixWorld.multiplyMatrices(parent.matrixWorld, camera.matrix);
  }
  camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
}
function updateUserCamera(camera, cameraXR, parent) {
  if (parent === null) {
    camera.matrix.copy(cameraXR.matrixWorld);
  } else {
    camera.matrix.copy(parent.matrixWorld);
    camera.matrix.invert();
    camera.matrix.multiply(cameraXR.matrixWorld);
  }
  camera.matrix.decompose(camera.position, camera.quaternion, camera.scale);
  camera.updateMatrixWorld(true);
  camera.projectionMatrix.copy(cameraXR.projectionMatrix);
  camera.projectionMatrixInverse.copy(cameraXR.projectionMatrixInverse);
  if (camera.isPerspectiveCamera) {
    camera.fov = RAD2DEG * 2 * Math.atan(1 / camera.projectionMatrix.elements[5]);
    camera.zoom = 1;
  }
}
function onSessionEvent(event) {
  const controllerIndex = this._controllerInputSources.indexOf(event.inputSource);
  if (controllerIndex === -1) {
    return;
  }
  const controller = this._controllers[controllerIndex];
  if (controller !== void 0) {
    const referenceSpace = this.getReferenceSpace();
    controller.update(event.inputSource, event.frame, referenceSpace);
    controller.dispatchEvent({ type: event.type, data: event.inputSource });
  }
}
function onSessionEnd() {
  const session = this._session;
  const renderer = this._renderer;
  session.removeEventListener("select", this._onSessionEvent);
  session.removeEventListener("selectstart", this._onSessionEvent);
  session.removeEventListener("selectend", this._onSessionEvent);
  session.removeEventListener("squeeze", this._onSessionEvent);
  session.removeEventListener("squeezestart", this._onSessionEvent);
  session.removeEventListener("squeezeend", this._onSessionEvent);
  session.removeEventListener("end", this._onSessionEnd);
  session.removeEventListener("inputsourceschange", this._onInputSourcesChange);
  for (let i = 0; i < this._controllers.length; i++) {
    const inputSource = this._controllerInputSources[i];
    if (inputSource === null) continue;
    this._controllerInputSources[i] = null;
    this._controllers[i].disconnect(inputSource);
  }
  this._currentDepthNear = null;
  this._currentDepthFar = null;
  renderer._resetXRState();
  this._session = null;
  this._xrRenderTarget = null;
  if (this._sessionUsesLayers === true) {
    for (const layer of this._layers) {
      layer.renderTarget = new XRRenderTarget(
        layer.pixelwidth,
        layer.pixelheight,
        {
          format: RGBAFormat,
          type: UnsignedByteType,
          depthTexture: new DepthTexture(
            layer.pixelwidth,
            layer.pixelheight,
            layer.stencilBuffer ? UnsignedInt248Type : UnsignedIntType,
            void 0,
            void 0,
            void 0,
            void 0,
            void 0,
            void 0,
            layer.stencilBuffer ? DepthStencilFormat : DepthFormat
          ),
          stencilBuffer: layer.stencilBuffer,
          resolveDepthBuffer: false,
          resolveStencilBuffer: false
        }
      );
      layer.renderTarget.isXRRenderTarget = false;
      layer.plane.material = layer.material;
      layer.material.map = layer.renderTarget.texture;
      layer.material.map.offset.y = 1;
      layer.material.map.repeat.y = -1;
      delete layer.xrlayer;
    }
  }
  this.isPresenting = false;
  this._useMultiview = false;
  renderer._animation.stop();
  renderer._animation.setAnimationLoop(this._currentAnimationLoop);
  renderer._animation.setContext(this._currentAnimationContext);
  renderer._animation.start();
  renderer.setPixelRatio(this._currentPixelRatio);
  renderer.setSize(this._currentSize.width, this._currentSize.height, false);
  this.dispatchEvent({ type: "sessionend" });
}
function onInputSourcesChange(event) {
  const controllers = this._controllers;
  const controllerInputSources = this._controllerInputSources;
  for (let i = 0; i < event.removed.length; i++) {
    const inputSource = event.removed[i];
    const index5 = controllerInputSources.indexOf(inputSource);
    if (index5 >= 0) {
      controllerInputSources[index5] = null;
      controllers[index5].disconnect(inputSource);
    }
  }
  for (let i = 0; i < event.added.length; i++) {
    const inputSource = event.added[i];
    let controllerIndex = controllerInputSources.indexOf(inputSource);
    if (controllerIndex === -1) {
      for (let i2 = 0; i2 < controllers.length; i2++) {
        if (i2 >= controllerInputSources.length) {
          controllerInputSources.push(inputSource);
          controllerIndex = i2;
          break;
        } else if (controllerInputSources[i2] === null) {
          controllerInputSources[i2] = inputSource;
          controllerIndex = i2;
          break;
        }
      }
      if (controllerIndex === -1) break;
    }
    const controller = controllers[controllerIndex];
    if (controller) {
      controller.connect(inputSource);
    }
  }
}
function createXRLayer(layer) {
  if (layer.type === "quad") {
    return this._glBinding.createQuadLayer({
      transform: new XRRigidTransform(layer.translation, layer.quaternion),
      width: layer.width / 2,
      height: layer.height / 2,
      space: this._referenceSpace,
      viewPixelWidth: layer.pixelwidth,
      viewPixelHeight: layer.pixelheight,
      clearOnAccess: false
    });
  } else {
    return this._glBinding.createCylinderLayer({
      transform: new XRRigidTransform(layer.translation, layer.quaternion),
      radius: layer.radius,
      centralAngle: layer.centralAngle,
      aspectRatio: layer.aspectRatio,
      space: this._referenceSpace,
      viewPixelWidth: layer.pixelwidth,
      viewPixelHeight: layer.pixelheight,
      clearOnAccess: false
    });
  }
}
function onAnimationFrame(time4, frame) {
  if (frame === void 0) return;
  const cameraXR = this._cameraXR;
  const renderer = this._renderer;
  const backend = renderer.backend;
  const glBaseLayer = this._glBaseLayer;
  const referenceSpace = this.getReferenceSpace();
  const pose = frame.getViewerPose(referenceSpace);
  this._xrFrame = frame;
  if (pose !== null) {
    const views = pose.views;
    if (this._glBaseLayer !== null) {
      backend.setXRTarget(glBaseLayer.framebuffer);
    }
    let cameraXRNeedsUpdate = false;
    if (views.length !== cameraXR.cameras.length) {
      cameraXR.cameras.length = 0;
      cameraXRNeedsUpdate = true;
    }
    for (let i = 0; i < views.length; i++) {
      const view = views[i];
      let viewport3;
      if (this._supportsLayers === true) {
        const glSubImage = this._glBinding.getViewSubImage(this._glProjLayer, view);
        viewport3 = glSubImage.viewport;
        if (i === 0) {
          backend.setXRRenderTargetTextures(
            this._xrRenderTarget,
            glSubImage.colorTexture,
            this._glProjLayer.ignoreDepthValues && !this._useMultiview ? void 0 : glSubImage.depthStencilTexture
          );
        }
      } else {
        viewport3 = glBaseLayer.getViewport(view);
      }
      let camera = this._cameras[i];
      if (camera === void 0) {
        camera = new PerspectiveCamera();
        camera.layers.enable(i);
        camera.viewport = new Vector4();
        this._cameras[i] = camera;
      }
      camera.matrix.fromArray(view.transform.matrix);
      camera.matrix.decompose(camera.position, camera.quaternion, camera.scale);
      camera.projectionMatrix.fromArray(view.projectionMatrix);
      camera.projectionMatrixInverse.copy(camera.projectionMatrix).invert();
      camera.viewport.set(viewport3.x, viewport3.y, viewport3.width, viewport3.height);
      if (i === 0) {
        cameraXR.matrix.copy(camera.matrix);
        cameraXR.matrix.decompose(cameraXR.position, cameraXR.quaternion, cameraXR.scale);
      }
      if (cameraXRNeedsUpdate === true) {
        cameraXR.cameras.push(camera);
      }
    }
    renderer.setOutputRenderTarget(this._xrRenderTarget);
  }
  for (let i = 0; i < this._controllers.length; i++) {
    const inputSource = this._controllerInputSources[i];
    const controller = this._controllers[i];
    if (inputSource !== null && controller !== void 0) {
      controller.update(inputSource, frame, referenceSpace);
    }
  }
  if (this._currentAnimationLoop) this._currentAnimationLoop(time4, frame);
  if (frame.detectedPlanes) {
    this.dispatchEvent({ type: "planesdetected", data: frame });
  }
  this._xrFrame = null;
}
var _scene = new Scene();
var _drawingBufferSize = new Vector2();
var _screen = new Vector4();
var _frustum = new Frustum();
var _frustumArray = new FrustumArray();
var _projScreenMatrix = new Matrix4();
var _vector4 = new Vector4();
var Renderer = class {
  /**
   * Renderer options.
   *
   * @typedef {Object} Renderer~Options
   * @property {boolean} [logarithmicDepthBuffer=false] - Whether logarithmic depth buffer is enabled or not.
   * @property {boolean} [alpha=true] - Whether the default framebuffer (which represents the final contents of the canvas) should be transparent or opaque.
   * @property {boolean} [depth=true] - Whether the default framebuffer should have a depth buffer or not.
   * @property {boolean} [stencil=false] - Whether the default framebuffer should have a stencil buffer or not.
   * @property {boolean} [antialias=false] - Whether MSAA as the default anti-aliasing should be enabled or not.
   * @property {number} [samples=0] - When `antialias` is `true`, `4` samples are used by default. This parameter can set to any other integer value than 0
   * to overwrite the default.
   * @property {?Function} [getFallback=null] - This callback function can be used to provide a fallback backend, if the primary backend can't be targeted.
   * @property {number} [colorBufferType=HalfFloatType] - Defines the type of color buffers. The default `HalfFloatType` is recommend for best
   * quality. To save memory and bandwidth, `UnsignedByteType` might be used. This will reduce rendering quality though.
   * @property {boolean} [multiview=false] - If set to `true`, the renderer will use multiview during WebXR rendering if supported.
   */
  /**
  	 * Constructs a new renderer.
  	 *
  	 * @param {Backend} backend - The backend the renderer is targeting (e.g. WebGPU or WebGL 2).
  	 * @param {Renderer~Options} [parameters] - The configuration parameter.
  
  	 */
  constructor(backend, parameters = {}) {
    this.isRenderer = true;
    const {
      logarithmicDepthBuffer = false,
      alpha = true,
      depth: depth3 = true,
      stencil = false,
      antialias = false,
      samples = 0,
      getFallback = null,
      colorBufferType = HalfFloatType,
      multiview = false
    } = parameters;
    this.domElement = backend.getDomElement();
    this.backend = backend;
    this.samples = samples || antialias === true ? 4 : 0;
    this.autoClear = true;
    this.autoClearColor = true;
    this.autoClearDepth = true;
    this.autoClearStencil = true;
    this.alpha = alpha;
    this.logarithmicDepthBuffer = logarithmicDepthBuffer;
    this.outputColorSpace = SRGBColorSpace;
    this.toneMapping = NoToneMapping;
    this.toneMappingExposure = 1;
    this.sortObjects = true;
    this.depth = depth3;
    this.stencil = stencil;
    this.info = new Info();
    this.overrideNodes = {
      modelViewMatrix: null,
      modelNormalViewMatrix: null
    };
    this.library = new NodeLibrary();
    this.lighting = new Lighting();
    this._getFallback = getFallback;
    this._pixelRatio = 1;
    this._width = this.domElement.width;
    this._height = this.domElement.height;
    this._viewport = new Vector4(0, 0, this._width, this._height);
    this._scissor = new Vector4(0, 0, this._width, this._height);
    this._scissorTest = false;
    this._attributes = null;
    this._geometries = null;
    this._nodes = null;
    this._animation = null;
    this._bindings = null;
    this._objects = null;
    this._pipelines = null;
    this._bundles = null;
    this._renderLists = null;
    this._renderContexts = null;
    this._textures = null;
    this._background = null;
    this._quad = new QuadMesh(new NodeMaterial());
    this._quad.material.name = "Renderer_output";
    this._currentRenderContext = null;
    this._opaqueSort = null;
    this._transparentSort = null;
    this._frameBufferTarget = null;
    const alphaClear = this.alpha === true ? 0 : 1;
    this._clearColor = new Color4(0, 0, 0, alphaClear);
    this._clearDepth = 1;
    this._clearStencil = 0;
    this._renderTarget = null;
    this._activeCubeFace = 0;
    this._activeMipmapLevel = 0;
    this._outputRenderTarget = null;
    this._mrt = null;
    this._renderObjectFunction = null;
    this._currentRenderObjectFunction = null;
    this._currentRenderBundle = null;
    this._handleObjectFunction = this._renderObjectDirect;
    this._isDeviceLost = false;
    this.onDeviceLost = this._onDeviceLost;
    this._colorBufferType = colorBufferType;
    this._initialized = false;
    this._initPromise = null;
    this._compilationPromises = null;
    this.transparent = true;
    this.opaque = true;
    this.shadowMap = {
      enabled: false,
      type: PCFShadowMap
    };
    this.xr = new XRManager(this, multiview);
    this.debug = {
      checkShaderErrors: true,
      onShaderError: null,
      getShaderAsync: async (scene, camera, object2) => {
        await this.compileAsync(scene, camera);
        const renderList = this._renderLists.get(scene, camera);
        const renderContext = this._renderContexts.get(scene, camera, this._renderTarget);
        const material = scene.overrideMaterial || object2.material;
        const renderObject = this._objects.get(object2, material, scene, camera, renderList.lightsNode, renderContext, renderContext.clippingContext);
        const { fragmentShader: fragmentShader2, vertexShader: vertexShader2 } = renderObject.getNodeBuilderState();
        return { fragmentShader: fragmentShader2, vertexShader: vertexShader2 };
      }
    };
  }
  /**
   * Initializes the renderer so it is ready for usage.
   *
   * @async
   * @return {Promise<this>} A Promise that resolves when the renderer has been initialized.
   */
  async init() {
    if (this._initialized) {
      throw new Error("Renderer: Backend has already been initialized.");
    }
    if (this._initPromise !== null) {
      return this._initPromise;
    }
    this._initPromise = new Promise(async (resolve, reject) => {
      let backend = this.backend;
      try {
        await backend.init(this);
      } catch (error) {
        if (this._getFallback !== null) {
          try {
            this.backend = backend = this._getFallback(error);
            await backend.init(this);
          } catch (error2) {
            reject(error2);
            return;
          }
        } else {
          reject(error);
          return;
        }
      }
      this._nodes = new Nodes(this, backend);
      this._animation = new Animation(this._nodes, this.info);
      this._attributes = new Attributes(backend);
      this._background = new Background(this, this._nodes);
      this._geometries = new Geometries(this._attributes, this.info);
      this._textures = new Textures(this, backend, this.info);
      this._pipelines = new Pipelines(backend, this._nodes);
      this._bindings = new Bindings(backend, this._nodes, this._textures, this._attributes, this._pipelines, this.info);
      this._objects = new RenderObjects(this, this._nodes, this._geometries, this._pipelines, this._bindings, this.info);
      this._renderLists = new RenderLists(this.lighting);
      this._bundles = new RenderBundles();
      this._renderContexts = new RenderContexts();
      this._animation.start();
      this._initialized = true;
      resolve(this);
    });
    return this._initPromise;
  }
  /**
   * The coordinate system of the renderer. The value of this property
   * depends on the selected backend. Either `THREE.WebGLCoordinateSystem` or
   * `THREE.WebGPUCoordinateSystem`.
   *
   * @readonly
   * @type {number}
   */
  get coordinateSystem() {
    return this.backend.coordinateSystem;
  }
  /**
   * Compiles all materials in the given scene. This can be useful to avoid a
   * phenomenon which is called "shader compilation stutter", which occurs when
   * rendering an object with a new shader for the first time.
   *
   * If you want to add a 3D object to an existing scene, use the third optional
   * parameter for applying the target scene. Note that the (target) scene's lighting
   * and environment must be configured before calling this method.
   *
   * @async
   * @param {Object3D} scene - The scene or 3D object to precompile.
   * @param {Camera} camera - The camera that is used to render the scene.
   * @param {?Scene} targetScene - If the first argument is a 3D object, this parameter must represent the scene the 3D object is going to be added.
   * @return {Promise<Array|undefined>} A Promise that resolves when the compile has been finished.
   */
  async compileAsync(scene, camera, targetScene = null) {
    if (this._isDeviceLost === true) return;
    if (this._initialized === false) await this.init();
    const nodeFrame = this._nodes.nodeFrame;
    const previousRenderId = nodeFrame.renderId;
    const previousRenderContext = this._currentRenderContext;
    const previousRenderObjectFunction = this._currentRenderObjectFunction;
    const previousCompilationPromises = this._compilationPromises;
    const sceneRef = scene.isScene === true ? scene : _scene;
    if (targetScene === null) targetScene = scene;
    const renderTarget = this._renderTarget;
    const renderContext = this._renderContexts.get(targetScene, camera, renderTarget);
    const activeMipmapLevel = this._activeMipmapLevel;
    const compilationPromises = [];
    this._currentRenderContext = renderContext;
    this._currentRenderObjectFunction = this.renderObject;
    this._handleObjectFunction = this._createObjectPipeline;
    this._compilationPromises = compilationPromises;
    nodeFrame.renderId++;
    nodeFrame.update();
    renderContext.depth = this.depth;
    renderContext.stencil = this.stencil;
    if (!renderContext.clippingContext) renderContext.clippingContext = new ClippingContext();
    renderContext.clippingContext.updateGlobal(sceneRef, camera);
    sceneRef.onBeforeRender(this, scene, camera, renderTarget);
    const renderList = this._renderLists.get(scene, camera);
    renderList.begin();
    this._projectObject(scene, camera, 0, renderList, renderContext.clippingContext);
    if (targetScene !== scene) {
      targetScene.traverseVisible(function(object2) {
        if (object2.isLight && object2.layers.test(camera.layers)) {
          renderList.pushLight(object2);
        }
      });
    }
    renderList.finish();
    if (renderTarget !== null) {
      this._textures.updateRenderTarget(renderTarget, activeMipmapLevel);
      const renderTargetData = this._textures.get(renderTarget);
      renderContext.textures = renderTargetData.textures;
      renderContext.depthTexture = renderTargetData.depthTexture;
    } else {
      renderContext.textures = null;
      renderContext.depthTexture = null;
    }
    this._background.update(sceneRef, renderList, renderContext);
    const opaqueObjects = renderList.opaque;
    const transparentObjects = renderList.transparent;
    const transparentDoublePassObjects = renderList.transparentDoublePass;
    const lightsNode = renderList.lightsNode;
    if (this.opaque === true && opaqueObjects.length > 0) this._renderObjects(opaqueObjects, camera, sceneRef, lightsNode);
    if (this.transparent === true && transparentObjects.length > 0) this._renderTransparents(transparentObjects, transparentDoublePassObjects, camera, sceneRef, lightsNode);
    nodeFrame.renderId = previousRenderId;
    this._currentRenderContext = previousRenderContext;
    this._currentRenderObjectFunction = previousRenderObjectFunction;
    this._compilationPromises = previousCompilationPromises;
    this._handleObjectFunction = this._renderObjectDirect;
    await Promise.all(compilationPromises);
  }
  /**
   * Renders the scene in an async fashion.
   *
   * @async
   * @param {Object3D} scene - The scene or 3D object to render.
   * @param {Camera} camera - The camera.
   * @return {Promise} A Promise that resolves when the render has been finished.
   */
  async renderAsync(scene, camera) {
    if (this._initialized === false) await this.init();
    this._renderScene(scene, camera);
  }
  /**
   * Can be used to synchronize CPU operations with GPU tasks. So when this method is called,
   * the CPU waits for the GPU to complete its operation (e.g. a compute task).
   *
   * @async
   * @return {Promise} A Promise that resolves when synchronization has been finished.
   */
  async waitForGPU() {
    await this.backend.waitForGPU();
  }
  /**
   * Enables or disables high precision for model-view and normal-view matrices.
   * When enabled, will use CPU 64-bit precision for higher precision instead of GPU 32-bit for higher performance.
   *
   * NOTE: 64-bit precision is not compatible with `InstancedMesh` and `SkinnedMesh`.
   *
   * @param {boolean} value - Whether to enable or disable high precision.
   * @type {boolean}
   */
  set highPrecision(value) {
    if (value === true) {
      this.overrideNodes.modelViewMatrix = highpModelViewMatrix;
      this.overrideNodes.modelNormalViewMatrix = highpModelNormalViewMatrix;
    } else if (this.highPrecision) {
      this.overrideNodes.modelViewMatrix = null;
      this.overrideNodes.modelNormalViewMatrix = null;
    }
  }
  /**
   * Returns whether high precision is enabled or not.
   *
   * @return {boolean} Whether high precision is enabled or not.
   * @type {boolean}
   */
  get highPrecision() {
    return this.overrideNodes.modelViewMatrix === highpModelViewMatrix && this.overrideNodes.modelNormalViewMatrix === highpModelNormalViewMatrix;
  }
  /**
   * Sets the given MRT configuration.
   *
   * @param {MRTNode} mrt - The MRT node to set.
   * @return {Renderer} A reference to this renderer.
   */
  setMRT(mrt3) {
    this._mrt = mrt3;
    return this;
  }
  /**
   * Returns the MRT configuration.
   *
   * @return {MRTNode} The MRT configuration.
   */
  getMRT() {
    return this._mrt;
  }
  /**
   * Returns the color buffer type.
   *
   * @return {number} The color buffer type.
   */
  getColorBufferType() {
    return this._colorBufferType;
  }
  /**
   * Default implementation of the device lost callback.
   *
   * @private
   * @param {Object} info - Information about the context lost.
   */
  _onDeviceLost(info) {
    let errorMessage = `THREE.WebGPURenderer: ${info.api} Device Lost:

Message: ${info.message}`;
    if (info.reason) {
      errorMessage += `
Reason: ${info.reason}`;
    }
    console.error(errorMessage);
    this._isDeviceLost = true;
  }
  /**
   * Renders the given render bundle.
   *
   * @private
   * @param {Object} bundle - Render bundle data.
   * @param {Scene} sceneRef - The scene the render bundle belongs to.
   * @param {LightsNode} lightsNode - The lights node.
   */
  _renderBundle(bundle, sceneRef, lightsNode) {
    const { bundleGroup, camera, renderList } = bundle;
    const renderContext = this._currentRenderContext;
    const renderBundle = this._bundles.get(bundleGroup, camera);
    const renderBundleData = this.backend.get(renderBundle);
    if (renderBundleData.renderContexts === void 0) renderBundleData.renderContexts = /* @__PURE__ */ new Set();
    const needsUpdate = bundleGroup.version !== renderBundleData.version;
    const renderBundleNeedsUpdate = renderBundleData.renderContexts.has(renderContext) === false || needsUpdate;
    renderBundleData.renderContexts.add(renderContext);
    if (renderBundleNeedsUpdate) {
      this.backend.beginBundle(renderContext);
      if (renderBundleData.renderObjects === void 0 || needsUpdate) {
        renderBundleData.renderObjects = [];
      }
      this._currentRenderBundle = renderBundle;
      const {
        transparentDoublePass: transparentDoublePassObjects,
        transparent: transparentObjects,
        opaque: opaqueObjects
      } = renderList;
      if (this.opaque === true && opaqueObjects.length > 0) this._renderObjects(opaqueObjects, camera, sceneRef, lightsNode);
      if (this.transparent === true && transparentObjects.length > 0) this._renderTransparents(transparentObjects, transparentDoublePassObjects, camera, sceneRef, lightsNode);
      this._currentRenderBundle = null;
      this.backend.finishBundle(renderContext, renderBundle);
      renderBundleData.version = bundleGroup.version;
    } else {
      const { renderObjects } = renderBundleData;
      for (let i = 0, l = renderObjects.length; i < l; i++) {
        const renderObject = renderObjects[i];
        if (this._nodes.needsRefresh(renderObject)) {
          this._nodes.updateBefore(renderObject);
          this._nodes.updateForRender(renderObject);
          this._bindings.updateForRender(renderObject);
          this._nodes.updateAfter(renderObject);
        }
      }
    }
    this.backend.addBundle(renderContext, renderBundle);
  }
  /**
   * Renders the scene or 3D object with the given camera. This method can only be called
   * if the renderer has been initialized.
   *
   * The target of the method is the default framebuffer (meaning the canvas)
   * or alternatively a render target when specified via `setRenderTarget()`.
   *
   * @param {Object3D} scene - The scene or 3D object to render.
   * @param {Camera} camera - The camera to render the scene with.
   * @return {?Promise} A Promise that resolve when the scene has been rendered.
   * Only returned when the renderer has not been initialized.
   */
  render(scene, camera) {
    if (this._initialized === false) {
      console.warn("THREE.Renderer: .render() called before the backend is initialized. Try using .renderAsync() instead.");
      return this.renderAsync(scene, camera);
    }
    this._renderScene(scene, camera);
  }
  /**
   * Returns an internal render target which is used when computing the output tone mapping
   * and color space conversion. Unlike in `WebGLRenderer`, this is done in a separate render
   * pass and not inline to achieve more correct results.
   *
   * @private
   * @return {?RenderTarget} The render target. The method returns `null` if no output conversion should be applied.
   */
  _getFrameBufferTarget() {
    const { currentToneMapping, currentColorSpace } = this;
    const useToneMapping = currentToneMapping !== NoToneMapping;
    const useColorSpace = currentColorSpace !== ColorManagement.workingColorSpace;
    if (useToneMapping === false && useColorSpace === false) return null;
    const { width, height } = this.getDrawingBufferSize(_drawingBufferSize);
    const { depth: depth3, stencil } = this;
    let frameBufferTarget = this._frameBufferTarget;
    if (frameBufferTarget === null) {
      frameBufferTarget = new RenderTarget(width, height, {
        depthBuffer: depth3,
        stencilBuffer: stencil,
        type: this._colorBufferType,
        format: RGBAFormat,
        colorSpace: ColorManagement.workingColorSpace,
        generateMipmaps: false,
        minFilter: LinearFilter,
        magFilter: LinearFilter,
        samples: this.samples
      });
      frameBufferTarget.isPostProcessingRenderTarget = true;
      this._frameBufferTarget = frameBufferTarget;
    }
    const outputRenderTarget = this.getOutputRenderTarget();
    frameBufferTarget.depthBuffer = depth3;
    frameBufferTarget.stencilBuffer = stencil;
    if (outputRenderTarget !== null) {
      frameBufferTarget.setSize(outputRenderTarget.width, outputRenderTarget.height, outputRenderTarget.depth);
    } else {
      frameBufferTarget.setSize(width, height, 1);
    }
    frameBufferTarget.viewport.copy(this._viewport);
    frameBufferTarget.scissor.copy(this._scissor);
    frameBufferTarget.viewport.multiplyScalar(this._pixelRatio);
    frameBufferTarget.scissor.multiplyScalar(this._pixelRatio);
    frameBufferTarget.scissorTest = this._scissorTest;
    frameBufferTarget.multiview = outputRenderTarget !== null ? outputRenderTarget.multiview : false;
    frameBufferTarget.resolveDepthBuffer = outputRenderTarget !== null ? outputRenderTarget.resolveDepthBuffer : true;
    frameBufferTarget._autoAllocateDepthBuffer = outputRenderTarget !== null ? outputRenderTarget._autoAllocateDepthBuffer : false;
    return frameBufferTarget;
  }
  /**
   * Renders the scene or 3D object with the given camera.
   *
   * @private
   * @param {Object3D} scene - The scene or 3D object to render.
   * @param {Camera} camera - The camera to render the scene with.
   * @param {boolean} [useFrameBufferTarget=true] - Whether to use a framebuffer target or not.
   * @return {RenderContext} The current render context.
   */
  _renderScene(scene, camera, useFrameBufferTarget = true) {
    if (this._isDeviceLost === true) return;
    const frameBufferTarget = useFrameBufferTarget ? this._getFrameBufferTarget() : null;
    const nodeFrame = this._nodes.nodeFrame;
    const previousRenderId = nodeFrame.renderId;
    const previousRenderContext = this._currentRenderContext;
    const previousRenderObjectFunction = this._currentRenderObjectFunction;
    const sceneRef = scene.isScene === true ? scene : _scene;
    const outputRenderTarget = this._renderTarget || this._outputRenderTarget;
    const activeCubeFace = this._activeCubeFace;
    const activeMipmapLevel = this._activeMipmapLevel;
    let renderTarget;
    if (frameBufferTarget !== null) {
      renderTarget = frameBufferTarget;
      this.setRenderTarget(renderTarget);
    } else {
      renderTarget = outputRenderTarget;
    }
    const renderContext = this._renderContexts.get(scene, camera, renderTarget);
    this._currentRenderContext = renderContext;
    this._currentRenderObjectFunction = this._renderObjectFunction || this.renderObject;
    this.info.calls++;
    this.info.render.calls++;
    this.info.render.frameCalls++;
    nodeFrame.renderId = this.info.calls;
    const coordinateSystem = this.coordinateSystem;
    const xr = this.xr;
    if (camera.coordinateSystem !== coordinateSystem && xr.isPresenting === false) {
      camera.coordinateSystem = coordinateSystem;
      camera.updateProjectionMatrix();
      if (camera.isArrayCamera) {
        for (const subCamera of camera.cameras) {
          subCamera.coordinateSystem = coordinateSystem;
          subCamera.updateProjectionMatrix();
        }
      }
    }
    if (scene.matrixWorldAutoUpdate === true) scene.updateMatrixWorld();
    if (camera.parent === null && camera.matrixWorldAutoUpdate === true) camera.updateMatrixWorld();
    if (xr.enabled === true && xr.isPresenting === true) {
      if (xr.cameraAutoUpdate === true) xr.updateCamera(camera);
      camera = xr.getCamera();
    }
    let viewport3 = this._viewport;
    let scissor = this._scissor;
    let pixelRatio = this._pixelRatio;
    if (renderTarget !== null) {
      viewport3 = renderTarget.viewport;
      scissor = renderTarget.scissor;
      pixelRatio = 1;
    }
    this.getDrawingBufferSize(_drawingBufferSize);
    _screen.set(0, 0, _drawingBufferSize.width, _drawingBufferSize.height);
    const minDepth = viewport3.minDepth === void 0 ? 0 : viewport3.minDepth;
    const maxDepth2 = viewport3.maxDepth === void 0 ? 1 : viewport3.maxDepth;
    renderContext.viewportValue.copy(viewport3).multiplyScalar(pixelRatio).floor();
    renderContext.viewportValue.width >>= activeMipmapLevel;
    renderContext.viewportValue.height >>= activeMipmapLevel;
    renderContext.viewportValue.minDepth = minDepth;
    renderContext.viewportValue.maxDepth = maxDepth2;
    renderContext.viewport = renderContext.viewportValue.equals(_screen) === false;
    renderContext.scissorValue.copy(scissor).multiplyScalar(pixelRatio).floor();
    renderContext.scissor = this._scissorTest && renderContext.scissorValue.equals(_screen) === false;
    renderContext.scissorValue.width >>= activeMipmapLevel;
    renderContext.scissorValue.height >>= activeMipmapLevel;
    if (!renderContext.clippingContext) renderContext.clippingContext = new ClippingContext();
    renderContext.clippingContext.updateGlobal(sceneRef, camera);
    sceneRef.onBeforeRender(this, scene, camera, renderTarget);
    const frustum = camera.isArrayCamera ? _frustumArray : _frustum;
    if (!camera.isArrayCamera) {
      _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
      frustum.setFromProjectionMatrix(_projScreenMatrix, camera.coordinateSystem, camera.reversedDepth);
    }
    const renderList = this._renderLists.get(scene, camera);
    renderList.begin();
    this._projectObject(scene, camera, 0, renderList, renderContext.clippingContext);
    renderList.finish();
    if (this.sortObjects === true) {
      renderList.sort(this._opaqueSort, this._transparentSort);
    }
    if (renderTarget !== null) {
      this._textures.updateRenderTarget(renderTarget, activeMipmapLevel);
      const renderTargetData = this._textures.get(renderTarget);
      renderContext.textures = renderTargetData.textures;
      renderContext.depthTexture = renderTargetData.depthTexture;
      renderContext.width = renderTargetData.width;
      renderContext.height = renderTargetData.height;
      renderContext.renderTarget = renderTarget;
      renderContext.depth = renderTarget.depthBuffer;
      renderContext.stencil = renderTarget.stencilBuffer;
    } else {
      renderContext.textures = null;
      renderContext.depthTexture = null;
      renderContext.width = _drawingBufferSize.width;
      renderContext.height = _drawingBufferSize.height;
      renderContext.depth = this.depth;
      renderContext.stencil = this.stencil;
    }
    renderContext.width >>= activeMipmapLevel;
    renderContext.height >>= activeMipmapLevel;
    renderContext.activeCubeFace = activeCubeFace;
    renderContext.activeMipmapLevel = activeMipmapLevel;
    renderContext.occlusionQueryCount = renderList.occlusionQueryCount;
    renderContext.scissorValue.max(_vector4.set(0, 0, 0, 0));
    if (renderContext.scissorValue.x + renderContext.scissorValue.width > renderContext.width) {
      renderContext.scissorValue.width = Math.max(renderContext.width - renderContext.scissorValue.x, 0);
    }
    if (renderContext.scissorValue.y + renderContext.scissorValue.height > renderContext.height) {
      renderContext.scissorValue.height = Math.max(renderContext.height - renderContext.scissorValue.y, 0);
    }
    this._background.update(sceneRef, renderList, renderContext);
    renderContext.camera = camera;
    this.backend.beginRender(renderContext);
    const {
      bundles,
      lightsNode,
      transparentDoublePass: transparentDoublePassObjects,
      transparent: transparentObjects,
      opaque: opaqueObjects
    } = renderList;
    if (bundles.length > 0) this._renderBundles(bundles, sceneRef, lightsNode);
    if (this.opaque === true && opaqueObjects.length > 0) this._renderObjects(opaqueObjects, camera, sceneRef, lightsNode);
    if (this.transparent === true && transparentObjects.length > 0) this._renderTransparents(transparentObjects, transparentDoublePassObjects, camera, sceneRef, lightsNode);
    this.backend.finishRender(renderContext);
    nodeFrame.renderId = previousRenderId;
    this._currentRenderContext = previousRenderContext;
    this._currentRenderObjectFunction = previousRenderObjectFunction;
    if (frameBufferTarget !== null) {
      this.setRenderTarget(outputRenderTarget, activeCubeFace, activeMipmapLevel);
      this._renderOutput(renderTarget);
    }
    sceneRef.onAfterRender(this, scene, camera, renderTarget);
    return renderContext;
  }
  _setXRLayerSize(width, height) {
    this._width = width;
    this._height = height;
    this.setViewport(0, 0, width, height);
  }
  /**
   * The output pass performs tone mapping and color space conversion.
   *
   * @private
   * @param {RenderTarget} renderTarget - The current render target.
   */
  _renderOutput(renderTarget) {
    const quad = this._quad;
    if (this._nodes.hasOutputChange(renderTarget.texture)) {
      quad.material.fragmentNode = this._nodes.getOutputNode(renderTarget.texture);
      quad.material.needsUpdate = true;
    }
    const currentAutoClear = this.autoClear;
    const currentXR = this.xr.enabled;
    this.autoClear = false;
    this.xr.enabled = false;
    this._renderScene(quad, quad.camera, false);
    this.autoClear = currentAutoClear;
    this.xr.enabled = currentXR;
  }
  /**
   * Returns the maximum available anisotropy for texture filtering.
   *
   * @return {number} The maximum available anisotropy.
   */
  getMaxAnisotropy() {
    return this.backend.getMaxAnisotropy();
  }
  /**
   * Returns the active cube face.
   *
   * @return {number} The active cube face.
   */
  getActiveCubeFace() {
    return this._activeCubeFace;
  }
  /**
   * Returns the active mipmap level.
   *
   * @return {number} The active mipmap level.
   */
  getActiveMipmapLevel() {
    return this._activeMipmapLevel;
  }
  /**
   * Applications are advised to always define the animation loop
   * with this method and not manually with `requestAnimationFrame()`
   * for best compatibility.
   *
   * @async
   * @param {?Function} callback - The application's animation loop.
   * @return {Promise} A Promise that resolves when the set has been executed.
   */
  async setAnimationLoop(callback) {
    if (this._initialized === false) await this.init();
    this._animation.setAnimationLoop(callback);
  }
  /**
   * Can be used to transfer buffer data from a storage buffer attribute
   * from the GPU to the CPU in context of compute shaders.
   *
   * @async
   * @param {StorageBufferAttribute} attribute - The storage buffer attribute.
   * @return {Promise<ArrayBuffer>} A promise that resolves with the buffer data when the data are ready.
   */
  async getArrayBufferAsync(attribute3) {
    return await this.backend.getArrayBufferAsync(attribute3);
  }
  /**
   * Returns the rendering context.
   *
   * @return {GPUCanvasContext|WebGL2RenderingContext} The rendering context.
   */
  getContext() {
    return this.backend.getContext();
  }
  /**
   * Returns the pixel ratio.
   *
   * @return {number} The pixel ratio.
   */
  getPixelRatio() {
    return this._pixelRatio;
  }
  /**
   * Returns the drawing buffer size in physical pixels. This method honors the pixel ratio.
   *
   * @param {Vector2} target - The method writes the result in this target object.
   * @return {Vector2} The drawing buffer size.
   */
  getDrawingBufferSize(target) {
    return target.set(this._width * this._pixelRatio, this._height * this._pixelRatio).floor();
  }
  /**
   * Returns the renderer's size in logical pixels. This method does not honor the pixel ratio.
   *
   * @param {Vector2} target - The method writes the result in this target object.
   * @return {Vector2} The renderer's size in logical pixels.
   */
  getSize(target) {
    return target.set(this._width, this._height);
  }
  /**
   * Sets the given pixel ratio and resizes the canvas if necessary.
   *
   * @param {number} [value=1] - The pixel ratio.
   */
  setPixelRatio(value = 1) {
    if (this._pixelRatio === value) return;
    this._pixelRatio = value;
    this.setSize(this._width, this._height, false);
  }
  /**
   * This method allows to define the drawing buffer size by specifying
   * width, height and pixel ratio all at once. The size of the drawing
   * buffer is computed with this formula:
   * ```js
   * size.x = width * pixelRatio;
   * size.y = height * pixelRatio;
   * ```
   *
   * @param {number} width - The width in logical pixels.
   * @param {number} height - The height in logical pixels.
   * @param {number} pixelRatio - The pixel ratio.
   */
  setDrawingBufferSize(width, height, pixelRatio) {
    if (this.xr && this.xr.isPresenting) return;
    this._width = width;
    this._height = height;
    this._pixelRatio = pixelRatio;
    this.domElement.width = Math.floor(width * pixelRatio);
    this.domElement.height = Math.floor(height * pixelRatio);
    this.setViewport(0, 0, width, height);
    if (this._initialized) this.backend.updateSize();
  }
  /**
   * Sets the size of the renderer.
   *
   * @param {number} width - The width in logical pixels.
   * @param {number} height - The height in logical pixels.
   * @param {boolean} [updateStyle=true] - Whether to update the `style` attribute of the canvas or not.
   */
  setSize(width, height, updateStyle = true) {
    if (this.xr && this.xr.isPresenting) return;
    this._width = width;
    this._height = height;
    this.domElement.width = Math.floor(width * this._pixelRatio);
    this.domElement.height = Math.floor(height * this._pixelRatio);
    if (updateStyle === true) {
      this.domElement.style.width = width + "px";
      this.domElement.style.height = height + "px";
    }
    this.setViewport(0, 0, width, height);
    if (this._initialized) this.backend.updateSize();
  }
  /**
   * Defines a manual sort function for the opaque render list.
   * Pass `null` to use the default sort.
   *
   * @param {Function} method - The sort function.
   */
  setOpaqueSort(method) {
    this._opaqueSort = method;
  }
  /**
   * Defines a manual sort function for the transparent render list.
   * Pass `null` to use the default sort.
   *
   * @param {Function} method - The sort function.
   */
  setTransparentSort(method) {
    this._transparentSort = method;
  }
  /**
   * Returns the scissor rectangle.
   *
   * @param {Vector4} target - The method writes the result in this target object.
   * @return {Vector4} The scissor rectangle.
   */
  getScissor(target) {
    const scissor = this._scissor;
    target.x = scissor.x;
    target.y = scissor.y;
    target.width = scissor.width;
    target.height = scissor.height;
    return target;
  }
  /**
   * Defines the scissor rectangle.
   *
   * @param {number | Vector4} x - The horizontal coordinate for the lower left corner of the box in logical pixel unit.
   * Instead of passing four arguments, the method also works with a single four-dimensional vector.
   * @param {number} y - The vertical coordinate for the lower left corner of the box in logical pixel unit.
   * @param {number} width - The width of the scissor box in logical pixel unit.
   * @param {number} height - The height of the scissor box in logical pixel unit.
   */
  setScissor(x, y, width, height) {
    const scissor = this._scissor;
    if (x.isVector4) {
      scissor.copy(x);
    } else {
      scissor.set(x, y, width, height);
    }
  }
  /**
   * Returns the scissor test value.
   *
   * @return {boolean} Whether the scissor test should be enabled or not.
   */
  getScissorTest() {
    return this._scissorTest;
  }
  /**
   * Defines the scissor test.
   *
   * @param {boolean} boolean - Whether the scissor test should be enabled or not.
   */
  setScissorTest(boolean) {
    this._scissorTest = boolean;
    this.backend.setScissorTest(boolean);
  }
  /**
   * Returns the viewport definition.
   *
   * @param {Vector4} target - The method writes the result in this target object.
   * @return {Vector4} The viewport definition.
   */
  getViewport(target) {
    return target.copy(this._viewport);
  }
  /**
   * Defines the viewport.
   *
   * @param {number | Vector4} x - The horizontal coordinate for the lower left corner of the viewport origin in logical pixel unit.
   * @param {number} y - The vertical coordinate for the lower left corner of the viewport origin  in logical pixel unit.
   * @param {number} width - The width of the viewport in logical pixel unit.
   * @param {number} height - The height of the viewport in logical pixel unit.
   * @param {number} minDepth - The minimum depth value of the viewport. WebGPU only.
   * @param {number} maxDepth - The maximum depth value of the viewport. WebGPU only.
   */
  setViewport(x, y, width, height, minDepth = 0, maxDepth2 = 1) {
    const viewport3 = this._viewport;
    if (x.isVector4) {
      viewport3.copy(x);
    } else {
      viewport3.set(x, y, width, height);
    }
    viewport3.minDepth = minDepth;
    viewport3.maxDepth = maxDepth2;
  }
  /**
   * Returns the clear color.
   *
   * @param {Color} target - The method writes the result in this target object.
   * @return {Color} The clear color.
   */
  getClearColor(target) {
    return target.copy(this._clearColor);
  }
  /**
   * Defines the clear color and optionally the clear alpha.
   *
   * @param {Color} color - The clear color.
   * @param {number} [alpha=1] - The clear alpha.
   */
  setClearColor(color4, alpha = 1) {
    this._clearColor.set(color4);
    this._clearColor.a = alpha;
  }
  /**
   * Returns the clear alpha.
   *
   * @return {number} The clear alpha.
   */
  getClearAlpha() {
    return this._clearColor.a;
  }
  /**
   * Defines the clear alpha.
   *
   * @param {number} alpha - The clear alpha.
   */
  setClearAlpha(alpha) {
    this._clearColor.a = alpha;
  }
  /**
   * Returns the clear depth.
   *
   * @return {number} The clear depth.
   */
  getClearDepth() {
    return this._clearDepth;
  }
  /**
   * Defines the clear depth.
   *
   * @param {number} depth - The clear depth.
   */
  setClearDepth(depth3) {
    this._clearDepth = depth3;
  }
  /**
   * Returns the clear stencil.
   *
   * @return {number} The clear stencil.
   */
  getClearStencil() {
    return this._clearStencil;
  }
  /**
   * Defines the clear stencil.
   *
   * @param {number} stencil - The clear stencil.
   */
  setClearStencil(stencil) {
    this._clearStencil = stencil;
  }
  /**
   * This method performs an occlusion query for the given 3D object.
   * It returns `true` if the given 3D object is fully occluded by other
   * 3D objects in the scene.
   *
   * @param {Object3D} object - The 3D object to test.
   * @return {boolean} Whether the 3D object is fully occluded or not.
   */
  isOccluded(object2) {
    const renderContext = this._currentRenderContext;
    return renderContext && this.backend.isOccluded(renderContext, object2);
  }
  /**
   * Performs a manual clear operation. This method ignores `autoClear` properties.
   *
   * @param {boolean} [color=true] - Whether the color buffer should be cleared or not.
   * @param {boolean} [depth=true] - Whether the depth buffer should be cleared or not.
   * @param {boolean} [stencil=true] - Whether the stencil buffer should be cleared or not.
   * @return {Promise} A Promise that resolves when the clear operation has been executed.
   * Only returned when the renderer has not been initialized.
   */
  clear(color4 = true, depth3 = true, stencil = true) {
    if (this._initialized === false) {
      console.warn("THREE.Renderer: .clear() called before the backend is initialized. Try using .clearAsync() instead.");
      return this.clearAsync(color4, depth3, stencil);
    }
    const renderTarget = this._renderTarget || this._getFrameBufferTarget();
    let renderContext = null;
    if (renderTarget !== null) {
      this._textures.updateRenderTarget(renderTarget);
      const renderTargetData = this._textures.get(renderTarget);
      renderContext = this._renderContexts.getForClear(renderTarget);
      renderContext.textures = renderTargetData.textures;
      renderContext.depthTexture = renderTargetData.depthTexture;
      renderContext.width = renderTargetData.width;
      renderContext.height = renderTargetData.height;
      renderContext.renderTarget = renderTarget;
      renderContext.depth = renderTarget.depthBuffer;
      renderContext.stencil = renderTarget.stencilBuffer;
      renderContext.clearColorValue = this.backend.getClearColor();
      renderContext.activeCubeFace = this.getActiveCubeFace();
      renderContext.activeMipmapLevel = this.getActiveMipmapLevel();
    }
    this.backend.clear(color4, depth3, stencil, renderContext);
    if (renderTarget !== null && this._renderTarget === null) {
      this._renderOutput(renderTarget);
    }
  }
  /**
   * Performs a manual clear operation of the color buffer. This method ignores `autoClear` properties.
   *
   * @return {Promise} A Promise that resolves when the clear operation has been executed.
   * Only returned when the renderer has not been initialized.
   */
  clearColor() {
    return this.clear(true, false, false);
  }
  /**
   * Performs a manual clear operation of the depth buffer. This method ignores `autoClear` properties.
   *
   * @return {Promise} A Promise that resolves when the clear operation has been executed.
   * Only returned when the renderer has not been initialized.
   */
  clearDepth() {
    return this.clear(false, true, false);
  }
  /**
   * Performs a manual clear operation of the stencil buffer. This method ignores `autoClear` properties.
   *
   * @return {Promise} A Promise that resolves when the clear operation has been executed.
   * Only returned when the renderer has not been initialized.
   */
  clearStencil() {
    return this.clear(false, false, true);
  }
  /**
   * Async version of {@link Renderer#clear}.
   *
   * @async
   * @param {boolean} [color=true] - Whether the color buffer should be cleared or not.
   * @param {boolean} [depth=true] - Whether the depth buffer should be cleared or not.
   * @param {boolean} [stencil=true] - Whether the stencil buffer should be cleared or not.
   * @return {Promise} A Promise that resolves when the clear operation has been executed.
   */
  async clearAsync(color4 = true, depth3 = true, stencil = true) {
    if (this._initialized === false) await this.init();
    this.clear(color4, depth3, stencil);
  }
  /**
   * Async version of {@link Renderer#clearColor}.
   *
   * @async
   * @return {Promise} A Promise that resolves when the clear operation has been executed.
   */
  async clearColorAsync() {
    this.clearAsync(true, false, false);
  }
  /**
   * Async version of {@link Renderer#clearDepth}.
   *
   * @async
   * @return {Promise} A Promise that resolves when the clear operation has been executed.
   */
  async clearDepthAsync() {
    this.clearAsync(false, true, false);
  }
  /**
   * Async version of {@link Renderer#clearStencil}.
   *
   * @async
   * @return {Promise} A Promise that resolves when the clear operation has been executed.
   */
  async clearStencilAsync() {
    this.clearAsync(false, false, true);
  }
  /**
   * The current tone mapping of the renderer. When not producing screen output,
   * the tone mapping is always `NoToneMapping`.
   *
   * @type {number}
   */
  get currentToneMapping() {
    return this.isOutputTarget ? this.toneMapping : NoToneMapping;
  }
  /**
   * The current color space of the renderer. When not producing screen output,
   * the color space is always the working color space.
   *
   * @type {string}
   */
  get currentColorSpace() {
    return this.isOutputTarget ? this.outputColorSpace : ColorManagement.workingColorSpace;
  }
  /**
   * Returns `true` if the rendering settings are set to screen output.
   *
   * @returns {boolean} True if the current render target is the same of output render target or `null`, otherwise false.
   */
  get isOutputTarget() {
    return this._renderTarget === this._outputRenderTarget || this._renderTarget === null;
  }
  /**
   * Frees all internal resources of the renderer. Call this method if the renderer
   * is no longer in use by your app.
   */
  dispose() {
    if (this._initialized === true) {
      this.info.dispose();
      this.backend.dispose();
      this._animation.dispose();
      this._objects.dispose();
      this._pipelines.dispose();
      this._nodes.dispose();
      this._bindings.dispose();
      this._renderLists.dispose();
      this._renderContexts.dispose();
      this._textures.dispose();
      if (this._frameBufferTarget !== null) this._frameBufferTarget.dispose();
      Object.values(this.backend.timestampQueryPool).forEach((queryPool) => {
        if (queryPool !== null) queryPool.dispose();
      });
    }
    this.setRenderTarget(null);
    this.setAnimationLoop(null);
  }
  /**
   * Sets the given render target. Calling this method means the renderer does not
   * target the default framebuffer (meaning the canvas) anymore but a custom framebuffer.
   * Use `null` as the first argument to reset the state.
   *
   * @param {?RenderTarget} renderTarget - The render target to set.
   * @param {number} [activeCubeFace=0] - The active cube face.
   * @param {number} [activeMipmapLevel=0] - The active mipmap level.
   */
  setRenderTarget(renderTarget, activeCubeFace = 0, activeMipmapLevel = 0) {
    this._renderTarget = renderTarget;
    this._activeCubeFace = activeCubeFace;
    this._activeMipmapLevel = activeMipmapLevel;
  }
  /**
   * Returns the current render target.
   *
   * @return {?RenderTarget} The render target. Returns `null` if no render target is set.
   */
  getRenderTarget() {
    return this._renderTarget;
  }
  /**
   * Sets the output render target for the renderer.
   *
   * @param {Object} renderTarget - The render target to set as the output target.
   */
  setOutputRenderTarget(renderTarget) {
    this._outputRenderTarget = renderTarget;
  }
  /**
   * Returns the current output target.
   *
   * @return {?RenderTarget} The current output render target. Returns `null` if no output target is set.
   */
  getOutputRenderTarget() {
    return this._outputRenderTarget;
  }
  /**
   * Resets the renderer to the initial state before WebXR started.
   *
   */
  _resetXRState() {
    this.backend.setXRTarget(null);
    this.setOutputRenderTarget(null);
    this.setRenderTarget(null);
    this._frameBufferTarget.dispose();
    this._frameBufferTarget = null;
  }
  /**
   * Callback for {@link Renderer#setRenderObjectFunction}.
   *
   * @callback renderObjectFunction
   * @param {Object3D} object - The 3D object.
   * @param {Scene} scene - The scene the 3D object belongs to.
   * @param {Camera} camera - The camera the object should be rendered with.
   * @param {BufferGeometry} geometry - The object's geometry.
   * @param {Material} material - The object's material.
   * @param {?Object} group - Only relevant for objects using multiple materials. This represents a group entry from the respective `BufferGeometry`.
   * @param {LightsNode} lightsNode - The current lights node.
   * @param {ClippingContext} clippingContext - The clipping context.
   * @param {?string} [passId=null] - An optional ID for identifying the pass.
   */
  /**
   * Sets the given render object function. Calling this method overwrites the default implementation
   * which is {@link Renderer#renderObject}. Defining a custom function can be useful
   * if you want to modify the way objects are rendered. For example you can define things like "every
   * object that has material of a certain type should perform a pre-pass with a special overwrite material".
   * The custom function must always call `renderObject()` in its implementation.
   *
   * Use `null` as the first argument to reset the state.
   *
   * @param {?renderObjectFunction} renderObjectFunction - The render object function.
   */
  setRenderObjectFunction(renderObjectFunction) {
    this._renderObjectFunction = renderObjectFunction;
  }
  /**
   * Returns the current render object function.
   *
   * @return {?Function} The current render object function. Returns `null` if no function is set.
   */
  getRenderObjectFunction() {
    return this._renderObjectFunction;
  }
  /**
   * Execute a single or an array of compute nodes. This method can only be called
   * if the renderer has been initialized.
   *
   * @param {Node|Array<Node>} computeNodes - The compute node(s).
   * @param {?(Array<number>|number)} [dispatchSizeOrCount=null] - Array with [ x, y, z ] values for dispatch or a single number for the count.
   * @return {Promise|undefined} A Promise that resolve when the compute has finished. Only returned when the renderer has not been initialized.
   */
  compute(computeNodes, dispatchSizeOrCount = null) {
    if (this._isDeviceLost === true) return;
    if (this._initialized === false) {
      console.warn("THREE.Renderer: .compute() called before the backend is initialized. Try using .computeAsync() instead.");
      return this.computeAsync(computeNodes);
    }
    const nodeFrame = this._nodes.nodeFrame;
    const previousRenderId = nodeFrame.renderId;
    this.info.calls++;
    this.info.compute.calls++;
    this.info.compute.frameCalls++;
    nodeFrame.renderId = this.info.calls;
    const backend = this.backend;
    const pipelines = this._pipelines;
    const bindings = this._bindings;
    const nodes = this._nodes;
    const computeList = Array.isArray(computeNodes) ? computeNodes : [computeNodes];
    if (computeList[0] === void 0 || computeList[0].isComputeNode !== true) {
      throw new Error("THREE.Renderer: .compute() expects a ComputeNode.");
    }
    backend.beginCompute(computeNodes);
    for (const computeNode of computeList) {
      if (pipelines.has(computeNode) === false) {
        const dispose = () => {
          computeNode.removeEventListener("dispose", dispose);
          pipelines.delete(computeNode);
          bindings.delete(computeNode);
          nodes.delete(computeNode);
        };
        computeNode.addEventListener("dispose", dispose);
        const onInitFn = computeNode.onInitFunction;
        if (onInitFn !== null) {
          onInitFn.call(computeNode, { renderer: this });
        }
      }
      nodes.updateForCompute(computeNode);
      bindings.updateForCompute(computeNode);
      const computeBindings = bindings.getForCompute(computeNode);
      const computePipeline = pipelines.getForCompute(computeNode, computeBindings);
      backend.compute(computeNodes, computeNode, computeBindings, computePipeline, dispatchSizeOrCount);
    }
    backend.finishCompute(computeNodes);
    nodeFrame.renderId = previousRenderId;
  }
  /**
   * Execute a single or an array of compute nodes.
   *
   * @async
   * @param {Node|Array<Node>} computeNodes - The compute node(s).
   * @param {?(Array<number>|number)} [dispatchSizeOrCount=null] - Array with [ x, y, z ] values for dispatch or a single number for the count.
   * @return {Promise} A Promise that resolve when the compute has finished.
   */
  async computeAsync(computeNodes, dispatchSizeOrCount = null) {
    if (this._initialized === false) await this.init();
    this.compute(computeNodes, dispatchSizeOrCount);
  }
  /**
   * Checks if the given feature is supported by the selected backend.
   *
   * @async
   * @param {string} name - The feature's name.
   * @return {Promise<boolean>} A Promise that resolves with a bool that indicates whether the feature is supported or not.
   */
  async hasFeatureAsync(name) {
    if (this._initialized === false) await this.init();
    return this.backend.hasFeature(name);
  }
  async resolveTimestampsAsync(type = "render") {
    if (this._initialized === false) await this.init();
    return this.backend.resolveTimestampsAsync(type);
  }
  /**
   * Checks if the given feature is supported by the selected backend. If the
   * renderer has not been initialized, this method always returns `false`.
   *
   * @param {string} name - The feature's name.
   * @return {boolean} Whether the feature is supported or not.
   */
  hasFeature(name) {
    if (this._initialized === false) {
      console.warn("THREE.Renderer: .hasFeature() called before the backend is initialized. Try using .hasFeatureAsync() instead.");
      return false;
    }
    return this.backend.hasFeature(name);
  }
  /**
   * Returns `true` when the renderer has been initialized.
   *
   * @return {boolean} Whether the renderer has been initialized or not.
   */
  hasInitialized() {
    return this._initialized;
  }
  /**
   * Initializes the given textures. Useful for preloading a texture rather than waiting until first render
   * (which can cause noticeable lags due to decode and GPU upload overhead).
   *
   * @async
   * @param {Texture} texture - The texture.
   * @return {Promise} A Promise that resolves when the texture has been initialized.
   */
  async initTextureAsync(texture3) {
    if (this._initialized === false) await this.init();
    this._textures.updateTexture(texture3);
  }
  /**
   * Initializes the given texture. Useful for preloading a texture rather than waiting until first render
   * (which can cause noticeable lags due to decode and GPU upload overhead).
   *
   * This method can only be used if the renderer has been initialized.
   *
   * @param {Texture} texture - The texture.
   */
  initTexture(texture3) {
    if (this._initialized === false) {
      console.warn("THREE.Renderer: .initTexture() called before the backend is initialized. Try using .initTextureAsync() instead.");
    }
    this._textures.updateTexture(texture3);
  }
  /**
   * Copies the current bound framebuffer into the given texture.
   *
   * @param {FramebufferTexture} framebufferTexture - The texture.
   * @param {?(Vector2|Vector4)} [rectangle=null] - A two or four dimensional vector that defines the rectangular portion of the framebuffer that should be copied.
   */
  copyFramebufferToTexture(framebufferTexture, rectangle = null) {
    if (rectangle !== null) {
      if (rectangle.isVector2) {
        rectangle = _vector4.set(rectangle.x, rectangle.y, framebufferTexture.image.width, framebufferTexture.image.height).floor();
      } else if (rectangle.isVector4) {
        rectangle = _vector4.copy(rectangle).floor();
      } else {
        console.error("THREE.Renderer.copyFramebufferToTexture: Invalid rectangle.");
        return;
      }
    } else {
      rectangle = _vector4.set(0, 0, framebufferTexture.image.width, framebufferTexture.image.height);
    }
    let renderContext = this._currentRenderContext;
    let renderTarget;
    if (renderContext !== null) {
      renderTarget = renderContext.renderTarget;
    } else {
      renderTarget = this._renderTarget || this._getFrameBufferTarget();
      if (renderTarget !== null) {
        this._textures.updateRenderTarget(renderTarget);
        renderContext = this._textures.get(renderTarget);
      }
    }
    this._textures.updateTexture(framebufferTexture, { renderTarget });
    this.backend.copyFramebufferToTexture(framebufferTexture, renderContext, rectangle);
  }
  /**
   * Copies data of the given source texture into a destination texture.
   *
   * @param {Texture} srcTexture - The source texture.
   * @param {Texture} dstTexture - The destination texture.
   * @param {Box2|Box3} [srcRegion=null] - A bounding box which describes the source region. Can be two or three-dimensional.
   * @param {Vector2|Vector3} [dstPosition=null] - A vector that represents the origin of the destination region. Can be two or three-dimensional.
   * @param {number} [srcLevel=0] - The source mip level to copy from.
   * @param {number} [dstLevel=0] - The destination mip level to copy to.
   */
  copyTextureToTexture(srcTexture, dstTexture, srcRegion = null, dstPosition = null, srcLevel = 0, dstLevel = 0) {
    this._textures.updateTexture(srcTexture);
    this._textures.updateTexture(dstTexture);
    this.backend.copyTextureToTexture(srcTexture, dstTexture, srcRegion, dstPosition, srcLevel, dstLevel);
  }
  /**
   * Reads pixel data from the given render target.
   *
   * @async
   * @param {RenderTarget} renderTarget - The render target to read from.
   * @param {number} x - The `x` coordinate of the copy region's origin.
   * @param {number} y - The `y` coordinate of the copy region's origin.
   * @param {number} width - The width of the copy region.
   * @param {number} height - The height of the copy region.
   * @param {number} [textureIndex=0] - The texture index of a MRT render target.
   * @param {number} [faceIndex=0] - The active cube face index.
   * @return {Promise<TypedArray>} A Promise that resolves when the read has been finished. The resolve provides the read data as a typed array.
   */
  async readRenderTargetPixelsAsync(renderTarget, x, y, width, height, textureIndex = 0, faceIndex = 0) {
    return this.backend.copyTextureToBuffer(renderTarget.textures[textureIndex], x, y, width, height, faceIndex);
  }
  /**
   * Analyzes the given 3D object's hierarchy and builds render lists from the
   * processed hierarchy.
   *
   * @param {Object3D} object - The 3D object to process (usually a scene).
   * @param {Camera} camera - The camera the object is rendered with.
   * @param {number} groupOrder - The group order is derived from the `renderOrder` of groups and is used to group 3D objects within groups.
   * @param {RenderList} renderList - The current render list.
   * @param {ClippingContext} clippingContext - The current clipping context.
   */
  _projectObject(object2, camera, groupOrder, renderList, clippingContext) {
    if (object2.visible === false) return;
    const visible = object2.layers.test(camera.layers);
    if (visible) {
      if (object2.isGroup) {
        groupOrder = object2.renderOrder;
        if (object2.isClippingGroup && object2.enabled) clippingContext = clippingContext.getGroupContext(object2);
      } else if (object2.isLOD) {
        if (object2.autoUpdate === true) object2.update(camera);
      } else if (object2.isLight) {
        renderList.pushLight(object2);
      } else if (object2.isSprite) {
        const frustum = camera.isArrayCamera ? _frustumArray : _frustum;
        if (!object2.frustumCulled || frustum.intersectsSprite(object2, camera)) {
          if (this.sortObjects === true) {
            _vector4.setFromMatrixPosition(object2.matrixWorld).applyMatrix4(_projScreenMatrix);
          }
          const { geometry, material } = object2;
          if (material.visible) {
            renderList.push(object2, geometry, material, groupOrder, _vector4.z, null, clippingContext);
          }
        }
      } else if (object2.isLineLoop) {
        console.error("THREE.Renderer: Objects of type THREE.LineLoop are not supported. Please use THREE.Line or THREE.LineSegments.");
      } else if (object2.isMesh || object2.isLine || object2.isPoints) {
        const frustum = camera.isArrayCamera ? _frustumArray : _frustum;
        if (!object2.frustumCulled || frustum.intersectsObject(object2, camera)) {
          const { geometry, material } = object2;
          if (this.sortObjects === true) {
            if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
            _vector4.copy(geometry.boundingSphere.center).applyMatrix4(object2.matrixWorld).applyMatrix4(_projScreenMatrix);
          }
          if (Array.isArray(material)) {
            const groups2 = geometry.groups;
            for (let i = 0, l = groups2.length; i < l; i++) {
              const group2 = groups2[i];
              const groupMaterial = material[group2.materialIndex];
              if (groupMaterial && groupMaterial.visible) {
                renderList.push(object2, geometry, groupMaterial, groupOrder, _vector4.z, group2, clippingContext);
              }
            }
          } else if (material.visible) {
            renderList.push(object2, geometry, material, groupOrder, _vector4.z, null, clippingContext);
          }
        }
      }
    }
    if (object2.isBundleGroup === true && this.backend.beginBundle !== void 0) {
      const baseRenderList = renderList;
      renderList = this._renderLists.get(object2, camera);
      renderList.begin();
      baseRenderList.pushBundle({
        bundleGroup: object2,
        camera,
        renderList
      });
      renderList.finish();
    }
    const children = object2.children;
    for (let i = 0, l = children.length; i < l; i++) {
      this._projectObject(children[i], camera, groupOrder, renderList, clippingContext);
    }
  }
  /**
   * Renders the given render bundles.
   *
   * @private
   * @param {Array<Object>} bundles - Array with render bundle data.
   * @param {Scene} sceneRef - The scene the render bundles belong to.
   * @param {LightsNode} lightsNode - The current lights node.
   */
  _renderBundles(bundles, sceneRef, lightsNode) {
    for (const bundle of bundles) {
      this._renderBundle(bundle, sceneRef, lightsNode);
    }
  }
  /**
   * Renders the transparent objects from the given render lists.
   *
   * @private
   * @param {Array<Object>} renderList - The transparent render list.
   * @param {Array<Object>} doublePassList - The list of transparent objects which require a double pass (e.g. because of transmission).
   * @param {Camera} camera - The camera the render list should be rendered with.
   * @param {Scene} scene - The scene the render list belongs to.
   * @param {LightsNode} lightsNode - The current lights node.
   */
  _renderTransparents(renderList, doublePassList, camera, scene, lightsNode) {
    if (doublePassList.length > 0) {
      for (const { material } of doublePassList) {
        material.side = BackSide;
      }
      this._renderObjects(doublePassList, camera, scene, lightsNode, "backSide");
      for (const { material } of doublePassList) {
        material.side = FrontSide;
      }
      this._renderObjects(renderList, camera, scene, lightsNode);
      for (const { material } of doublePassList) {
        material.side = DoubleSide;
      }
    } else {
      this._renderObjects(renderList, camera, scene, lightsNode);
    }
  }
  /**
   * Renders the objects from the given render list.
   *
   * @private
   * @param {Array<Object>} renderList - The render list.
   * @param {Camera} camera - The camera the render list should be rendered with.
   * @param {Scene} scene - The scene the render list belongs to.
   * @param {LightsNode} lightsNode - The current lights node.
   * @param {?string} [passId=null] - An optional ID for identifying the pass.
   */
  _renderObjects(renderList, camera, scene, lightsNode, passId = null) {
    for (let i = 0, il = renderList.length; i < il; i++) {
      const { object: object2, geometry, material, group: group2, clippingContext } = renderList[i];
      this._currentRenderObjectFunction(object2, scene, camera, geometry, material, group2, lightsNode, clippingContext, passId);
    }
  }
  /**
   * This method represents the default render object function that manages the render lifecycle
   * of the object.
   *
   * @param {Object3D} object - The 3D object.
   * @param {Scene} scene - The scene the 3D object belongs to.
   * @param {Camera} camera - The camera the object should be rendered with.
   * @param {BufferGeometry} geometry - The object's geometry.
   * @param {Material} material - The object's material.
   * @param {?Object} group - Only relevant for objects using multiple materials. This represents a group entry from the respective `BufferGeometry`.
   * @param {LightsNode} lightsNode - The current lights node.
   * @param {?ClippingContext} clippingContext - The clipping context.
   * @param {?string} [passId=null] - An optional ID for identifying the pass.
   */
  renderObject(object2, scene, camera, geometry, material, group2, lightsNode, clippingContext = null, passId = null) {
    let overridePositionNode;
    let overrideColorNode;
    let overrideDepthNode;
    object2.onBeforeRender(this, scene, camera, geometry, material, group2);
    if (material.allowOverride === true && scene.overrideMaterial !== null) {
      const overrideMaterial = scene.overrideMaterial;
      if (material.positionNode && material.positionNode.isNode) {
        overridePositionNode = overrideMaterial.positionNode;
        overrideMaterial.positionNode = material.positionNode;
      }
      overrideMaterial.alphaTest = material.alphaTest;
      overrideMaterial.alphaMap = material.alphaMap;
      overrideMaterial.transparent = material.transparent || material.transmission > 0;
      if (overrideMaterial.isShadowPassMaterial) {
        overrideMaterial.side = material.shadowSide === null ? material.side : material.shadowSide;
        if (material.depthNode && material.depthNode.isNode) {
          overrideDepthNode = overrideMaterial.depthNode;
          overrideMaterial.depthNode = material.depthNode;
        }
        if (material.castShadowNode && material.castShadowNode.isNode) {
          overrideColorNode = overrideMaterial.colorNode;
          overrideMaterial.colorNode = material.castShadowNode;
        }
        if (material.castShadowPositionNode && material.castShadowPositionNode.isNode) {
          overridePositionNode = overrideMaterial.positionNode;
          overrideMaterial.positionNode = material.castShadowPositionNode;
        }
      }
      material = overrideMaterial;
    }
    if (material.transparent === true && material.side === DoubleSide && material.forceSinglePass === false) {
      material.side = BackSide;
      this._handleObjectFunction(object2, material, scene, camera, lightsNode, group2, clippingContext, "backSide");
      material.side = FrontSide;
      this._handleObjectFunction(object2, material, scene, camera, lightsNode, group2, clippingContext, passId);
      material.side = DoubleSide;
    } else {
      this._handleObjectFunction(object2, material, scene, camera, lightsNode, group2, clippingContext, passId);
    }
    if (overridePositionNode !== void 0) {
      scene.overrideMaterial.positionNode = overridePositionNode;
    }
    if (overrideDepthNode !== void 0) {
      scene.overrideMaterial.depthNode = overrideDepthNode;
    }
    if (overrideColorNode !== void 0) {
      scene.overrideMaterial.colorNode = overrideColorNode;
    }
    object2.onAfterRender(this, scene, camera, geometry, material, group2);
  }
  /**
   * This method represents the default `_handleObjectFunction` implementation which creates
   * a render object from the given data and performs the draw command with the selected backend.
   *
   * @private
   * @param {Object3D} object - The 3D object.
   * @param {Material} material - The object's material.
   * @param {Scene} scene - The scene the 3D object belongs to.
   * @param {Camera} camera - The camera the object should be rendered with.
   * @param {LightsNode} lightsNode - The current lights node.
   * @param {?{start: number, count: number}} group - Only relevant for objects using multiple materials. This represents a group entry from the respective `BufferGeometry`.
   * @param {ClippingContext} clippingContext - The clipping context.
   * @param {string} [passId] - An optional ID for identifying the pass.
   */
  _renderObjectDirect(object2, material, scene, camera, lightsNode, group2, clippingContext, passId) {
    const renderObject = this._objects.get(object2, material, scene, camera, lightsNode, this._currentRenderContext, clippingContext, passId);
    renderObject.drawRange = object2.geometry.drawRange;
    renderObject.group = group2;
    const needsRefresh = this._nodes.needsRefresh(renderObject);
    if (needsRefresh) {
      this._nodes.updateBefore(renderObject);
      this._geometries.updateForRender(renderObject);
      this._nodes.updateForRender(renderObject);
      this._bindings.updateForRender(renderObject);
    }
    this._pipelines.updateForRender(renderObject);
    if (this._currentRenderBundle !== null) {
      const renderBundleData = this.backend.get(this._currentRenderBundle);
      renderBundleData.renderObjects.push(renderObject);
      renderObject.bundle = this._currentRenderBundle.bundleGroup;
    }
    this.backend.draw(renderObject, this.info);
    if (needsRefresh) this._nodes.updateAfter(renderObject);
  }
  /**
   * A different implementation for `_handleObjectFunction` which only makes sure the object is ready for rendering.
   * Used in `compileAsync()`.
   *
   * @private
   * @param {Object3D} object - The 3D object.
   * @param {Material} material - The object's material.
   * @param {Scene} scene - The scene the 3D object belongs to.
   * @param {Camera} camera - The camera the object should be rendered with.
   * @param {LightsNode} lightsNode - The current lights node.
   * @param {?{start: number, count: number}} group - Only relevant for objects using multiple materials. This represents a group entry from the respective `BufferGeometry`.
   * @param {ClippingContext} clippingContext - The clipping context.
   * @param {string} [passId] - An optional ID for identifying the pass.
   */
  _createObjectPipeline(object2, material, scene, camera, lightsNode, group2, clippingContext, passId) {
    const renderObject = this._objects.get(object2, material, scene, camera, lightsNode, this._currentRenderContext, clippingContext, passId);
    renderObject.drawRange = object2.geometry.drawRange;
    renderObject.group = group2;
    this._nodes.updateBefore(renderObject);
    this._geometries.updateForRender(renderObject);
    this._nodes.updateForRender(renderObject);
    this._bindings.updateForRender(renderObject);
    this._pipelines.getForRender(renderObject, this._compilationPromises);
    this._nodes.updateAfter(renderObject);
  }
  /**
   * Alias for `compileAsync()`.
   *
   * @method
   * @param {Object3D} scene - The scene or 3D object to precompile.
   * @param {Camera} camera - The camera that is used to render the scene.
   * @param {Scene} targetScene - If the first argument is a 3D object, this parameter must represent the scene the 3D object is going to be added.
   * @return {function(Object3D, Camera, ?Scene): Promise|undefined} A Promise that resolves when the compile has been finished.
   */
  get compile() {
    return this.compileAsync;
  }
};
var Binding = class {
  /**
   * Constructs a new binding.
   *
   * @param {string} [name=''] - The binding's name.
   */
  constructor(name = "") {
    this.name = name;
    this.visibility = 0;
  }
  /**
   * Makes sure binding's resource is visible for the given shader stage.
   *
   * @param {number} visibility - The shader stage.
   */
  setVisibility(visibility) {
    this.visibility |= visibility;
  }
  /**
   * Clones the binding.
   *
   * @return {Binding} The cloned binding.
   */
  clone() {
    return Object.assign(new this.constructor(), this);
  }
};
function getFloatLength(floatLength) {
  return floatLength + (GPU_CHUNK_BYTES - floatLength % GPU_CHUNK_BYTES) % GPU_CHUNK_BYTES;
}
var Buffer = class extends Binding {
  /**
   * Constructs a new buffer.
   *
   * @param {string} name - The buffer's name.
   * @param {TypedArray} [buffer=null] - The buffer.
   */
  constructor(name, buffer3 = null) {
    super(name);
    this.isBuffer = true;
    this.bytesPerElement = Float32Array.BYTES_PER_ELEMENT;
    this._buffer = buffer3;
  }
  /**
   * The buffer's byte length.
   *
   * @type {number}
   * @readonly
   */
  get byteLength() {
    return getFloatLength(this._buffer.byteLength);
  }
  /**
   * A reference to the internal buffer.
   *
   * @type {Float32Array}
   * @readonly
   */
  get buffer() {
    return this._buffer;
  }
  /**
   * Updates the binding.
   *
   * @return {boolean} Whether the buffer has been updated and must be
   * uploaded to the GPU.
   */
  update() {
    return true;
  }
};
var UniformBuffer = class extends Buffer {
  /**
   * Constructs a new uniform buffer.
   *
   * @param {string} name - The buffer's name.
   * @param {TypedArray} [buffer=null] - The buffer.
   */
  constructor(name, buffer3 = null) {
    super(name, buffer3);
    this.isUniformBuffer = true;
  }
};
var _id$4 = 0;
var NodeUniformBuffer = class extends UniformBuffer {
  /**
   * Constructs a new node-based uniform buffer.
   *
   * @param {BufferNode} nodeUniform - The uniform buffer node.
   * @param {UniformGroupNode} groupNode - The uniform group node.
   */
  constructor(nodeUniform, groupNode) {
    super("UniformBuffer_" + _id$4++, nodeUniform ? nodeUniform.value : null);
    this.nodeUniform = nodeUniform;
    this.groupNode = groupNode;
  }
  /**
   * The uniform buffer.
   *
   * @type {Float32Array}
   */
  get buffer() {
    return this.nodeUniform.value;
  }
};
var UniformsGroup2 = class extends UniformBuffer {
  /**
   * Constructs a new uniforms group.
   *
   * @param {string} name - The group's name.
   */
  constructor(name) {
    super(name);
    this.isUniformsGroup = true;
    this._values = null;
    this.uniforms = [];
  }
  /**
   * Adds a uniform to this group.
   *
   * @param {Uniform} uniform - The uniform to add.
   * @return {UniformsGroup} A reference to this group.
   */
  addUniform(uniform3) {
    this.uniforms.push(uniform3);
    return this;
  }
  /**
   * Removes a uniform from this group.
   *
   * @param {Uniform} uniform - The uniform to remove.
   * @return {UniformsGroup} A reference to this group.
   */
  removeUniform(uniform3) {
    const index5 = this.uniforms.indexOf(uniform3);
    if (index5 !== -1) {
      this.uniforms.splice(index5, 1);
    }
    return this;
  }
  /**
   * An array with the raw uniform values.
   *
   * @type {Array<number>}
   */
  get values() {
    if (this._values === null) {
      this._values = Array.from(this.buffer);
    }
    return this._values;
  }
  /**
   * A Float32 array buffer with the uniform values.
   *
   * @type {Float32Array}
   */
  get buffer() {
    let buffer3 = this._buffer;
    if (buffer3 === null) {
      const byteLength = this.byteLength;
      buffer3 = new Float32Array(new ArrayBuffer(byteLength));
      this._buffer = buffer3;
    }
    return buffer3;
  }
  /**
   * The byte length of the buffer with correct buffer alignment.
   *
   * @type {number}
   */
  get byteLength() {
    const bytesPerElement = this.bytesPerElement;
    let offset = 0;
    for (let i = 0, l = this.uniforms.length; i < l; i++) {
      const uniform3 = this.uniforms[i];
      const boundary = uniform3.boundary;
      const itemSize = uniform3.itemSize * bytesPerElement;
      const chunkOffset = offset % GPU_CHUNK_BYTES;
      const chunkPadding = chunkOffset % boundary;
      const chunkStart = chunkOffset + chunkPadding;
      offset += chunkPadding;
      if (chunkStart !== 0 && GPU_CHUNK_BYTES - chunkStart < itemSize) {
        offset += GPU_CHUNK_BYTES - chunkStart;
      }
      uniform3.offset = offset / bytesPerElement;
      offset += itemSize;
    }
    return Math.ceil(offset / GPU_CHUNK_BYTES) * GPU_CHUNK_BYTES;
  }
  /**
   * Updates this group by updating each uniform object of
   * the internal uniform list. The uniform objects check if their
   * values has actually changed so this method only returns
   * `true` if there is a real value change.
   *
   * @return {boolean} Whether the uniforms have been updated and
   * must be uploaded to the GPU.
   */
  update() {
    let updated = false;
    for (const uniform3 of this.uniforms) {
      if (this.updateByType(uniform3) === true) {
        updated = true;
      }
    }
    return updated;
  }
  /**
   * Updates a given uniform by calling an update method matching
   * the uniforms type.
   *
   * @param {Uniform} uniform - The uniform to update.
   * @return {boolean} Whether the uniform has been updated or not.
   */
  updateByType(uniform3) {
    if (uniform3.isNumberUniform) return this.updateNumber(uniform3);
    if (uniform3.isVector2Uniform) return this.updateVector2(uniform3);
    if (uniform3.isVector3Uniform) return this.updateVector3(uniform3);
    if (uniform3.isVector4Uniform) return this.updateVector4(uniform3);
    if (uniform3.isColorUniform) return this.updateColor(uniform3);
    if (uniform3.isMatrix3Uniform) return this.updateMatrix3(uniform3);
    if (uniform3.isMatrix4Uniform) return this.updateMatrix4(uniform3);
    console.error("THREE.WebGPUUniformsGroup: Unsupported uniform type.", uniform3);
  }
  /**
   * Updates a given Number uniform.
   *
   * @param {NumberUniform} uniform - The Number uniform.
   * @return {boolean} Whether the uniform has been updated or not.
   */
  updateNumber(uniform3) {
    let updated = false;
    const a = this.values;
    const v2 = uniform3.getValue();
    const offset = uniform3.offset;
    const type = uniform3.getType();
    if (a[offset] !== v2) {
      const b = this._getBufferForType(type);
      b[offset] = a[offset] = v2;
      updated = true;
    }
    return updated;
  }
  /**
   * Updates a given Vector2 uniform.
   *
   * @param {Vector2Uniform} uniform - The Vector2 uniform.
   * @return {boolean} Whether the uniform has been updated or not.
   */
  updateVector2(uniform3) {
    let updated = false;
    const a = this.values;
    const v2 = uniform3.getValue();
    const offset = uniform3.offset;
    const type = uniform3.getType();
    if (a[offset + 0] !== v2.x || a[offset + 1] !== v2.y) {
      const b = this._getBufferForType(type);
      b[offset + 0] = a[offset + 0] = v2.x;
      b[offset + 1] = a[offset + 1] = v2.y;
      updated = true;
    }
    return updated;
  }
  /**
   * Updates a given Vector3 uniform.
   *
   * @param {Vector3Uniform} uniform - The Vector3 uniform.
   * @return {boolean} Whether the uniform has been updated or not.
   */
  updateVector3(uniform3) {
    let updated = false;
    const a = this.values;
    const v2 = uniform3.getValue();
    const offset = uniform3.offset;
    const type = uniform3.getType();
    if (a[offset + 0] !== v2.x || a[offset + 1] !== v2.y || a[offset + 2] !== v2.z) {
      const b = this._getBufferForType(type);
      b[offset + 0] = a[offset + 0] = v2.x;
      b[offset + 1] = a[offset + 1] = v2.y;
      b[offset + 2] = a[offset + 2] = v2.z;
      updated = true;
    }
    return updated;
  }
  /**
   * Updates a given Vector4 uniform.
   *
   * @param {Vector4Uniform} uniform - The Vector4 uniform.
   * @return {boolean} Whether the uniform has been updated or not.
   */
  updateVector4(uniform3) {
    let updated = false;
    const a = this.values;
    const v2 = uniform3.getValue();
    const offset = uniform3.offset;
    const type = uniform3.getType();
    if (a[offset + 0] !== v2.x || a[offset + 1] !== v2.y || a[offset + 2] !== v2.z || a[offset + 4] !== v2.w) {
      const b = this._getBufferForType(type);
      b[offset + 0] = a[offset + 0] = v2.x;
      b[offset + 1] = a[offset + 1] = v2.y;
      b[offset + 2] = a[offset + 2] = v2.z;
      b[offset + 3] = a[offset + 3] = v2.w;
      updated = true;
    }
    return updated;
  }
  /**
   * Updates a given Color uniform.
   *
   * @param {ColorUniform} uniform - The Color uniform.
   * @return {boolean} Whether the uniform has been updated or not.
   */
  updateColor(uniform3) {
    let updated = false;
    const a = this.values;
    const c3 = uniform3.getValue();
    const offset = uniform3.offset;
    if (a[offset + 0] !== c3.r || a[offset + 1] !== c3.g || a[offset + 2] !== c3.b) {
      const b = this.buffer;
      b[offset + 0] = a[offset + 0] = c3.r;
      b[offset + 1] = a[offset + 1] = c3.g;
      b[offset + 2] = a[offset + 2] = c3.b;
      updated = true;
    }
    return updated;
  }
  /**
   * Updates a given Matrix3 uniform.
   *
   * @param {Matrix3Uniform} uniform - The Matrix3 uniform.
   * @return {boolean} Whether the uniform has been updated or not.
   */
  updateMatrix3(uniform3) {
    let updated = false;
    const a = this.values;
    const e = uniform3.getValue().elements;
    const offset = uniform3.offset;
    if (a[offset + 0] !== e[0] || a[offset + 1] !== e[1] || a[offset + 2] !== e[2] || a[offset + 4] !== e[3] || a[offset + 5] !== e[4] || a[offset + 6] !== e[5] || a[offset + 8] !== e[6] || a[offset + 9] !== e[7] || a[offset + 10] !== e[8]) {
      const b = this.buffer;
      b[offset + 0] = a[offset + 0] = e[0];
      b[offset + 1] = a[offset + 1] = e[1];
      b[offset + 2] = a[offset + 2] = e[2];
      b[offset + 4] = a[offset + 4] = e[3];
      b[offset + 5] = a[offset + 5] = e[4];
      b[offset + 6] = a[offset + 6] = e[5];
      b[offset + 8] = a[offset + 8] = e[6];
      b[offset + 9] = a[offset + 9] = e[7];
      b[offset + 10] = a[offset + 10] = e[8];
      updated = true;
    }
    return updated;
  }
  /**
   * Updates a given Matrix4 uniform.
   *
   * @param {Matrix4Uniform} uniform - The Matrix4 uniform.
   * @return {boolean} Whether the uniform has been updated or not.
   */
  updateMatrix4(uniform3) {
    let updated = false;
    const a = this.values;
    const e = uniform3.getValue().elements;
    const offset = uniform3.offset;
    if (arraysEqual(a, e, offset) === false) {
      const b = this.buffer;
      b.set(e, offset);
      setArray(a, e, offset);
      updated = true;
    }
    return updated;
  }
  /**
   * Returns a typed array that matches the given data type.
   *
   * @param {string} type - The data type.
   * @return {TypedArray} The typed array.
   */
  _getBufferForType(type) {
    if (type === "int" || type === "ivec2" || type === "ivec3" || type === "ivec4") return new Int32Array(this.buffer.buffer);
    if (type === "uint" || type === "uvec2" || type === "uvec3" || type === "uvec4") return new Uint32Array(this.buffer.buffer);
    return this.buffer;
  }
};
function setArray(a, b, offset) {
  for (let i = 0, l = b.length; i < l; i++) {
    a[offset + i] = b[i];
  }
}
function arraysEqual(a, b, offset) {
  for (let i = 0, l = b.length; i < l; i++) {
    if (a[offset + i] !== b[i]) return false;
  }
  return true;
}
var _id$3 = 0;
var NodeUniformsGroup = class extends UniformsGroup2 {
  /**
   * Constructs a new node-based uniforms group.
   *
   * @param {string} name - The group's name.
   * @param {UniformGroupNode} groupNode - The uniform group node.
   */
  constructor(name, groupNode) {
    super(name);
    this.id = _id$3++;
    this.groupNode = groupNode;
    this.isNodeUniformsGroup = true;
  }
};
var Sampler = class extends Binding {
  /**
   * Constructs a new sampler.
   *
   * @param {string} name - The samplers's name.
   * @param {?Texture} texture - The texture this binding is referring to.
   */
  constructor(name, texture3) {
    super(name);
    this.texture = texture3;
    this.version = texture3 ? texture3.version : 0;
    this.generation = null;
    this.isSampler = true;
  }
  /**
   * Sets the texture of this sampler.
   * @param {?Texture} value - The texture to set.
   */
  set texture(value) {
    if (this._texture === value) return;
    const onDispose = () => {
      this._texture = null;
      this.generation = null;
      this.version = 0;
    };
    if (this._texture) {
      this._texture.removeEventListener("dispose", onDispose);
    }
    this._texture = value;
    this.generation = null;
    this.version = 0;
    if (this._texture) {
      this._texture.addEventListener("dispose", onDispose);
    }
  }
  /**
   * Gets the texture of this sampler.
   * @return {?Texture} The texture.
   */
  get texture() {
    return this._texture;
  }
  /**
   * Updates the binding.
   *
   * @return {boolean} Whether the texture has been updated and must be
   * uploaded to the GPU.
   */
  update() {
    const { texture: texture3, version } = this;
    if (version !== texture3.version) {
      this.version = texture3.version;
      return true;
    }
    return false;
  }
  clone() {
    const clonedSampler = super.clone();
    clonedSampler._texture = null;
    clonedSampler.texture = this.texture;
    return clonedSampler;
  }
};
var _id$2 = 0;
var SampledTexture = class extends Sampler {
  /**
   * Constructs a new sampled texture.
   *
   * @param {string} name - The sampled texture's name.
   * @param {?Texture} texture - The texture this binding is referring to.
   */
  constructor(name, texture3) {
    super(name, texture3);
    this.id = _id$2++;
    this.store = false;
    this.isSampledTexture = true;
  }
};
var NodeSampledTexture = class extends SampledTexture {
  /**
   * Constructs a new node-based sampled texture.
   *
   * @param {string} name - The textures's name.
   * @param {TextureNode} textureNode - The texture node.
   * @param {UniformGroupNode} groupNode - The uniform group node.
   * @param {?string} [access=null] - The access type.
   */
  constructor(name, textureNode, groupNode, access = null) {
    super(name, textureNode ? textureNode.value : null);
    this.textureNode = textureNode;
    this.groupNode = groupNode;
    this.access = access;
  }
  /**
   * Updates the binding.
   *
   * @return {boolean} Whether the texture has been updated and must be
   * uploaded to the GPU.
   */
  update() {
    const { textureNode } = this;
    if (this.texture !== textureNode.value) {
      this.texture = textureNode.value;
      return true;
    }
    return super.update();
  }
};
var NodeSampledCubeTexture = class extends NodeSampledTexture {
  /**
   * Constructs a new node-based sampled cube texture.
   *
   * @param {string} name - The textures's name.
   * @param {TextureNode} textureNode - The texture node.
   * @param {UniformGroupNode} groupNode - The uniform group node.
   * @param {?string} [access=null] - The access type.
   */
  constructor(name, textureNode, groupNode, access = null) {
    super(name, textureNode, groupNode, access);
    this.isSampledCubeTexture = true;
  }
};
var NodeSampledTexture3D = class extends NodeSampledTexture {
  /**
   * Constructs a new node-based sampled 3D texture.
   *
   * @param {string} name - The textures's name.
   * @param {TextureNode} textureNode - The texture node.
   * @param {UniformGroupNode} groupNode - The uniform group node.
   * @param {?string} [access=null] - The access type.
   */
  constructor(name, textureNode, groupNode, access = null) {
    super(name, textureNode, groupNode, access);
    this.isSampledTexture3D = true;
  }
};
var glslMethods = {
  textureDimensions: "textureSize",
  equals: "equal",
  bitcast_float_int: "floatBitsToInt",
  bitcast_int_float: "intBitsToFloat",
  bitcast_uint_float: "uintBitsToFloat",
  bitcast_float_uint: "floatBitsToUint"
};
var precisionLib = {
  low: "lowp",
  medium: "mediump",
  high: "highp"
};
var supports$1 = {
  swizzleAssign: true,
  storageBuffer: false
};
var interpolationTypeMap = {
  perspective: "smooth",
  linear: "noperspective"
};
var interpolationModeMap = {
  "centroid": "centroid"
};
var defaultPrecisions = `
precision highp float;
precision highp int;
precision highp sampler2D;
precision highp sampler3D;
precision highp samplerCube;
precision highp sampler2DArray;

precision highp usampler2D;
precision highp usampler3D;
precision highp usamplerCube;
precision highp usampler2DArray;

precision highp isampler2D;
precision highp isampler3D;
precision highp isamplerCube;
precision highp isampler2DArray;

precision lowp sampler2DShadow;
precision lowp sampler2DArrayShadow;
precision lowp samplerCubeShadow;
`;
var GLSLNodeBuilder = class extends NodeBuilder {
  /**
   * Constructs a new GLSL node builder renderer.
   *
   * @param {Object3D} object - The 3D object.
   * @param {Renderer} renderer - The renderer.
   */
  constructor(object2, renderer) {
    super(object2, renderer, new GLSLNodeParser());
    this.uniformGroups = {};
    this.transforms = [];
    this.extensions = {};
    this.builtins = { vertex: [], fragment: [], compute: [] };
  }
  /**
   * Checks if the given texture requires a manual conversion to the working color space.
   *
   * @param {Texture} texture - The texture to check.
   * @return {boolean} Whether the given texture requires a conversion to working color space or not.
   */
  needsToWorkingColorSpace(texture3) {
    return texture3.isVideoTexture === true && texture3.colorSpace !== NoColorSpace;
  }
  /**
   * Returns the native shader method name for a given generic name.
   *
   * @param {string} method - The method name to resolve.
   * @return {string} The resolved GLSL method name.
   */
  getMethod(method) {
    return glslMethods[method] || method;
  }
  /**
   * Returns the bitcast method name for a given input and outputType.
   *
   * @param {string} type - The output type to bitcast to.
   * @param {string} inputType - The input type of the.
   * @return {string} The resolved WGSL bitcast invocation.
   */
  getBitcastMethod(type, inputType) {
    return glslMethods[`bitcast_${inputType}_${type}`];
  }
  /**
   * Returns the native snippet for a ternary operation.
   *
   * @param {string} condSnippet - The condition determining which expression gets resolved.
   * @param {string} ifSnippet - The expression to resolve to if the condition is true.
   * @param {string} elseSnippet - The expression to resolve to if the condition is false.
   * @return {string} The resolved method name.
   */
  getTernary(condSnippet, ifSnippet, elseSnippet) {
    return `${condSnippet} ? ${ifSnippet} : ${elseSnippet}`;
  }
  /**
   * Returns the output struct name. Not relevant for GLSL.
   *
   * @return {string}
   */
  getOutputStructName() {
    return "";
  }
  /**
   * Builds the given shader node.
   *
   * @param {ShaderNodeInternal} shaderNode - The shader node.
   * @return {string} The GLSL function code.
   */
  buildFunctionCode(shaderNode) {
    const layout = shaderNode.layout;
    const flowData = this.flowShaderNode(shaderNode);
    const parameters = [];
    for (const input of layout.inputs) {
      parameters.push(this.getType(input.type) + " " + input.name);
    }
    const code3 = `${this.getType(layout.type)} ${layout.name}( ${parameters.join(", ")} ) {

	${flowData.vars}

${flowData.code}
	return ${flowData.result};

}`;
    return code3;
  }
  /**
   * Setups the Pixel Buffer Object (PBO) for the given storage
   * buffer node.
   *
   * @param {StorageBufferNode} storageBufferNode - The storage buffer node.
   */
  setupPBO(storageBufferNode) {
    const attribute3 = storageBufferNode.value;
    if (attribute3.pbo === void 0) {
      const originalArray = attribute3.array;
      const numElements = attribute3.count * attribute3.itemSize;
      const { itemSize } = attribute3;
      const isInteger = attribute3.array.constructor.name.toLowerCase().includes("int");
      let format2 = isInteger ? RedIntegerFormat : RedFormat;
      if (itemSize === 2) {
        format2 = isInteger ? RGIntegerFormat : RGFormat;
      } else if (itemSize === 3) {
        format2 = isInteger ? RGBIntegerFormat : RGBFormat;
      } else if (itemSize === 4) {
        format2 = isInteger ? RGBAIntegerFormat : RGBAFormat;
      }
      const typeMap = {
        Float32Array: FloatType,
        Uint8Array: UnsignedByteType,
        Uint16Array: UnsignedShortType,
        Uint32Array: UnsignedIntType,
        Int8Array: ByteType,
        Int16Array: ShortType,
        Int32Array: IntType,
        Uint8ClampedArray: UnsignedByteType
      };
      const width = Math.pow(2, Math.ceil(Math.log2(Math.sqrt(numElements / itemSize))));
      let height = Math.ceil(numElements / itemSize / width);
      if (width * height * itemSize < numElements) height++;
      const newSize = width * height * itemSize;
      const newArray = new originalArray.constructor(newSize);
      newArray.set(originalArray, 0);
      attribute3.array = newArray;
      const pboTexture = new DataTexture(attribute3.array, width, height, format2, typeMap[attribute3.array.constructor.name] || FloatType);
      pboTexture.needsUpdate = true;
      pboTexture.isPBOTexture = true;
      const pbo = new TextureNode(pboTexture, null, null);
      pbo.setPrecision("high");
      attribute3.pboNode = pbo;
      attribute3.pbo = pbo.value;
      this.getUniformFromNode(attribute3.pboNode, "texture", this.shaderStage, this.context.nodeName);
    }
  }
  /**
   * Returns a GLSL snippet that represents the property name of the given node.
   *
   * @param {Node} node - The node.
   * @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.
   * @return {string} The property name.
   */
  getPropertyName(node, shaderStage = this.shaderStage) {
    if (node.isNodeUniform && node.node.isTextureNode !== true && node.node.isBufferNode !== true) {
      return shaderStage.charAt(0) + "_" + node.name;
    }
    return super.getPropertyName(node, shaderStage);
  }
  /**
   * Setups the Pixel Buffer Object (PBO) for the given storage
   * buffer node.
   *
   * @param {StorageArrayElementNode} storageArrayElementNode - The storage array element node.
   * @return {string} The property name.
   */
  generatePBO(storageArrayElementNode) {
    const { node, indexNode } = storageArrayElementNode;
    const attribute3 = node.value;
    if (this.renderer.backend.has(attribute3)) {
      const attributeData = this.renderer.backend.get(attribute3);
      attributeData.pbo = attribute3.pbo;
    }
    const nodeUniform = this.getUniformFromNode(attribute3.pboNode, "texture", this.shaderStage, this.context.nodeName);
    const textureName = this.getPropertyName(nodeUniform);
    this.increaseUsage(indexNode);
    const indexSnippet = indexNode.build(this, "uint");
    const elementNodeData = this.getDataFromNode(storageArrayElementNode);
    let propertyName = elementNodeData.propertyName;
    if (propertyName === void 0) {
      const nodeVar = this.getVarFromNode(storageArrayElementNode);
      propertyName = this.getPropertyName(nodeVar);
      const bufferNodeData = this.getDataFromNode(node);
      let propertySizeName = bufferNodeData.propertySizeName;
      if (propertySizeName === void 0) {
        propertySizeName = propertyName + "Size";
        this.getVarFromNode(node, propertySizeName, "uint");
        this.addLineFlowCode(`${propertySizeName} = uint( textureSize( ${textureName}, 0 ).x )`, storageArrayElementNode);
        bufferNodeData.propertySizeName = propertySizeName;
      }
      const { itemSize } = attribute3;
      const channel = "." + vectorComponents.join("").slice(0, itemSize);
      const uvSnippet = `ivec2(${indexSnippet} % ${propertySizeName}, ${indexSnippet} / ${propertySizeName})`;
      const snippet = this.generateTextureLoad(null, textureName, uvSnippet, null, null, "0");
      let prefix = "vec4";
      if (attribute3.pbo.type === UnsignedIntType) {
        prefix = "uvec4";
      } else if (attribute3.pbo.type === IntType) {
        prefix = "ivec4";
      }
      this.addLineFlowCode(`${propertyName} = ${prefix}(${snippet})${channel}`, storageArrayElementNode);
      elementNodeData.propertyName = propertyName;
    }
    return propertyName;
  }
  /**
   * Generates the GLSL snippet that reads a single texel from a texture without sampling or filtering.
   *
   * @param {?Texture} texture - The texture.
   * @param {string} textureProperty - The name of the texture uniform in the shader.
   * @param {string} uvIndexSnippet - A GLSL snippet that represents texture coordinates used for sampling.
   * @param {?string} depthSnippet - A GLSL snippet that represents the 0-based texture array index to sample.
   * @param {?string} offsetSnippet - A GLSL snippet that represents the offset that will be applied to the unnormalized texture coordinate before sampling the texture.
   * @param {string} [levelSnippet='0u'] - A GLSL snippet that represents the mip level, with level 0 containing a full size version of the texture.
   * @return {string} The GLSL snippet.
   */
  generateTextureLoad(texture3, textureProperty, uvIndexSnippet, depthSnippet, offsetSnippet, levelSnippet = "0") {
    let snippet;
    if (depthSnippet) {
      if (offsetSnippet) {
        snippet = `texelFetchOffset( ${textureProperty}, ivec3( ${uvIndexSnippet}, ${depthSnippet} ), ${levelSnippet}, ${offsetSnippet} )`;
      } else {
        snippet = `texelFetch( ${textureProperty}, ivec3( ${uvIndexSnippet}, ${depthSnippet} ), ${levelSnippet} )`;
      }
    } else {
      if (offsetSnippet) {
        snippet = `texelFetchOffset( ${textureProperty}, ${uvIndexSnippet}, ${levelSnippet}, ${offsetSnippet} )`;
      } else {
        snippet = `texelFetch( ${textureProperty}, ${uvIndexSnippet}, ${levelSnippet} )`;
      }
    }
    if (texture3 !== null && texture3.isDepthTexture) {
      snippet += ".x";
    }
    return snippet;
  }
  /**
   * Generates the GLSL snippet for sampling/loading the given texture.
   *
   * @param {Texture} texture - The texture.
   * @param {string} textureProperty - The name of the texture uniform in the shader.
   * @param {string} uvSnippet - A GLSL snippet that represents texture coordinates used for sampling.
   * @param {?string} depthSnippet -  A GLSL snippet that represents the 0-based texture array index to sample.
   * @param {?string} offsetSnippet - A GLSL snippet that represents the offset that will be applied to the unnormalized texture coordinate before sampling the texture.
   * @return {string} The GLSL snippet.
   */
  generateTexture(texture3, textureProperty, uvSnippet, depthSnippet, offsetSnippet) {
    if (depthSnippet) uvSnippet = `vec3( ${uvSnippet}, ${depthSnippet} )`;
    if (texture3.isDepthTexture) {
      if (offsetSnippet) return `textureOffset( ${textureProperty}, ${uvSnippet}, ${offsetSnippet} ).x`;
      return `texture( ${textureProperty}, ${uvSnippet} ).x`;
    }
    if (offsetSnippet) return `textureOffset( ${textureProperty}, ${uvSnippet}, ${offsetSnippet} )`;
    return `texture( ${textureProperty}, ${uvSnippet} )`;
  }
  /**
   * Generates the GLSL snippet when sampling textures with explicit mip level.
   *
   * @param {Texture} texture - The texture.
   * @param {string} textureProperty - The name of the texture uniform in the shader.
   * @param {string} uvSnippet - A GLSL snippet that represents texture coordinates used for sampling.
   * @param {string} levelSnippet - A GLSL snippet that represents the mip level, with level 0 containing a full size version of the texture.
   * @param {?string} offsetSnippet - A GLSL snippet that represents the offset that will be applied to the unnormalized texture coordinate before sampling the texture.
   * @return {string} The GLSL snippet.
   */
  generateTextureLevel(texture3, textureProperty, uvSnippet, levelSnippet, offsetSnippet) {
    if (offsetSnippet) {
      return `textureLodOffset( ${textureProperty}, ${uvSnippet}, ${levelSnippet}, ${offsetSnippet} )`;
    }
    return `textureLod( ${textureProperty}, ${uvSnippet}, ${levelSnippet} )`;
  }
  /**
   * Generates the GLSL snippet when sampling textures with a bias to the mip level.
   *
   * @param {Texture} texture - The texture.
   * @param {string} textureProperty - The name of the texture uniform in the shader.
   * @param {string} uvSnippet - A GLSL snippet that represents texture coordinates used for sampling.
   * @param {string} biasSnippet - A GLSL snippet that represents the bias to apply to the mip level before sampling.
   * @param {?string} offsetSnippet - A GLSL snippet that represents the offset that will be applied to the unnormalized texture coordinate before sampling the texture.
   * @return {string} The GLSL snippet.
   */
  generateTextureBias(texture3, textureProperty, uvSnippet, biasSnippet, offsetSnippet) {
    if (offsetSnippet) {
      return `textureOffset( ${textureProperty}, ${uvSnippet}, ${offsetSnippet}, ${biasSnippet} )`;
    }
    return `texture( ${textureProperty}, ${uvSnippet}, ${biasSnippet} )`;
  }
  /**
   * Generates the GLSL snippet for sampling/loading the given texture using explicit gradients.
   *
   * @param {Texture} texture - The texture.
   * @param {string} textureProperty - The name of the texture uniform in the shader.
   * @param {string} uvSnippet - A GLSL snippet that represents texture coordinates used for sampling.
   * @param {Array<string>} gradSnippet - An array holding both gradient GLSL snippets.
   * @param {?string} offsetSnippet - A GLSL snippet that represents the offset that will be applied to the unnormalized texture coordinate before sampling the texture.
   * @return {string} The GLSL snippet.
   */
  generateTextureGrad(texture3, textureProperty, uvSnippet, gradSnippet, offsetSnippet) {
    if (offsetSnippet) {
      return `textureGradOffset( ${textureProperty}, ${uvSnippet}, ${gradSnippet[0]}, ${gradSnippet[1]}, ${offsetSnippet} )`;
    }
    return `textureGrad( ${textureProperty}, ${uvSnippet}, ${gradSnippet[0]}, ${gradSnippet[1]} )`;
  }
  /**
   * Generates the GLSL snippet for sampling a depth texture and comparing the sampled depth values
   * against a reference value.
   *
   * @param {Texture} texture - The texture.
   * @param {string} textureProperty - The name of the texture uniform in the shader.
   * @param {string} uvSnippet - A GLSL snippet that represents texture coordinates used for sampling.
   * @param {string} compareSnippet -  A GLSL snippet that represents the reference value.
   * @param {?string} depthSnippet - A GLSL snippet that represents 0-based texture array index to sample.
   * @param {?string} offsetSnippet - A GLSL snippet that represents the offset that will be applied to the unnormalized texture coordinate before sampling the texture.
   * @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.
   * @return {string} The GLSL snippet.
   */
  generateTextureCompare(texture3, textureProperty, uvSnippet, compareSnippet, depthSnippet, offsetSnippet, shaderStage = this.shaderStage) {
    if (shaderStage === "fragment") {
      if (depthSnippet) {
        if (offsetSnippet) {
          return `textureOffset( ${textureProperty}, vec4( ${uvSnippet}, ${depthSnippet}, ${compareSnippet} ), ${offsetSnippet} )`;
        }
        return `texture( ${textureProperty}, vec4( ${uvSnippet}, ${depthSnippet}, ${compareSnippet} ) )`;
      }
      if (offsetSnippet) {
        return `textureOffset( ${textureProperty}, vec3( ${uvSnippet}, ${compareSnippet} ), ${offsetSnippet} )`;
      }
      return `texture( ${textureProperty}, vec3( ${uvSnippet}, ${compareSnippet} ) )`;
    } else {
      console.error(`WebGPURenderer: THREE.DepthTexture.compareFunction() does not support ${shaderStage} shader.`);
    }
  }
  /**
   * Returns the variables of the given shader stage as a GLSL string.
   *
   * @param {string} shaderStage - The shader stage.
   * @return {string} The GLSL snippet that defines the variables.
   */
  getVars(shaderStage) {
    const snippets = [];
    const vars = this.vars[shaderStage];
    if (vars !== void 0) {
      for (const variable of vars) {
        snippets.push(`${this.getVar(variable.type, variable.name, variable.count)};`);
      }
    }
    return snippets.join("\n	");
  }
  /**
   * Returns the uniforms of the given shader stage as a GLSL string.
   *
   * @param {string} shaderStage - The shader stage.
   * @return {string} The GLSL snippet that defines the uniforms.
   */
  getUniforms(shaderStage) {
    const uniforms = this.uniforms[shaderStage];
    const bindingSnippets = [];
    const uniformGroups = {};
    for (const uniform3 of uniforms) {
      let snippet = null;
      let group2 = false;
      if (uniform3.type === "texture" || uniform3.type === "texture3D") {
        const texture3 = uniform3.node.value;
        let typePrefix = "";
        if (texture3.isDataTexture === true || texture3.isData3DTexture === true) {
          if (texture3.type === UnsignedIntType) {
            typePrefix = "u";
          } else if (texture3.type === IntType) {
            typePrefix = "i";
          }
        }
        if (uniform3.type === "texture3D" && texture3.isArrayTexture === false) {
          snippet = `${typePrefix}sampler3D ${uniform3.name};`;
        } else if (texture3.compareFunction) {
          if (texture3.isArrayTexture === true) {
            snippet = `sampler2DArrayShadow ${uniform3.name};`;
          } else {
            snippet = `sampler2DShadow ${uniform3.name};`;
          }
        } else if (texture3.isArrayTexture === true || texture3.isDataArrayTexture === true || texture3.isCompressedArrayTexture === true) {
          snippet = `${typePrefix}sampler2DArray ${uniform3.name};`;
        } else {
          snippet = `${typePrefix}sampler2D ${uniform3.name};`;
        }
      } else if (uniform3.type === "cubeTexture") {
        snippet = `samplerCube ${uniform3.name};`;
      } else if (uniform3.type === "buffer") {
        const bufferNode = uniform3.node;
        const bufferType = this.getType(bufferNode.bufferType);
        const bufferCount = bufferNode.bufferCount;
        const bufferCountSnippet = bufferCount > 0 ? bufferCount : "";
        snippet = `${bufferNode.name} {
	${bufferType} ${uniform3.name}[${bufferCountSnippet}];
};
`;
      } else {
        const vectorType = this.getVectorType(uniform3.type);
        snippet = `${vectorType} ${this.getPropertyName(uniform3, shaderStage)};`;
        group2 = true;
      }
      const precision = uniform3.node.precision;
      if (precision !== null) {
        snippet = precisionLib[precision] + " " + snippet;
      }
      if (group2) {
        snippet = "	" + snippet;
        const groupName = uniform3.groupNode.name;
        const groupSnippets = uniformGroups[groupName] || (uniformGroups[groupName] = []);
        groupSnippets.push(snippet);
      } else {
        snippet = "uniform " + snippet;
        bindingSnippets.push(snippet);
      }
    }
    let output3 = "";
    for (const name in uniformGroups) {
      const groupSnippets = uniformGroups[name];
      output3 += this._getGLSLUniformStruct(shaderStage + "_" + name, groupSnippets.join("\n")) + "\n";
    }
    output3 += bindingSnippets.join("\n");
    return output3;
  }
  /**
   * Returns the type for a given buffer attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute.
   * @return {string} The type.
   */
  getTypeFromAttribute(attribute3) {
    let nodeType = super.getTypeFromAttribute(attribute3);
    if (/^[iu]/.test(nodeType) && attribute3.gpuType !== IntType) {
      let dataAttribute = attribute3;
      if (attribute3.isInterleavedBufferAttribute) dataAttribute = attribute3.data;
      const array4 = dataAttribute.array;
      if ((array4 instanceof Uint32Array || array4 instanceof Int32Array) === false) {
        nodeType = nodeType.slice(1);
      }
    }
    return nodeType;
  }
  /**
   * Returns the shader attributes of the given shader stage as a GLSL string.
   *
   * @param {string} shaderStage - The shader stage.
   * @return {string} The GLSL snippet that defines the shader attributes.
   */
  getAttributes(shaderStage) {
    let snippet = "";
    if (shaderStage === "vertex" || shaderStage === "compute") {
      const attributes = this.getAttributesArray();
      let location = 0;
      for (const attribute3 of attributes) {
        snippet += `layout( location = ${location++} ) in ${attribute3.type} ${attribute3.name};
`;
      }
    }
    return snippet;
  }
  /**
   * Returns the members of the given struct type node as a GLSL string.
   *
   * @param {StructTypeNode} struct - The struct type node.
   * @return {string} The GLSL snippet that defines the struct members.
   */
  getStructMembers(struct3) {
    const snippets = [];
    for (const member of struct3.members) {
      snippets.push(`	${member.type} ${member.name};`);
    }
    return snippets.join("\n");
  }
  /**
   * Returns the structs of the given shader stage as a GLSL string.
   *
   * @param {string} shaderStage - The shader stage.
   * @return {string} The GLSL snippet that defines the structs.
   */
  getStructs(shaderStage) {
    const snippets = [];
    const structs = this.structs[shaderStage];
    const outputSnippet = [];
    for (const struct3 of structs) {
      if (struct3.output) {
        for (const member of struct3.members) {
          outputSnippet.push(`layout( location = ${member.index} ) out ${member.type} ${member.name};`);
        }
      } else {
        let snippet = "struct " + struct3.name + " {\n";
        snippet += this.getStructMembers(struct3);
        snippet += "\n};\n";
        snippets.push(snippet);
      }
    }
    if (outputSnippet.length === 0) {
      outputSnippet.push("layout( location = 0 ) out vec4 fragColor;");
    }
    return "\n" + outputSnippet.join("\n") + "\n\n" + snippets.join("\n");
  }
  /**
   * Returns the varyings of the given shader stage as a GLSL string.
   *
   * @param {string} shaderStage - The shader stage.
   * @return {string} The GLSL snippet that defines the varyings.
   */
  getVaryings(shaderStage) {
    let snippet = "";
    const varyings = this.varyings;
    if (shaderStage === "vertex" || shaderStage === "compute") {
      for (const varying3 of varyings) {
        if (shaderStage === "compute") varying3.needsInterpolation = true;
        const type = this.getType(varying3.type);
        if (varying3.needsInterpolation) {
          if (varying3.interpolationType) {
            const interpolationType = interpolationTypeMap[varying3.interpolationType] || varying3.interpolationType;
            const sampling = interpolationModeMap[varying3.interpolationSampling] || "";
            snippet += `${interpolationType} ${sampling} out ${type} ${varying3.name};
`;
          } else {
            const flat = type.includes("int") || type.includes("uv") || type.includes("iv") ? "flat " : "";
            snippet += `${flat}out ${type} ${varying3.name};
`;
          }
        } else {
          snippet += `${type} ${varying3.name};
`;
        }
      }
    } else if (shaderStage === "fragment") {
      for (const varying3 of varyings) {
        if (varying3.needsInterpolation) {
          const type = this.getType(varying3.type);
          if (varying3.interpolationType) {
            const interpolationType = interpolationTypeMap[varying3.interpolationType] || varying3.interpolationType;
            const sampling = interpolationModeMap[varying3.interpolationSampling] || "";
            snippet += `${interpolationType} ${sampling} in ${type} ${varying3.name};
`;
          } else {
            const flat = type.includes("int") || type.includes("uv") || type.includes("iv") ? "flat " : "";
            snippet += `${flat}in ${type} ${varying3.name};
`;
          }
        }
      }
    }
    for (const builtin3 of this.builtins[shaderStage]) {
      snippet += `${builtin3};
`;
    }
    return snippet;
  }
  /**
   * Returns the vertex index builtin.
   *
   * @return {string} The vertex index.
   */
  getVertexIndex() {
    return "uint( gl_VertexID )";
  }
  /**
   * Returns the instance index builtin.
   *
   * @return {string} The instance index.
   */
  getInstanceIndex() {
    return "uint( gl_InstanceID )";
  }
  /**
   * Returns the invocation local index builtin.
   *
   * @return {string} The invocation local index.
   */
  getInvocationLocalIndex() {
    const workgroupSize = this.object.workgroupSize;
    const size = workgroupSize.reduce((acc, curr) => acc * curr, 1);
    return `uint( gl_InstanceID ) % ${size}u`;
  }
  /**
   * Returns the draw index builtin.
   *
   * @return {?string} The drawIndex shader string. Returns `null` if `WEBGL_multi_draw` isn't supported by the device.
   */
  getDrawIndex() {
    const extensions = this.renderer.backend.extensions;
    if (extensions.has("WEBGL_multi_draw")) {
      return "uint( gl_DrawID )";
    }
    return null;
  }
  /**
   * Returns the front facing builtin.
   *
   * @return {string} The front facing builtin.
   */
  getFrontFacing() {
    return "gl_FrontFacing";
  }
  /**
   * Returns the frag coord builtin.
   *
   * @return {string} The frag coord builtin.
   */
  getFragCoord() {
    return "gl_FragCoord.xy";
  }
  /**
   * Returns the frag depth builtin.
   *
   * @return {string} The frag depth builtin.
   */
  getFragDepth() {
    return "gl_FragDepth";
  }
  /**
   * Enables the given extension.
   *
   * @param {string} name - The extension name.
   * @param {string} behavior - The extension behavior.
   * @param {string} [shaderStage=this.shaderStage] - The shader stage.
   */
  enableExtension(name, behavior, shaderStage = this.shaderStage) {
    const map4 = this.extensions[shaderStage] || (this.extensions[shaderStage] = /* @__PURE__ */ new Map());
    if (map4.has(name) === false) {
      map4.set(name, {
        name,
        behavior
      });
    }
  }
  /**
   * Returns the enabled extensions of the given shader stage as a GLSL string.
   *
   * @param {string} shaderStage - The shader stage.
   * @return {string} The GLSL snippet that defines the enabled extensions.
   */
  getExtensions(shaderStage) {
    const snippets = [];
    if (shaderStage === "vertex") {
      const ext = this.renderer.backend.extensions;
      const isBatchedMesh = this.object.isBatchedMesh;
      if (isBatchedMesh && ext.has("WEBGL_multi_draw")) {
        this.enableExtension("GL_ANGLE_multi_draw", "require", shaderStage);
      }
    }
    const extensions = this.extensions[shaderStage];
    if (extensions !== void 0) {
      for (const { name, behavior } of extensions.values()) {
        snippets.push(`#extension ${name} : ${behavior}`);
      }
    }
    return snippets.join("\n");
  }
  /**
   * Returns the clip distances builtin.
   *
   * @return {string} The clip distances builtin.
   */
  getClipDistance() {
    return "gl_ClipDistance";
  }
  /**
   * Whether the requested feature is available or not.
   *
   * @param {string} name - The requested feature.
   * @return {boolean} Whether the requested feature is supported or not.
   */
  isAvailable(name) {
    let result = supports$1[name];
    if (result === void 0) {
      let extensionName;
      result = false;
      switch (name) {
        case "float32Filterable":
          extensionName = "OES_texture_float_linear";
          break;
        case "clipDistance":
          extensionName = "WEBGL_clip_cull_distance";
          break;
      }
      if (extensionName !== void 0) {
        const extensions = this.renderer.backend.extensions;
        if (extensions.has(extensionName)) {
          extensions.get(extensionName);
          result = true;
        }
      }
      supports$1[name] = result;
    }
    return result;
  }
  /**
   * Whether to flip texture data along its vertical axis or not.
   *
   * @return {boolean} Returns always `true` in context of GLSL.
   */
  isFlipY() {
    return true;
  }
  /**
   * Enables hardware clipping.
   *
   * @param {string} planeCount - The clipping plane count.
   */
  enableHardwareClipping(planeCount) {
    this.enableExtension("GL_ANGLE_clip_cull_distance", "require");
    this.builtins["vertex"].push(`out float gl_ClipDistance[ ${planeCount} ]`);
  }
  /**
   * Enables multiview.
   */
  enableMultiview() {
    this.enableExtension("GL_OVR_multiview2", "require", "fragment");
    this.enableExtension("GL_OVR_multiview2", "require", "vertex");
    this.builtins["vertex"].push("layout(num_views = 2) in");
  }
  /**
   * Registers a transform in context of Transform Feedback.
   *
   * @param {string} varyingName - The varying name.
   * @param {AttributeNode} attributeNode - The attribute node.
   */
  registerTransform(varyingName, attributeNode) {
    this.transforms.push({ varyingName, attributeNode });
  }
  /**
   * Returns the transforms of the given shader stage as a GLSL string.
   *
   * @param {string} shaderStage - The shader stage.
   * @return {string} The GLSL snippet that defines the transforms.
   */
  getTransforms() {
    const transforms = this.transforms;
    let snippet = "";
    for (let i = 0; i < transforms.length; i++) {
      const transform = transforms[i];
      const attributeName = this.getPropertyName(transform.attributeNode);
      if (attributeName) snippet += `${transform.varyingName} = ${attributeName};
	`;
    }
    return snippet;
  }
  /**
   * Returns a GLSL struct based on the given name and variables.
   *
   * @private
   * @param {string} name - The struct name.
   * @param {string} vars - The struct variables.
   * @return {string} The GLSL snippet representing a struct.
   */
  _getGLSLUniformStruct(name, vars) {
    return `
layout( std140 ) uniform ${name} {
${vars}
};`;
  }
  /**
   * Returns a GLSL vertex shader based on the given shader data.
   *
   * @private
   * @param {Object} shaderData - The shader data.
   * @return {string} The vertex shader.
   */
  _getGLSLVertexCode(shaderData) {
    return `#version 300 es

${this.getSignature()}

// extensions
${shaderData.extensions}

// precision
${defaultPrecisions}

// uniforms
${shaderData.uniforms}

// varyings
${shaderData.varyings}

// attributes
${shaderData.attributes}

// codes
${shaderData.codes}

void main() {

	// vars
	${shaderData.vars}

	// transforms
	${shaderData.transforms}

	// flow
	${shaderData.flow}

	gl_PointSize = 1.0;

}
`;
  }
  /**
   * Returns a GLSL fragment shader based on the given shader data.
   *
   * @private
   * @param {Object} shaderData - The shader data.
   * @return {string} The vertex shader.
   */
  _getGLSLFragmentCode(shaderData) {
    return `#version 300 es

${this.getSignature()}

// extensions
${shaderData.extensions}

// precision
${defaultPrecisions}

// uniforms
${shaderData.uniforms}

// varyings
${shaderData.varyings}

// codes
${shaderData.codes}

// structs
${shaderData.structs}

void main() {

	// vars
	${shaderData.vars}

	// flow
	${shaderData.flow}

}
`;
  }
  /**
   * Controls the code build of the shader stages.
   */
  buildCode() {
    const shadersData = this.material !== null ? { fragment: {}, vertex: {} } : { compute: {} };
    this.sortBindingGroups();
    for (const shaderStage in shadersData) {
      let flow = "// code\n\n";
      flow += this.flowCode[shaderStage];
      const flowNodes = this.flowNodes[shaderStage];
      const mainNode = flowNodes[flowNodes.length - 1];
      for (const node of flowNodes) {
        const flowSlotData = this.getFlowData(
          node
          /*, shaderStage*/
        );
        const slotName = node.name;
        if (slotName) {
          if (flow.length > 0) flow += "\n";
          flow += `	// flow -> ${slotName}
	`;
        }
        flow += `${flowSlotData.code}
	`;
        if (node === mainNode && shaderStage !== "compute") {
          flow += "// result\n	";
          if (shaderStage === "vertex") {
            flow += "gl_Position = ";
            flow += `${flowSlotData.result};`;
          } else if (shaderStage === "fragment") {
            if (!node.outputNode.isOutputStructNode) {
              flow += "fragColor = ";
              flow += `${flowSlotData.result};`;
            }
          }
        }
      }
      const stageData = shadersData[shaderStage];
      stageData.extensions = this.getExtensions(shaderStage);
      stageData.uniforms = this.getUniforms(shaderStage);
      stageData.attributes = this.getAttributes(shaderStage);
      stageData.varyings = this.getVaryings(shaderStage);
      stageData.vars = this.getVars(shaderStage);
      stageData.structs = this.getStructs(shaderStage);
      stageData.codes = this.getCodes(shaderStage);
      stageData.transforms = this.getTransforms(shaderStage);
      stageData.flow = flow;
    }
    if (this.material !== null) {
      this.vertexShader = this._getGLSLVertexCode(shadersData.vertex);
      this.fragmentShader = this._getGLSLFragmentCode(shadersData.fragment);
    } else {
      this.computeShader = this._getGLSLVertexCode(shadersData.compute);
    }
  }
  /**
   * This method is one of the more important ones since it's responsible
   * for generating a matching binding instance for the given uniform node.
   *
   * These bindings are later used in the renderer to create bind groups
   * and layouts.
   *
   * @param {UniformNode} node - The uniform node.
   * @param {string} type - The node data type.
   * @param {string} shaderStage - The shader stage.
   * @param {?string} [name=null] - An optional uniform name.
   * @return {NodeUniform} The node uniform object.
   */
  getUniformFromNode(node, type, shaderStage, name = null) {
    const uniformNode = super.getUniformFromNode(node, type, shaderStage, name);
    const nodeData = this.getDataFromNode(node, shaderStage, this.globalCache);
    let uniformGPU = nodeData.uniformGPU;
    if (uniformGPU === void 0) {
      const group2 = node.groupNode;
      const groupName = group2.name;
      const bindings = this.getBindGroupArray(groupName, shaderStage);
      if (type === "texture") {
        uniformGPU = new NodeSampledTexture(uniformNode.name, uniformNode.node, group2);
        bindings.push(uniformGPU);
      } else if (type === "cubeTexture") {
        uniformGPU = new NodeSampledCubeTexture(uniformNode.name, uniformNode.node, group2);
        bindings.push(uniformGPU);
      } else if (type === "texture3D") {
        uniformGPU = new NodeSampledTexture3D(uniformNode.name, uniformNode.node, group2);
        bindings.push(uniformGPU);
      } else if (type === "buffer") {
        node.name = `NodeBuffer_${node.id}`;
        uniformNode.name = `buffer${node.id}`;
        const buffer3 = new NodeUniformBuffer(node, group2);
        buffer3.name = node.name;
        bindings.push(buffer3);
        uniformGPU = buffer3;
      } else {
        const uniformsStage = this.uniformGroups[shaderStage] || (this.uniformGroups[shaderStage] = {});
        let uniformsGroup = uniformsStage[groupName];
        if (uniformsGroup === void 0) {
          uniformsGroup = new NodeUniformsGroup(shaderStage + "_" + groupName, group2);
          uniformsStage[groupName] = uniformsGroup;
          bindings.push(uniformsGroup);
        }
        uniformGPU = this.getNodeUniform(uniformNode, type);
        uniformsGroup.addUniform(uniformGPU);
      }
      nodeData.uniformGPU = uniformGPU;
    }
    return uniformNode;
  }
};
var _vector2 = null;
var _color4 = null;
var Backend = class {
  /**
   * Constructs a new backend.
   *
   * @param {Object} parameters - An object holding parameters for the backend.
   */
  constructor(parameters = {}) {
    this.parameters = Object.assign({}, parameters);
    this.data = /* @__PURE__ */ new WeakMap();
    this.renderer = null;
    this.domElement = null;
    this.timestampQueryPool = {
      "render": null,
      "compute": null
    };
    this.trackTimestamp = parameters.trackTimestamp === true;
  }
  /**
   * Initializes the backend so it is ready for usage. Concrete backends
   * are supposed to implement their rendering context creation and related
   * operations in this method.
   *
   * @async
   * @param {Renderer} renderer - The renderer.
   * @return {Promise} A Promise that resolves when the backend has been initialized.
   */
  async init(renderer) {
    this.renderer = renderer;
  }
  /**
   * The coordinate system of the backend.
   *
   * @abstract
   * @type {number}
   * @readonly
   */
  get coordinateSystem() {
  }
  // render context
  /**
   * This method is executed at the beginning of a render call and
   * can be used by the backend to prepare the state for upcoming
   * draw calls.
   *
   * @abstract
   * @param {RenderContext} renderContext - The render context.
   */
  beginRender() {
  }
  /**
   * This method is executed at the end of a render call and
   * can be used by the backend to finalize work after draw
   * calls.
   *
   * @abstract
   * @param {RenderContext} renderContext - The render context.
   */
  finishRender() {
  }
  /**
   * This method is executed at the beginning of a compute call and
   * can be used by the backend to prepare the state for upcoming
   * compute tasks.
   *
   * @abstract
   * @param {Node|Array<Node>} computeGroup - The compute node(s).
   */
  beginCompute() {
  }
  /**
   * This method is executed at the end of a compute call and
   * can be used by the backend to finalize work after compute
   * tasks.
   *
   * @abstract
   * @param {Node|Array<Node>} computeGroup - The compute node(s).
   */
  finishCompute() {
  }
  // render object
  /**
   * Executes a draw command for the given render object.
   *
   * @abstract
   * @param {RenderObject} renderObject - The render object to draw.
   * @param {Info} info - Holds a series of statistical information about the GPU memory and the rendering process.
   */
  draw() {
  }
  // compute node
  /**
   * Executes a compute command for the given compute node.
   *
   * @abstract
   * @param {Node|Array<Node>} computeGroup - The group of compute nodes of a compute call. Can be a single compute node.
   * @param {Node} computeNode - The compute node.
   * @param {Array<BindGroup>} bindings - The bindings.
   * @param {ComputePipeline} computePipeline - The compute pipeline.
   */
  compute() {
  }
  // program
  /**
   * Creates a shader program from the given programmable stage.
   *
   * @abstract
   * @param {ProgrammableStage} program - The programmable stage.
   */
  createProgram() {
  }
  /**
   * Destroys the shader program of the given programmable stage.
   *
   * @abstract
   * @param {ProgrammableStage} program - The programmable stage.
   */
  destroyProgram() {
  }
  // bindings
  /**
   * Creates bindings from the given bind group definition.
   *
   * @abstract
   * @param {BindGroup} bindGroup - The bind group.
   * @param {Array<BindGroup>} bindings - Array of bind groups.
   * @param {number} cacheIndex - The cache index.
   * @param {number} version - The version.
   */
  createBindings() {
  }
  /**
   * Updates the given bind group definition.
   *
   * @abstract
   * @param {BindGroup} bindGroup - The bind group.
   * @param {Array<BindGroup>} bindings - Array of bind groups.
   * @param {number} cacheIndex - The cache index.
   * @param {number} version - The version.
   */
  updateBindings() {
  }
  /**
   * Updates a buffer binding.
   *
   * @abstract
   * @param {Buffer} binding - The buffer binding to update.
   */
  updateBinding() {
  }
  // pipeline
  /**
   * Creates a render pipeline for the given render object.
   *
   * @abstract
   * @param {RenderObject} renderObject - The render object.
   * @param {Array<Promise>} promises - An array of compilation promises which are used in `compileAsync()`.
   */
  createRenderPipeline() {
  }
  /**
   * Creates a compute pipeline for the given compute node.
   *
   * @abstract
   * @param {ComputePipeline} computePipeline - The compute pipeline.
   * @param {Array<BindGroup>} bindings - The bindings.
   */
  createComputePipeline() {
  }
  // cache key
  /**
   * Returns `true` if the render pipeline requires an update.
   *
   * @abstract
   * @param {RenderObject} renderObject - The render object.
   * @return {boolean} Whether the render pipeline requires an update or not.
   */
  needsRenderUpdate() {
  }
  /**
   * Returns a cache key that is used to identify render pipelines.
   *
   * @abstract
   * @param {RenderObject} renderObject - The render object.
   * @return {string} The cache key.
   */
  getRenderCacheKey() {
  }
  // node builder
  /**
   * Returns a node builder for the given render object.
   *
   * @abstract
   * @param {RenderObject} renderObject - The render object.
   * @param {Renderer} renderer - The renderer.
   * @return {NodeBuilder} The node builder.
   */
  createNodeBuilder() {
  }
  // textures
  /**
   * Creates a GPU sampler for the given texture.
   *
   * @abstract
   * @param {Texture} texture - The texture to create the sampler for.
   */
  createSampler() {
  }
  /**
   * Destroys the GPU sampler for the given texture.
   *
   * @abstract
   * @param {Texture} texture - The texture to destroy the sampler for.
   */
  destroySampler() {
  }
  /**
   * Creates a default texture for the given texture that can be used
   * as a placeholder until the actual texture is ready for usage.
   *
   * @abstract
   * @param {Texture} texture - The texture to create a default texture for.
   */
  createDefaultTexture() {
  }
  /**
   * Defines a texture on the GPU for the given texture object.
   *
   * @abstract
   * @param {Texture} texture - The texture.
   * @param {Object} [options={}] - Optional configuration parameter.
   */
  createTexture() {
  }
  /**
   * Uploads the updated texture data to the GPU.
   *
   * @abstract
   * @param {Texture} texture - The texture.
   * @param {Object} [options={}] - Optional configuration parameter.
   */
  updateTexture() {
  }
  /**
   * Generates mipmaps for the given texture.
   *
   * @abstract
   * @param {Texture} texture - The texture.
   */
  generateMipmaps() {
  }
  /**
   * Destroys the GPU data for the given texture object.
   *
   * @abstract
   * @param {Texture} texture - The texture.
   */
  destroyTexture() {
  }
  /**
   * Returns texture data as a typed array.
   *
   * @abstract
   * @async
   * @param {Texture} texture - The texture to copy.
   * @param {number} x - The x coordinate of the copy origin.
   * @param {number} y - The y coordinate of the copy origin.
   * @param {number} width - The width of the copy.
   * @param {number} height - The height of the copy.
   * @param {number} faceIndex - The face index.
   * @return {Promise<TypedArray>} A Promise that resolves with a typed array when the copy operation has finished.
   */
  async copyTextureToBuffer() {
  }
  /**
   * Copies data of the given source texture to the given destination texture.
   *
   * @abstract
   * @param {Texture} srcTexture - The source texture.
   * @param {Texture} dstTexture - The destination texture.
   * @param {?(Box3|Box2)} [srcRegion=null] - The region of the source texture to copy.
   * @param {?(Vector2|Vector3)} [dstPosition=null] - The destination position of the copy.
   * @param {number} [srcLevel=0] - The source mip level to copy from.
   * @param {number} [dstLevel=0] - The destination mip level to copy to.
   */
  copyTextureToTexture() {
  }
  /**
  * Copies the current bound framebuffer to the given texture.
  *
  * @abstract
  * @param {Texture} texture - The destination texture.
  * @param {RenderContext} renderContext - The render context.
  * @param {Vector4} rectangle - A four dimensional vector defining the origin and dimension of the copy.
  */
  copyFramebufferToTexture() {
  }
  // attributes
  /**
   * Creates the GPU buffer of a shader attribute.
   *
   * @abstract
   * @param {BufferAttribute} attribute - The buffer attribute.
   */
  createAttribute() {
  }
  /**
   * Creates the GPU buffer of an indexed shader attribute.
   *
   * @abstract
   * @param {BufferAttribute} attribute - The indexed buffer attribute.
   */
  createIndexAttribute() {
  }
  /**
   * Creates the GPU buffer of a storage attribute.
   *
   * @abstract
   * @param {BufferAttribute} attribute - The buffer attribute.
   */
  createStorageAttribute() {
  }
  /**
   * Updates the GPU buffer of a shader attribute.
   *
   * @abstract
   * @param {BufferAttribute} attribute - The buffer attribute to update.
   */
  updateAttribute() {
  }
  /**
   * Destroys the GPU buffer of a shader attribute.
   *
   * @abstract
   * @param {BufferAttribute} attribute - The buffer attribute to destroy.
   */
  destroyAttribute() {
  }
  // canvas
  /**
   * Returns the backend's rendering context.
   *
   * @abstract
   * @return {Object} The rendering context.
   */
  getContext() {
  }
  /**
   * Backends can use this method if they have to run
   * logic when the renderer gets resized.
   *
   * @abstract
   */
  updateSize() {
  }
  /**
   * Updates the viewport with the values from the given render context.
   *
   * @abstract
   * @param {RenderContext} renderContext - The render context.
   */
  updateViewport() {
  }
  // utils
  /**
   * Returns a unique identifier for the given render context that can be used
   * to allocate resources like occlusion queries or timestamp queries.
   *
   * @param {RenderContext|ComputeNode} abstractRenderContext - The render context.
   * @return {string} The unique identifier.
   */
  getTimestampUID(abstractRenderContext) {
    const contextData = this.get(abstractRenderContext);
    let uid = abstractRenderContext.isComputeNode === true ? "c" : "r";
    uid += ":" + contextData.frameCalls + ":" + abstractRenderContext.id;
    return uid;
  }
  /**
   * Returns `true` if the given 3D object is fully occluded by other
   * 3D objects in the scene. Backends must implement this method by using
   * a Occlusion Query API.
   *
   * @abstract
   * @param {RenderContext} renderContext - The render context.
   * @param {Object3D} object - The 3D object to test.
   * @return {boolean} Whether the 3D object is fully occluded or not.
   */
  isOccluded() {
  }
  /**
   * Resolves the time stamp for the given render context and type.
   *
   * @async
   * @abstract
   * @param {string} [type='render'] - The type of the time stamp.
   * @return {Promise<number>} A Promise that resolves with the time stamp.
   */
  async resolveTimestampsAsync(type = "render") {
    if (!this.trackTimestamp) {
      warnOnce("WebGPURenderer: Timestamp tracking is disabled.");
      return;
    }
    const queryPool = this.timestampQueryPool[type];
    if (!queryPool) {
      warnOnce(`WebGPURenderer: No timestamp query pool for type '${type}' found.`);
      return;
    }
    const duration = await queryPool.resolveQueriesAsync();
    this.renderer.info[type].timestamp = duration;
    return duration;
  }
  /**
   * Can be used to synchronize CPU operations with GPU tasks. So when this method is called,
   * the CPU waits for the GPU to complete its operation (e.g. a compute task).
   *
   * @async
   * @abstract
   * @return {Promise} A Promise that resolves when synchronization has been finished.
   */
  async waitForGPU() {
  }
  /**
   * This method performs a readback operation by moving buffer data from
   * a storage buffer attribute from the GPU to the CPU.
   *
   * @async
   * @param {StorageBufferAttribute} attribute - The storage buffer attribute.
   * @return {Promise<ArrayBuffer>} A promise that resolves with the buffer data when the data are ready.
   */
  async getArrayBufferAsync() {
  }
  /**
   * Checks if the given feature is supported by the backend.
   *
   * @async
   * @abstract
   * @param {string} name - The feature's name.
   * @return {Promise<boolean>} A Promise that resolves with a bool that indicates whether the feature is supported or not.
   */
  async hasFeatureAsync() {
  }
  /**
   * Checks if the given feature is supported  by the backend.
   *
   * @abstract
   * @param {string} name - The feature's name.
   * @return {boolean} Whether the feature is supported or not.
   */
  hasFeature() {
  }
  /**
   * Returns the maximum anisotropy texture filtering value.
   *
   * @abstract
   * @return {number} The maximum anisotropy texture filtering value.
   */
  getMaxAnisotropy() {
  }
  /**
   * Returns the drawing buffer size.
   *
   * @return {Vector2} The drawing buffer size.
   */
  getDrawingBufferSize() {
    _vector2 = _vector2 || new Vector2();
    return this.renderer.getDrawingBufferSize(_vector2);
  }
  /**
   * Defines the scissor test.
   *
   * @abstract
   * @param {boolean} boolean - Whether the scissor test should be enabled or not.
   */
  setScissorTest() {
  }
  /**
   * Returns the clear color and alpha into a single
   * color object.
   *
   * @return {Color4} The clear color.
   */
  getClearColor() {
    const renderer = this.renderer;
    _color4 = _color4 || new Color4();
    renderer.getClearColor(_color4);
    _color4.getRGB(_color4);
    return _color4;
  }
  /**
   * Returns the DOM element. If no DOM element exists, the backend
   * creates a new one.
   *
   * @return {HTMLCanvasElement} The DOM element.
   */
  getDomElement() {
    let domElement = this.domElement;
    if (domElement === null) {
      domElement = this.parameters.canvas !== void 0 ? this.parameters.canvas : createCanvasElement();
      if ("setAttribute" in domElement) domElement.setAttribute("data-engine", `three.js r${REVISION} webgpu`);
      this.domElement = domElement;
    }
    return domElement;
  }
  /**
   * Sets a dictionary for the given object into the
   * internal data structure.
   *
   * @param {Object} object - The object.
   * @param {Object} value - The dictionary to set.
   */
  set(object2, value) {
    this.data.set(object2, value);
  }
  /**
   * Returns the dictionary for the given object.
   *
   * @param {Object} object - The object.
   * @return {Object} The object's dictionary.
   */
  get(object2) {
    let map4 = this.data.get(object2);
    if (map4 === void 0) {
      map4 = {};
      this.data.set(object2, map4);
    }
    return map4;
  }
  /**
   * Checks if the given object has a dictionary
   * with data defined.
   *
   * @param {Object} object - The object.
   * @return {boolean} Whether a dictionary for the given object as been defined or not.
   */
  has(object2) {
    return this.data.has(object2);
  }
  /**
   * Deletes an object from the internal data structure.
   *
   * @param {Object} object - The object to delete.
   */
  delete(object2) {
    this.data.delete(object2);
  }
  /**
   * Frees internal resources.
   *
   * @abstract
   */
  dispose() {
  }
};
var _id$1 = 0;
var DualAttributeData = class {
  constructor(attributeData, dualBuffer) {
    this.buffers = [attributeData.bufferGPU, dualBuffer];
    this.type = attributeData.type;
    this.bufferType = attributeData.bufferType;
    this.pbo = attributeData.pbo;
    this.byteLength = attributeData.byteLength;
    this.bytesPerElement = attributeData.BYTES_PER_ELEMENT;
    this.version = attributeData.version;
    this.isInteger = attributeData.isInteger;
    this.activeBufferIndex = 0;
    this.baseId = attributeData.id;
  }
  get id() {
    return `${this.baseId}|${this.activeBufferIndex}`;
  }
  get bufferGPU() {
    return this.buffers[this.activeBufferIndex];
  }
  get transformBuffer() {
    return this.buffers[this.activeBufferIndex ^ 1];
  }
  switchBuffers() {
    this.activeBufferIndex ^= 1;
  }
};
var WebGLAttributeUtils = class {
  /**
   * Constructs a new utility object.
   *
   * @param {WebGLBackend} backend - The WebGL 2 backend.
   */
  constructor(backend) {
    this.backend = backend;
  }
  /**
   * Creates the GPU buffer for the given buffer attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute.
   * @param {GLenum } bufferType - A flag that indicates the buffer type and thus binding point target.
   */
  createAttribute(attribute3, bufferType) {
    const backend = this.backend;
    const { gl } = backend;
    const array4 = attribute3.array;
    const usage = attribute3.usage || gl.STATIC_DRAW;
    const bufferAttribute3 = attribute3.isInterleavedBufferAttribute ? attribute3.data : attribute3;
    const bufferData = backend.get(bufferAttribute3);
    let bufferGPU = bufferData.bufferGPU;
    if (bufferGPU === void 0) {
      bufferGPU = this._createBuffer(gl, bufferType, array4, usage);
      bufferData.bufferGPU = bufferGPU;
      bufferData.bufferType = bufferType;
      bufferData.version = bufferAttribute3.version;
    }
    let type;
    if (array4 instanceof Float32Array) {
      type = gl.FLOAT;
    } else if (typeof Float16Array !== "undefined" && array4 instanceof Float16Array) {
      type = gl.HALF_FLOAT;
    } else if (array4 instanceof Uint16Array) {
      if (attribute3.isFloat16BufferAttribute) {
        type = gl.HALF_FLOAT;
      } else {
        type = gl.UNSIGNED_SHORT;
      }
    } else if (array4 instanceof Int16Array) {
      type = gl.SHORT;
    } else if (array4 instanceof Uint32Array) {
      type = gl.UNSIGNED_INT;
    } else if (array4 instanceof Int32Array) {
      type = gl.INT;
    } else if (array4 instanceof Int8Array) {
      type = gl.BYTE;
    } else if (array4 instanceof Uint8Array) {
      type = gl.UNSIGNED_BYTE;
    } else if (array4 instanceof Uint8ClampedArray) {
      type = gl.UNSIGNED_BYTE;
    } else {
      throw new Error("THREE.WebGLBackend: Unsupported buffer data format: " + array4);
    }
    let attributeData = {
      bufferGPU,
      bufferType,
      type,
      byteLength: array4.byteLength,
      bytesPerElement: array4.BYTES_PER_ELEMENT,
      version: attribute3.version,
      pbo: attribute3.pbo,
      isInteger: type === gl.INT || type === gl.UNSIGNED_INT || attribute3.gpuType === IntType,
      id: _id$1++
    };
    if (attribute3.isStorageBufferAttribute || attribute3.isStorageInstancedBufferAttribute) {
      const bufferGPUDual = this._createBuffer(gl, bufferType, array4, usage);
      attributeData = new DualAttributeData(attributeData, bufferGPUDual);
    }
    backend.set(attribute3, attributeData);
  }
  /**
   * Updates the GPU buffer of the given buffer attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute.
   */
  updateAttribute(attribute3) {
    const backend = this.backend;
    const { gl } = backend;
    const array4 = attribute3.array;
    const bufferAttribute3 = attribute3.isInterleavedBufferAttribute ? attribute3.data : attribute3;
    const bufferData = backend.get(bufferAttribute3);
    const bufferType = bufferData.bufferType;
    const updateRanges = attribute3.isInterleavedBufferAttribute ? attribute3.data.updateRanges : attribute3.updateRanges;
    gl.bindBuffer(bufferType, bufferData.bufferGPU);
    if (updateRanges.length === 0) {
      gl.bufferSubData(bufferType, 0, array4);
    } else {
      for (let i = 0, l = updateRanges.length; i < l; i++) {
        const range5 = updateRanges[i];
        gl.bufferSubData(
          bufferType,
          range5.start * array4.BYTES_PER_ELEMENT,
          array4,
          range5.start,
          range5.count
        );
      }
      bufferAttribute3.clearUpdateRanges();
    }
    gl.bindBuffer(bufferType, null);
    bufferData.version = bufferAttribute3.version;
  }
  /**
   * Destroys the GPU buffer of the given buffer attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute.
   */
  destroyAttribute(attribute3) {
    const backend = this.backend;
    const { gl } = backend;
    if (attribute3.isInterleavedBufferAttribute) {
      backend.delete(attribute3.data);
    }
    const attributeData = backend.get(attribute3);
    gl.deleteBuffer(attributeData.bufferGPU);
    backend.delete(attribute3);
  }
  /**
   * This method performs a readback operation by moving buffer data from
   * a storage buffer attribute from the GPU to the CPU.
   *
   * @async
   * @param {StorageBufferAttribute} attribute - The storage buffer attribute.
   * @return {Promise<ArrayBuffer>} A promise that resolves with the buffer data when the data are ready.
   */
  async getArrayBufferAsync(attribute3) {
    const backend = this.backend;
    const { gl } = backend;
    const bufferAttribute3 = attribute3.isInterleavedBufferAttribute ? attribute3.data : attribute3;
    const { bufferGPU } = backend.get(bufferAttribute3);
    const array4 = attribute3.array;
    const byteLength = array4.byteLength;
    gl.bindBuffer(gl.COPY_READ_BUFFER, bufferGPU);
    const writeBuffer = gl.createBuffer();
    gl.bindBuffer(gl.COPY_WRITE_BUFFER, writeBuffer);
    gl.bufferData(gl.COPY_WRITE_BUFFER, byteLength, gl.STREAM_READ);
    gl.copyBufferSubData(gl.COPY_READ_BUFFER, gl.COPY_WRITE_BUFFER, 0, 0, byteLength);
    await backend.utils._clientWaitAsync();
    const dstBuffer = new attribute3.array.constructor(array4.length);
    gl.bindBuffer(gl.COPY_WRITE_BUFFER, writeBuffer);
    gl.getBufferSubData(gl.COPY_WRITE_BUFFER, 0, dstBuffer);
    gl.deleteBuffer(writeBuffer);
    gl.bindBuffer(gl.COPY_READ_BUFFER, null);
    gl.bindBuffer(gl.COPY_WRITE_BUFFER, null);
    return dstBuffer.buffer;
  }
  /**
   * Creates a WebGL buffer with the given data.
   *
   * @private
   * @param {WebGL2RenderingContext} gl - The rendering context.
   * @param {GLenum } bufferType - A flag that indicates the buffer type and thus binding point target.
   * @param {TypedArray} array - The array of the buffer attribute.
   * @param {GLenum} usage - The usage.
   * @return {WebGLBuffer} The WebGL buffer.
   */
  _createBuffer(gl, bufferType, array4, usage) {
    const bufferGPU = gl.createBuffer();
    gl.bindBuffer(bufferType, bufferGPU);
    gl.bufferData(bufferType, array4, usage);
    gl.bindBuffer(bufferType, null);
    return bufferGPU;
  }
};
var equationToGL;
var factorToGL;
var WebGLState = class {
  /**
   * Constructs a new utility object.
   *
   * @param {WebGLBackend} backend - The WebGL 2 backend.
   */
  constructor(backend) {
    this.backend = backend;
    this.gl = this.backend.gl;
    this.enabled = {};
    this.currentFlipSided = null;
    this.currentCullFace = null;
    this.currentProgram = null;
    this.currentBlendingEnabled = false;
    this.currentBlending = null;
    this.currentBlendSrc = null;
    this.currentBlendDst = null;
    this.currentBlendSrcAlpha = null;
    this.currentBlendDstAlpha = null;
    this.currentPremultipledAlpha = null;
    this.currentPolygonOffsetFactor = null;
    this.currentPolygonOffsetUnits = null;
    this.currentColorMask = null;
    this.currentDepthFunc = null;
    this.currentDepthMask = null;
    this.currentStencilFunc = null;
    this.currentStencilRef = null;
    this.currentStencilFuncMask = null;
    this.currentStencilFail = null;
    this.currentStencilZFail = null;
    this.currentStencilZPass = null;
    this.currentStencilMask = null;
    this.currentLineWidth = null;
    this.currentClippingPlanes = 0;
    this.currentVAO = null;
    this.currentIndex = null;
    this.currentBoundFramebuffers = {};
    this.currentDrawbuffers = /* @__PURE__ */ new WeakMap();
    this.maxTextures = this.gl.getParameter(this.gl.MAX_TEXTURE_IMAGE_UNITS);
    this.currentTextureSlot = null;
    this.currentBoundTextures = {};
    this.currentBoundBufferBases = {};
    this._init();
  }
  /**
   * Inits the state of the utility.
   *
   * @private
   */
  _init() {
    const gl = this.gl;
    equationToGL = {
      [AddEquation]: gl.FUNC_ADD,
      [SubtractEquation]: gl.FUNC_SUBTRACT,
      [ReverseSubtractEquation]: gl.FUNC_REVERSE_SUBTRACT
    };
    factorToGL = {
      [ZeroFactor]: gl.ZERO,
      [OneFactor]: gl.ONE,
      [SrcColorFactor]: gl.SRC_COLOR,
      [SrcAlphaFactor]: gl.SRC_ALPHA,
      [SrcAlphaSaturateFactor]: gl.SRC_ALPHA_SATURATE,
      [DstColorFactor]: gl.DST_COLOR,
      [DstAlphaFactor]: gl.DST_ALPHA,
      [OneMinusSrcColorFactor]: gl.ONE_MINUS_SRC_COLOR,
      [OneMinusSrcAlphaFactor]: gl.ONE_MINUS_SRC_ALPHA,
      [OneMinusDstColorFactor]: gl.ONE_MINUS_DST_COLOR,
      [OneMinusDstAlphaFactor]: gl.ONE_MINUS_DST_ALPHA
    };
    const scissorParam = gl.getParameter(gl.SCISSOR_BOX);
    const viewportParam = gl.getParameter(gl.VIEWPORT);
    this.currentScissor = new Vector4().fromArray(scissorParam);
    this.currentViewport = new Vector4().fromArray(viewportParam);
    this._tempVec4 = new Vector4();
  }
  /**
   * Enables the given WebGL capability.
   *
   * This method caches the capability state so
   * `gl.enable()` is only called when necessary.
   *
   * @param {GLenum} id - The capability to enable.
   */
  enable(id) {
    const { enabled } = this;
    if (enabled[id] !== true) {
      this.gl.enable(id);
      enabled[id] = true;
    }
  }
  /**
   * Disables the given WebGL capability.
   *
   * This method caches the capability state so
   * `gl.disable()` is only called when necessary.
   *
   * @param {GLenum} id - The capability to enable.
   */
  disable(id) {
    const { enabled } = this;
    if (enabled[id] !== false) {
      this.gl.disable(id);
      enabled[id] = false;
    }
  }
  /**
   * Specifies whether polygons are front- or back-facing
   * by setting the winding orientation.
   *
   * This method caches the state so `gl.frontFace()` is only
   * called when necessary.
   *
   * @param {boolean} flipSided - Whether triangles flipped their sides or not.
   */
  setFlipSided(flipSided) {
    if (this.currentFlipSided !== flipSided) {
      const { gl } = this;
      if (flipSided) {
        gl.frontFace(gl.CW);
      } else {
        gl.frontFace(gl.CCW);
      }
      this.currentFlipSided = flipSided;
    }
  }
  /**
   * Specifies whether or not front- and/or back-facing
   * polygons can be culled.
   *
   * This method caches the state so `gl.cullFace()` is only
   * called when necessary.
   *
   * @param {number} cullFace - Defines which polygons are candidates for culling.
   */
  setCullFace(cullFace) {
    const { gl } = this;
    if (cullFace !== CullFaceNone) {
      this.enable(gl.CULL_FACE);
      if (cullFace !== this.currentCullFace) {
        if (cullFace === CullFaceBack) {
          gl.cullFace(gl.BACK);
        } else if (cullFace === CullFaceFront) {
          gl.cullFace(gl.FRONT);
        } else {
          gl.cullFace(gl.FRONT_AND_BACK);
        }
      }
    } else {
      this.disable(gl.CULL_FACE);
    }
    this.currentCullFace = cullFace;
  }
  /**
   * Specifies the width of line primitives.
   *
   * This method caches the state so `gl.lineWidth()` is only
   * called when necessary.
   *
   * @param {number} width - The line width.
   */
  setLineWidth(width) {
    const { currentLineWidth, gl } = this;
    if (width !== currentLineWidth) {
      gl.lineWidth(width);
      this.currentLineWidth = width;
    }
  }
  /**
   * Defines the blending.
   *
   * This method caches the state so `gl.blendEquation()`, `gl.blendEquationSeparate()`,
   * `gl.blendFunc()` and  `gl.blendFuncSeparate()` are only called when necessary.
   *
   * @param {number} blending - The blending type.
   * @param {number} blendEquation - The blending equation.
   * @param {number} blendSrc - Only relevant for custom blending. The RGB source blending factor.
   * @param {number} blendDst - Only relevant for custom blending. The RGB destination blending factor.
   * @param {number} blendEquationAlpha - Only relevant for custom blending. The blending equation for alpha.
   * @param {number} blendSrcAlpha - Only relevant for custom blending. The alpha source blending factor.
   * @param {number} blendDstAlpha - Only relevant for custom blending. The alpha destination blending factor.
   * @param {boolean} premultipliedAlpha - Whether premultiplied alpha is enabled or not.
   */
  setBlending(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha) {
    const { gl } = this;
    if (blending === NoBlending) {
      if (this.currentBlendingEnabled === true) {
        this.disable(gl.BLEND);
        this.currentBlendingEnabled = false;
      }
      return;
    }
    if (this.currentBlendingEnabled === false) {
      this.enable(gl.BLEND);
      this.currentBlendingEnabled = true;
    }
    if (blending !== CustomBlending) {
      if (blending !== this.currentBlending || premultipliedAlpha !== this.currentPremultipledAlpha) {
        if (this.currentBlendEquation !== AddEquation || this.currentBlendEquationAlpha !== AddEquation) {
          gl.blendEquation(gl.FUNC_ADD);
          this.currentBlendEquation = AddEquation;
          this.currentBlendEquationAlpha = AddEquation;
        }
        if (premultipliedAlpha) {
          switch (blending) {
            case NormalBlending:
              gl.blendFuncSeparate(gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
              break;
            case AdditiveBlending:
              gl.blendFunc(gl.ONE, gl.ONE);
              break;
            case SubtractiveBlending:
              gl.blendFuncSeparate(gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ZERO, gl.ONE);
              break;
            case MultiplyBlending:
              gl.blendFuncSeparate(gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA, gl.ZERO, gl.ONE);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", blending);
              break;
          }
        } else {
          switch (blending) {
            case NormalBlending:
              gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
              break;
            case AdditiveBlending:
              gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE, gl.ONE, gl.ONE);
              break;
            case SubtractiveBlending:
              console.error("THREE.WebGLState: SubtractiveBlending requires material.premultipliedAlpha = true");
              break;
            case MultiplyBlending:
              console.error("THREE.WebGLState: MultiplyBlending requires material.premultipliedAlpha = true");
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", blending);
              break;
          }
        }
        this.currentBlendSrc = null;
        this.currentBlendDst = null;
        this.currentBlendSrcAlpha = null;
        this.currentBlendDstAlpha = null;
        this.currentBlending = blending;
        this.currentPremultipledAlpha = premultipliedAlpha;
      }
      return;
    }
    blendEquationAlpha = blendEquationAlpha || blendEquation;
    blendSrcAlpha = blendSrcAlpha || blendSrc;
    blendDstAlpha = blendDstAlpha || blendDst;
    if (blendEquation !== this.currentBlendEquation || blendEquationAlpha !== this.currentBlendEquationAlpha) {
      gl.blendEquationSeparate(equationToGL[blendEquation], equationToGL[blendEquationAlpha]);
      this.currentBlendEquation = blendEquation;
      this.currentBlendEquationAlpha = blendEquationAlpha;
    }
    if (blendSrc !== this.currentBlendSrc || blendDst !== this.currentBlendDst || blendSrcAlpha !== this.currentBlendSrcAlpha || blendDstAlpha !== this.currentBlendDstAlpha) {
      gl.blendFuncSeparate(factorToGL[blendSrc], factorToGL[blendDst], factorToGL[blendSrcAlpha], factorToGL[blendDstAlpha]);
      this.currentBlendSrc = blendSrc;
      this.currentBlendDst = blendDst;
      this.currentBlendSrcAlpha = blendSrcAlpha;
      this.currentBlendDstAlpha = blendDstAlpha;
    }
    this.currentBlending = blending;
    this.currentPremultipledAlpha = false;
  }
  /**
   * Specifies whether colors can be written when rendering
   * into a framebuffer or not.
   *
   * This method caches the state so `gl.colorMask()` is only
   * called when necessary.
   *
   * @param {boolean} colorMask - The color mask.
   */
  setColorMask(colorMask) {
    if (this.currentColorMask !== colorMask) {
      this.gl.colorMask(colorMask, colorMask, colorMask, colorMask);
      this.currentColorMask = colorMask;
    }
  }
  /**
   * Specifies whether the depth test is enabled or not.
   *
   * @param {boolean} depthTest - Whether the depth test is enabled or not.
   */
  setDepthTest(depthTest) {
    const { gl } = this;
    if (depthTest) {
      this.enable(gl.DEPTH_TEST);
    } else {
      this.disable(gl.DEPTH_TEST);
    }
  }
  /**
   * Specifies whether depth values can be written when rendering
   * into a framebuffer or not.
   *
   * This method caches the state so `gl.depthMask()` is only
   * called when necessary.
   *
   * @param {boolean} depthMask - The depth mask.
   */
  setDepthMask(depthMask) {
    if (this.currentDepthMask !== depthMask) {
      this.gl.depthMask(depthMask);
      this.currentDepthMask = depthMask;
    }
  }
  /**
   * Specifies the depth compare function.
   *
   * This method caches the state so `gl.depthFunc()` is only
   * called when necessary.
   *
   * @param {number} depthFunc - The depth compare function.
   */
  setDepthFunc(depthFunc) {
    if (this.currentDepthFunc !== depthFunc) {
      const { gl } = this;
      switch (depthFunc) {
        case NeverDepth:
          gl.depthFunc(gl.NEVER);
          break;
        case AlwaysDepth:
          gl.depthFunc(gl.ALWAYS);
          break;
        case LessDepth:
          gl.depthFunc(gl.LESS);
          break;
        case LessEqualDepth:
          gl.depthFunc(gl.LEQUAL);
          break;
        case EqualDepth:
          gl.depthFunc(gl.EQUAL);
          break;
        case GreaterEqualDepth:
          gl.depthFunc(gl.GEQUAL);
          break;
        case GreaterDepth:
          gl.depthFunc(gl.GREATER);
          break;
        case NotEqualDepth:
          gl.depthFunc(gl.NOTEQUAL);
          break;
        default:
          gl.depthFunc(gl.LEQUAL);
      }
      this.currentDepthFunc = depthFunc;
    }
  }
  /**
   * Specifies the scissor box.
   *
   * @param {number} x - The x-coordinate of the lower left corner of the viewport.
   * @param {number} y - The y-coordinate of the lower left corner of the viewport.
   * @param {number} width - The width of the viewport.
   * @param {number} height - The height of the viewport.
   *
   */
  scissor(x, y, width, height) {
    const scissor = this._tempVec4.set(x, y, width, height);
    if (this.currentScissor.equals(scissor) === false) {
      const { gl } = this;
      gl.scissor(scissor.x, scissor.y, scissor.z, scissor.w);
      this.currentScissor.copy(scissor);
    }
  }
  /**
   * Specifies the viewport.
   *
   * @param {number} x - The x-coordinate of the lower left corner of the viewport.
   * @param {number} y - The y-coordinate of the lower left corner of the viewport.
   * @param {number} width - The width of the viewport.
   * @param {number} height - The height of the viewport.
   *
   */
  viewport(x, y, width, height) {
    const viewport3 = this._tempVec4.set(x, y, width, height);
    if (this.currentViewport.equals(viewport3) === false) {
      const { gl } = this;
      gl.viewport(viewport3.x, viewport3.y, viewport3.z, viewport3.w);
      this.currentViewport.copy(viewport3);
    }
  }
  /**
   * Defines the scissor test.
   *
   * @param {boolean} boolean - Whether the scissor test should be enabled or not.
   */
  setScissorTest(boolean) {
    const gl = this.gl;
    if (boolean) {
      gl.enable(gl.SCISSOR_TEST);
    } else {
      gl.disable(gl.SCISSOR_TEST);
    }
  }
  /**
   * Specifies whether the stencil test is enabled or not.
   *
   * @param {boolean} stencilTest - Whether the stencil test is enabled or not.
   */
  setStencilTest(stencilTest) {
    const { gl } = this;
    if (stencilTest) {
      this.enable(gl.STENCIL_TEST);
    } else {
      this.disable(gl.STENCIL_TEST);
    }
  }
  /**
   * Specifies whether stencil values can be written when rendering
   * into a framebuffer or not.
   *
   * This method caches the state so `gl.stencilMask()` is only
   * called when necessary.
   *
   * @param {boolean} stencilMask - The stencil mask.
   */
  setStencilMask(stencilMask) {
    if (this.currentStencilMask !== stencilMask) {
      this.gl.stencilMask(stencilMask);
      this.currentStencilMask = stencilMask;
    }
  }
  /**
   * Specifies whether the stencil test functions.
   *
   * This method caches the state so `gl.stencilFunc()` is only
   * called when necessary.
   *
   * @param {number} stencilFunc - The stencil compare function.
   * @param {number} stencilRef - The reference value for the stencil test.
   * @param {number} stencilMask - A bit-wise mask that is used to AND the reference value and the stored stencil value when the test is done.
   */
  setStencilFunc(stencilFunc, stencilRef, stencilMask) {
    if (this.currentStencilFunc !== stencilFunc || this.currentStencilRef !== stencilRef || this.currentStencilFuncMask !== stencilMask) {
      this.gl.stencilFunc(stencilFunc, stencilRef, stencilMask);
      this.currentStencilFunc = stencilFunc;
      this.currentStencilRef = stencilRef;
      this.currentStencilFuncMask = stencilMask;
    }
  }
  /**
   * Specifies whether the stencil test operation.
   *
   * This method caches the state so `gl.stencilOp()` is only
   * called when necessary.
   *
   * @param {number} stencilFail - The function to use when the stencil test fails.
   * @param {number} stencilZFail - The function to use when the stencil test passes, but the depth test fail.
   * @param {number} stencilZPass - The function to use when both the stencil test and the depth test pass,
   * or when the stencil test passes and there is no depth buffer or depth testing is disabled.
   */
  setStencilOp(stencilFail, stencilZFail, stencilZPass) {
    if (this.currentStencilFail !== stencilFail || this.currentStencilZFail !== stencilZFail || this.currentStencilZPass !== stencilZPass) {
      this.gl.stencilOp(stencilFail, stencilZFail, stencilZPass);
      this.currentStencilFail = stencilFail;
      this.currentStencilZFail = stencilZFail;
      this.currentStencilZPass = stencilZPass;
    }
  }
  /**
   * Configures the WebGL state for the given material.
   *
   * @param {Material} material - The material to configure the state for.
   * @param {number} frontFaceCW - Whether the front faces are counter-clockwise or not.
   * @param {number} hardwareClippingPlanes - The number of hardware clipping planes.
   */
  setMaterial(material, frontFaceCW, hardwareClippingPlanes) {
    const { gl } = this;
    material.side === DoubleSide ? this.disable(gl.CULL_FACE) : this.enable(gl.CULL_FACE);
    let flipSided = material.side === BackSide;
    if (frontFaceCW) flipSided = !flipSided;
    this.setFlipSided(flipSided);
    material.blending === NormalBlending && material.transparent === false ? this.setBlending(NoBlending) : this.setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha);
    this.setDepthFunc(material.depthFunc);
    this.setDepthTest(material.depthTest);
    this.setDepthMask(material.depthWrite);
    this.setColorMask(material.colorWrite);
    const stencilWrite = material.stencilWrite;
    this.setStencilTest(stencilWrite);
    if (stencilWrite) {
      this.setStencilMask(material.stencilWriteMask);
      this.setStencilFunc(material.stencilFunc, material.stencilRef, material.stencilFuncMask);
      this.setStencilOp(material.stencilFail, material.stencilZFail, material.stencilZPass);
    }
    this.setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);
    material.alphaToCoverage === true && this.backend.renderer.samples > 1 ? this.enable(gl.SAMPLE_ALPHA_TO_COVERAGE) : this.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
    if (hardwareClippingPlanes > 0) {
      if (this.currentClippingPlanes !== hardwareClippingPlanes) {
        const CLIP_DISTANCE0_WEBGL = 12288;
        for (let i = 0; i < 8; i++) {
          if (i < hardwareClippingPlanes) {
            this.enable(CLIP_DISTANCE0_WEBGL + i);
          } else {
            this.disable(CLIP_DISTANCE0_WEBGL + i);
          }
        }
      }
    }
  }
  /**
   * Specifies the polygon offset.
   *
   * This method caches the state so `gl.polygonOffset()` is only
   * called when necessary.
   *
   * @param {boolean} polygonOffset - Whether polygon offset is enabled or not.
   * @param {number} factor - The scale factor for the variable depth offset for each polygon.
   * @param {number} units - The multiplier by which an implementation-specific value is multiplied with to create a constant depth offset.
   */
  setPolygonOffset(polygonOffset, factor, units) {
    const { gl } = this;
    if (polygonOffset) {
      this.enable(gl.POLYGON_OFFSET_FILL);
      if (this.currentPolygonOffsetFactor !== factor || this.currentPolygonOffsetUnits !== units) {
        gl.polygonOffset(factor, units);
        this.currentPolygonOffsetFactor = factor;
        this.currentPolygonOffsetUnits = units;
      }
    } else {
      this.disable(gl.POLYGON_OFFSET_FILL);
    }
  }
  /**
   * Defines the usage of the given WebGL program.
   *
   * This method caches the state so `gl.useProgram()` is only
   * called when necessary.
   *
   * @param {WebGLProgram} program - The WebGL program to use.
   * @return {boolean} Whether a program change has been executed or not.
   */
  useProgram(program) {
    if (this.currentProgram !== program) {
      this.gl.useProgram(program);
      this.currentProgram = program;
      return true;
    }
    return false;
  }
  /**
   * Sets the vertex state by binding the given VAO and element buffer.
   *
   * @param {WebGLVertexArrayObject} vao - The VAO.
   * @param {?WebGLBuffer} indexBuffer - The index buffer.
   * @return {boolean} Whether a vertex state has been changed or not.
   */
  setVertexState(vao, indexBuffer = null) {
    const gl = this.gl;
    if (this.currentVAO !== vao || this.currentIndex !== indexBuffer) {
      gl.bindVertexArray(vao);
      if (indexBuffer !== null) {
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
      }
      this.currentVAO = vao;
      this.currentIndex = indexBuffer;
      return true;
    }
    return false;
  }
  /**
   * Resets the vertex array state by resetting the VAO and element buffer.
   */
  resetVertexState() {
    const gl = this.gl;
    gl.bindVertexArray(null);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
    this.currentVAO = null;
    this.currentIndex = null;
  }
  // framebuffer
  /**
   * Binds the given framebuffer.
   *
   * This method caches the state so `gl.bindFramebuffer()` is only
   * called when necessary.
   *
   * @param {number} target - The binding point (target).
   * @param {WebGLFramebuffer} framebuffer - The WebGL framebuffer to bind.
   * @return {boolean} Whether a bind has been executed or not.
   */
  bindFramebuffer(target, framebuffer) {
    const { gl, currentBoundFramebuffers } = this;
    if (currentBoundFramebuffers[target] !== framebuffer) {
      gl.bindFramebuffer(target, framebuffer);
      currentBoundFramebuffers[target] = framebuffer;
      if (target === gl.DRAW_FRAMEBUFFER) {
        currentBoundFramebuffers[gl.FRAMEBUFFER] = framebuffer;
      }
      if (target === gl.FRAMEBUFFER) {
        currentBoundFramebuffers[gl.DRAW_FRAMEBUFFER] = framebuffer;
      }
      return true;
    }
    return false;
  }
  /**
   * Defines draw buffers to which fragment colors are written into.
   * Configures the MRT setup of custom framebuffers.
   *
   * This method caches the state so `gl.drawBuffers()` is only
   * called when necessary.
   *
   * @param {RenderContext} renderContext - The render context.
   * @param {WebGLFramebuffer} framebuffer - The WebGL framebuffer.
   */
  drawBuffers(renderContext, framebuffer) {
    const { gl } = this;
    let drawBuffers = [];
    let needsUpdate = false;
    if (renderContext.textures !== null) {
      drawBuffers = this.currentDrawbuffers.get(framebuffer);
      if (drawBuffers === void 0) {
        drawBuffers = [];
        this.currentDrawbuffers.set(framebuffer, drawBuffers);
      }
      const textures = renderContext.textures;
      if (drawBuffers.length !== textures.length || drawBuffers[0] !== gl.COLOR_ATTACHMENT0) {
        for (let i = 0, il = textures.length; i < il; i++) {
          drawBuffers[i] = gl.COLOR_ATTACHMENT0 + i;
        }
        drawBuffers.length = textures.length;
        needsUpdate = true;
      }
    } else {
      if (drawBuffers[0] !== gl.BACK) {
        drawBuffers[0] = gl.BACK;
        needsUpdate = true;
      }
    }
    if (needsUpdate) {
      gl.drawBuffers(drawBuffers);
    }
  }
  // texture
  /**
   * Makes the given texture unit active.
   *
   * This method caches the state so `gl.activeTexture()` is only
   * called when necessary.
   *
   * @param {number} webglSlot - The texture unit to make active.
   */
  activeTexture(webglSlot) {
    const { gl, currentTextureSlot, maxTextures } = this;
    if (webglSlot === void 0) webglSlot = gl.TEXTURE0 + maxTextures - 1;
    if (currentTextureSlot !== webglSlot) {
      gl.activeTexture(webglSlot);
      this.currentTextureSlot = webglSlot;
    }
  }
  /**
   * Binds the given WebGL texture to a target.
   *
   * This method caches the state so `gl.bindTexture()` is only
   * called when necessary.
   *
   * @param {number} webglType - The binding point (target).
   * @param {WebGLTexture} webglTexture - The WebGL texture to bind.
   * @param {number} webglSlot - The texture.
   */
  bindTexture(webglType, webglTexture, webglSlot) {
    const { gl, currentTextureSlot, currentBoundTextures, maxTextures } = this;
    if (webglSlot === void 0) {
      if (currentTextureSlot === null) {
        webglSlot = gl.TEXTURE0 + maxTextures - 1;
      } else {
        webglSlot = currentTextureSlot;
      }
    }
    let boundTexture = currentBoundTextures[webglSlot];
    if (boundTexture === void 0) {
      boundTexture = { type: void 0, texture: void 0 };
      currentBoundTextures[webglSlot] = boundTexture;
    }
    if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {
      if (currentTextureSlot !== webglSlot) {
        gl.activeTexture(webglSlot);
        this.currentTextureSlot = webglSlot;
      }
      gl.bindTexture(webglType, webglTexture);
      boundTexture.type = webglType;
      boundTexture.texture = webglTexture;
    }
  }
  /**
   * Binds a given WebGL buffer to a given binding point (target) at a given index.
   *
   * This method caches the state so `gl.bindBufferBase()` is only
   * called when necessary.
   *
   * @param {number} target - The target for the bind operation.
   * @param {number} index - The index of the target.
   * @param {WebGLBuffer} buffer - The WebGL buffer.
   * @return {boolean} Whether a bind has been executed or not.
   */
  bindBufferBase(target, index5, buffer3) {
    const { gl } = this;
    const key = `${target}-${index5}`;
    if (this.currentBoundBufferBases[key] !== buffer3) {
      gl.bindBufferBase(target, index5, buffer3);
      this.currentBoundBufferBases[key] = buffer3;
      return true;
    }
    return false;
  }
  /**
   * Unbinds the current bound texture.
   *
   * This method caches the state so `gl.bindTexture()` is only
   * called when necessary.
   */
  unbindTexture() {
    const { gl, currentTextureSlot, currentBoundTextures } = this;
    const boundTexture = currentBoundTextures[currentTextureSlot];
    if (boundTexture !== void 0 && boundTexture.type !== void 0) {
      gl.bindTexture(boundTexture.type, null);
      boundTexture.type = void 0;
      boundTexture.texture = void 0;
    }
  }
};
var WebGLUtils = class {
  /**
   * Constructs a new utility object.
   *
   * @param {WebGLBackend} backend - The WebGL 2 backend.
   */
  constructor(backend) {
    this.backend = backend;
    this.gl = this.backend.gl;
    this.extensions = backend.extensions;
  }
  /**
   * Converts the given three.js constant into a WebGL constant.
   * The method currently supports the conversion of texture formats
   * and types.
   *
   * @param {number} p - The three.js constant.
   * @param {string} [colorSpace=NoColorSpace] - The color space.
   * @return {?number} The corresponding WebGL constant.
   */
  convert(p, colorSpace = NoColorSpace) {
    const { gl, extensions } = this;
    let extension;
    const transfer = ColorManagement.getTransfer(colorSpace);
    if (p === UnsignedByteType) return gl.UNSIGNED_BYTE;
    if (p === UnsignedShort4444Type) return gl.UNSIGNED_SHORT_4_4_4_4;
    if (p === UnsignedShort5551Type) return gl.UNSIGNED_SHORT_5_5_5_1;
    if (p === UnsignedInt5999Type) return gl.UNSIGNED_INT_5_9_9_9_REV;
    if (p === UnsignedInt101111Type) return gl.UNSIGNED_INT_10F_11F_11F_REV;
    if (p === ByteType) return gl.BYTE;
    if (p === ShortType) return gl.SHORT;
    if (p === UnsignedShortType) return gl.UNSIGNED_SHORT;
    if (p === IntType) return gl.INT;
    if (p === UnsignedIntType) return gl.UNSIGNED_INT;
    if (p === FloatType) return gl.FLOAT;
    if (p === HalfFloatType) {
      return gl.HALF_FLOAT;
    }
    if (p === AlphaFormat) return gl.ALPHA;
    if (p === RGBFormat) return gl.RGB;
    if (p === RGBAFormat) return gl.RGBA;
    if (p === DepthFormat) return gl.DEPTH_COMPONENT;
    if (p === DepthStencilFormat) return gl.DEPTH_STENCIL;
    if (p === RedFormat) return gl.RED;
    if (p === RedIntegerFormat) return gl.RED_INTEGER;
    if (p === RGFormat) return gl.RG;
    if (p === RGIntegerFormat) return gl.RG_INTEGER;
    if (p === RGBAIntegerFormat) return gl.RGBA_INTEGER;
    if (p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format || p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format) {
      if (transfer === SRGBTransfer) {
        extension = extensions.get("WEBGL_compressed_texture_s3tc_srgb");
        if (extension !== null) {
          if (p === RGB_S3TC_DXT1_Format) return extension.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          if (p === RGBA_S3TC_DXT1_Format) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          if (p === RGBA_S3TC_DXT3_Format) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
          if (p === RGBA_S3TC_DXT5_Format) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
        } else {
          return null;
        }
      } else {
        extension = extensions.get("WEBGL_compressed_texture_s3tc");
        if (extension !== null) {
          if (p === RGB_S3TC_DXT1_Format) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
          if (p === RGBA_S3TC_DXT1_Format) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
          if (p === RGBA_S3TC_DXT3_Format) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
          if (p === RGBA_S3TC_DXT5_Format) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
        } else {
          return null;
        }
      }
    }
    if (p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format || p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format) {
      extension = extensions.get("WEBGL_compressed_texture_pvrtc");
      if (extension !== null) {
        if (p === RGB_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (p === RGB_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (p === RGBA_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (p === RGBA_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else {
        return null;
      }
    }
    if (p === RGB_ETC1_Format || p === RGB_ETC2_Format || p === RGBA_ETC2_EAC_Format) {
      extension = extensions.get("WEBGL_compressed_texture_etc");
      if (extension !== null) {
        if (p === RGB_ETC1_Format || p === RGB_ETC2_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ETC2 : extension.COMPRESSED_RGB8_ETC2;
        if (p === RGBA_ETC2_EAC_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : extension.COMPRESSED_RGBA8_ETC2_EAC;
      } else {
        return null;
      }
    }
    if (p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format || p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format || p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format || p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format || p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format) {
      extension = extensions.get("WEBGL_compressed_texture_astc");
      if (extension !== null) {
        if (p === RGBA_ASTC_4x4_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : extension.COMPRESSED_RGBA_ASTC_4x4_KHR;
        if (p === RGBA_ASTC_5x4_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : extension.COMPRESSED_RGBA_ASTC_5x4_KHR;
        if (p === RGBA_ASTC_5x5_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : extension.COMPRESSED_RGBA_ASTC_5x5_KHR;
        if (p === RGBA_ASTC_6x5_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : extension.COMPRESSED_RGBA_ASTC_6x5_KHR;
        if (p === RGBA_ASTC_6x6_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : extension.COMPRESSED_RGBA_ASTC_6x6_KHR;
        if (p === RGBA_ASTC_8x5_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : extension.COMPRESSED_RGBA_ASTC_8x5_KHR;
        if (p === RGBA_ASTC_8x6_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : extension.COMPRESSED_RGBA_ASTC_8x6_KHR;
        if (p === RGBA_ASTC_8x8_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : extension.COMPRESSED_RGBA_ASTC_8x8_KHR;
        if (p === RGBA_ASTC_10x5_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : extension.COMPRESSED_RGBA_ASTC_10x5_KHR;
        if (p === RGBA_ASTC_10x6_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : extension.COMPRESSED_RGBA_ASTC_10x6_KHR;
        if (p === RGBA_ASTC_10x8_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : extension.COMPRESSED_RGBA_ASTC_10x8_KHR;
        if (p === RGBA_ASTC_10x10_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : extension.COMPRESSED_RGBA_ASTC_10x10_KHR;
        if (p === RGBA_ASTC_12x10_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : extension.COMPRESSED_RGBA_ASTC_12x10_KHR;
        if (p === RGBA_ASTC_12x12_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : extension.COMPRESSED_RGBA_ASTC_12x12_KHR;
      } else {
        return null;
      }
    }
    if (p === RGBA_BPTC_Format) {
      extension = extensions.get("EXT_texture_compression_bptc");
      if (extension !== null) {
        if (p === RGBA_BPTC_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : extension.COMPRESSED_RGBA_BPTC_UNORM_EXT;
      } else {
        return null;
      }
    }
    if (p === RED_RGTC1_Format || p === SIGNED_RED_RGTC1_Format || p === RED_GREEN_RGTC2_Format || p === SIGNED_RED_GREEN_RGTC2_Format) {
      extension = extensions.get("EXT_texture_compression_rgtc");
      if (extension !== null) {
        if (p === RED_RGTC1_Format) return extension.COMPRESSED_RED_RGTC1_EXT;
        if (p === SIGNED_RED_RGTC1_Format) return extension.COMPRESSED_SIGNED_RED_RGTC1_EXT;
        if (p === RED_GREEN_RGTC2_Format) return extension.COMPRESSED_RED_GREEN_RGTC2_EXT;
        if (p === SIGNED_RED_GREEN_RGTC2_Format) return extension.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
      } else {
        return null;
      }
    }
    if (p === UnsignedInt248Type) {
      return gl.UNSIGNED_INT_24_8;
    }
    return gl[p] !== void 0 ? gl[p] : null;
  }
  /**
   * This method can be used to synchronize the CPU with the GPU by waiting until
   * ongoing GPU commands have been completed.
   *
   * @private
   * @return {Promise} A promise that resolves when all ongoing GPU commands have been completed.
   */
  _clientWaitAsync() {
    const { gl } = this;
    const sync = gl.fenceSync(gl.SYNC_GPU_COMMANDS_COMPLETE, 0);
    gl.flush();
    return new Promise((resolve, reject) => {
      function test() {
        const res = gl.clientWaitSync(sync, gl.SYNC_FLUSH_COMMANDS_BIT, 0);
        if (res === gl.WAIT_FAILED) {
          gl.deleteSync(sync);
          reject();
          return;
        }
        if (res === gl.TIMEOUT_EXPIRED) {
          requestAnimationFrame(test);
          return;
        }
        gl.deleteSync(sync);
        resolve();
      }
      test();
    });
  }
};
var initialized = false;
var wrappingToGL;
var filterToGL;
var compareToGL;
var WebGLTextureUtils = class {
  /**
   * Constructs a new utility object.
   *
   * @param {WebGLBackend} backend - The WebGL 2 backend.
   */
  constructor(backend) {
    this.backend = backend;
    this.gl = backend.gl;
    this.extensions = backend.extensions;
    this.defaultTextures = {};
    if (initialized === false) {
      this._init();
      initialized = true;
    }
  }
  /**
   * Inits the state of the utility.
   *
   * @private
   */
  _init() {
    const gl = this.gl;
    wrappingToGL = {
      [RepeatWrapping]: gl.REPEAT,
      [ClampToEdgeWrapping]: gl.CLAMP_TO_EDGE,
      [MirroredRepeatWrapping]: gl.MIRRORED_REPEAT
    };
    filterToGL = {
      [NearestFilter]: gl.NEAREST,
      [NearestMipmapNearestFilter]: gl.NEAREST_MIPMAP_NEAREST,
      [NearestMipmapLinearFilter]: gl.NEAREST_MIPMAP_LINEAR,
      [LinearFilter]: gl.LINEAR,
      [LinearMipmapNearestFilter]: gl.LINEAR_MIPMAP_NEAREST,
      [LinearMipmapLinearFilter]: gl.LINEAR_MIPMAP_LINEAR
    };
    compareToGL = {
      [NeverCompare]: gl.NEVER,
      [AlwaysCompare]: gl.ALWAYS,
      [LessCompare]: gl.LESS,
      [LessEqualCompare]: gl.LEQUAL,
      [EqualCompare]: gl.EQUAL,
      [GreaterEqualCompare]: gl.GEQUAL,
      [GreaterCompare]: gl.GREATER,
      [NotEqualCompare]: gl.NOTEQUAL
    };
  }
  /**
   * Returns the native texture type for the given texture.
   *
   * @param {Texture} texture - The texture.
   * @return {GLenum} The native texture type.
   */
  getGLTextureType(texture3) {
    const { gl } = this;
    let glTextureType;
    if (texture3.isCubeTexture === true) {
      glTextureType = gl.TEXTURE_CUBE_MAP;
    } else if (texture3.isArrayTexture === true || texture3.isDataArrayTexture === true || texture3.isCompressedArrayTexture === true) {
      glTextureType = gl.TEXTURE_2D_ARRAY;
    } else if (texture3.isData3DTexture === true) {
      glTextureType = gl.TEXTURE_3D;
    } else {
      glTextureType = gl.TEXTURE_2D;
    }
    return glTextureType;
  }
  /**
   * Returns the native texture type for the given texture.
   *
   * @param {?string} internalFormatName - The internal format name. When `null`, the internal format is derived from the subsequent parameters.
   * @param {GLenum} glFormat - The WebGL format.
   * @param {GLenum} glType - The WebGL type.
   * @param {string} colorSpace - The texture's color space.
   * @param {boolean} [forceLinearTransfer=false] - Whether to force a linear transfer or not.
   * @return {GLenum} The internal format.
   */
  getInternalFormat(internalFormatName, glFormat, glType, colorSpace, forceLinearTransfer = false) {
    const { gl, extensions } = this;
    if (internalFormatName !== null) {
      if (gl[internalFormatName] !== void 0) return gl[internalFormatName];
      console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + internalFormatName + "'");
    }
    let internalFormat = glFormat;
    if (glFormat === gl.RED) {
      if (glType === gl.FLOAT) internalFormat = gl.R32F;
      if (glType === gl.HALF_FLOAT) internalFormat = gl.R16F;
      if (glType === gl.UNSIGNED_BYTE) internalFormat = gl.R8;
      if (glType === gl.UNSIGNED_SHORT) internalFormat = gl.R16;
      if (glType === gl.UNSIGNED_INT) internalFormat = gl.R32UI;
      if (glType === gl.BYTE) internalFormat = gl.R8I;
      if (glType === gl.SHORT) internalFormat = gl.R16I;
      if (glType === gl.INT) internalFormat = gl.R32I;
    }
    if (glFormat === gl.RED_INTEGER) {
      if (glType === gl.UNSIGNED_BYTE) internalFormat = gl.R8UI;
      if (glType === gl.UNSIGNED_SHORT) internalFormat = gl.R16UI;
      if (glType === gl.UNSIGNED_INT) internalFormat = gl.R32UI;
      if (glType === gl.BYTE) internalFormat = gl.R8I;
      if (glType === gl.SHORT) internalFormat = gl.R16I;
      if (glType === gl.INT) internalFormat = gl.R32I;
    }
    if (glFormat === gl.RG) {
      if (glType === gl.FLOAT) internalFormat = gl.RG32F;
      if (glType === gl.HALF_FLOAT) internalFormat = gl.RG16F;
      if (glType === gl.UNSIGNED_BYTE) internalFormat = gl.RG8;
      if (glType === gl.UNSIGNED_SHORT) internalFormat = gl.RG16;
      if (glType === gl.UNSIGNED_INT) internalFormat = gl.RG32UI;
      if (glType === gl.BYTE) internalFormat = gl.RG8I;
      if (glType === gl.SHORT) internalFormat = gl.RG16I;
      if (glType === gl.INT) internalFormat = gl.RG32I;
    }
    if (glFormat === gl.RG_INTEGER) {
      if (glType === gl.UNSIGNED_BYTE) internalFormat = gl.RG8UI;
      if (glType === gl.UNSIGNED_SHORT) internalFormat = gl.RG16UI;
      if (glType === gl.UNSIGNED_INT) internalFormat = gl.RG32UI;
      if (glType === gl.BYTE) internalFormat = gl.RG8I;
      if (glType === gl.SHORT) internalFormat = gl.RG16I;
      if (glType === gl.INT) internalFormat = gl.RG32I;
    }
    if (glFormat === gl.RGB) {
      const transfer = forceLinearTransfer ? LinearTransfer : ColorManagement.getTransfer(colorSpace);
      if (glType === gl.FLOAT) internalFormat = gl.RGB32F;
      if (glType === gl.HALF_FLOAT) internalFormat = gl.RGB16F;
      if (glType === gl.UNSIGNED_BYTE) internalFormat = gl.RGB8;
      if (glType === gl.UNSIGNED_SHORT) internalFormat = gl.RGB16;
      if (glType === gl.UNSIGNED_INT) internalFormat = gl.RGB32UI;
      if (glType === gl.BYTE) internalFormat = gl.RGB8I;
      if (glType === gl.SHORT) internalFormat = gl.RGB16I;
      if (glType === gl.INT) internalFormat = gl.RGB32I;
      if (glType === gl.UNSIGNED_BYTE) internalFormat = transfer === SRGBTransfer ? gl.SRGB8 : gl.RGB8;
      if (glType === gl.UNSIGNED_SHORT_5_6_5) internalFormat = gl.RGB565;
      if (glType === gl.UNSIGNED_SHORT_5_5_5_1) internalFormat = gl.RGB5_A1;
      if (glType === gl.UNSIGNED_SHORT_4_4_4_4) internalFormat = gl.RGB4;
      if (glType === gl.UNSIGNED_INT_5_9_9_9_REV) internalFormat = gl.RGB9_E5;
      if (glType === gl.UNSIGNED_INT_10F_11F_11F_REV) internalFormat = gl.R11F_G11F_B10F;
    }
    if (glFormat === gl.RGB_INTEGER) {
      if (glType === gl.UNSIGNED_BYTE) internalFormat = gl.RGB8UI;
      if (glType === gl.UNSIGNED_SHORT) internalFormat = gl.RGB16UI;
      if (glType === gl.UNSIGNED_INT) internalFormat = gl.RGB32UI;
      if (glType === gl.BYTE) internalFormat = gl.RGB8I;
      if (glType === gl.SHORT) internalFormat = gl.RGB16I;
      if (glType === gl.INT) internalFormat = gl.RGB32I;
    }
    if (glFormat === gl.RGBA) {
      const transfer = forceLinearTransfer ? LinearTransfer : ColorManagement.getTransfer(colorSpace);
      if (glType === gl.FLOAT) internalFormat = gl.RGBA32F;
      if (glType === gl.HALF_FLOAT) internalFormat = gl.RGBA16F;
      if (glType === gl.UNSIGNED_BYTE) internalFormat = gl.RGBA8;
      if (glType === gl.UNSIGNED_SHORT) internalFormat = gl.RGBA16;
      if (glType === gl.UNSIGNED_INT) internalFormat = gl.RGBA32UI;
      if (glType === gl.BYTE) internalFormat = gl.RGBA8I;
      if (glType === gl.SHORT) internalFormat = gl.RGBA16I;
      if (glType === gl.INT) internalFormat = gl.RGBA32I;
      if (glType === gl.UNSIGNED_BYTE) internalFormat = transfer === SRGBTransfer ? gl.SRGB8_ALPHA8 : gl.RGBA8;
      if (glType === gl.UNSIGNED_SHORT_4_4_4_4) internalFormat = gl.RGBA4;
      if (glType === gl.UNSIGNED_SHORT_5_5_5_1) internalFormat = gl.RGB5_A1;
    }
    if (glFormat === gl.RGBA_INTEGER) {
      if (glType === gl.UNSIGNED_BYTE) internalFormat = gl.RGBA8UI;
      if (glType === gl.UNSIGNED_SHORT) internalFormat = gl.RGBA16UI;
      if (glType === gl.UNSIGNED_INT) internalFormat = gl.RGBA32UI;
      if (glType === gl.BYTE) internalFormat = gl.RGBA8I;
      if (glType === gl.SHORT) internalFormat = gl.RGBA16I;
      if (glType === gl.INT) internalFormat = gl.RGBA32I;
    }
    if (glFormat === gl.DEPTH_COMPONENT) {
      if (glType === gl.UNSIGNED_SHORT) internalFormat = gl.DEPTH_COMPONENT16;
      if (glType === gl.UNSIGNED_INT) internalFormat = gl.DEPTH_COMPONENT24;
      if (glType === gl.FLOAT) internalFormat = gl.DEPTH_COMPONENT32F;
    }
    if (glFormat === gl.DEPTH_STENCIL) {
      if (glType === gl.UNSIGNED_INT_24_8) internalFormat = gl.DEPTH24_STENCIL8;
    }
    if (internalFormat === gl.R16F || internalFormat === gl.R32F || internalFormat === gl.RG16F || internalFormat === gl.RG32F || internalFormat === gl.RGBA16F || internalFormat === gl.RGBA32F) {
      extensions.get("EXT_color_buffer_float");
    }
    return internalFormat;
  }
  /**
   * Sets the texture parameters for the given texture.
   *
   * @param {GLenum} textureType - The texture type.
   * @param {Texture} texture - The texture.
   */
  setTextureParameters(textureType, texture3) {
    const { gl, extensions, backend } = this;
    const workingPrimaries = ColorManagement.getPrimaries(ColorManagement.workingColorSpace);
    const texturePrimaries = texture3.colorSpace === NoColorSpace ? null : ColorManagement.getPrimaries(texture3.colorSpace);
    const unpackConversion = texture3.colorSpace === NoColorSpace || workingPrimaries === texturePrimaries ? gl.NONE : gl.BROWSER_DEFAULT_WEBGL;
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, texture3.flipY);
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture3.premultiplyAlpha);
    gl.pixelStorei(gl.UNPACK_ALIGNMENT, texture3.unpackAlignment);
    gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, unpackConversion);
    gl.texParameteri(textureType, gl.TEXTURE_WRAP_S, wrappingToGL[texture3.wrapS]);
    gl.texParameteri(textureType, gl.TEXTURE_WRAP_T, wrappingToGL[texture3.wrapT]);
    if (textureType === gl.TEXTURE_3D || textureType === gl.TEXTURE_2D_ARRAY) {
      if (!texture3.isArrayTexture) {
        gl.texParameteri(textureType, gl.TEXTURE_WRAP_R, wrappingToGL[texture3.wrapR]);
      }
    }
    gl.texParameteri(textureType, gl.TEXTURE_MAG_FILTER, filterToGL[texture3.magFilter]);
    const hasMipmaps = texture3.mipmaps !== void 0 && texture3.mipmaps.length > 0;
    const minFilter = texture3.minFilter === LinearFilter && hasMipmaps ? LinearMipmapLinearFilter : texture3.minFilter;
    gl.texParameteri(textureType, gl.TEXTURE_MIN_FILTER, filterToGL[minFilter]);
    if (texture3.compareFunction) {
      gl.texParameteri(textureType, gl.TEXTURE_COMPARE_MODE, gl.COMPARE_REF_TO_TEXTURE);
      gl.texParameteri(textureType, gl.TEXTURE_COMPARE_FUNC, compareToGL[texture3.compareFunction]);
    }
    if (extensions.has("EXT_texture_filter_anisotropic") === true) {
      if (texture3.magFilter === NearestFilter) return;
      if (texture3.minFilter !== NearestMipmapLinearFilter && texture3.minFilter !== LinearMipmapLinearFilter) return;
      if (texture3.type === FloatType && extensions.has("OES_texture_float_linear") === false) return;
      if (texture3.anisotropy > 1) {
        const extension = extensions.get("EXT_texture_filter_anisotropic");
        gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture3.anisotropy, backend.getMaxAnisotropy()));
      }
    }
  }
  /**
   * Creates a default texture for the given texture that can be used
   * as a placeholder until the actual texture is ready for usage.
   *
   * @param {Texture} texture - The texture to create a default texture for.
   */
  createDefaultTexture(texture3) {
    const { gl, backend, defaultTextures } = this;
    const glTextureType = this.getGLTextureType(texture3);
    let textureGPU = defaultTextures[glTextureType];
    if (textureGPU === void 0) {
      textureGPU = gl.createTexture();
      backend.state.bindTexture(glTextureType, textureGPU);
      gl.texParameteri(glTextureType, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
      gl.texParameteri(glTextureType, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
      defaultTextures[glTextureType] = textureGPU;
    }
    backend.set(texture3, {
      textureGPU,
      glTextureType,
      isDefault: true
    });
  }
  /**
   * Defines a texture on the GPU for the given texture object.
   *
   * @param {Texture} texture - The texture.
   * @param {Object} [options={}] - Optional configuration parameter.
   * @return {undefined}
   */
  createTexture(texture3, options) {
    const { gl, backend } = this;
    const { levels, width, height, depth: depth3 } = options;
    const glFormat = backend.utils.convert(texture3.format, texture3.colorSpace);
    const glType = backend.utils.convert(texture3.type);
    const glInternalFormat = this.getInternalFormat(texture3.internalFormat, glFormat, glType, texture3.colorSpace, texture3.isVideoTexture);
    const textureGPU = gl.createTexture();
    const glTextureType = this.getGLTextureType(texture3);
    backend.state.bindTexture(glTextureType, textureGPU);
    this.setTextureParameters(glTextureType, texture3);
    if (texture3.isArrayTexture || texture3.isDataArrayTexture || texture3.isCompressedArrayTexture) {
      gl.texStorage3D(gl.TEXTURE_2D_ARRAY, levels, glInternalFormat, width, height, depth3);
    } else if (texture3.isData3DTexture) {
      gl.texStorage3D(gl.TEXTURE_3D, levels, glInternalFormat, width, height, depth3);
    } else if (!texture3.isVideoTexture) {
      gl.texStorage2D(glTextureType, levels, glInternalFormat, width, height);
    }
    backend.set(texture3, {
      textureGPU,
      glTextureType,
      glFormat,
      glType,
      glInternalFormat
    });
  }
  /**
   * Uploads texture buffer data to the GPU memory.
   *
   * @param {WebGLBuffer} buffer - The buffer data.
   * @param {Texture} texture - The texture,
   */
  copyBufferToTexture(buffer3, texture3) {
    const { gl, backend } = this;
    const { textureGPU, glTextureType, glFormat, glType } = backend.get(texture3);
    const { width, height } = texture3.source.data;
    gl.bindBuffer(gl.PIXEL_UNPACK_BUFFER, buffer3);
    backend.state.bindTexture(glTextureType, textureGPU);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
    gl.texSubImage2D(glTextureType, 0, 0, 0, width, height, glFormat, glType, 0);
    gl.bindBuffer(gl.PIXEL_UNPACK_BUFFER, null);
    backend.state.unbindTexture();
  }
  /**
   * Uploads the updated texture data to the GPU.
   *
   * @param {Texture} texture - The texture.
   * @param {Object} [options={}] - Optional configuration parameter.
   */
  updateTexture(texture3, options) {
    const { gl } = this;
    const { width, height } = options;
    const { textureGPU, glTextureType, glFormat, glType, glInternalFormat } = this.backend.get(texture3);
    if (texture3.isRenderTargetTexture || textureGPU === void 0)
      return;
    this.backend.state.bindTexture(glTextureType, textureGPU);
    this.setTextureParameters(glTextureType, texture3);
    if (texture3.isCompressedTexture) {
      const mipmaps = texture3.mipmaps;
      const image = options.image;
      for (let i = 0; i < mipmaps.length; i++) {
        const mipmap = mipmaps[i];
        if (texture3.isCompressedArrayTexture) {
          if (texture3.format !== gl.RGBA) {
            if (glFormat !== null) {
              gl.compressedTexSubImage3D(gl.TEXTURE_2D_ARRAY, i, 0, 0, 0, mipmap.width, mipmap.height, image.depth, glFormat, mipmap.data);
            } else {
              console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
            }
          } else {
            gl.texSubImage3D(gl.TEXTURE_2D_ARRAY, i, 0, 0, 0, mipmap.width, mipmap.height, image.depth, glFormat, glType, mipmap.data);
          }
        } else {
          if (glFormat !== null) {
            gl.compressedTexSubImage2D(gl.TEXTURE_2D, i, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data);
          } else {
            console.warn("Unsupported compressed texture format");
          }
        }
      }
    } else if (texture3.isCubeTexture) {
      const images = options.images;
      const mipmaps = texture3.mipmaps;
      for (let i = 0; i < 6; i++) {
        const image = getImage(images[i]);
        gl.texSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, 0, 0, width, height, glFormat, glType, image);
        for (let j = 0; j < mipmaps.length; j++) {
          const mipmap = mipmaps[j];
          const image2 = getImage(mipmap.images[i]);
          gl.texSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, 0, 0, image2.width, image2.height, glFormat, glType, image2);
        }
      }
    } else if (texture3.isDataArrayTexture || texture3.isArrayTexture) {
      const image = options.image;
      if (texture3.layerUpdates.size > 0) {
        const layerByteLength = getByteLength(image.width, image.height, texture3.format, texture3.type);
        for (const layerIndex of texture3.layerUpdates) {
          const layerData = image.data.subarray(
            layerIndex * layerByteLength / image.data.BYTES_PER_ELEMENT,
            (layerIndex + 1) * layerByteLength / image.data.BYTES_PER_ELEMENT
          );
          gl.texSubImage3D(gl.TEXTURE_2D_ARRAY, 0, 0, 0, layerIndex, image.width, image.height, 1, glFormat, glType, layerData);
        }
        texture3.clearLayerUpdates();
      } else {
        gl.texSubImage3D(gl.TEXTURE_2D_ARRAY, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data);
      }
    } else if (texture3.isData3DTexture) {
      const image = options.image;
      gl.texSubImage3D(gl.TEXTURE_3D, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data);
    } else if (texture3.isVideoTexture) {
      texture3.update();
      gl.texImage2D(glTextureType, 0, glInternalFormat, glFormat, glType, options.image);
    } else {
      const mipmaps = texture3.mipmaps;
      if (mipmaps.length > 0) {
        for (let i = 0, il = mipmaps.length; i < il; i++) {
          const mipmap = mipmaps[i];
          const image = getImage(mipmap);
          gl.texSubImage2D(glTextureType, i, 0, 0, mipmap.width, mipmap.height, glFormat, glType, image);
        }
      } else {
        const image = getImage(options.image);
        gl.texSubImage2D(glTextureType, 0, 0, 0, width, height, glFormat, glType, image);
      }
    }
  }
  /**
   * Generates mipmaps for the given texture.
   *
   * @param {Texture} texture - The texture.
   */
  generateMipmaps(texture3) {
    const { gl, backend } = this;
    const { textureGPU, glTextureType } = backend.get(texture3);
    backend.state.bindTexture(glTextureType, textureGPU);
    gl.generateMipmap(glTextureType);
  }
  /**
   * Deallocates the render buffers of the given render target.
   *
   * @param {RenderTarget} renderTarget - The render target.
   */
  deallocateRenderBuffers(renderTarget) {
    const { gl, backend } = this;
    if (renderTarget) {
      const renderContextData = backend.get(renderTarget);
      renderContextData.renderBufferStorageSetup = void 0;
      if (renderContextData.framebuffers) {
        for (const cacheKey in renderContextData.framebuffers) {
          gl.deleteFramebuffer(renderContextData.framebuffers[cacheKey]);
        }
        delete renderContextData.framebuffers;
      }
      if (renderContextData.depthRenderbuffer) {
        gl.deleteRenderbuffer(renderContextData.depthRenderbuffer);
        delete renderContextData.depthRenderbuffer;
      }
      if (renderContextData.stencilRenderbuffer) {
        gl.deleteRenderbuffer(renderContextData.stencilRenderbuffer);
        delete renderContextData.stencilRenderbuffer;
      }
      if (renderContextData.msaaFrameBuffer) {
        gl.deleteFramebuffer(renderContextData.msaaFrameBuffer);
        delete renderContextData.msaaFrameBuffer;
      }
      if (renderContextData.msaaRenderbuffers) {
        for (let i = 0; i < renderContextData.msaaRenderbuffers.length; i++) {
          gl.deleteRenderbuffer(renderContextData.msaaRenderbuffers[i]);
        }
        delete renderContextData.msaaRenderbuffers;
      }
    }
  }
  /**
   * Destroys the GPU data for the given texture object.
   *
   * @param {Texture} texture - The texture.
   */
  destroyTexture(texture3) {
    const { gl, backend } = this;
    const { textureGPU, renderTarget } = backend.get(texture3);
    this.deallocateRenderBuffers(renderTarget);
    gl.deleteTexture(textureGPU);
    backend.delete(texture3);
  }
  /**
   * Copies data of the given source texture to the given destination texture.
   *
   * @param {Texture} srcTexture - The source texture.
   * @param {Texture} dstTexture - The destination texture.
   * @param {?(Box3|Box2)} [srcRegion=null] - The region of the source texture to copy.
   * @param {?(Vector2|Vector3)} [dstPosition=null] - The destination position of the copy.
   * @param {number} [srcLevel=0] - The source mip level to copy from.
   * @param {number} [dstLevel=0] - The destination mip level to copy to.
   */
  copyTextureToTexture(srcTexture, dstTexture, srcRegion = null, dstPosition = null, srcLevel = 0, dstLevel = 0) {
    const { gl, backend } = this;
    const { state } = this.backend;
    const { textureGPU: dstTextureGPU, glTextureType, glType, glFormat } = backend.get(dstTexture);
    state.bindTexture(glTextureType, dstTextureGPU);
    let width, height, depth3, minX, minY, minZ;
    let dstX, dstY, dstZ;
    const image = srcTexture.isCompressedTexture ? srcTexture.mipmaps[dstLevel] : srcTexture.image;
    if (srcRegion !== null) {
      width = srcRegion.max.x - srcRegion.min.x;
      height = srcRegion.max.y - srcRegion.min.y;
      depth3 = srcRegion.isBox3 ? srcRegion.max.z - srcRegion.min.z : 1;
      minX = srcRegion.min.x;
      minY = srcRegion.min.y;
      minZ = srcRegion.isBox3 ? srcRegion.min.z : 0;
    } else {
      const levelScale = Math.pow(2, -srcLevel);
      width = Math.floor(image.width * levelScale);
      height = Math.floor(image.height * levelScale);
      if (srcTexture.isDataArrayTexture || srcTexture.isArrayTexture) {
        depth3 = image.depth;
      } else if (srcTexture.isData3DTexture) {
        depth3 = Math.floor(image.depth * levelScale);
      } else {
        depth3 = 1;
      }
      minX = 0;
      minY = 0;
      minZ = 0;
    }
    if (dstPosition !== null) {
      dstX = dstPosition.x;
      dstY = dstPosition.y;
      dstZ = dstPosition.z;
    } else {
      dstX = 0;
      dstY = 0;
      dstZ = 0;
    }
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY);
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha);
    gl.pixelStorei(gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment);
    const currentUnpackRowLen = gl.getParameter(gl.UNPACK_ROW_LENGTH);
    const currentUnpackImageHeight = gl.getParameter(gl.UNPACK_IMAGE_HEIGHT);
    const currentUnpackSkipPixels = gl.getParameter(gl.UNPACK_SKIP_PIXELS);
    const currentUnpackSkipRows = gl.getParameter(gl.UNPACK_SKIP_ROWS);
    const currentUnpackSkipImages = gl.getParameter(gl.UNPACK_SKIP_IMAGES);
    gl.pixelStorei(gl.UNPACK_ROW_LENGTH, image.width);
    gl.pixelStorei(gl.UNPACK_IMAGE_HEIGHT, image.height);
    gl.pixelStorei(gl.UNPACK_SKIP_PIXELS, minX);
    gl.pixelStorei(gl.UNPACK_SKIP_ROWS, minY);
    gl.pixelStorei(gl.UNPACK_SKIP_IMAGES, minZ);
    const isDst3D = dstTexture.isDataArrayTexture || dstTexture.isData3DTexture || dstTexture.isArrayTexture;
    if (srcTexture.isRenderTargetTexture || srcTexture.isDepthTexture) {
      const srcTextureData = backend.get(srcTexture);
      const dstTextureData = backend.get(dstTexture);
      const srcRenderContextData = backend.get(srcTextureData.renderTarget);
      const dstRenderContextData = backend.get(dstTextureData.renderTarget);
      const srcFramebuffer = srcRenderContextData.framebuffers[srcTextureData.cacheKey];
      const dstFramebuffer = dstRenderContextData.framebuffers[dstTextureData.cacheKey];
      state.bindFramebuffer(gl.READ_FRAMEBUFFER, srcFramebuffer);
      state.bindFramebuffer(gl.DRAW_FRAMEBUFFER, dstFramebuffer);
      let mask = gl.COLOR_BUFFER_BIT;
      if (srcTexture.isDepthTexture) mask = gl.DEPTH_BUFFER_BIT;
      gl.blitFramebuffer(minX, minY, width, height, dstX, dstY, width, height, mask, gl.NEAREST);
      state.bindFramebuffer(gl.READ_FRAMEBUFFER, null);
      state.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);
    } else {
      if (isDst3D) {
        if (srcTexture.isDataTexture || srcTexture.isData3DTexture) {
          gl.texSubImage3D(glTextureType, dstLevel, dstX, dstY, dstZ, width, height, depth3, glFormat, glType, image.data);
        } else if (dstTexture.isCompressedArrayTexture) {
          gl.compressedTexSubImage3D(glTextureType, dstLevel, dstX, dstY, dstZ, width, height, depth3, glFormat, image.data);
        } else {
          gl.texSubImage3D(glTextureType, dstLevel, dstX, dstY, dstZ, width, height, depth3, glFormat, glType, image);
        }
      } else {
        if (srcTexture.isDataTexture) {
          gl.texSubImage2D(glTextureType, dstLevel, dstX, dstY, width, height, glFormat, glType, image.data);
        } else if (srcTexture.isCompressedTexture) {
          gl.compressedTexSubImage2D(glTextureType, dstLevel, dstX, dstY, image.width, image.height, glFormat, image.data);
        } else {
          gl.texSubImage2D(glTextureType, dstLevel, dstX, dstY, width, height, glFormat, glType, image);
        }
      }
    }
    gl.pixelStorei(gl.UNPACK_ROW_LENGTH, currentUnpackRowLen);
    gl.pixelStorei(gl.UNPACK_IMAGE_HEIGHT, currentUnpackImageHeight);
    gl.pixelStorei(gl.UNPACK_SKIP_PIXELS, currentUnpackSkipPixels);
    gl.pixelStorei(gl.UNPACK_SKIP_ROWS, currentUnpackSkipRows);
    gl.pixelStorei(gl.UNPACK_SKIP_IMAGES, currentUnpackSkipImages);
    if (dstLevel === 0 && dstTexture.generateMipmaps) {
      gl.generateMipmap(glTextureType);
    }
    state.unbindTexture();
  }
  /**
   * Copies the current bound framebuffer to the given texture.
   *
   * @param {Texture} texture - The destination texture.
   * @param {RenderContext} renderContext - The render context.
   * @param {Vector4} rectangle - A four dimensional vector defining the origin and dimension of the copy.
   */
  copyFramebufferToTexture(texture3, renderContext, rectangle) {
    const { gl } = this;
    const { state } = this.backend;
    const { textureGPU } = this.backend.get(texture3);
    const { x, y, z: width, w: height } = rectangle;
    const requireDrawFrameBuffer = texture3.isDepthTexture === true || renderContext.renderTarget && renderContext.renderTarget.samples > 0;
    const srcHeight = renderContext.renderTarget ? renderContext.renderTarget.height : this.backend.getDrawingBufferSize().y;
    if (requireDrawFrameBuffer) {
      const partial = x !== 0 || y !== 0;
      let mask;
      let attachment;
      if (texture3.isDepthTexture === true) {
        mask = gl.DEPTH_BUFFER_BIT;
        attachment = gl.DEPTH_ATTACHMENT;
        if (renderContext.stencil) {
          mask |= gl.STENCIL_BUFFER_BIT;
        }
      } else {
        mask = gl.COLOR_BUFFER_BIT;
        attachment = gl.COLOR_ATTACHMENT0;
      }
      if (partial) {
        const renderTargetContextData = this.backend.get(renderContext.renderTarget);
        const fb = renderTargetContextData.framebuffers[renderContext.getCacheKey()];
        const msaaFrameBuffer = renderTargetContextData.msaaFrameBuffer;
        state.bindFramebuffer(gl.DRAW_FRAMEBUFFER, fb);
        state.bindFramebuffer(gl.READ_FRAMEBUFFER, msaaFrameBuffer);
        const flippedY = srcHeight - y - height;
        gl.blitFramebuffer(x, flippedY, x + width, flippedY + height, x, flippedY, x + width, flippedY + height, mask, gl.NEAREST);
        state.bindFramebuffer(gl.READ_FRAMEBUFFER, fb);
        state.bindTexture(gl.TEXTURE_2D, textureGPU);
        gl.copyTexSubImage2D(gl.TEXTURE_2D, 0, 0, 0, x, flippedY, width, height);
        state.unbindTexture();
      } else {
        const fb = gl.createFramebuffer();
        state.bindFramebuffer(gl.DRAW_FRAMEBUFFER, fb);
        gl.framebufferTexture2D(gl.DRAW_FRAMEBUFFER, attachment, gl.TEXTURE_2D, textureGPU, 0);
        gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, mask, gl.NEAREST);
        gl.deleteFramebuffer(fb);
      }
    } else {
      state.bindTexture(gl.TEXTURE_2D, textureGPU);
      gl.copyTexSubImage2D(gl.TEXTURE_2D, 0, 0, 0, x, srcHeight - height - y, width, height);
      state.unbindTexture();
    }
    if (texture3.generateMipmaps) this.generateMipmaps(texture3);
    this.backend._setFramebuffer(renderContext);
  }
  /**
   * SetupS storage for internal depth/stencil buffers and bind to correct framebuffer.
   *
   * @param {WebGLRenderbuffer} renderbuffer - The render buffer.
   * @param {RenderContext} renderContext - The render context.
   * @param {number} samples - The MSAA sample count.
   * @param {boolean} [useMultisampledRTT=false] - Whether to use WEBGL_multisampled_render_to_texture or not.
   */
  setupRenderBufferStorage(renderbuffer, renderContext, samples, useMultisampledRTT = false) {
    const { gl } = this;
    const renderTarget = renderContext.renderTarget;
    const { depthTexture, depthBuffer, stencilBuffer, width, height } = renderTarget;
    gl.bindRenderbuffer(gl.RENDERBUFFER, renderbuffer);
    if (depthBuffer && !stencilBuffer) {
      let glInternalFormat = gl.DEPTH_COMPONENT24;
      if (useMultisampledRTT === true) {
        const multisampledRTTExt = this.extensions.get("WEBGL_multisampled_render_to_texture");
        multisampledRTTExt.renderbufferStorageMultisampleEXT(gl.RENDERBUFFER, renderTarget.samples, glInternalFormat, width, height);
      } else if (samples > 0) {
        if (depthTexture && depthTexture.isDepthTexture) {
          if (depthTexture.type === gl.FLOAT) {
            glInternalFormat = gl.DEPTH_COMPONENT32F;
          }
        }
        gl.renderbufferStorageMultisample(gl.RENDERBUFFER, samples, glInternalFormat, width, height);
      } else {
        gl.renderbufferStorage(gl.RENDERBUFFER, glInternalFormat, width, height);
      }
      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, renderbuffer);
    } else if (depthBuffer && stencilBuffer) {
      if (samples > 0) {
        gl.renderbufferStorageMultisample(gl.RENDERBUFFER, samples, gl.DEPTH24_STENCIL8, width, height);
      } else {
        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, width, height);
      }
      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, renderbuffer);
    }
    gl.bindRenderbuffer(gl.RENDERBUFFER, null);
  }
  /**
   * Returns texture data as a typed array.
   *
   * @async
   * @param {Texture} texture - The texture to copy.
   * @param {number} x - The x coordinate of the copy origin.
   * @param {number} y - The y coordinate of the copy origin.
   * @param {number} width - The width of the copy.
   * @param {number} height - The height of the copy.
   * @param {number} faceIndex - The face index.
   * @return {Promise<TypedArray>} A Promise that resolves with a typed array when the copy operation has finished.
   */
  async copyTextureToBuffer(texture3, x, y, width, height, faceIndex) {
    const { backend, gl } = this;
    const { textureGPU, glFormat, glType } = this.backend.get(texture3);
    const fb = gl.createFramebuffer();
    gl.bindFramebuffer(gl.READ_FRAMEBUFFER, fb);
    const target = texture3.isCubeTexture ? gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex : gl.TEXTURE_2D;
    gl.framebufferTexture2D(gl.READ_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, target, textureGPU, 0);
    const typedArrayType = this._getTypedArrayType(glType);
    const bytesPerTexel = this._getBytesPerTexel(glType, glFormat);
    const elementCount = width * height;
    const byteLength = elementCount * bytesPerTexel;
    const buffer3 = gl.createBuffer();
    gl.bindBuffer(gl.PIXEL_PACK_BUFFER, buffer3);
    gl.bufferData(gl.PIXEL_PACK_BUFFER, byteLength, gl.STREAM_READ);
    gl.readPixels(x, y, width, height, glFormat, glType, 0);
    gl.bindBuffer(gl.PIXEL_PACK_BUFFER, null);
    await backend.utils._clientWaitAsync();
    const dstBuffer = new typedArrayType(byteLength / typedArrayType.BYTES_PER_ELEMENT);
    gl.bindBuffer(gl.PIXEL_PACK_BUFFER, buffer3);
    gl.getBufferSubData(gl.PIXEL_PACK_BUFFER, 0, dstBuffer);
    gl.bindBuffer(gl.PIXEL_PACK_BUFFER, null);
    gl.deleteFramebuffer(fb);
    return dstBuffer;
  }
  /**
   * Returns the corresponding typed array type for the given WebGL data type.
   *
   * @private
   * @param {GLenum} glType - The WebGL data type.
   * @return {TypedArray.constructor} The typed array type.
   */
  _getTypedArrayType(glType) {
    const { gl } = this;
    if (glType === gl.UNSIGNED_BYTE) return Uint8Array;
    if (glType === gl.UNSIGNED_SHORT_4_4_4_4) return Uint16Array;
    if (glType === gl.UNSIGNED_SHORT_5_5_5_1) return Uint16Array;
    if (glType === gl.UNSIGNED_SHORT_5_6_5) return Uint16Array;
    if (glType === gl.UNSIGNED_SHORT) return Uint16Array;
    if (glType === gl.UNSIGNED_INT) return Uint32Array;
    if (glType === gl.HALF_FLOAT) return Uint16Array;
    if (glType === gl.FLOAT) return Float32Array;
    throw new Error(`Unsupported WebGL type: ${glType}`);
  }
  /**
   * Returns the bytes-per-texel value for the given WebGL data type and texture format.
   *
   * @private
   * @param {GLenum} glType - The WebGL data type.
   * @param {GLenum} glFormat - The WebGL texture format.
   * @return {number} The bytes-per-texel.
   */
  _getBytesPerTexel(glType, glFormat) {
    const { gl } = this;
    let bytesPerComponent = 0;
    if (glType === gl.UNSIGNED_BYTE) bytesPerComponent = 1;
    if (glType === gl.UNSIGNED_SHORT_4_4_4_4 || glType === gl.UNSIGNED_SHORT_5_5_5_1 || glType === gl.UNSIGNED_SHORT_5_6_5 || glType === gl.UNSIGNED_SHORT || glType === gl.HALF_FLOAT) bytesPerComponent = 2;
    if (glType === gl.UNSIGNED_INT || glType === gl.FLOAT) bytesPerComponent = 4;
    if (glFormat === gl.RGBA) return bytesPerComponent * 4;
    if (glFormat === gl.RGB) return bytesPerComponent * 3;
    if (glFormat === gl.ALPHA) return bytesPerComponent;
  }
};
function getImage(source) {
  if (source.isDataTexture) {
    return source.image.data;
  } else if (typeof HTMLImageElement !== "undefined" && source instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && source instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && source instanceof ImageBitmap || typeof OffscreenCanvas !== "undefined" && source instanceof OffscreenCanvas) {
    return source;
  }
  return source.data;
}
var WebGLExtensions = class {
  /**
   * Constructs a new utility object.
   *
   * @param {WebGLBackend} backend - The WebGL 2 backend.
   */
  constructor(backend) {
    this.backend = backend;
    this.gl = this.backend.gl;
    this.availableExtensions = this.gl.getSupportedExtensions();
    this.extensions = {};
  }
  /**
   * Returns the extension object for the given extension name.
   *
   * @param {string} name - The extension name.
   * @return {Object} The extension object.
   */
  get(name) {
    let extension = this.extensions[name];
    if (extension === void 0) {
      extension = this.gl.getExtension(name);
      this.extensions[name] = extension;
    }
    return extension;
  }
  /**
   * Returns `true` if the requested extension is available.
   *
   * @param {string} name - The extension name.
   * @return {boolean} Whether the given extension is available or not.
   */
  has(name) {
    return this.availableExtensions.includes(name);
  }
};
var WebGLCapabilities = class {
  /**
   * Constructs a new utility object.
   *
   * @param {WebGLBackend} backend - The WebGL 2 backend.
   */
  constructor(backend) {
    this.backend = backend;
    this.maxAnisotropy = null;
  }
  /**
   * Returns the maximum anisotropy texture filtering value. This value
   * depends on the device and is reported by the `EXT_texture_filter_anisotropic`
   * WebGL extension.
   *
   * @return {number} The maximum anisotropy texture filtering value.
   */
  getMaxAnisotropy() {
    if (this.maxAnisotropy !== null) return this.maxAnisotropy;
    const gl = this.backend.gl;
    const extensions = this.backend.extensions;
    if (extensions.has("EXT_texture_filter_anisotropic") === true) {
      const extension = extensions.get("EXT_texture_filter_anisotropic");
      this.maxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else {
      this.maxAnisotropy = 0;
    }
    return this.maxAnisotropy;
  }
};
var GLFeatureName = {
  "WEBGL_multi_draw": "WEBGL_multi_draw",
  "WEBGL_compressed_texture_astc": "texture-compression-astc",
  "WEBGL_compressed_texture_etc": "texture-compression-etc2",
  "WEBGL_compressed_texture_etc1": "texture-compression-etc1",
  "WEBGL_compressed_texture_pvrtc": "texture-compression-pvrtc",
  "WEBKIT_WEBGL_compressed_texture_pvrtc": "texture-compression-pvrtc",
  "WEBGL_compressed_texture_s3tc": "texture-compression-bc",
  "EXT_texture_compression_bptc": "texture-compression-bptc",
  "EXT_disjoint_timer_query_webgl2": "timestamp-query",
  "OVR_multiview2": "OVR_multiview2"
};
var WebGLBufferRenderer = class {
  constructor(backend) {
    this.gl = backend.gl;
    this.extensions = backend.extensions;
    this.info = backend.renderer.info;
    this.mode = null;
    this.index = 0;
    this.type = null;
    this.object = null;
  }
  render(start, count2) {
    const { gl, mode: mode2, object: object2, type, info, index: index5 } = this;
    if (index5 !== 0) {
      gl.drawElements(mode2, count2, type, start);
    } else {
      gl.drawArrays(mode2, start, count2);
    }
    info.update(object2, count2, 1);
  }
  renderInstances(start, count2, primcount) {
    const { gl, mode: mode2, type, index: index5, object: object2, info } = this;
    if (primcount === 0) return;
    if (index5 !== 0) {
      gl.drawElementsInstanced(mode2, count2, type, start, primcount);
    } else {
      gl.drawArraysInstanced(mode2, start, count2, primcount);
    }
    info.update(object2, count2, primcount);
  }
  renderMultiDraw(starts, counts, drawCount) {
    const { extensions, mode: mode2, object: object2, info } = this;
    if (drawCount === 0) return;
    const extension = extensions.get("WEBGL_multi_draw");
    if (extension === null) {
      for (let i = 0; i < drawCount; i++) {
        this.render(starts[i], counts[i]);
      }
    } else {
      if (this.index !== 0) {
        extension.multiDrawElementsWEBGL(mode2, counts, 0, this.type, starts, 0, drawCount);
      } else {
        extension.multiDrawArraysWEBGL(mode2, starts, 0, counts, 0, drawCount);
      }
      let elementCount = 0;
      for (let i = 0; i < drawCount; i++) {
        elementCount += counts[i];
      }
      info.update(object2, elementCount, 1);
    }
  }
  renderMultiDrawInstances(starts, counts, drawCount, primcount) {
    const { extensions, mode: mode2, object: object2, info } = this;
    if (drawCount === 0) return;
    const extension = extensions.get("WEBGL_multi_draw");
    if (extension === null) {
      for (let i = 0; i < drawCount; i++) {
        this.renderInstances(starts[i], counts[i], primcount[i]);
      }
    } else {
      if (this.index !== 0) {
        extension.multiDrawElementsInstancedWEBGL(mode2, counts, 0, this.type, starts, 0, primcount, 0, drawCount);
      } else {
        extension.multiDrawArraysInstancedWEBGL(mode2, starts, 0, counts, 0, primcount, 0, drawCount);
      }
      let elementCount = 0;
      for (let i = 0; i < drawCount; i++) {
        elementCount += counts[i] * primcount[i];
      }
      info.update(object2, elementCount, 1);
    }
  }
  //
};
var TimestampQueryPool = class {
  /**
   * Creates a new timestamp query pool.
   *
   * @param {number} [maxQueries=256] - Maximum number of queries this pool can hold.
   */
  constructor(maxQueries = 256) {
    this.trackTimestamp = true;
    this.maxQueries = maxQueries;
    this.currentQueryIndex = 0;
    this.queryOffsets = /* @__PURE__ */ new Map();
    this.isDisposed = false;
    this.lastValue = 0;
    this.pendingResolve = false;
  }
  /**
   * Allocate queries for a specific uid.
   *
   * @abstract
   * @param {string} uid - A unique identifier for the render context.
   * @returns {?number}
   */
  allocateQueriesForContext() {
  }
  /**
   * Resolve all timestamps and return data (or process them).
   *
   * @abstract
   * @async
   * @returns {Promise<number>|number} The resolved timestamp value.
   */
  async resolveQueriesAsync() {
  }
  /**
   * Dispose of the query pool.
   *
   * @abstract
   */
  dispose() {
  }
};
var WebGLTimestampQueryPool = class extends TimestampQueryPool {
  /**
   * Creates a new WebGL timestamp query pool.
   *
   * @param {WebGLRenderingContext|WebGL2RenderingContext} gl - The WebGL context.
   * @param {string} type - The type identifier for this query pool.
   * @param {number} [maxQueries=2048] - Maximum number of queries this pool can hold.
   */
  constructor(gl, type, maxQueries = 2048) {
    super(maxQueries);
    this.gl = gl;
    this.type = type;
    this.ext = gl.getExtension("EXT_disjoint_timer_query_webgl2") || gl.getExtension("EXT_disjoint_timer_query");
    if (!this.ext) {
      console.warn("EXT_disjoint_timer_query not supported; timestamps will be disabled.");
      this.trackTimestamp = false;
      return;
    }
    this.queries = [];
    for (let i = 0; i < this.maxQueries; i++) {
      this.queries.push(gl.createQuery());
    }
    this.activeQuery = null;
    this.queryStates = /* @__PURE__ */ new Map();
  }
  /**
   * Allocates a pair of queries for a given render context.
   *
   * @param {string} uid - A unique identifier for the render context.
   * @returns {?number} The base offset for the allocated queries, or null if allocation failed.
   */
  allocateQueriesForContext(uid) {
    if (!this.trackTimestamp) return null;
    if (this.currentQueryIndex + 2 > this.maxQueries) {
      warnOnce(`WebGPUTimestampQueryPool [${this.type}]: Maximum number of queries exceeded, when using trackTimestamp it is necessary to resolves the queries via renderer.resolveTimestampsAsync( THREE.TimestampQuery.${this.type.toUpperCase()} ).`);
      return null;
    }
    const baseOffset = this.currentQueryIndex;
    this.currentQueryIndex += 2;
    this.queryStates.set(baseOffset, "inactive");
    this.queryOffsets.set(uid, baseOffset);
    return baseOffset;
  }
  /**
   * Begins a timestamp query for the specified render context.
   *
   * @param {string} uid - A unique identifier for the render context.
   */
  beginQuery(uid) {
    if (!this.trackTimestamp || this.isDisposed) {
      return;
    }
    const baseOffset = this.queryOffsets.get(uid);
    if (baseOffset == null) {
      return;
    }
    if (this.activeQuery !== null) {
      return;
    }
    const query = this.queries[baseOffset];
    if (!query) {
      return;
    }
    try {
      if (this.queryStates.get(baseOffset) === "inactive") {
        this.gl.beginQuery(this.ext.TIME_ELAPSED_EXT, query);
        this.activeQuery = baseOffset;
        this.queryStates.set(baseOffset, "started");
      }
    } catch (error) {
      console.error("Error in beginQuery:", error);
      this.activeQuery = null;
      this.queryStates.set(baseOffset, "inactive");
    }
  }
  /**
   * Ends the active timestamp query for the specified render context.
   *
   * @param {string} uid - A unique identifier for the render context.
   */
  endQuery(uid) {
    if (!this.trackTimestamp || this.isDisposed) {
      return;
    }
    const baseOffset = this.queryOffsets.get(uid);
    if (baseOffset == null) {
      return;
    }
    if (this.activeQuery !== baseOffset) {
      return;
    }
    try {
      this.gl.endQuery(this.ext.TIME_ELAPSED_EXT);
      this.queryStates.set(baseOffset, "ended");
      this.activeQuery = null;
    } catch (error) {
      console.error("Error in endQuery:", error);
      this.queryStates.set(baseOffset, "inactive");
      this.activeQuery = null;
    }
  }
  /**
   * Asynchronously resolves all completed queries and returns the total duration.
   *
   * @async
   * @returns {Promise<number>} The total duration in milliseconds, or the last valid value if resolution fails.
   */
  async resolveQueriesAsync() {
    if (!this.trackTimestamp || this.pendingResolve) {
      return this.lastValue;
    }
    this.pendingResolve = true;
    try {
      const resolvePromises = [];
      for (const [baseOffset, state] of this.queryStates) {
        if (state === "ended") {
          const query = this.queries[baseOffset];
          resolvePromises.push(this.resolveQuery(query));
        }
      }
      if (resolvePromises.length === 0) {
        return this.lastValue;
      }
      const results = await Promise.all(resolvePromises);
      const totalDuration = results.reduce((acc, val) => acc + val, 0);
      this.lastValue = totalDuration;
      this.currentQueryIndex = 0;
      this.queryOffsets.clear();
      this.queryStates.clear();
      this.activeQuery = null;
      return totalDuration;
    } catch (error) {
      console.error("Error resolving queries:", error);
      return this.lastValue;
    } finally {
      this.pendingResolve = false;
    }
  }
  /**
   * Resolves a single query, checking for completion and disjoint operation.
   *
   * @async
   * @param {WebGLQuery} query - The query object to resolve.
   * @returns {Promise<number>} The elapsed time in milliseconds.
   */
  async resolveQuery(query) {
    return new Promise((resolve) => {
      if (this.isDisposed) {
        resolve(this.lastValue);
        return;
      }
      let timeoutId;
      let isResolved = false;
      const cleanup = () => {
        if (timeoutId) {
          clearTimeout(timeoutId);
          timeoutId = null;
        }
      };
      const finalizeResolution = (value) => {
        if (!isResolved) {
          isResolved = true;
          cleanup();
          resolve(value);
        }
      };
      const checkQuery = () => {
        if (this.isDisposed) {
          finalizeResolution(this.lastValue);
          return;
        }
        try {
          const disjoint2 = this.gl.getParameter(this.ext.GPU_DISJOINT_EXT);
          if (disjoint2) {
            finalizeResolution(this.lastValue);
            return;
          }
          const available = this.gl.getQueryParameter(query, this.gl.QUERY_RESULT_AVAILABLE);
          if (!available) {
            timeoutId = setTimeout(checkQuery, 1);
            return;
          }
          const elapsed = this.gl.getQueryParameter(query, this.gl.QUERY_RESULT);
          resolve(Number(elapsed) / 1e6);
        } catch (error) {
          console.error("Error checking query:", error);
          resolve(this.lastValue);
        }
      };
      checkQuery();
    });
  }
  /**
   * Releases all resources held by this query pool.
   * This includes deleting all query objects and clearing internal state.
   */
  dispose() {
    if (this.isDisposed) {
      return;
    }
    this.isDisposed = true;
    if (!this.trackTimestamp) return;
    for (const query of this.queries) {
      this.gl.deleteQuery(query);
    }
    this.queries = [];
    this.queryStates.clear();
    this.queryOffsets.clear();
    this.lastValue = 0;
    this.activeQuery = null;
  }
};
var WebGLBackend = class extends Backend {
  /**
   * WebGLBackend options.
   *
   * @typedef {Object} WebGLBackend~Options
   * @property {boolean} [logarithmicDepthBuffer=false] - Whether logarithmic depth buffer is enabled or not.
   * @property {boolean} [alpha=true] - Whether the default framebuffer (which represents the final contents of the canvas) should be transparent or opaque.
   * @property {boolean} [depth=true] - Whether the default framebuffer should have a depth buffer or not.
   * @property {boolean} [stencil=false] - Whether the default framebuffer should have a stencil buffer or not.
   * @property {boolean} [antialias=false] - Whether MSAA as the default anti-aliasing should be enabled or not.
   * @property {number} [samples=0] - When `antialias` is `true`, `4` samples are used by default. Set this parameter to any other integer value than 0 to overwrite the default.
   * @property {boolean} [forceWebGL=false] - If set to `true`, the renderer uses a WebGL 2 backend no matter if WebGPU is supported or not.
   * @property {WebGL2RenderingContext} [context=undefined] - A WebGL 2 rendering context.
   */
  /**
   * Constructs a new WebGPU backend.
   *
   * @param {WebGLBackend~Options} [parameters] - The configuration parameter.
   */
  constructor(parameters = {}) {
    super(parameters);
    this.isWebGLBackend = true;
    this.attributeUtils = null;
    this.extensions = null;
    this.capabilities = null;
    this.textureUtils = null;
    this.bufferRenderer = null;
    this.gl = null;
    this.state = null;
    this.utils = null;
    this.vaoCache = {};
    this.transformFeedbackCache = {};
    this.discard = false;
    this.disjoint = null;
    this.parallel = null;
    this._currentContext = null;
    this._knownBindings = /* @__PURE__ */ new WeakSet();
    this._supportsInvalidateFramebuffer = typeof navigator === "undefined" ? false : /OculusBrowser/g.test(navigator.userAgent);
    this._xrFramebuffer = null;
  }
  /**
   * Initializes the backend so it is ready for usage.
   *
   * @param {Renderer} renderer - The renderer.
   */
  init(renderer) {
    super.init(renderer);
    const parameters = this.parameters;
    const contextAttributes = {
      antialias: renderer.samples > 0,
      alpha: true,
      // always true for performance reasons
      depth: renderer.depth,
      stencil: renderer.stencil
    };
    const glContext = parameters.context !== void 0 ? parameters.context : renderer.domElement.getContext("webgl2", contextAttributes);
    function onContextLost(event) {
      event.preventDefault();
      const contextLossInfo = {
        api: "WebGL",
        message: event.statusMessage || "Unknown reason",
        reason: null,
        originalEvent: event
      };
      renderer.onDeviceLost(contextLossInfo);
    }
    this._onContextLost = onContextLost;
    renderer.domElement.addEventListener("webglcontextlost", onContextLost, false);
    this.gl = glContext;
    this.extensions = new WebGLExtensions(this);
    this.capabilities = new WebGLCapabilities(this);
    this.attributeUtils = new WebGLAttributeUtils(this);
    this.textureUtils = new WebGLTextureUtils(this);
    this.bufferRenderer = new WebGLBufferRenderer(this);
    this.state = new WebGLState(this);
    this.utils = new WebGLUtils(this);
    this.extensions.get("EXT_color_buffer_float");
    this.extensions.get("WEBGL_clip_cull_distance");
    this.extensions.get("OES_texture_float_linear");
    this.extensions.get("EXT_color_buffer_half_float");
    this.extensions.get("WEBGL_multisampled_render_to_texture");
    this.extensions.get("WEBGL_render_shared_exponent");
    this.extensions.get("WEBGL_multi_draw");
    this.extensions.get("OVR_multiview2");
    this.disjoint = this.extensions.get("EXT_disjoint_timer_query_webgl2");
    this.parallel = this.extensions.get("KHR_parallel_shader_compile");
  }
  /**
   * The coordinate system of the backend.
   *
   * @type {number}
   * @readonly
   */
  get coordinateSystem() {
    return WebGLCoordinateSystem;
  }
  /**
   * This method performs a readback operation by moving buffer data from
   * a storage buffer attribute from the GPU to the CPU.
   *
   * @async
   * @param {StorageBufferAttribute} attribute - The storage buffer attribute.
   * @return {Promise<ArrayBuffer>} A promise that resolves with the buffer data when the data are ready.
   */
  async getArrayBufferAsync(attribute3) {
    return await this.attributeUtils.getArrayBufferAsync(attribute3);
  }
  /**
   * Can be used to synchronize CPU operations with GPU tasks. So when this method is called,
   * the CPU waits for the GPU to complete its operation (e.g. a compute task).
   *
   * @async
   * @return {Promise} A Promise that resolves when synchronization has been finished.
   */
  async waitForGPU() {
    await this.utils._clientWaitAsync();
  }
  /**
   * Ensures the backend is XR compatible.
   *
   * @async
   * @return {Promise} A Promise that resolve when the renderer is XR compatible.
   */
  async makeXRCompatible() {
    const attributes = this.gl.getContextAttributes();
    if (attributes.xrCompatible !== true) {
      await this.gl.makeXRCompatible();
    }
  }
  /**
   * Sets the XR rendering destination.
   *
   * @param {WebGLFramebuffer} xrFramebuffer - The XR framebuffer.
   */
  setXRTarget(xrFramebuffer) {
    this._xrFramebuffer = xrFramebuffer;
  }
  /**
   * Configures the given XR render target with external textures.
   *
   * This method is only relevant when using the WebXR Layers API.
   *
   * @param {XRRenderTarget} renderTarget - The XR render target.
   * @param {WebGLTexture} colorTexture - A native color texture.
   * @param {?WebGLTexture} [depthTexture=null] - A native depth texture.
   */
  setXRRenderTargetTextures(renderTarget, colorTexture, depthTexture = null) {
    const gl = this.gl;
    this.set(renderTarget.texture, { textureGPU: colorTexture, glInternalFormat: gl.RGBA8 });
    if (depthTexture !== null) {
      const glInternalFormat = renderTarget.stencilBuffer ? gl.DEPTH24_STENCIL8 : gl.DEPTH_COMPONENT24;
      this.set(renderTarget.depthTexture, { textureGPU: depthTexture, glInternalFormat });
      if (this.extensions.has("WEBGL_multisampled_render_to_texture") === true && renderTarget._autoAllocateDepthBuffer === true && renderTarget.multiview === false) {
        console.warn("THREE.WebGLBackend: Render-to-texture extension was disabled because an external texture was provided");
      }
      renderTarget._autoAllocateDepthBuffer = false;
    }
  }
  /**
   * Inits a time stamp query for the given render context.
   *
   * @param {string} type - The type of the timestamp query.
   * @param {string} uid - A unique identifier for the timestamp query.
   */
  initTimestampQuery(type, uid) {
    if (!this.disjoint || !this.trackTimestamp) return;
    if (!this.timestampQueryPool[type]) {
      this.timestampQueryPool[type] = new WebGLTimestampQueryPool(this.gl, type, 2048);
    }
    const timestampQueryPool = this.timestampQueryPool[type];
    const baseOffset = timestampQueryPool.allocateQueriesForContext(uid);
    if (baseOffset !== null) {
      timestampQueryPool.beginQuery(uid);
    }
  }
  // timestamp utils
  /**
   * Prepares the timestamp buffer.
   *
   * @param {string} type - The type of the timestamp query.
   * @param {string} uid - A unique identifier for the timestamp query.
   */
  prepareTimestampBuffer(type, uid) {
    if (!this.disjoint || !this.trackTimestamp) return;
    const timestampQueryPool = this.timestampQueryPool[type];
    timestampQueryPool.endQuery(uid);
  }
  /**
   * Returns the backend's rendering context.
   *
   * @return {WebGL2RenderingContext} The rendering context.
   */
  getContext() {
    return this.gl;
  }
  /**
   * This method is executed at the beginning of a render call and prepares
   * the WebGL state for upcoming render calls
   *
   * @param {RenderContext} renderContext - The render context.
   */
  beginRender(renderContext) {
    const { state } = this;
    const renderContextData = this.get(renderContext);
    renderContextData.frameCalls = this.renderer.info.render.frameCalls;
    if (renderContext.viewport) {
      this.updateViewport(renderContext);
    } else {
      const { width, height } = this.getDrawingBufferSize();
      state.viewport(0, 0, width, height);
    }
    if (renderContext.scissor) {
      const { x, y, width, height } = renderContext.scissorValue;
      state.scissor(x, renderContext.height - height - y, width, height);
    }
    this.initTimestampQuery(TimestampQuery.RENDER, this.getTimestampUID(renderContext));
    renderContextData.previousContext = this._currentContext;
    this._currentContext = renderContext;
    this._setFramebuffer(renderContext);
    this.clear(renderContext.clearColor, renderContext.clearDepth, renderContext.clearStencil, renderContext, false);
    const occlusionQueryCount = renderContext.occlusionQueryCount;
    if (occlusionQueryCount > 0) {
      renderContextData.currentOcclusionQueries = renderContextData.occlusionQueries;
      renderContextData.currentOcclusionQueryObjects = renderContextData.occlusionQueryObjects;
      renderContextData.lastOcclusionObject = null;
      renderContextData.occlusionQueries = new Array(occlusionQueryCount);
      renderContextData.occlusionQueryObjects = new Array(occlusionQueryCount);
      renderContextData.occlusionQueryIndex = 0;
    }
  }
  /**
   * This method is executed at the end of a render call and finalizes work
   * after draw calls.
   *
   * @param {RenderContext} renderContext - The render context.
   */
  finishRender(renderContext) {
    const { gl, state } = this;
    const renderContextData = this.get(renderContext);
    const previousContext = renderContextData.previousContext;
    state.resetVertexState();
    const occlusionQueryCount = renderContext.occlusionQueryCount;
    if (occlusionQueryCount > 0) {
      if (occlusionQueryCount > renderContextData.occlusionQueryIndex) {
        gl.endQuery(gl.ANY_SAMPLES_PASSED);
      }
      this.resolveOccludedAsync(renderContext);
    }
    const textures = renderContext.textures;
    if (textures !== null) {
      for (let i = 0; i < textures.length; i++) {
        const texture3 = textures[i];
        if (texture3.generateMipmaps) {
          this.generateMipmaps(texture3);
        }
      }
    }
    this._currentContext = previousContext;
    this._resolveRenderTarget(renderContext);
    if (previousContext !== null) {
      this._setFramebuffer(previousContext);
      if (previousContext.viewport) {
        this.updateViewport(previousContext);
      } else {
        const { width, height } = this.getDrawingBufferSize();
        state.viewport(0, 0, width, height);
      }
    }
    this.prepareTimestampBuffer(TimestampQuery.RENDER, this.getTimestampUID(renderContext));
  }
  /**
   * This method processes the result of occlusion queries and writes it
   * into render context data.
   *
   * @async
   * @param {RenderContext} renderContext - The render context.
   */
  resolveOccludedAsync(renderContext) {
    const renderContextData = this.get(renderContext);
    const { currentOcclusionQueries, currentOcclusionQueryObjects } = renderContextData;
    if (currentOcclusionQueries && currentOcclusionQueryObjects) {
      const occluded = /* @__PURE__ */ new WeakSet();
      const { gl } = this;
      renderContextData.currentOcclusionQueryObjects = null;
      renderContextData.currentOcclusionQueries = null;
      const check = () => {
        let completed = 0;
        for (let i = 0; i < currentOcclusionQueries.length; i++) {
          const query = currentOcclusionQueries[i];
          if (query === null) continue;
          if (gl.getQueryParameter(query, gl.QUERY_RESULT_AVAILABLE)) {
            if (gl.getQueryParameter(query, gl.QUERY_RESULT) === 0) occluded.add(currentOcclusionQueryObjects[i]);
            currentOcclusionQueries[i] = null;
            gl.deleteQuery(query);
            completed++;
          }
        }
        if (completed < currentOcclusionQueries.length) {
          requestAnimationFrame(check);
        } else {
          renderContextData.occluded = occluded;
        }
      };
      check();
    }
  }
  /**
   * Returns `true` if the given 3D object is fully occluded by other
   * 3D objects in the scene.
   *
   * @param {RenderContext} renderContext - The render context.
   * @param {Object3D} object - The 3D object to test.
   * @return {boolean} Whether the 3D object is fully occluded or not.
   */
  isOccluded(renderContext, object2) {
    const renderContextData = this.get(renderContext);
    return renderContextData.occluded && renderContextData.occluded.has(object2);
  }
  /**
   * Updates the viewport with the values from the given render context.
   *
   * @param {RenderContext} renderContext - The render context.
   */
  updateViewport(renderContext) {
    const { state } = this;
    const { x, y, width, height } = renderContext.viewportValue;
    state.viewport(x, renderContext.height - height - y, width, height);
  }
  /**
   * Defines the scissor test.
   *
   * @param {boolean} boolean - Whether the scissor test should be enabled or not.
   */
  setScissorTest(boolean) {
    const state = this.state;
    state.setScissorTest(boolean);
  }
  /**
   * Returns the clear color and alpha into a single
   * color object.
   *
   * @return {Color4} The clear color.
   */
  getClearColor() {
    const clearColor = super.getClearColor();
    clearColor.r *= clearColor.a;
    clearColor.g *= clearColor.a;
    clearColor.b *= clearColor.a;
    return clearColor;
  }
  /**
   * Performs a clear operation.
   *
   * @param {boolean} color - Whether the color buffer should be cleared or not.
   * @param {boolean} depth - Whether the depth buffer should be cleared or not.
   * @param {boolean} stencil - Whether the stencil buffer should be cleared or not.
   * @param {?Object} [descriptor=null] - The render context of the current set render target.
   * @param {boolean} [setFrameBuffer=true] - Controls whether the intermediate framebuffer should be set or not.
   * @param {boolean} [resolveRenderTarget=true] - Controls whether an active render target should be resolved
   * or not. Only relevant for explicit clears.
   */
  clear(color4, depth3, stencil, descriptor = null, setFrameBuffer = true, resolveRenderTarget = true) {
    const { gl, renderer } = this;
    if (descriptor === null) {
      const clearColor = this.getClearColor();
      descriptor = {
        textures: null,
        clearColorValue: clearColor
      };
    }
    let clear = 0;
    if (color4) clear |= gl.COLOR_BUFFER_BIT;
    if (depth3) clear |= gl.DEPTH_BUFFER_BIT;
    if (stencil) clear |= gl.STENCIL_BUFFER_BIT;
    if (clear !== 0) {
      let clearColor;
      if (descriptor.clearColorValue) {
        clearColor = descriptor.clearColorValue;
      } else {
        clearColor = this.getClearColor();
      }
      const clearDepth = renderer.getClearDepth();
      const clearStencil = renderer.getClearStencil();
      if (depth3) this.state.setDepthMask(true);
      if (descriptor.textures === null) {
        gl.clearColor(clearColor.r, clearColor.g, clearColor.b, clearColor.a);
        gl.clear(clear);
      } else {
        if (setFrameBuffer) this._setFramebuffer(descriptor);
        if (color4) {
          for (let i = 0; i < descriptor.textures.length; i++) {
            if (i === 0) {
              gl.clearBufferfv(gl.COLOR, i, [clearColor.r, clearColor.g, clearColor.b, clearColor.a]);
            } else {
              gl.clearBufferfv(gl.COLOR, i, [0, 0, 0, 1]);
            }
          }
        }
        if (depth3 && stencil) {
          gl.clearBufferfi(gl.DEPTH_STENCIL, 0, clearDepth, clearStencil);
        } else if (depth3) {
          gl.clearBufferfv(gl.DEPTH, 0, [clearDepth]);
        } else if (stencil) {
          gl.clearBufferiv(gl.STENCIL, 0, [clearStencil]);
        }
        if (setFrameBuffer && resolveRenderTarget) this._resolveRenderTarget(descriptor);
      }
    }
  }
  /**
   * This method is executed at the beginning of a compute call and
   * prepares the state for upcoming compute tasks.
   *
   * @param {Node|Array<Node>} computeGroup - The compute node(s).
   */
  beginCompute(computeGroup) {
    const { state, gl } = this;
    const computeGroupData = this.get(computeGroup);
    computeGroupData.frameCalls = this.renderer.info.compute.frameCalls;
    state.bindFramebuffer(gl.FRAMEBUFFER, null);
    this.initTimestampQuery(TimestampQuery.COMPUTE, this.getTimestampUID(computeGroup));
  }
  /**
   * Executes a compute command for the given compute node.
   *
   * @param {Node|Array<Node>} computeGroup - The group of compute nodes of a compute call. Can be a single compute node.
   * @param {Node} computeNode - The compute node.
   * @param {Array<BindGroup>} bindings - The bindings.
   * @param {ComputePipeline} pipeline - The compute pipeline.
   * @param {?number} [count=null] - The count of compute invocations. If `null`, the count is determined by the compute node.
   */
  compute(computeGroup, computeNode, bindings, pipeline, count2 = null) {
    const { state, gl } = this;
    if (this.discard === false) {
      gl.enable(gl.RASTERIZER_DISCARD);
      this.discard = true;
    }
    const { programGPU, transformBuffers, attributes } = this.get(pipeline);
    const vaoKey = this._getVaoKey(attributes);
    const vaoGPU = this.vaoCache[vaoKey];
    if (vaoGPU === void 0) {
      this.vaoCache[vaoKey] = this._createVao(attributes);
    } else {
      state.setVertexState(vaoGPU);
    }
    state.useProgram(programGPU);
    this._bindUniforms(bindings);
    const transformFeedbackGPU = this._getTransformFeedback(transformBuffers);
    gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, transformFeedbackGPU);
    gl.beginTransformFeedback(gl.POINTS);
    count2 = count2 !== null ? count2 : computeNode.count;
    if (Array.isArray(count2)) {
      warnOnce("WebGLBackend.compute(): The count parameter must be a single number, not an array.");
      count2 = count2[0];
    }
    if (attributes[0].isStorageInstancedBufferAttribute) {
      gl.drawArraysInstanced(gl.POINTS, 0, 1, count2);
    } else {
      gl.drawArrays(gl.POINTS, 0, count2);
    }
    gl.endTransformFeedback();
    gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null);
    for (let i = 0; i < transformBuffers.length; i++) {
      const dualAttributeData = transformBuffers[i];
      if (dualAttributeData.pbo && this.has(dualAttributeData.pbo)) {
        this.textureUtils.copyBufferToTexture(dualAttributeData.transformBuffer, dualAttributeData.pbo);
      }
      dualAttributeData.switchBuffers();
    }
  }
  /**
   * This method is executed at the end of a compute call and
   * finalizes work after compute tasks.
   *
   * @param {Node|Array<Node>} computeGroup - The compute node(s).
   */
  finishCompute(computeGroup) {
    const gl = this.gl;
    this.discard = false;
    gl.disable(gl.RASTERIZER_DISCARD);
    this.prepareTimestampBuffer(TimestampQuery.COMPUTE, this.getTimestampUID(computeGroup));
    if (this._currentContext) {
      this._setFramebuffer(this._currentContext);
    }
  }
  /**
   * Internal to determine if the current render target is a render target array with depth 2D array texture.
   *
   * @param {RenderContext} renderContext - The render context.
   * @return {boolean} Whether the render target is a render target array with depth 2D array texture.
   *
   * @private
   */
  _isRenderCameraDepthArray(renderContext) {
    return renderContext.depthTexture && renderContext.depthTexture.isArrayTexture && renderContext.camera.isArrayCamera;
  }
  /**
   * Executes a draw command for the given render object.
   *
   * @param {RenderObject} renderObject - The render object to draw.
   * @param {Info} info - Holds a series of statistical information about the GPU memory and the rendering process.
   */
  draw(renderObject) {
    const { object: object2, pipeline, material, context: context3, hardwareClippingPlanes } = renderObject;
    const { programGPU } = this.get(pipeline);
    const { gl, state } = this;
    const contextData = this.get(context3);
    const drawParams = renderObject.getDrawParameters();
    if (drawParams === null) return;
    this._bindUniforms(renderObject.getBindings());
    const frontFaceCW = object2.isMesh && object2.matrixWorld.determinant() < 0;
    state.setMaterial(material, frontFaceCW, hardwareClippingPlanes);
    state.useProgram(programGPU);
    const attributes = renderObject.getAttributes();
    const attributesData = this.get(attributes);
    let vaoGPU = attributesData.vaoGPU;
    if (vaoGPU === void 0) {
      const vaoKey = this._getVaoKey(attributes);
      vaoGPU = this.vaoCache[vaoKey];
      if (vaoGPU === void 0) {
        vaoGPU = this._createVao(attributes);
        this.vaoCache[vaoKey] = vaoGPU;
        attributesData.vaoGPU = vaoGPU;
      }
    }
    const index5 = renderObject.getIndex();
    const indexGPU = index5 !== null ? this.get(index5).bufferGPU : null;
    state.setVertexState(vaoGPU, indexGPU);
    const lastObject = contextData.lastOcclusionObject;
    if (lastObject !== object2 && lastObject !== void 0) {
      if (lastObject !== null && lastObject.occlusionTest === true) {
        gl.endQuery(gl.ANY_SAMPLES_PASSED);
        contextData.occlusionQueryIndex++;
      }
      if (object2.occlusionTest === true) {
        const query = gl.createQuery();
        gl.beginQuery(gl.ANY_SAMPLES_PASSED, query);
        contextData.occlusionQueries[contextData.occlusionQueryIndex] = query;
        contextData.occlusionQueryObjects[contextData.occlusionQueryIndex] = object2;
      }
      contextData.lastOcclusionObject = object2;
    }
    const renderer = this.bufferRenderer;
    if (object2.isPoints) renderer.mode = gl.POINTS;
    else if (object2.isLineSegments) renderer.mode = gl.LINES;
    else if (object2.isLine) renderer.mode = gl.LINE_STRIP;
    else if (object2.isLineLoop) renderer.mode = gl.LINE_LOOP;
    else {
      if (material.wireframe === true) {
        state.setLineWidth(material.wireframeLinewidth * this.renderer.getPixelRatio());
        renderer.mode = gl.LINES;
      } else {
        renderer.mode = gl.TRIANGLES;
      }
    }
    const { vertexCount, instanceCount } = drawParams;
    let { firstVertex } = drawParams;
    renderer.object = object2;
    if (index5 !== null) {
      firstVertex *= index5.array.BYTES_PER_ELEMENT;
      const indexData = this.get(index5);
      renderer.index = index5.count;
      renderer.type = indexData.type;
    } else {
      renderer.index = 0;
    }
    const draw = () => {
      if (object2.isBatchedMesh) {
        if (object2._multiDrawInstances !== null) {
          warnOnce("THREE.WebGLBackend: renderMultiDrawInstances has been deprecated and will be removed in r184. Append to renderMultiDraw arguments and use indirection.");
          renderer.renderMultiDrawInstances(object2._multiDrawStarts, object2._multiDrawCounts, object2._multiDrawCount, object2._multiDrawInstances);
        } else if (!this.hasFeature("WEBGL_multi_draw")) {
          warnOnce("THREE.WebGLRenderer: WEBGL_multi_draw not supported.");
        } else {
          renderer.renderMultiDraw(object2._multiDrawStarts, object2._multiDrawCounts, object2._multiDrawCount);
        }
      } else if (instanceCount > 1) {
        renderer.renderInstances(firstVertex, vertexCount, instanceCount);
      } else {
        renderer.render(firstVertex, vertexCount);
      }
    };
    if (renderObject.camera.isArrayCamera === true && renderObject.camera.cameras.length > 0 && renderObject.camera.isMultiViewCamera === false) {
      const cameraData = this.get(renderObject.camera);
      const cameras = renderObject.camera.cameras;
      const cameraIndex3 = renderObject.getBindingGroup("cameraIndex").bindings[0];
      if (cameraData.indexesGPU === void 0 || cameraData.indexesGPU.length !== cameras.length) {
        const data = new Uint32Array([0, 0, 0, 0]);
        const indexesGPU = [];
        for (let i = 0, len = cameras.length; i < len; i++) {
          const bufferGPU = gl.createBuffer();
          data[0] = i;
          gl.bindBuffer(gl.UNIFORM_BUFFER, bufferGPU);
          gl.bufferData(gl.UNIFORM_BUFFER, data, gl.STATIC_DRAW);
          indexesGPU.push(bufferGPU);
        }
        cameraData.indexesGPU = indexesGPU;
      }
      const cameraIndexData = this.get(cameraIndex3);
      const pixelRatio = this.renderer.getPixelRatio();
      const renderTarget = this._currentContext.renderTarget;
      const isRenderCameraDepthArray = this._isRenderCameraDepthArray(this._currentContext);
      const prevActiveCubeFace = this._currentContext.activeCubeFace;
      if (isRenderCameraDepthArray) {
        const textureData = this.get(renderTarget.depthTexture);
        if (textureData.clearedRenderId !== this.renderer._nodes.nodeFrame.renderId) {
          textureData.clearedRenderId = this.renderer._nodes.nodeFrame.renderId;
          const { stencilBuffer } = renderTarget;
          for (let i = 0, len = cameras.length; i < len; i++) {
            this.renderer._activeCubeFace = i;
            this._currentContext.activeCubeFace = i;
            this._setFramebuffer(this._currentContext);
            this.clear(false, true, stencilBuffer, this._currentContext, false, false);
          }
          this.renderer._activeCubeFace = prevActiveCubeFace;
          this._currentContext.activeCubeFace = prevActiveCubeFace;
        }
      }
      for (let i = 0, len = cameras.length; i < len; i++) {
        const subCamera = cameras[i];
        if (object2.layers.test(subCamera.layers)) {
          if (isRenderCameraDepthArray) {
            this.renderer._activeCubeFace = i;
            this._currentContext.activeCubeFace = i;
            this._setFramebuffer(this._currentContext);
          }
          const vp = subCamera.viewport;
          if (vp !== void 0) {
            const x = vp.x * pixelRatio;
            const y = vp.y * pixelRatio;
            const width = vp.width * pixelRatio;
            const height = vp.height * pixelRatio;
            state.viewport(
              Math.floor(x),
              Math.floor(renderObject.context.height - height - y),
              Math.floor(width),
              Math.floor(height)
            );
          }
          state.bindBufferBase(gl.UNIFORM_BUFFER, cameraIndexData.index, cameraData.indexesGPU[i]);
          draw();
        }
        this._currentContext.activeCubeFace = prevActiveCubeFace;
        this.renderer._activeCubeFace = prevActiveCubeFace;
      }
    } else {
      draw();
    }
  }
  /**
   * Explain why always null is returned.
   *
   * @param {RenderObject} renderObject - The render object.
   * @return {boolean} Whether the render pipeline requires an update or not.
   */
  needsRenderUpdate() {
    return false;
  }
  /**
   * Explain why no cache key is computed.
   *
   * @param {RenderObject} renderObject - The render object.
   * @return {string} The cache key.
   */
  getRenderCacheKey() {
    return "";
  }
  // textures
  /**
   * Creates a default texture for the given texture that can be used
   * as a placeholder until the actual texture is ready for usage.
   *
   * @param {Texture} texture - The texture to create a default texture for.
   */
  createDefaultTexture(texture3) {
    this.textureUtils.createDefaultTexture(texture3);
  }
  /**
   * Defines a texture on the GPU for the given texture object.
   *
   * @param {Texture} texture - The texture.
   * @param {Object} [options={}] - Optional configuration parameter.
   */
  createTexture(texture3, options) {
    this.textureUtils.createTexture(texture3, options);
  }
  /**
   * Uploads the updated texture data to the GPU.
   *
   * @param {Texture} texture - The texture.
   * @param {Object} [options={}] - Optional configuration parameter.
   */
  updateTexture(texture3, options) {
    this.textureUtils.updateTexture(texture3, options);
  }
  /**
   * Generates mipmaps for the given texture.
   *
   * @param {Texture} texture - The texture.
   */
  generateMipmaps(texture3) {
    this.textureUtils.generateMipmaps(texture3);
  }
  /**
   * Destroys the GPU data for the given texture object.
   *
   * @param {Texture} texture - The texture.
   */
  destroyTexture(texture3) {
    this.textureUtils.destroyTexture(texture3);
  }
  /**
   * Returns texture data as a typed array.
   *
   * @async
   * @param {Texture} texture - The texture to copy.
   * @param {number} x - The x coordinate of the copy origin.
   * @param {number} y - The y coordinate of the copy origin.
   * @param {number} width - The width of the copy.
   * @param {number} height - The height of the copy.
   * @param {number} faceIndex - The face index.
   * @return {Promise<TypedArray>} A Promise that resolves with a typed array when the copy operation has finished.
   */
  async copyTextureToBuffer(texture3, x, y, width, height, faceIndex) {
    return this.textureUtils.copyTextureToBuffer(texture3, x, y, width, height, faceIndex);
  }
  /**
   * This method does nothing since WebGL 2 has no concept of samplers.
   *
   * @param {Texture} texture - The texture to create the sampler for.
   */
  createSampler() {
  }
  /**
   * This method does nothing since WebGL 2 has no concept of samplers.
   *
   * @param {Texture} texture - The texture to destroy the sampler for.
   */
  destroySampler() {
  }
  // node builder
  /**
   * Returns a node builder for the given render object.
   *
   * @param {RenderObject} object - The render object.
   * @param {Renderer} renderer - The renderer.
   * @return {GLSLNodeBuilder} The node builder.
   */
  createNodeBuilder(object2, renderer) {
    return new GLSLNodeBuilder(object2, renderer);
  }
  // program
  /**
   * Creates a shader program from the given programmable stage.
   *
   * @param {ProgrammableStage} program - The programmable stage.
   */
  createProgram(program) {
    const gl = this.gl;
    const { stage, code: code3 } = program;
    const shader = stage === "fragment" ? gl.createShader(gl.FRAGMENT_SHADER) : gl.createShader(gl.VERTEX_SHADER);
    gl.shaderSource(shader, code3);
    gl.compileShader(shader);
    this.set(program, {
      shaderGPU: shader
    });
  }
  /**
   * Destroys the shader program of the given programmable stage.
   *
   * @param {ProgrammableStage} program - The programmable stage.
   */
  destroyProgram(program) {
    this.delete(program);
  }
  /**
   * Creates a render pipeline for the given render object.
   *
   * @param {RenderObject} renderObject - The render object.
   * @param {Array<Promise>} promises - An array of compilation promises which are used in `compileAsync()`.
   */
  createRenderPipeline(renderObject, promises) {
    const gl = this.gl;
    const pipeline = renderObject.pipeline;
    const { fragmentProgram, vertexProgram } = pipeline;
    const programGPU = gl.createProgram();
    const fragmentShader2 = this.get(fragmentProgram).shaderGPU;
    const vertexShader2 = this.get(vertexProgram).shaderGPU;
    gl.attachShader(programGPU, fragmentShader2);
    gl.attachShader(programGPU, vertexShader2);
    gl.linkProgram(programGPU);
    this.set(pipeline, {
      programGPU,
      fragmentShader: fragmentShader2,
      vertexShader: vertexShader2
    });
    if (promises !== null && this.parallel) {
      const p = new Promise((resolve) => {
        const parallel = this.parallel;
        const checkStatus = () => {
          if (gl.getProgramParameter(programGPU, parallel.COMPLETION_STATUS_KHR)) {
            this._completeCompile(renderObject, pipeline);
            resolve();
          } else {
            requestAnimationFrame(checkStatus);
          }
        };
        checkStatus();
      });
      promises.push(p);
      return;
    }
    this._completeCompile(renderObject, pipeline);
  }
  /**
   * Formats the source code of error messages.
   *
   * @private
   * @param {string} string - The code.
   * @param {number} errorLine - The error line.
   * @return {string} The formatted code.
   */
  _handleSource(string3, errorLine) {
    const lines = string3.split("\n");
    const lines2 = [];
    const from = Math.max(errorLine - 6, 0);
    const to = Math.min(errorLine + 6, lines.length);
    for (let i = from; i < to; i++) {
      const line = i + 1;
      lines2.push(`${line === errorLine ? ">" : " "} ${line}: ${lines[i]}`);
    }
    return lines2.join("\n");
  }
  /**
   * Gets the shader compilation errors from the info log.
   *
   * @private
   * @param {WebGL2RenderingContext} gl - The rendering context.
   * @param {WebGLShader} shader - The WebGL shader object.
   * @param {string} type - The shader type.
   * @return {string} The shader errors.
   */
  _getShaderErrors(gl, shader, type) {
    const status = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
    const shaderInfoLog = gl.getShaderInfoLog(shader) || "";
    const errors = shaderInfoLog.trim();
    if (status && errors === "") return "";
    const errorMatches = /ERROR: 0:(\d+)/.exec(errors);
    if (errorMatches) {
      const errorLine = parseInt(errorMatches[1]);
      return type.toUpperCase() + "\n\n" + errors + "\n\n" + this._handleSource(gl.getShaderSource(shader), errorLine);
    } else {
      return errors;
    }
  }
  /**
   * Logs shader compilation errors.
   *
   * @private
   * @param {WebGLProgram} programGPU - The WebGL program.
   * @param {WebGLShader} glFragmentShader - The fragment shader as a native WebGL shader object.
   * @param {WebGLShader} glVertexShader - The vertex shader as a native WebGL shader object.
   */
  _logProgramError(programGPU, glFragmentShader, glVertexShader) {
    if (this.renderer.debug.checkShaderErrors) {
      const gl = this.gl;
      const programInfoLog = gl.getProgramInfoLog(programGPU) || "";
      const programLog = programInfoLog.trim();
      if (gl.getProgramParameter(programGPU, gl.LINK_STATUS) === false) {
        if (typeof this.renderer.debug.onShaderError === "function") {
          this.renderer.debug.onShaderError(gl, programGPU, glVertexShader, glFragmentShader);
        } else {
          const vertexErrors = this._getShaderErrors(gl, glVertexShader, "vertex");
          const fragmentErrors = this._getShaderErrors(gl, glFragmentShader, "fragment");
          console.error(
            "THREE.WebGLProgram: Shader Error " + gl.getError() + " - VALIDATE_STATUS " + gl.getProgramParameter(programGPU, gl.VALIDATE_STATUS) + "\n\nProgram Info Log: " + programLog + "\n" + vertexErrors + "\n" + fragmentErrors
          );
        }
      } else if (programLog !== "") {
        console.warn("THREE.WebGLProgram: Program Info Log:", programLog);
      }
    }
  }
  /**
   * Completes the shader program setup for the given render object.
   *
   * @private
   * @param {RenderObject} renderObject - The render object.
   * @param {RenderPipeline} pipeline - The render pipeline.
   */
  _completeCompile(renderObject, pipeline) {
    const { state, gl } = this;
    const pipelineData = this.get(pipeline);
    const { programGPU, fragmentShader: fragmentShader2, vertexShader: vertexShader2 } = pipelineData;
    if (gl.getProgramParameter(programGPU, gl.LINK_STATUS) === false) {
      this._logProgramError(programGPU, fragmentShader2, vertexShader2);
    }
    state.useProgram(programGPU);
    const bindings = renderObject.getBindings();
    this._setupBindings(bindings, programGPU);
    this.set(pipeline, {
      programGPU
    });
  }
  /**
   * Creates a compute pipeline for the given compute node.
   *
   * @param {ComputePipeline} computePipeline - The compute pipeline.
   * @param {Array<BindGroup>} bindings - The bindings.
   */
  createComputePipeline(computePipeline, bindings) {
    const { state, gl } = this;
    const fragmentProgram = {
      stage: "fragment",
      code: "#version 300 es\nprecision highp float;\nvoid main() {}"
    };
    this.createProgram(fragmentProgram);
    const { computeProgram } = computePipeline;
    const programGPU = gl.createProgram();
    const fragmentShader2 = this.get(fragmentProgram).shaderGPU;
    const vertexShader2 = this.get(computeProgram).shaderGPU;
    const transforms = computeProgram.transforms;
    const transformVaryingNames = [];
    const transformAttributeNodes = [];
    for (let i = 0; i < transforms.length; i++) {
      const transform = transforms[i];
      transformVaryingNames.push(transform.varyingName);
      transformAttributeNodes.push(transform.attributeNode);
    }
    gl.attachShader(programGPU, fragmentShader2);
    gl.attachShader(programGPU, vertexShader2);
    gl.transformFeedbackVaryings(
      programGPU,
      transformVaryingNames,
      gl.SEPARATE_ATTRIBS
    );
    gl.linkProgram(programGPU);
    if (gl.getProgramParameter(programGPU, gl.LINK_STATUS) === false) {
      this._logProgramError(programGPU, fragmentShader2, vertexShader2);
    }
    state.useProgram(programGPU);
    this._setupBindings(bindings, programGPU);
    const attributeNodes = computeProgram.attributes;
    const attributes = [];
    const transformBuffers = [];
    for (let i = 0; i < attributeNodes.length; i++) {
      const attribute3 = attributeNodes[i].node.attribute;
      attributes.push(attribute3);
      if (!this.has(attribute3)) this.attributeUtils.createAttribute(attribute3, gl.ARRAY_BUFFER);
    }
    for (let i = 0; i < transformAttributeNodes.length; i++) {
      const attribute3 = transformAttributeNodes[i].attribute;
      if (!this.has(attribute3)) this.attributeUtils.createAttribute(attribute3, gl.ARRAY_BUFFER);
      const attributeData = this.get(attribute3);
      transformBuffers.push(attributeData);
    }
    this.set(computePipeline, {
      programGPU,
      transformBuffers,
      attributes
    });
  }
  /**
   * Creates bindings from the given bind group definition.
   *
   * @param {BindGroup} bindGroup - The bind group.
   * @param {Array<BindGroup>} bindings - Array of bind groups.
   * @param {number} cacheIndex - The cache index.
   * @param {number} version - The version.
   */
  createBindings(bindGroup, bindings) {
    if (this._knownBindings.has(bindings) === false) {
      this._knownBindings.add(bindings);
      let uniformBuffers = 0;
      let textures = 0;
      for (const bindGroup2 of bindings) {
        this.set(bindGroup2, {
          textures,
          uniformBuffers
        });
        for (const binding of bindGroup2.bindings) {
          if (binding.isUniformBuffer) uniformBuffers++;
          if (binding.isSampledTexture) textures++;
        }
      }
    }
    this.updateBindings(bindGroup, bindings);
  }
  /**
   * Updates the given bind group definition.
   *
   * @param {BindGroup} bindGroup - The bind group.
   * @param {Array<BindGroup>} bindings - Array of bind groups.
   * @param {number} cacheIndex - The cache index.
   * @param {number} version - The version.
   */
  updateBindings(bindGroup) {
    const { gl } = this;
    const bindGroupData = this.get(bindGroup);
    let i = bindGroupData.uniformBuffers;
    let t = bindGroupData.textures;
    for (const binding of bindGroup.bindings) {
      const map4 = this.get(binding);
      if (binding.isUniformsGroup || binding.isUniformBuffer) {
        const data = binding.buffer;
        let { bufferGPU } = this.get(data);
        if (bufferGPU === void 0) {
          bufferGPU = gl.createBuffer();
          gl.bindBuffer(gl.UNIFORM_BUFFER, bufferGPU);
          gl.bufferData(gl.UNIFORM_BUFFER, data, gl.DYNAMIC_DRAW);
          this.set(data, { bufferGPU });
        } else {
          gl.bindBuffer(gl.UNIFORM_BUFFER, bufferGPU);
          gl.bufferSubData(gl.UNIFORM_BUFFER, 0, data);
        }
        map4.index = i++;
        map4.bufferGPU = bufferGPU;
        this.set(binding, map4);
      } else if (binding.isSampledTexture) {
        const { textureGPU, glTextureType } = this.get(binding.texture);
        map4.index = t++;
        map4.textureGPU = textureGPU;
        map4.glTextureType = glTextureType;
        this.set(binding, map4);
      }
    }
  }
  /**
   * Updates a buffer binding.
   *
   *  @param {Buffer} binding - The buffer binding to update.
   */
  updateBinding(binding) {
    const gl = this.gl;
    if (binding.isUniformsGroup || binding.isUniformBuffer) {
      const bindingData = this.get(binding);
      const bufferGPU = bindingData.bufferGPU;
      const data = binding.buffer;
      gl.bindBuffer(gl.UNIFORM_BUFFER, bufferGPU);
      gl.bufferData(gl.UNIFORM_BUFFER, data, gl.DYNAMIC_DRAW);
    }
  }
  // attributes
  /**
   * Creates the GPU buffer of an indexed shader attribute.
   *
   * @param {BufferAttribute} attribute - The indexed buffer attribute.
   */
  createIndexAttribute(attribute3) {
    const gl = this.gl;
    this.attributeUtils.createAttribute(attribute3, gl.ELEMENT_ARRAY_BUFFER);
  }
  /**
   * Creates the GPU buffer of a shader attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute.
   */
  createAttribute(attribute3) {
    if (this.has(attribute3)) return;
    const gl = this.gl;
    this.attributeUtils.createAttribute(attribute3, gl.ARRAY_BUFFER);
  }
  /**
   * Creates the GPU buffer of a storage attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute.
   */
  createStorageAttribute(attribute3) {
    if (this.has(attribute3)) return;
    const gl = this.gl;
    this.attributeUtils.createAttribute(attribute3, gl.ARRAY_BUFFER);
  }
  /**
   * Updates the GPU buffer of a shader attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute to update.
   */
  updateAttribute(attribute3) {
    this.attributeUtils.updateAttribute(attribute3);
  }
  /**
   * Destroys the GPU buffer of a shader attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute to destroy.
   */
  destroyAttribute(attribute3) {
    this.attributeUtils.destroyAttribute(attribute3);
  }
  /**
   * Checks if the given feature is supported  by the backend.
   *
   * @param {string} name - The feature's name.
   * @return {boolean} Whether the feature is supported or not.
   */
  hasFeature(name) {
    const keysMatching = Object.keys(GLFeatureName).filter((key) => GLFeatureName[key] === name);
    const extensions = this.extensions;
    for (let i = 0; i < keysMatching.length; i++) {
      if (extensions.has(keysMatching[i])) return true;
    }
    return false;
  }
  /**
   * Returns the maximum anisotropy texture filtering value.
   *
   * @return {number} The maximum anisotropy texture filtering value.
   */
  getMaxAnisotropy() {
    return this.capabilities.getMaxAnisotropy();
  }
  /**
   * Copies data of the given source texture to the given destination texture.
   *
   * @param {Texture} srcTexture - The source texture.
   * @param {Texture} dstTexture - The destination texture.
   * @param {?(Box3|Box2)} [srcRegion=null] - The region of the source texture to copy.
   * @param {?(Vector2|Vector3)} [dstPosition=null] - The destination position of the copy.
   * @param {number} [srcLevel=0] - The source mip level to copy from.
   * @param {number} [dstLevel=0] - The destination mip level to copy to.
   */
  copyTextureToTexture(srcTexture, dstTexture, srcRegion = null, dstPosition = null, srcLevel = 0, dstLevel = 0) {
    this.textureUtils.copyTextureToTexture(srcTexture, dstTexture, srcRegion, dstPosition, srcLevel, dstLevel);
  }
  /**
   * Copies the current bound framebuffer to the given texture.
   *
   * @param {Texture} texture - The destination texture.
   * @param {RenderContext} renderContext - The render context.
   * @param {Vector4} rectangle - A four dimensional vector defining the origin and dimension of the copy.
   */
  copyFramebufferToTexture(texture3, renderContext, rectangle) {
    this.textureUtils.copyFramebufferToTexture(texture3, renderContext, rectangle);
  }
  /**
   * Configures the active framebuffer from the given render context.
   *
   * @private
   * @param {RenderContext} descriptor - The render context.
   */
  _setFramebuffer(descriptor) {
    const { gl, state } = this;
    let currentFrameBuffer = null;
    if (descriptor.textures !== null) {
      const renderTarget = descriptor.renderTarget;
      const renderTargetContextData = this.get(renderTarget);
      const { samples, depthBuffer, stencilBuffer } = renderTarget;
      const isCube = renderTarget.isWebGLCubeRenderTarget === true;
      const isRenderTarget3D = renderTarget.isRenderTarget3D === true;
      const isRenderTargetArray = renderTarget.depth > 1;
      const isXRRenderTarget = renderTarget.isXRRenderTarget === true;
      const _hasExternalTextures = isXRRenderTarget === true && renderTarget._hasExternalTextures === true;
      let msaaFb = renderTargetContextData.msaaFrameBuffer;
      let depthRenderbuffer = renderTargetContextData.depthRenderbuffer;
      const multisampledRTTExt = this.extensions.get("WEBGL_multisampled_render_to_texture");
      const multiviewExt = this.extensions.get("OVR_multiview2");
      const useMultisampledRTT = this._useMultisampledExtension(renderTarget);
      const cacheKey = getCacheKey(descriptor);
      let fb;
      if (isCube) {
        renderTargetContextData.cubeFramebuffers || (renderTargetContextData.cubeFramebuffers = {});
        fb = renderTargetContextData.cubeFramebuffers[cacheKey];
      } else if (isXRRenderTarget && _hasExternalTextures === false) {
        fb = this._xrFramebuffer;
      } else {
        renderTargetContextData.framebuffers || (renderTargetContextData.framebuffers = {});
        fb = renderTargetContextData.framebuffers[cacheKey];
      }
      if (fb === void 0) {
        fb = gl.createFramebuffer();
        state.bindFramebuffer(gl.FRAMEBUFFER, fb);
        const textures = descriptor.textures;
        const depthInvalidationArray = [];
        if (isCube) {
          renderTargetContextData.cubeFramebuffers[cacheKey] = fb;
          const { textureGPU } = this.get(textures[0]);
          const cubeFace = this.renderer._activeCubeFace;
          const mipLevel = this.renderer._activeMipmapLevel;
          gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_CUBE_MAP_POSITIVE_X + cubeFace, textureGPU, mipLevel);
        } else {
          renderTargetContextData.framebuffers[cacheKey] = fb;
          for (let i = 0; i < textures.length; i++) {
            const texture3 = textures[i];
            const textureData = this.get(texture3);
            textureData.renderTarget = descriptor.renderTarget;
            textureData.cacheKey = cacheKey;
            const attachment = gl.COLOR_ATTACHMENT0 + i;
            if (renderTarget.multiview) {
              multiviewExt.framebufferTextureMultisampleMultiviewOVR(gl.FRAMEBUFFER, attachment, textureData.textureGPU, 0, samples, 0, 2);
            } else if (isRenderTarget3D || isRenderTargetArray) {
              const layer = this.renderer._activeCubeFace;
              const mipLevel = this.renderer._activeMipmapLevel;
              gl.framebufferTextureLayer(gl.FRAMEBUFFER, attachment, textureData.textureGPU, mipLevel, layer);
            } else {
              if (useMultisampledRTT) {
                multisampledRTTExt.framebufferTexture2DMultisampleEXT(gl.FRAMEBUFFER, attachment, gl.TEXTURE_2D, textureData.textureGPU, 0, samples);
              } else {
                const mipLevel = this.renderer._activeMipmapLevel;
                gl.framebufferTexture2D(gl.FRAMEBUFFER, attachment, gl.TEXTURE_2D, textureData.textureGPU, mipLevel);
              }
            }
          }
        }
        const depthStyle = stencilBuffer ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT;
        if (renderTarget._autoAllocateDepthBuffer === true) {
          const renderbuffer = gl.createRenderbuffer();
          this.textureUtils.setupRenderBufferStorage(renderbuffer, descriptor, 0, useMultisampledRTT);
          renderTargetContextData.xrDepthRenderbuffer = renderbuffer;
          depthInvalidationArray.push(stencilBuffer ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT);
          gl.bindRenderbuffer(gl.RENDERBUFFER, renderbuffer);
          gl.framebufferRenderbuffer(gl.FRAMEBUFFER, depthStyle, gl.RENDERBUFFER, renderbuffer);
        } else {
          if (descriptor.depthTexture !== null) {
            depthInvalidationArray.push(stencilBuffer ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT);
            const textureData = this.get(descriptor.depthTexture);
            textureData.renderTarget = descriptor.renderTarget;
            textureData.cacheKey = cacheKey;
            if (renderTarget.multiview) {
              multiviewExt.framebufferTextureMultisampleMultiviewOVR(gl.FRAMEBUFFER, depthStyle, textureData.textureGPU, 0, samples, 0, 2);
            } else if (_hasExternalTextures && useMultisampledRTT) {
              multisampledRTTExt.framebufferTexture2DMultisampleEXT(gl.FRAMEBUFFER, depthStyle, gl.TEXTURE_2D, textureData.textureGPU, 0, samples);
            } else {
              if (descriptor.depthTexture.isArrayTexture) {
                const layer = this.renderer._activeCubeFace;
                gl.framebufferTextureLayer(gl.FRAMEBUFFER, depthStyle, textureData.textureGPU, 0, layer);
              } else {
                gl.framebufferTexture2D(gl.FRAMEBUFFER, depthStyle, gl.TEXTURE_2D, textureData.textureGPU, 0);
              }
            }
          }
        }
        renderTargetContextData.depthInvalidationArray = depthInvalidationArray;
      } else {
        const isRenderCameraDepthArray = this._isRenderCameraDepthArray(descriptor);
        if (isRenderCameraDepthArray) {
          state.bindFramebuffer(gl.FRAMEBUFFER, fb);
          const layer = this.renderer._activeCubeFace;
          const depthData = this.get(descriptor.depthTexture);
          const depthStyle = stencilBuffer ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT;
          gl.framebufferTextureLayer(
            gl.FRAMEBUFFER,
            depthStyle,
            depthData.textureGPU,
            0,
            layer
          );
        }
        if ((isXRRenderTarget || useMultisampledRTT || renderTarget.multiview) && renderTarget._isOpaqueFramebuffer !== true) {
          state.bindFramebuffer(gl.FRAMEBUFFER, fb);
          const textureData = this.get(descriptor.textures[0]);
          if (renderTarget.multiview) {
            multiviewExt.framebufferTextureMultisampleMultiviewOVR(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, textureData.textureGPU, 0, samples, 0, 2);
          } else if (useMultisampledRTT) {
            multisampledRTTExt.framebufferTexture2DMultisampleEXT(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, textureData.textureGPU, 0, samples);
          } else {
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, textureData.textureGPU, 0);
          }
          const depthStyle = stencilBuffer ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT;
          if (renderTarget._autoAllocateDepthBuffer === true) {
            const renderbuffer = renderTargetContextData.xrDepthRenderbuffer;
            gl.bindRenderbuffer(gl.RENDERBUFFER, renderbuffer);
            gl.framebufferRenderbuffer(gl.FRAMEBUFFER, depthStyle, gl.RENDERBUFFER, renderbuffer);
          } else {
            const textureData2 = this.get(descriptor.depthTexture);
            if (renderTarget.multiview) {
              multiviewExt.framebufferTextureMultisampleMultiviewOVR(gl.FRAMEBUFFER, depthStyle, textureData2.textureGPU, 0, samples, 0, 2);
            } else if (useMultisampledRTT) {
              multisampledRTTExt.framebufferTexture2DMultisampleEXT(gl.FRAMEBUFFER, depthStyle, gl.TEXTURE_2D, textureData2.textureGPU, 0, samples);
            } else {
              gl.framebufferTexture2D(gl.FRAMEBUFFER, depthStyle, gl.TEXTURE_2D, textureData2.textureGPU, 0);
            }
          }
        }
      }
      if (samples > 0 && useMultisampledRTT === false && !renderTarget.multiview) {
        if (msaaFb === void 0) {
          const invalidationArray = [];
          msaaFb = gl.createFramebuffer();
          state.bindFramebuffer(gl.FRAMEBUFFER, msaaFb);
          const msaaRenderbuffers = [];
          const textures = descriptor.textures;
          for (let i = 0; i < textures.length; i++) {
            msaaRenderbuffers[i] = gl.createRenderbuffer();
            gl.bindRenderbuffer(gl.RENDERBUFFER, msaaRenderbuffers[i]);
            invalidationArray.push(gl.COLOR_ATTACHMENT0 + i);
            const texture3 = descriptor.textures[i];
            const textureData = this.get(texture3);
            gl.renderbufferStorageMultisample(gl.RENDERBUFFER, samples, textureData.glInternalFormat, descriptor.width, descriptor.height);
            gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, gl.RENDERBUFFER, msaaRenderbuffers[i]);
          }
          gl.bindRenderbuffer(gl.RENDERBUFFER, null);
          renderTargetContextData.msaaFrameBuffer = msaaFb;
          renderTargetContextData.msaaRenderbuffers = msaaRenderbuffers;
          if (depthBuffer && depthRenderbuffer === void 0) {
            depthRenderbuffer = gl.createRenderbuffer();
            this.textureUtils.setupRenderBufferStorage(depthRenderbuffer, descriptor, samples);
            renderTargetContextData.depthRenderbuffer = depthRenderbuffer;
            const depthStyle = stencilBuffer ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT;
            invalidationArray.push(depthStyle);
          }
          renderTargetContextData.invalidationArray = invalidationArray;
        }
        currentFrameBuffer = renderTargetContextData.msaaFrameBuffer;
      } else {
        currentFrameBuffer = fb;
      }
      state.drawBuffers(descriptor, fb);
    }
    state.bindFramebuffer(gl.FRAMEBUFFER, currentFrameBuffer);
  }
  /**
   * Computes the VAO key for the given index and attributes.
   *
   * @private
   * @param {Array<BufferAttribute>} attributes - An array of buffer attributes.
   * @return {string} The VAO key.
   */
  _getVaoKey(attributes) {
    let key = "";
    for (let i = 0; i < attributes.length; i++) {
      const attributeData = this.get(attributes[i]);
      key += ":" + attributeData.id;
    }
    return key;
  }
  /**
   * Creates a VAO from the index and attributes.
   *
   * @private
   * @param {Array<BufferAttribute>} attributes - An array of buffer attributes.
   * @return {Object} The VAO data.
   */
  _createVao(attributes) {
    const { gl } = this;
    const vaoGPU = gl.createVertexArray();
    gl.bindVertexArray(vaoGPU);
    for (let i = 0; i < attributes.length; i++) {
      const attribute3 = attributes[i];
      const attributeData = this.get(attribute3);
      gl.bindBuffer(gl.ARRAY_BUFFER, attributeData.bufferGPU);
      gl.enableVertexAttribArray(i);
      let stride, offset;
      if (attribute3.isInterleavedBufferAttribute === true) {
        stride = attribute3.data.stride * attributeData.bytesPerElement;
        offset = attribute3.offset * attributeData.bytesPerElement;
      } else {
        stride = 0;
        offset = 0;
      }
      if (attributeData.isInteger) {
        gl.vertexAttribIPointer(i, attribute3.itemSize, attributeData.type, stride, offset);
      } else {
        gl.vertexAttribPointer(i, attribute3.itemSize, attributeData.type, attribute3.normalized, stride, offset);
      }
      if (attribute3.isInstancedBufferAttribute && !attribute3.isInterleavedBufferAttribute) {
        gl.vertexAttribDivisor(i, attribute3.meshPerAttribute);
      } else if (attribute3.isInterleavedBufferAttribute && attribute3.data.isInstancedInterleavedBuffer) {
        gl.vertexAttribDivisor(i, attribute3.data.meshPerAttribute);
      }
    }
    gl.bindBuffer(gl.ARRAY_BUFFER, null);
    return vaoGPU;
  }
  /**
   * Creates a transform feedback from the given transform buffers.
   *
   * @private
   * @param {Array<DualAttributeData>} transformBuffers - The transform buffers.
   * @return {WebGLTransformFeedback} The transform feedback.
   */
  _getTransformFeedback(transformBuffers) {
    let key = "";
    for (let i = 0; i < transformBuffers.length; i++) {
      key += ":" + transformBuffers[i].id;
    }
    let transformFeedbackGPU = this.transformFeedbackCache[key];
    if (transformFeedbackGPU !== void 0) {
      return transformFeedbackGPU;
    }
    const { gl } = this;
    transformFeedbackGPU = gl.createTransformFeedback();
    gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, transformFeedbackGPU);
    for (let i = 0; i < transformBuffers.length; i++) {
      const attributeData = transformBuffers[i];
      gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, i, attributeData.transformBuffer);
    }
    gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null);
    this.transformFeedbackCache[key] = transformFeedbackGPU;
    return transformFeedbackGPU;
  }
  /**
   * Setups the given bindings.
   *
   * @private
   * @param {Array<BindGroup>} bindings - The bindings.
   * @param {WebGLProgram} programGPU - The WebGL program.
   */
  _setupBindings(bindings, programGPU) {
    const gl = this.gl;
    for (const bindGroup of bindings) {
      for (const binding of bindGroup.bindings) {
        const bindingData = this.get(binding);
        const index5 = bindingData.index;
        if (binding.isUniformsGroup || binding.isUniformBuffer) {
          const location = gl.getUniformBlockIndex(programGPU, binding.name);
          gl.uniformBlockBinding(programGPU, location, index5);
        } else if (binding.isSampledTexture) {
          const location = gl.getUniformLocation(programGPU, binding.name);
          gl.uniform1i(location, index5);
        }
      }
    }
  }
  /**
   * Binds the given uniforms.
   *
   * @private
   * @param {Array<BindGroup>} bindings - The bindings.
   */
  _bindUniforms(bindings) {
    const { gl, state } = this;
    for (const bindGroup of bindings) {
      for (const binding of bindGroup.bindings) {
        const bindingData = this.get(binding);
        const index5 = bindingData.index;
        if (binding.isUniformsGroup || binding.isUniformBuffer) {
          state.bindBufferBase(gl.UNIFORM_BUFFER, index5, bindingData.bufferGPU);
        } else if (binding.isSampledTexture) {
          state.bindTexture(bindingData.glTextureType, bindingData.textureGPU, gl.TEXTURE0 + index5);
        }
      }
    }
  }
  /**
   * The method ensures multisampled render targets are resolved.
   *
   * @private
   * @param {RenderContext} renderContext - The render context.
   */
  _resolveRenderTarget(renderContext) {
    const { gl, state } = this;
    const renderTarget = renderContext.renderTarget;
    if (renderContext.textures !== null && renderTarget) {
      const renderTargetContextData = this.get(renderTarget);
      if (renderTarget.samples > 0 && this._useMultisampledExtension(renderTarget) === false) {
        const fb = renderTargetContextData.framebuffers[renderContext.getCacheKey()];
        let mask = gl.COLOR_BUFFER_BIT;
        if (renderTarget.resolveDepthBuffer) {
          if (renderTarget.depthBuffer) mask |= gl.DEPTH_BUFFER_BIT;
          if (renderTarget.stencilBuffer && renderTarget.resolveStencilBuffer) mask |= gl.STENCIL_BUFFER_BIT;
        }
        const msaaFrameBuffer = renderTargetContextData.msaaFrameBuffer;
        const msaaRenderbuffers = renderTargetContextData.msaaRenderbuffers;
        const textures = renderContext.textures;
        const isMRT = textures.length > 1;
        state.bindFramebuffer(gl.READ_FRAMEBUFFER, msaaFrameBuffer);
        state.bindFramebuffer(gl.DRAW_FRAMEBUFFER, fb);
        if (isMRT) {
          for (let i = 0; i < textures.length; i++) {
            gl.framebufferRenderbuffer(gl.READ_FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, gl.RENDERBUFFER, null);
            gl.framebufferTexture2D(gl.DRAW_FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, gl.TEXTURE_2D, null, 0);
          }
        }
        for (let i = 0; i < textures.length; i++) {
          if (isMRT) {
            const { textureGPU } = this.get(textures[i]);
            gl.framebufferRenderbuffer(gl.READ_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.RENDERBUFFER, msaaRenderbuffers[i]);
            gl.framebufferTexture2D(gl.DRAW_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, textureGPU, 0);
          }
          if (renderContext.scissor) {
            const { x, y, width, height } = renderContext.scissorValue;
            const viewY = renderContext.height - height - y;
            gl.blitFramebuffer(x, viewY, x + width, viewY + height, x, viewY, x + width, viewY + height, mask, gl.NEAREST);
          } else {
            gl.blitFramebuffer(0, 0, renderContext.width, renderContext.height, 0, 0, renderContext.width, renderContext.height, mask, gl.NEAREST);
          }
        }
        if (isMRT) {
          for (let i = 0; i < textures.length; i++) {
            const { textureGPU } = this.get(textures[i]);
            gl.framebufferRenderbuffer(gl.READ_FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, gl.RENDERBUFFER, msaaRenderbuffers[i]);
            gl.framebufferTexture2D(gl.DRAW_FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, gl.TEXTURE_2D, textureGPU, 0);
          }
        }
        if (this._supportsInvalidateFramebuffer === true) {
          gl.invalidateFramebuffer(gl.READ_FRAMEBUFFER, renderTargetContextData.invalidationArray);
        }
      } else if (renderTarget.resolveDepthBuffer === false && renderTargetContextData.framebuffers) {
        const fb = renderTargetContextData.framebuffers[renderContext.getCacheKey()];
        state.bindFramebuffer(gl.DRAW_FRAMEBUFFER, fb);
        gl.invalidateFramebuffer(gl.DRAW_FRAMEBUFFER, renderTargetContextData.depthInvalidationArray);
      }
    }
  }
  /**
   * Returns `true` if the `WEBGL_multisampled_render_to_texture` extension
   * should be used when MSAA is enabled.
   *
   * @private
   * @param {RenderTarget} renderTarget - The render target that should be multisampled.
   * @return {boolean} Whether to use the `WEBGL_multisampled_render_to_texture` extension for MSAA or not.
   */
  _useMultisampledExtension(renderTarget) {
    if (renderTarget.multiview === true) {
      return true;
    }
    return renderTarget.samples > 0 && this.extensions.has("WEBGL_multisampled_render_to_texture") === true && renderTarget._autoAllocateDepthBuffer !== false;
  }
  /**
   * Frees internal resources.
   */
  dispose() {
    const extension = this.extensions.get("WEBGL_lose_context");
    if (extension) extension.loseContext();
    this.renderer.domElement.removeEventListener("webglcontextlost", this._onContextLost);
  }
};
var GPUPrimitiveTopology = {
  PointList: "point-list",
  LineList: "line-list",
  LineStrip: "line-strip",
  TriangleList: "triangle-list",
  TriangleStrip: "triangle-strip"
};
var GPUCompareFunction = {
  Never: "never",
  Less: "less",
  Equal: "equal",
  LessEqual: "less-equal",
  Greater: "greater",
  NotEqual: "not-equal",
  GreaterEqual: "greater-equal",
  Always: "always"
};
var GPUStoreOp = {
  Store: "store"
};
var GPULoadOp = {
  Load: "load",
  Clear: "clear"
};
var GPUFrontFace = {
  CCW: "ccw",
  CW: "cw"
};
var GPUCullMode = {
  None: "none",
  Back: "back"
};
var GPUIndexFormat = {
  Uint16: "uint16",
  Uint32: "uint32"
};
var GPUTextureFormat = {
  // 8-bit formats
  R8Unorm: "r8unorm",
  R8Snorm: "r8snorm",
  R8Uint: "r8uint",
  R8Sint: "r8sint",
  // 16-bit formats
  R16Uint: "r16uint",
  R16Sint: "r16sint",
  R16Float: "r16float",
  RG8Unorm: "rg8unorm",
  RG8Snorm: "rg8snorm",
  RG8Uint: "rg8uint",
  RG8Sint: "rg8sint",
  // 32-bit formats
  R32Uint: "r32uint",
  R32Sint: "r32sint",
  R32Float: "r32float",
  RG16Uint: "rg16uint",
  RG16Sint: "rg16sint",
  RG16Float: "rg16float",
  RGBA8Unorm: "rgba8unorm",
  RGBA8UnormSRGB: "rgba8unorm-srgb",
  RGBA8Snorm: "rgba8snorm",
  RGBA8Uint: "rgba8uint",
  RGBA8Sint: "rgba8sint",
  BGRA8Unorm: "bgra8unorm",
  BGRA8UnormSRGB: "bgra8unorm-srgb",
  // Packed 32-bit formats
  RGB9E5UFloat: "rgb9e5ufloat",
  RGB10A2Unorm: "rgb10a2unorm",
  RG11B10UFloat: "rg11b10ufloat",
  // 64-bit formats
  RG32Uint: "rg32uint",
  RG32Sint: "rg32sint",
  RG32Float: "rg32float",
  RGBA16Uint: "rgba16uint",
  RGBA16Sint: "rgba16sint",
  RGBA16Float: "rgba16float",
  // 128-bit formats
  RGBA32Uint: "rgba32uint",
  RGBA32Sint: "rgba32sint",
  RGBA32Float: "rgba32float",
  Depth16Unorm: "depth16unorm",
  Depth24Plus: "depth24plus",
  Depth24PlusStencil8: "depth24plus-stencil8",
  Depth32Float: "depth32float",
  // 'depth32float-stencil8' extension
  Depth32FloatStencil8: "depth32float-stencil8",
  // BC compressed formats usable if 'texture-compression-bc' is both
  // supported by the device/user agent and enabled in requestDevice.
  BC1RGBAUnorm: "bc1-rgba-unorm",
  BC1RGBAUnormSRGB: "bc1-rgba-unorm-srgb",
  BC2RGBAUnorm: "bc2-rgba-unorm",
  BC2RGBAUnormSRGB: "bc2-rgba-unorm-srgb",
  BC3RGBAUnorm: "bc3-rgba-unorm",
  BC3RGBAUnormSRGB: "bc3-rgba-unorm-srgb",
  BC4RUnorm: "bc4-r-unorm",
  BC4RSnorm: "bc4-r-snorm",
  BC5RGUnorm: "bc5-rg-unorm",
  BC5RGSnorm: "bc5-rg-snorm",
  BC6HRGBUFloat: "bc6h-rgb-ufloat",
  BC6HRGBFloat: "bc6h-rgb-float",
  BC7RGBAUnorm: "bc7-rgba-unorm",
  BC7RGBAUnormSRGB: "bc7-rgba-unorm-srgb",
  // ETC2 compressed formats usable if 'texture-compression-etc2' is both
  // supported by the device/user agent and enabled in requestDevice.
  ETC2RGB8Unorm: "etc2-rgb8unorm",
  ETC2RGB8UnormSRGB: "etc2-rgb8unorm-srgb",
  ETC2RGB8A1Unorm: "etc2-rgb8a1unorm",
  ETC2RGB8A1UnormSRGB: "etc2-rgb8a1unorm-srgb",
  ETC2RGBA8Unorm: "etc2-rgba8unorm",
  ETC2RGBA8UnormSRGB: "etc2-rgba8unorm-srgb",
  EACR11Unorm: "eac-r11unorm",
  EACR11Snorm: "eac-r11snorm",
  EACRG11Unorm: "eac-rg11unorm",
  EACRG11Snorm: "eac-rg11snorm",
  // ASTC compressed formats usable if 'texture-compression-astc' is both
  // supported by the device/user agent and enabled in requestDevice.
  ASTC4x4Unorm: "astc-4x4-unorm",
  ASTC4x4UnormSRGB: "astc-4x4-unorm-srgb",
  ASTC5x4Unorm: "astc-5x4-unorm",
  ASTC5x4UnormSRGB: "astc-5x4-unorm-srgb",
  ASTC5x5Unorm: "astc-5x5-unorm",
  ASTC5x5UnormSRGB: "astc-5x5-unorm-srgb",
  ASTC6x5Unorm: "astc-6x5-unorm",
  ASTC6x5UnormSRGB: "astc-6x5-unorm-srgb",
  ASTC6x6Unorm: "astc-6x6-unorm",
  ASTC6x6UnormSRGB: "astc-6x6-unorm-srgb",
  ASTC8x5Unorm: "astc-8x5-unorm",
  ASTC8x5UnormSRGB: "astc-8x5-unorm-srgb",
  ASTC8x6Unorm: "astc-8x6-unorm",
  ASTC8x6UnormSRGB: "astc-8x6-unorm-srgb",
  ASTC8x8Unorm: "astc-8x8-unorm",
  ASTC8x8UnormSRGB: "astc-8x8-unorm-srgb",
  ASTC10x5Unorm: "astc-10x5-unorm",
  ASTC10x5UnormSRGB: "astc-10x5-unorm-srgb",
  ASTC10x6Unorm: "astc-10x6-unorm",
  ASTC10x6UnormSRGB: "astc-10x6-unorm-srgb",
  ASTC10x8Unorm: "astc-10x8-unorm",
  ASTC10x8UnormSRGB: "astc-10x8-unorm-srgb",
  ASTC10x10Unorm: "astc-10x10-unorm",
  ASTC10x10UnormSRGB: "astc-10x10-unorm-srgb",
  ASTC12x10Unorm: "astc-12x10-unorm",
  ASTC12x10UnormSRGB: "astc-12x10-unorm-srgb",
  ASTC12x12Unorm: "astc-12x12-unorm",
  ASTC12x12UnormSRGB: "astc-12x12-unorm-srgb"
};
var GPUAddressMode = {
  ClampToEdge: "clamp-to-edge",
  Repeat: "repeat",
  MirrorRepeat: "mirror-repeat"
};
var GPUFilterMode = {
  Linear: "linear",
  Nearest: "nearest"
};
var GPUBlendFactor = {
  Zero: "zero",
  One: "one",
  Src: "src",
  OneMinusSrc: "one-minus-src",
  SrcAlpha: "src-alpha",
  OneMinusSrcAlpha: "one-minus-src-alpha",
  Dst: "dst",
  OneMinusDst: "one-minus-dst",
  DstAlpha: "dst-alpha",
  OneMinusDstAlpha: "one-minus-dst-alpha",
  SrcAlphaSaturated: "src-alpha-saturated",
  Constant: "constant",
  OneMinusConstant: "one-minus-constant"
};
var GPUBlendOperation = {
  Add: "add",
  Subtract: "subtract",
  ReverseSubtract: "reverse-subtract",
  Min: "min",
  Max: "max"
};
var GPUColorWriteFlags = {
  None: 0,
  All: 15
};
var GPUStencilOperation = {
  Keep: "keep",
  Zero: "zero",
  Replace: "replace",
  Invert: "invert",
  IncrementClamp: "increment-clamp",
  DecrementClamp: "decrement-clamp",
  IncrementWrap: "increment-wrap",
  DecrementWrap: "decrement-wrap"
};
var GPUBufferBindingType = {
  Storage: "storage",
  ReadOnlyStorage: "read-only-storage"
};
var GPUStorageTextureAccess = {
  WriteOnly: "write-only",
  ReadOnly: "read-only",
  ReadWrite: "read-write"
};
var GPUSamplerBindingType = {
  NonFiltering: "non-filtering",
  Comparison: "comparison"
};
var GPUTextureSampleType = {
  Float: "float",
  UnfilterableFloat: "unfilterable-float",
  Depth: "depth",
  SInt: "sint",
  UInt: "uint"
};
var GPUTextureDimension = {
  TwoD: "2d",
  ThreeD: "3d"
};
var GPUTextureViewDimension = {
  TwoD: "2d",
  TwoDArray: "2d-array",
  Cube: "cube",
  ThreeD: "3d"
};
var GPUTextureAspect = {
  All: "all"
};
var GPUInputStepMode = {
  Vertex: "vertex",
  Instance: "instance"
};
var GPUFeatureName = {
  CoreFeaturesAndLimits: "core-features-and-limits",
  DepthClipControl: "depth-clip-control",
  Depth32FloatStencil8: "depth32float-stencil8",
  TextureCompressionBC: "texture-compression-bc",
  TextureCompressionBCSliced3D: "texture-compression-bc-sliced-3d",
  TextureCompressionETC2: "texture-compression-etc2",
  TextureCompressionASTC: "texture-compression-astc",
  TextureCompressionASTCSliced3D: "texture-compression-astc-sliced-3d",
  TimestampQuery: "timestamp-query",
  IndirectFirstInstance: "indirect-first-instance",
  ShaderF16: "shader-f16",
  RG11B10UFloat: "rg11b10ufloat-renderable",
  BGRA8UNormStorage: "bgra8unorm-storage",
  Float32Filterable: "float32-filterable",
  Float32Blendable: "float32-blendable",
  ClipDistances: "clip-distances",
  DualSourceBlending: "dual-source-blending",
  Subgroups: "subgroups",
  TextureFormatsTier1: "texture-formats-tier1",
  TextureFormatsTier2: "texture-formats-tier2"
};
var NodeSampler = class extends Sampler {
  /**
   * Constructs a new node-based sampler.
   *
   * @param {string} name - The samplers's name.
   * @param {TextureNode} textureNode - The texture node.
   * @param {UniformGroupNode} groupNode - The uniform group node.
   */
  constructor(name, textureNode, groupNode) {
    super(name, textureNode ? textureNode.value : null);
    this.textureNode = textureNode;
    this.groupNode = groupNode;
  }
  /**
   * Updates the texture value of this sampler.
   */
  update() {
    this.texture = this.textureNode.value;
  }
};
var StorageBuffer = class extends Buffer {
  /**
   * Constructs a new uniform buffer.
   *
   * @param {string} name - The buffer's name.
   * @param {BufferAttribute} attribute - The buffer attribute.
   */
  constructor(name, attribute3) {
    super(name, attribute3 ? attribute3.array : null);
    this.attribute = attribute3;
    this.isStorageBuffer = true;
  }
};
var _id2 = 0;
var NodeStorageBuffer = class extends StorageBuffer {
  /**
   * Constructs a new node-based storage buffer.
   *
   * @param {StorageBufferNode} nodeUniform - The storage buffer node.
   * @param {UniformGroupNode} groupNode - The uniform group node.
   */
  constructor(nodeUniform, groupNode) {
    super("StorageBuffer_" + _id2++, nodeUniform ? nodeUniform.value : null);
    this.nodeUniform = nodeUniform;
    this.access = nodeUniform ? nodeUniform.access : NodeAccess.READ_WRITE;
    this.groupNode = groupNode;
  }
  /**
   * The storage buffer.
   *
   * @type {BufferAttribute}
   */
  get buffer() {
    return this.nodeUniform.value;
  }
};
var WebGPUTexturePassUtils = class extends DataMap {
  /**
   * Constructs a new utility object.
   *
   * @param {GPUDevice} device - The WebGPU device.
   */
  constructor(device) {
    super();
    this.device = device;
    const mipmapVertexSource = `
struct VarysStruct {
	@builtin( position ) Position: vec4<f32>,
	@location( 0 ) vTex : vec2<f32>
};

@vertex
fn main( @builtin( vertex_index ) vertexIndex : u32 ) -> VarysStruct {

	var Varys : VarysStruct;

	var pos = array< vec2<f32>, 4 >(
		vec2<f32>( -1.0,  1.0 ),
		vec2<f32>(  1.0,  1.0 ),
		vec2<f32>( -1.0, -1.0 ),
		vec2<f32>(  1.0, -1.0 )
	);

	var tex = array< vec2<f32>, 4 >(
		vec2<f32>( 0.0, 0.0 ),
		vec2<f32>( 1.0, 0.0 ),
		vec2<f32>( 0.0, 1.0 ),
		vec2<f32>( 1.0, 1.0 )
	);

	Varys.vTex = tex[ vertexIndex ];
	Varys.Position = vec4<f32>( pos[ vertexIndex ], 0.0, 1.0 );

	return Varys;

}
`;
    const mipmapFragmentSource = `
@group( 0 ) @binding( 0 )
var imgSampler : sampler;

@group( 0 ) @binding( 1 )
var img : texture_2d<f32>;

@fragment
fn main( @location( 0 ) vTex : vec2<f32> ) -> @location( 0 ) vec4<f32> {

	return textureSample( img, imgSampler, vTex );

}
`;
    const flipYFragmentSource = `
@group( 0 ) @binding( 0 )
var imgSampler : sampler;

@group( 0 ) @binding( 1 )
var img : texture_2d<f32>;

@fragment
fn main( @location( 0 ) vTex : vec2<f32> ) -> @location( 0 ) vec4<f32> {

	return textureSample( img, imgSampler, vec2( vTex.x, 1.0 - vTex.y ) );

}
`;
    this.mipmapSampler = device.createSampler({ minFilter: GPUFilterMode.Linear });
    this.flipYSampler = device.createSampler({ minFilter: GPUFilterMode.Nearest });
    this.transferPipelines = {};
    this.flipYPipelines = {};
    this.mipmapVertexShaderModule = device.createShaderModule({
      label: "mipmapVertex",
      code: mipmapVertexSource
    });
    this.mipmapFragmentShaderModule = device.createShaderModule({
      label: "mipmapFragment",
      code: mipmapFragmentSource
    });
    this.flipYFragmentShaderModule = device.createShaderModule({
      label: "flipYFragment",
      code: flipYFragmentSource
    });
  }
  /**
   * Returns a render pipeline for the internal copy render pass. The pass
   * requires a unique render pipeline for each texture format.
   *
   * @param {string} format - The GPU texture format
   * @return {GPURenderPipeline} The GPU render pipeline.
   */
  getTransferPipeline(format2) {
    let pipeline = this.transferPipelines[format2];
    if (pipeline === void 0) {
      pipeline = this.device.createRenderPipeline({
        label: `mipmap-${format2}`,
        vertex: {
          module: this.mipmapVertexShaderModule,
          entryPoint: "main"
        },
        fragment: {
          module: this.mipmapFragmentShaderModule,
          entryPoint: "main",
          targets: [{ format: format2 }]
        },
        primitive: {
          topology: GPUPrimitiveTopology.TriangleStrip,
          stripIndexFormat: GPUIndexFormat.Uint32
        },
        layout: "auto"
      });
      this.transferPipelines[format2] = pipeline;
    }
    return pipeline;
  }
  /**
   * Returns a render pipeline for the flipY render pass. The pass
   * requires a unique render pipeline for each texture format.
   *
   * @param {string} format - The GPU texture format
   * @return {GPURenderPipeline} The GPU render pipeline.
   */
  getFlipYPipeline(format2) {
    let pipeline = this.flipYPipelines[format2];
    if (pipeline === void 0) {
      pipeline = this.device.createRenderPipeline({
        label: `flipY-${format2}`,
        vertex: {
          module: this.mipmapVertexShaderModule,
          entryPoint: "main"
        },
        fragment: {
          module: this.flipYFragmentShaderModule,
          entryPoint: "main",
          targets: [{ format: format2 }]
        },
        primitive: {
          topology: GPUPrimitiveTopology.TriangleStrip,
          stripIndexFormat: GPUIndexFormat.Uint32
        },
        layout: "auto"
      });
      this.flipYPipelines[format2] = pipeline;
    }
    return pipeline;
  }
  /**
   * Flip the contents of the given GPU texture along its vertical axis.
   *
   * @param {GPUTexture} textureGPU - The GPU texture object.
   * @param {Object} textureGPUDescriptor - The texture descriptor.
   * @param {number} [baseArrayLayer=0] - The index of the first array layer accessible to the texture view.
   */
  flipY(textureGPU, textureGPUDescriptor, baseArrayLayer = 0) {
    const format2 = textureGPUDescriptor.format;
    const { width, height } = textureGPUDescriptor.size;
    const transferPipeline = this.getTransferPipeline(format2);
    const flipYPipeline = this.getFlipYPipeline(format2);
    const tempTexture = this.device.createTexture({
      size: { width, height, depthOrArrayLayers: 1 },
      format: format2,
      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING
    });
    const srcView = textureGPU.createView({
      baseMipLevel: 0,
      mipLevelCount: 1,
      dimension: GPUTextureViewDimension.TwoD,
      baseArrayLayer
    });
    const dstView = tempTexture.createView({
      baseMipLevel: 0,
      mipLevelCount: 1,
      dimension: GPUTextureViewDimension.TwoD,
      baseArrayLayer: 0
    });
    const commandEncoder = this.device.createCommandEncoder({});
    const pass3 = (pipeline, sourceView, destinationView) => {
      const bindGroupLayout = pipeline.getBindGroupLayout(0);
      const bindGroup = this.device.createBindGroup({
        layout: bindGroupLayout,
        entries: [{
          binding: 0,
          resource: this.flipYSampler
        }, {
          binding: 1,
          resource: sourceView
        }]
      });
      const passEncoder = commandEncoder.beginRenderPass({
        colorAttachments: [{
          view: destinationView,
          loadOp: GPULoadOp.Clear,
          storeOp: GPUStoreOp.Store,
          clearValue: [0, 0, 0, 0]
        }]
      });
      passEncoder.setPipeline(pipeline);
      passEncoder.setBindGroup(0, bindGroup);
      passEncoder.draw(4, 1, 0, 0);
      passEncoder.end();
    };
    pass3(transferPipeline, srcView, dstView);
    pass3(flipYPipeline, dstView, srcView);
    this.device.queue.submit([commandEncoder.finish()]);
    tempTexture.destroy();
  }
  /**
   * Generates mipmaps for the given GPU texture.
   *
   * @param {GPUTexture} textureGPU - The GPU texture object.
   * @param {Object} textureGPUDescriptor - The texture descriptor.
   * @param {number} [baseArrayLayer=0] - The index of the first array layer accessible to the texture view.
   */
  generateMipmaps(textureGPU, textureGPUDescriptor, baseArrayLayer = 0) {
    const textureData = this.get(textureGPU);
    if (textureData.useCount === void 0) {
      textureData.useCount = 0;
      textureData.layers = [];
    }
    const passes = textureData.layers[baseArrayLayer] || this._mipmapCreateBundles(textureGPU, textureGPUDescriptor, baseArrayLayer);
    const commandEncoder = this.device.createCommandEncoder({});
    this._mipmapRunBundles(commandEncoder, passes);
    this.device.queue.submit([commandEncoder.finish()]);
    if (textureData.useCount !== 0) textureData.layers[baseArrayLayer] = passes;
    textureData.useCount++;
  }
  /**
   * Since multiple copy render passes are required to generate mipmaps, the passes
   * are managed as render bundles to improve performance.
   *
   * @param {GPUTexture} textureGPU - The GPU texture object.
   * @param {Object} textureGPUDescriptor - The texture descriptor.
   * @param {number} baseArrayLayer - The index of the first array layer accessible to the texture view.
   * @return {Array<Object>} An array of render bundles.
   */
  _mipmapCreateBundles(textureGPU, textureGPUDescriptor, baseArrayLayer) {
    const pipeline = this.getTransferPipeline(textureGPUDescriptor.format);
    const bindGroupLayout = pipeline.getBindGroupLayout(0);
    let srcView = textureGPU.createView({
      baseMipLevel: 0,
      mipLevelCount: 1,
      dimension: GPUTextureViewDimension.TwoD,
      baseArrayLayer
    });
    const passes = [];
    for (let i = 1; i < textureGPUDescriptor.mipLevelCount; i++) {
      const bindGroup = this.device.createBindGroup({
        layout: bindGroupLayout,
        entries: [{
          binding: 0,
          resource: this.mipmapSampler
        }, {
          binding: 1,
          resource: srcView
        }]
      });
      const dstView = textureGPU.createView({
        baseMipLevel: i,
        mipLevelCount: 1,
        dimension: GPUTextureViewDimension.TwoD,
        baseArrayLayer
      });
      const passDescriptor = {
        colorAttachments: [{
          view: dstView,
          loadOp: GPULoadOp.Clear,
          storeOp: GPUStoreOp.Store,
          clearValue: [0, 0, 0, 0]
        }]
      };
      const passEncoder = this.device.createRenderBundleEncoder({
        colorFormats: [textureGPUDescriptor.format]
      });
      passEncoder.setPipeline(pipeline);
      passEncoder.setBindGroup(0, bindGroup);
      passEncoder.draw(4, 1, 0, 0);
      passes.push({
        renderBundles: [passEncoder.finish()],
        passDescriptor
      });
      srcView = dstView;
    }
    return passes;
  }
  /**
   * Executes the render bundles.
   *
   * @param {GPUCommandEncoder} commandEncoder - The GPU command encoder.
   * @param {Array<Object>} passes - An array of render bundles.
   */
  _mipmapRunBundles(commandEncoder, passes) {
    const levels = passes.length;
    for (let i = 0; i < levels; i++) {
      const pass3 = passes[i];
      const passEncoder = commandEncoder.beginRenderPass(pass3.passDescriptor);
      passEncoder.executeBundles(pass3.renderBundles);
      passEncoder.end();
    }
  }
};
var _compareToWebGPU = {
  [NeverCompare]: "never",
  [LessCompare]: "less",
  [EqualCompare]: "equal",
  [LessEqualCompare]: "less-equal",
  [GreaterCompare]: "greater",
  [GreaterEqualCompare]: "greater-equal",
  [AlwaysCompare]: "always",
  [NotEqualCompare]: "not-equal"
};
var _flipMap = [0, 1, 3, 2, 4, 5];
var WebGPUTextureUtils = class {
  /**
   * Constructs a new utility object.
   *
   * @param {WebGPUBackend} backend - The WebGPU backend.
   */
  constructor(backend) {
    this.backend = backend;
    this._passUtils = null;
    this.defaultTexture = {};
    this.defaultCubeTexture = {};
    this.defaultVideoFrame = null;
    this.colorBuffer = null;
    this.depthTexture = new DepthTexture();
    this.depthTexture.name = "depthBuffer";
  }
  /**
   * Creates a GPU sampler for the given texture.
   *
   * @param {Texture} texture - The texture to create the sampler for.
   */
  createSampler(texture3) {
    const backend = this.backend;
    const device = backend.device;
    const textureGPU = backend.get(texture3);
    const samplerDescriptorGPU = {
      addressModeU: this._convertAddressMode(texture3.wrapS),
      addressModeV: this._convertAddressMode(texture3.wrapT),
      addressModeW: this._convertAddressMode(texture3.wrapR),
      magFilter: this._convertFilterMode(texture3.magFilter),
      minFilter: this._convertFilterMode(texture3.minFilter),
      mipmapFilter: this._convertFilterMode(texture3.minFilter),
      maxAnisotropy: 1
    };
    if (samplerDescriptorGPU.magFilter === GPUFilterMode.Linear && samplerDescriptorGPU.minFilter === GPUFilterMode.Linear && samplerDescriptorGPU.mipmapFilter === GPUFilterMode.Linear) {
      samplerDescriptorGPU.maxAnisotropy = texture3.anisotropy;
    }
    if (texture3.isDepthTexture && texture3.compareFunction !== null) {
      samplerDescriptorGPU.compare = _compareToWebGPU[texture3.compareFunction];
    }
    textureGPU.sampler = device.createSampler(samplerDescriptorGPU);
  }
  /**
   * Creates a default texture for the given texture that can be used
   * as a placeholder until the actual texture is ready for usage.
   *
   * @param {Texture} texture - The texture to create a default texture for.
   */
  createDefaultTexture(texture3) {
    let textureGPU;
    const format2 = getFormat2(texture3);
    if (texture3.isCubeTexture) {
      textureGPU = this._getDefaultCubeTextureGPU(format2);
    } else {
      textureGPU = this._getDefaultTextureGPU(format2);
    }
    this.backend.get(texture3).texture = textureGPU;
  }
  /**
   * Defines a texture on the GPU for the given texture object.
   *
   * @param {Texture} texture - The texture.
   * @param {Object} [options={}] - Optional configuration parameter.
   */
  createTexture(texture3, options = {}) {
    const backend = this.backend;
    const textureData = backend.get(texture3);
    if (textureData.initialized) {
      throw new Error("WebGPUTextureUtils: Texture already initialized.");
    }
    if (texture3.isExternalTexture) {
      textureData.texture = texture3.sourceTexture;
      textureData.initialized = true;
      return;
    }
    if (options.needsMipmaps === void 0) options.needsMipmaps = false;
    if (options.levels === void 0) options.levels = 1;
    if (options.depth === void 0) options.depth = 1;
    const { width, height, depth: depth3, levels } = options;
    if (texture3.isFramebufferTexture) {
      if (options.renderTarget) {
        options.format = this.backend.utils.getCurrentColorFormat(options.renderTarget);
      } else {
        options.format = this.backend.utils.getPreferredCanvasFormat();
      }
    }
    const dimension = this._getDimension(texture3);
    const format2 = texture3.internalFormat || options.format || getFormat2(texture3, backend.device);
    textureData.format = format2;
    const { samples, primarySamples, isMSAA } = backend.utils.getTextureSampleData(texture3);
    let usage = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC;
    if (texture3.isStorageTexture === true) {
      usage |= GPUTextureUsage.STORAGE_BINDING;
    }
    if (texture3.isCompressedTexture !== true && texture3.isCompressedArrayTexture !== true && format2 !== GPUTextureFormat.RGB9E5UFloat) {
      usage |= GPUTextureUsage.RENDER_ATTACHMENT;
    }
    const textureDescriptorGPU = {
      label: texture3.name,
      size: {
        width,
        height,
        depthOrArrayLayers: depth3
      },
      mipLevelCount: levels,
      sampleCount: primarySamples,
      dimension,
      format: format2,
      usage
    };
    if (format2 === void 0) {
      console.warn("WebGPURenderer: Texture format not supported.");
      this.createDefaultTexture(texture3);
      return;
    }
    if (texture3.isCubeTexture) {
      textureDescriptorGPU.textureBindingViewDimension = GPUTextureViewDimension.Cube;
    }
    textureData.texture = backend.device.createTexture(textureDescriptorGPU);
    if (isMSAA) {
      const msaaTextureDescriptorGPU = Object.assign({}, textureDescriptorGPU);
      msaaTextureDescriptorGPU.label = msaaTextureDescriptorGPU.label + "-msaa";
      msaaTextureDescriptorGPU.sampleCount = samples;
      msaaTextureDescriptorGPU.mipLevelCount = 1;
      textureData.msaaTexture = backend.device.createTexture(msaaTextureDescriptorGPU);
    }
    textureData.initialized = true;
    textureData.textureDescriptorGPU = textureDescriptorGPU;
  }
  /**
   * Destroys the GPU data for the given texture object.
   *
   * @param {Texture} texture - The texture.
   */
  destroyTexture(texture3) {
    const backend = this.backend;
    const textureData = backend.get(texture3);
    if (textureData.texture !== void 0) textureData.texture.destroy();
    if (textureData.msaaTexture !== void 0) textureData.msaaTexture.destroy();
    backend.delete(texture3);
  }
  /**
   * Destroys the GPU sampler for the given texture.
   *
   * @param {Texture} texture - The texture to destroy the sampler for.
   */
  destroySampler(texture3) {
    const backend = this.backend;
    const textureData = backend.get(texture3);
    delete textureData.sampler;
  }
  /**
   * Generates mipmaps for the given texture.
   *
   * @param {Texture} texture - The texture.
   */
  generateMipmaps(texture3) {
    const textureData = this.backend.get(texture3);
    if (texture3.isCubeTexture) {
      for (let i = 0; i < 6; i++) {
        this._generateMipmaps(textureData.texture, textureData.textureDescriptorGPU, i);
      }
    } else {
      const depth3 = texture3.image.depth || 1;
      for (let i = 0; i < depth3; i++) {
        this._generateMipmaps(textureData.texture, textureData.textureDescriptorGPU, i);
      }
    }
  }
  /**
   * Returns the color buffer representing the color
   * attachment of the default framebuffer.
   *
   * @return {GPUTexture} The color buffer.
   */
  getColorBuffer() {
    if (this.colorBuffer) this.colorBuffer.destroy();
    const backend = this.backend;
    const { width, height } = backend.getDrawingBufferSize();
    this.colorBuffer = backend.device.createTexture({
      label: "colorBuffer",
      size: {
        width,
        height,
        depthOrArrayLayers: 1
      },
      sampleCount: backend.utils.getSampleCount(backend.renderer.samples),
      format: backend.utils.getPreferredCanvasFormat(),
      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC
    });
    return this.colorBuffer;
  }
  /**
   * Returns the depth buffer representing the depth
   * attachment of the default framebuffer.
   *
   * @param {boolean} [depth=true] - Whether depth is enabled or not.
   * @param {boolean} [stencil=false] -  Whether stencil is enabled or not.
   * @return {GPUTexture} The depth buffer.
   */
  getDepthBuffer(depth3 = true, stencil = false) {
    const backend = this.backend;
    const { width, height } = backend.getDrawingBufferSize();
    const depthTexture = this.depthTexture;
    const depthTextureGPU = backend.get(depthTexture).texture;
    let format2, type;
    if (stencil) {
      format2 = DepthStencilFormat;
      type = UnsignedInt248Type;
    } else if (depth3) {
      format2 = DepthFormat;
      type = UnsignedIntType;
    }
    if (depthTextureGPU !== void 0) {
      if (depthTexture.image.width === width && depthTexture.image.height === height && depthTexture.format === format2 && depthTexture.type === type) {
        return depthTextureGPU;
      }
      this.destroyTexture(depthTexture);
    }
    depthTexture.name = "depthBuffer";
    depthTexture.format = format2;
    depthTexture.type = type;
    depthTexture.image.width = width;
    depthTexture.image.height = height;
    this.createTexture(depthTexture, { width, height });
    return backend.get(depthTexture).texture;
  }
  /**
   * Uploads the updated texture data to the GPU.
   *
   * @param {Texture} texture - The texture.
   * @param {Object} [options={}] - Optional configuration parameter.
   */
  updateTexture(texture3, options) {
    const textureData = this.backend.get(texture3);
    const mipmaps = texture3.mipmaps;
    const { textureDescriptorGPU } = textureData;
    if (texture3.isRenderTargetTexture || textureDescriptorGPU === void 0)
      return;
    if (texture3.isDataTexture) {
      if (mipmaps.length > 0) {
        for (let i = 0, il = mipmaps.length; i < il; i++) {
          const mipmap = mipmaps[i];
          this._copyBufferToTexture(mipmap, textureData.texture, textureDescriptorGPU, 0, texture3.flipY, 0, i);
        }
      } else {
        this._copyBufferToTexture(options.image, textureData.texture, textureDescriptorGPU, 0, texture3.flipY);
      }
    } else if (texture3.isArrayTexture || texture3.isDataArrayTexture || texture3.isData3DTexture) {
      for (let i = 0; i < options.image.depth; i++) {
        this._copyBufferToTexture(options.image, textureData.texture, textureDescriptorGPU, i, texture3.flipY, i);
      }
    } else if (texture3.isCompressedTexture || texture3.isCompressedArrayTexture) {
      this._copyCompressedBufferToTexture(texture3.mipmaps, textureData.texture, textureDescriptorGPU);
    } else if (texture3.isCubeTexture) {
      this._copyCubeMapToTexture(texture3, textureData.texture, textureDescriptorGPU);
    } else {
      if (mipmaps.length > 0) {
        for (let i = 0, il = mipmaps.length; i < il; i++) {
          const mipmap = mipmaps[i];
          this._copyImageToTexture(mipmap, textureData.texture, textureDescriptorGPU, 0, texture3.flipY, texture3.premultiplyAlpha, i);
        }
      } else {
        this._copyImageToTexture(options.image, textureData.texture, textureDescriptorGPU, 0, texture3.flipY, texture3.premultiplyAlpha);
      }
    }
    textureData.version = texture3.version;
  }
  /**
   * Returns texture data as a typed array.
   *
   * @async
   * @param {Texture} texture - The texture to copy.
   * @param {number} x - The x coordinate of the copy origin.
   * @param {number} y - The y coordinate of the copy origin.
   * @param {number} width - The width of the copy.
   * @param {number} height - The height of the copy.
   * @param {number} faceIndex - The face index.
   * @return {Promise<TypedArray>} A Promise that resolves with a typed array when the copy operation has finished.
   */
  async copyTextureToBuffer(texture3, x, y, width, height, faceIndex) {
    const device = this.backend.device;
    const textureData = this.backend.get(texture3);
    const textureGPU = textureData.texture;
    const format2 = textureData.textureDescriptorGPU.format;
    const bytesPerTexel = this._getBytesPerTexel(format2);
    let bytesPerRow = width * bytesPerTexel;
    bytesPerRow = Math.ceil(bytesPerRow / 256) * 256;
    const readBuffer = device.createBuffer(
      {
        size: (height - 1) * bytesPerRow + width * bytesPerTexel,
        // see https://github.com/mrdoob/three.js/issues/31658#issuecomment-3229442010
        usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
      }
    );
    const encoder = device.createCommandEncoder();
    encoder.copyTextureToBuffer(
      {
        texture: textureGPU,
        origin: { x, y, z: faceIndex }
      },
      {
        buffer: readBuffer,
        bytesPerRow
      },
      {
        width,
        height
      }
    );
    const typedArrayType = this._getTypedArrayType(format2);
    device.queue.submit([encoder.finish()]);
    await readBuffer.mapAsync(GPUMapMode.READ);
    const buffer3 = readBuffer.getMappedRange();
    return new typedArrayType(buffer3);
  }
  /**
   * Returns the default GPU texture for the given format.
   *
   * @private
   * @param {string} format - The GPU format.
   * @return {GPUTexture} The GPU texture.
   */
  _getDefaultTextureGPU(format2) {
    let defaultTexture = this.defaultTexture[format2];
    if (defaultTexture === void 0) {
      const texture3 = new Texture();
      texture3.minFilter = NearestFilter;
      texture3.magFilter = NearestFilter;
      this.createTexture(texture3, { width: 1, height: 1, format: format2 });
      this.defaultTexture[format2] = defaultTexture = texture3;
    }
    return this.backend.get(defaultTexture).texture;
  }
  /**
   * Returns the default GPU cube texture for the given format.
   *
   * @private
   * @param {string} format - The GPU format.
   * @return {GPUTexture} The GPU texture.
   */
  _getDefaultCubeTextureGPU(format2) {
    let defaultCubeTexture = this.defaultTexture[format2];
    if (defaultCubeTexture === void 0) {
      const texture3 = new CubeTexture();
      texture3.minFilter = NearestFilter;
      texture3.magFilter = NearestFilter;
      this.createTexture(texture3, { width: 1, height: 1, depth: 6 });
      this.defaultCubeTexture[format2] = defaultCubeTexture = texture3;
    }
    return this.backend.get(defaultCubeTexture).texture;
  }
  /**
   * Uploads cube texture image data to the GPU memory.
   *
   * @private
   * @param {CubeTexture} texture - The cube texture.
   * @param {GPUTexture} textureGPU - The GPU texture.
   * @param {Object} textureDescriptorGPU - The GPU texture descriptor.
   */
  _copyCubeMapToTexture(texture3, textureGPU, textureDescriptorGPU) {
    const images = texture3.images;
    const mipmaps = texture3.mipmaps;
    for (let i = 0; i < 6; i++) {
      const image = images[i];
      const flipIndex = texture3.flipY === true ? _flipMap[i] : i;
      if (image.isDataTexture) {
        this._copyBufferToTexture(image.image, textureGPU, textureDescriptorGPU, flipIndex, texture3.flipY);
      } else {
        this._copyImageToTexture(image, textureGPU, textureDescriptorGPU, flipIndex, texture3.flipY, texture3.premultiplyAlpha);
      }
      for (let j = 0; j < mipmaps.length; j++) {
        const mipmap = mipmaps[j];
        const image2 = mipmap.images[i];
        if (image2.isDataTexture) {
          this._copyBufferToTexture(image2.image, textureGPU, textureDescriptorGPU, flipIndex, texture3.flipY, 0, j + 1);
        } else {
          this._copyImageToTexture(image2, textureGPU, textureDescriptorGPU, flipIndex, texture3.flipY, texture3.premultiplyAlpha, j + 1);
        }
      }
    }
  }
  /**
   * Uploads texture image data to the GPU memory.
   *
   * @private
   * @param {HTMLImageElement|ImageBitmap|HTMLCanvasElement} image - The image data.
   * @param {GPUTexture} textureGPU - The GPU texture.
   * @param {Object} textureDescriptorGPU - The GPU texture descriptor.
   * @param {number} originDepth - The origin depth.
   * @param {boolean} flipY - Whether to flip texture data along their vertical axis or not.
   * @param {boolean} premultiplyAlpha - Whether the texture should have its RGB channels premultiplied by the alpha channel or not.
   * @param {number} [mipLevel=0] - The mip level where the data should be copied to.
   */
  _copyImageToTexture(image, textureGPU, textureDescriptorGPU, originDepth, flipY, premultiplyAlpha3, mipLevel = 0) {
    const device = this.backend.device;
    const width = mipLevel > 0 ? image.width : textureDescriptorGPU.size.width;
    const height = mipLevel > 0 ? image.height : textureDescriptorGPU.size.height;
    device.queue.copyExternalImageToTexture(
      {
        source: image,
        flipY
      },
      {
        texture: textureGPU,
        mipLevel,
        origin: { x: 0, y: 0, z: originDepth },
        premultipliedAlpha: premultiplyAlpha3
      },
      {
        width,
        height,
        depthOrArrayLayers: 1
      }
    );
  }
  /**
   * Returns the pass utils singleton.
   *
   * @private
   * @return {WebGPUTexturePassUtils} The utils instance.
   */
  _getPassUtils() {
    let passUtils = this._passUtils;
    if (passUtils === null) {
      this._passUtils = passUtils = new WebGPUTexturePassUtils(this.backend.device);
    }
    return passUtils;
  }
  /**
   * Generates mipmaps for the given GPU texture.
   *
   * @private
   * @param {GPUTexture} textureGPU - The GPU texture object.
   * @param {Object} textureDescriptorGPU - The texture descriptor.
   * @param {number} [baseArrayLayer=0] - The index of the first array layer accessible to the texture view.
   */
  _generateMipmaps(textureGPU, textureDescriptorGPU, baseArrayLayer = 0) {
    this._getPassUtils().generateMipmaps(textureGPU, textureDescriptorGPU, baseArrayLayer);
  }
  /**
   * Flip the contents of the given GPU texture along its vertical axis.
   *
   * @private
   * @param {GPUTexture} textureGPU - The GPU texture object.
   * @param {Object} textureDescriptorGPU - The texture descriptor.
   * @param {number} [originDepth=0] - The origin depth.
   */
  _flipY(textureGPU, textureDescriptorGPU, originDepth = 0) {
    this._getPassUtils().flipY(textureGPU, textureDescriptorGPU, originDepth);
  }
  /**
   * Uploads texture buffer data to the GPU memory.
   *
   * @private
   * @param {Object} image - An object defining the image buffer data.
   * @param {GPUTexture} textureGPU - The GPU texture.
   * @param {Object} textureDescriptorGPU - The GPU texture descriptor.
   * @param {number} originDepth - The origin depth.
   * @param {boolean} flipY - Whether to flip texture data along their vertical axis or not.
   * @param {number} [depth=0] - The depth offset when copying array or 3D texture data.
   * @param {number} [mipLevel=0] - The mip level where the data should be copied to.
   */
  _copyBufferToTexture(image, textureGPU, textureDescriptorGPU, originDepth, flipY, depth3 = 0, mipLevel = 0) {
    const device = this.backend.device;
    const data = image.data;
    const bytesPerTexel = this._getBytesPerTexel(textureDescriptorGPU.format);
    const bytesPerRow = image.width * bytesPerTexel;
    device.queue.writeTexture(
      {
        texture: textureGPU,
        mipLevel,
        origin: { x: 0, y: 0, z: originDepth }
      },
      data,
      {
        offset: image.width * image.height * bytesPerTexel * depth3,
        bytesPerRow
      },
      {
        width: image.width,
        height: image.height,
        depthOrArrayLayers: 1
      }
    );
    if (flipY === true) {
      this._flipY(textureGPU, textureDescriptorGPU, originDepth);
    }
  }
  /**
   * Uploads compressed texture data to the GPU memory.
   *
   * @private
   * @param {Array<Object>} mipmaps - An array with mipmap data.
   * @param {GPUTexture} textureGPU - The GPU texture.
   * @param {Object} textureDescriptorGPU - The GPU texture descriptor.
   */
  _copyCompressedBufferToTexture(mipmaps, textureGPU, textureDescriptorGPU) {
    const device = this.backend.device;
    const blockData = this._getBlockData(textureDescriptorGPU.format);
    const isArrayTexture = textureDescriptorGPU.size.depthOrArrayLayers > 1;
    for (let i = 0; i < mipmaps.length; i++) {
      const mipmap = mipmaps[i];
      const width = mipmap.width;
      const height = mipmap.height;
      const depth3 = isArrayTexture ? textureDescriptorGPU.size.depthOrArrayLayers : 1;
      const bytesPerRow = Math.ceil(width / blockData.width) * blockData.byteLength;
      const bytesPerImage = bytesPerRow * Math.ceil(height / blockData.height);
      for (let j = 0; j < depth3; j++) {
        device.queue.writeTexture(
          {
            texture: textureGPU,
            mipLevel: i,
            origin: { x: 0, y: 0, z: j }
          },
          mipmap.data,
          {
            offset: j * bytesPerImage,
            bytesPerRow,
            rowsPerImage: Math.ceil(height / blockData.height)
          },
          {
            width: Math.ceil(width / blockData.width) * blockData.width,
            height: Math.ceil(height / blockData.height) * blockData.height,
            depthOrArrayLayers: 1
          }
        );
      }
    }
  }
  /**
   * This method is only relevant for compressed texture formats. It returns a block
   * data descriptor for the given GPU compressed texture format.
   *
   * @private
   * @param {string} format - The GPU compressed texture format.
   * @return {Object} The block data descriptor.
   */
  _getBlockData(format2) {
    if (format2 === GPUTextureFormat.BC1RGBAUnorm || format2 === GPUTextureFormat.BC1RGBAUnormSRGB) return { byteLength: 8, width: 4, height: 4 };
    if (format2 === GPUTextureFormat.BC2RGBAUnorm || format2 === GPUTextureFormat.BC2RGBAUnormSRGB) return { byteLength: 16, width: 4, height: 4 };
    if (format2 === GPUTextureFormat.BC3RGBAUnorm || format2 === GPUTextureFormat.BC3RGBAUnormSRGB) return { byteLength: 16, width: 4, height: 4 };
    if (format2 === GPUTextureFormat.BC4RUnorm || format2 === GPUTextureFormat.BC4RSnorm) return { byteLength: 8, width: 4, height: 4 };
    if (format2 === GPUTextureFormat.BC5RGUnorm || format2 === GPUTextureFormat.BC5RGSnorm) return { byteLength: 16, width: 4, height: 4 };
    if (format2 === GPUTextureFormat.BC6HRGBUFloat || format2 === GPUTextureFormat.BC6HRGBFloat) return { byteLength: 16, width: 4, height: 4 };
    if (format2 === GPUTextureFormat.BC7RGBAUnorm || format2 === GPUTextureFormat.BC7RGBAUnormSRGB) return { byteLength: 16, width: 4, height: 4 };
    if (format2 === GPUTextureFormat.ETC2RGB8Unorm || format2 === GPUTextureFormat.ETC2RGB8UnormSRGB) return { byteLength: 8, width: 4, height: 4 };
    if (format2 === GPUTextureFormat.ETC2RGB8A1Unorm || format2 === GPUTextureFormat.ETC2RGB8A1UnormSRGB) return { byteLength: 8, width: 4, height: 4 };
    if (format2 === GPUTextureFormat.ETC2RGBA8Unorm || format2 === GPUTextureFormat.ETC2RGBA8UnormSRGB) return { byteLength: 16, width: 4, height: 4 };
    if (format2 === GPUTextureFormat.EACR11Unorm) return { byteLength: 8, width: 4, height: 4 };
    if (format2 === GPUTextureFormat.EACR11Snorm) return { byteLength: 8, width: 4, height: 4 };
    if (format2 === GPUTextureFormat.EACRG11Unorm) return { byteLength: 16, width: 4, height: 4 };
    if (format2 === GPUTextureFormat.EACRG11Snorm) return { byteLength: 16, width: 4, height: 4 };
    if (format2 === GPUTextureFormat.ASTC4x4Unorm || format2 === GPUTextureFormat.ASTC4x4UnormSRGB) return { byteLength: 16, width: 4, height: 4 };
    if (format2 === GPUTextureFormat.ASTC5x4Unorm || format2 === GPUTextureFormat.ASTC5x4UnormSRGB) return { byteLength: 16, width: 5, height: 4 };
    if (format2 === GPUTextureFormat.ASTC5x5Unorm || format2 === GPUTextureFormat.ASTC5x5UnormSRGB) return { byteLength: 16, width: 5, height: 5 };
    if (format2 === GPUTextureFormat.ASTC6x5Unorm || format2 === GPUTextureFormat.ASTC6x5UnormSRGB) return { byteLength: 16, width: 6, height: 5 };
    if (format2 === GPUTextureFormat.ASTC6x6Unorm || format2 === GPUTextureFormat.ASTC6x6UnormSRGB) return { byteLength: 16, width: 6, height: 6 };
    if (format2 === GPUTextureFormat.ASTC8x5Unorm || format2 === GPUTextureFormat.ASTC8x5UnormSRGB) return { byteLength: 16, width: 8, height: 5 };
    if (format2 === GPUTextureFormat.ASTC8x6Unorm || format2 === GPUTextureFormat.ASTC8x6UnormSRGB) return { byteLength: 16, width: 8, height: 6 };
    if (format2 === GPUTextureFormat.ASTC8x8Unorm || format2 === GPUTextureFormat.ASTC8x8UnormSRGB) return { byteLength: 16, width: 8, height: 8 };
    if (format2 === GPUTextureFormat.ASTC10x5Unorm || format2 === GPUTextureFormat.ASTC10x5UnormSRGB) return { byteLength: 16, width: 10, height: 5 };
    if (format2 === GPUTextureFormat.ASTC10x6Unorm || format2 === GPUTextureFormat.ASTC10x6UnormSRGB) return { byteLength: 16, width: 10, height: 6 };
    if (format2 === GPUTextureFormat.ASTC10x8Unorm || format2 === GPUTextureFormat.ASTC10x8UnormSRGB) return { byteLength: 16, width: 10, height: 8 };
    if (format2 === GPUTextureFormat.ASTC10x10Unorm || format2 === GPUTextureFormat.ASTC10x10UnormSRGB) return { byteLength: 16, width: 10, height: 10 };
    if (format2 === GPUTextureFormat.ASTC12x10Unorm || format2 === GPUTextureFormat.ASTC12x10UnormSRGB) return { byteLength: 16, width: 12, height: 10 };
    if (format2 === GPUTextureFormat.ASTC12x12Unorm || format2 === GPUTextureFormat.ASTC12x12UnormSRGB) return { byteLength: 16, width: 12, height: 12 };
  }
  /**
   * Converts the three.js uv wrapping constants to GPU address mode constants.
   *
   * @private
   * @param {number} value - The three.js constant defining a uv wrapping mode.
   * @return {string} The GPU address mode.
   */
  _convertAddressMode(value) {
    let addressMode = GPUAddressMode.ClampToEdge;
    if (value === RepeatWrapping) {
      addressMode = GPUAddressMode.Repeat;
    } else if (value === MirroredRepeatWrapping) {
      addressMode = GPUAddressMode.MirrorRepeat;
    }
    return addressMode;
  }
  /**
   * Converts the three.js filter constants to GPU filter constants.
   *
   * @private
   * @param {number} value - The three.js constant defining a filter mode.
   * @return {string} The GPU filter mode.
   */
  _convertFilterMode(value) {
    let filterMode = GPUFilterMode.Linear;
    if (value === NearestFilter || value === NearestMipmapNearestFilter || value === NearestMipmapLinearFilter) {
      filterMode = GPUFilterMode.Nearest;
    }
    return filterMode;
  }
  /**
   * Returns the bytes-per-texel value for the given GPU texture format.
   *
   * @private
   * @param {string} format - The GPU texture format.
   * @return {number} The bytes-per-texel.
   */
  _getBytesPerTexel(format2) {
    if (format2 === GPUTextureFormat.R8Unorm || format2 === GPUTextureFormat.R8Snorm || format2 === GPUTextureFormat.R8Uint || format2 === GPUTextureFormat.R8Sint) return 1;
    if (format2 === GPUTextureFormat.R16Uint || format2 === GPUTextureFormat.R16Sint || format2 === GPUTextureFormat.R16Float || format2 === GPUTextureFormat.RG8Unorm || format2 === GPUTextureFormat.RG8Snorm || format2 === GPUTextureFormat.RG8Uint || format2 === GPUTextureFormat.RG8Sint) return 2;
    if (format2 === GPUTextureFormat.R32Uint || format2 === GPUTextureFormat.R32Sint || format2 === GPUTextureFormat.R32Float || format2 === GPUTextureFormat.RG16Uint || format2 === GPUTextureFormat.RG16Sint || format2 === GPUTextureFormat.RG16Float || format2 === GPUTextureFormat.RGBA8Unorm || format2 === GPUTextureFormat.RGBA8UnormSRGB || format2 === GPUTextureFormat.RGBA8Snorm || format2 === GPUTextureFormat.RGBA8Uint || format2 === GPUTextureFormat.RGBA8Sint || format2 === GPUTextureFormat.BGRA8Unorm || format2 === GPUTextureFormat.BGRA8UnormSRGB || // Packed 32-bit formats
    format2 === GPUTextureFormat.RGB9E5UFloat || format2 === GPUTextureFormat.RGB10A2Unorm || format2 === GPUTextureFormat.RG11B10UFloat || format2 === GPUTextureFormat.Depth32Float || format2 === GPUTextureFormat.Depth24Plus || format2 === GPUTextureFormat.Depth24PlusStencil8 || format2 === GPUTextureFormat.Depth32FloatStencil8) return 4;
    if (format2 === GPUTextureFormat.RG32Uint || format2 === GPUTextureFormat.RG32Sint || format2 === GPUTextureFormat.RG32Float || format2 === GPUTextureFormat.RGBA16Uint || format2 === GPUTextureFormat.RGBA16Sint || format2 === GPUTextureFormat.RGBA16Float) return 8;
    if (format2 === GPUTextureFormat.RGBA32Uint || format2 === GPUTextureFormat.RGBA32Sint || format2 === GPUTextureFormat.RGBA32Float) return 16;
  }
  /**
   * Returns the corresponding typed array type for the given GPU texture format.
   *
   * @private
   * @param {string} format - The GPU texture format.
   * @return {TypedArray.constructor} The typed array type.
   */
  _getTypedArrayType(format2) {
    if (format2 === GPUTextureFormat.R8Uint) return Uint8Array;
    if (format2 === GPUTextureFormat.R8Sint) return Int8Array;
    if (format2 === GPUTextureFormat.R8Unorm) return Uint8Array;
    if (format2 === GPUTextureFormat.R8Snorm) return Int8Array;
    if (format2 === GPUTextureFormat.RG8Uint) return Uint8Array;
    if (format2 === GPUTextureFormat.RG8Sint) return Int8Array;
    if (format2 === GPUTextureFormat.RG8Unorm) return Uint8Array;
    if (format2 === GPUTextureFormat.RG8Snorm) return Int8Array;
    if (format2 === GPUTextureFormat.RGBA8Uint) return Uint8Array;
    if (format2 === GPUTextureFormat.RGBA8Sint) return Int8Array;
    if (format2 === GPUTextureFormat.RGBA8Unorm || format2 === GPUTextureFormat.RGBA8UnormSRGB) return Uint8Array;
    if (format2 === GPUTextureFormat.RGBA8Snorm) return Int8Array;
    if (format2 === GPUTextureFormat.R16Uint) return Uint16Array;
    if (format2 === GPUTextureFormat.R16Sint) return Int16Array;
    if (format2 === GPUTextureFormat.RG16Uint) return Uint16Array;
    if (format2 === GPUTextureFormat.RG16Sint) return Int16Array;
    if (format2 === GPUTextureFormat.RGBA16Uint) return Uint16Array;
    if (format2 === GPUTextureFormat.RGBA16Sint) return Int16Array;
    if (format2 === GPUTextureFormat.R16Float) return Uint16Array;
    if (format2 === GPUTextureFormat.RG16Float) return Uint16Array;
    if (format2 === GPUTextureFormat.RGBA16Float) return Uint16Array;
    if (format2 === GPUTextureFormat.R32Uint) return Uint32Array;
    if (format2 === GPUTextureFormat.R32Sint) return Int32Array;
    if (format2 === GPUTextureFormat.R32Float) return Float32Array;
    if (format2 === GPUTextureFormat.RG32Uint) return Uint32Array;
    if (format2 === GPUTextureFormat.RG32Sint) return Int32Array;
    if (format2 === GPUTextureFormat.RG32Float) return Float32Array;
    if (format2 === GPUTextureFormat.RGBA32Uint) return Uint32Array;
    if (format2 === GPUTextureFormat.RGBA32Sint) return Int32Array;
    if (format2 === GPUTextureFormat.RGBA32Float) return Float32Array;
    if (format2 === GPUTextureFormat.BGRA8Unorm || format2 === GPUTextureFormat.BGRA8UnormSRGB) return Uint8Array;
    if (format2 === GPUTextureFormat.RGB10A2Unorm) return Uint32Array;
    if (format2 === GPUTextureFormat.RGB9E5UFloat) return Uint32Array;
    if (format2 === GPUTextureFormat.RG11B10UFloat) return Uint32Array;
    if (format2 === GPUTextureFormat.Depth32Float) return Float32Array;
    if (format2 === GPUTextureFormat.Depth24Plus) return Uint32Array;
    if (format2 === GPUTextureFormat.Depth24PlusStencil8) return Uint32Array;
    if (format2 === GPUTextureFormat.Depth32FloatStencil8) return Float32Array;
  }
  /**
   * Returns the GPU dimensions for the given texture.
   *
   * @private
   * @param {Texture} texture - The texture.
   * @return {string} The GPU dimension.
   */
  _getDimension(texture3) {
    let dimension;
    if (texture3.is3DTexture || texture3.isData3DTexture) {
      dimension = GPUTextureDimension.ThreeD;
    } else {
      dimension = GPUTextureDimension.TwoD;
    }
    return dimension;
  }
};
function getFormat2(texture3, device = null) {
  const format2 = texture3.format;
  const type = texture3.type;
  const colorSpace = texture3.colorSpace;
  const transfer = ColorManagement.getTransfer(colorSpace);
  let formatGPU;
  if (texture3.isCompressedTexture === true || texture3.isCompressedArrayTexture === true) {
    switch (format2) {
      case RGB_S3TC_DXT1_Format:
      case RGBA_S3TC_DXT1_Format:
        formatGPU = transfer === SRGBTransfer ? GPUTextureFormat.BC1RGBAUnormSRGB : GPUTextureFormat.BC1RGBAUnorm;
        break;
      case RGBA_S3TC_DXT3_Format:
        formatGPU = transfer === SRGBTransfer ? GPUTextureFormat.BC2RGBAUnormSRGB : GPUTextureFormat.BC2RGBAUnorm;
        break;
      case RGBA_S3TC_DXT5_Format:
        formatGPU = transfer === SRGBTransfer ? GPUTextureFormat.BC3RGBAUnormSRGB : GPUTextureFormat.BC3RGBAUnorm;
        break;
      case RED_RGTC1_Format:
        formatGPU = GPUTextureFormat.BC4RUnorm;
        break;
      case SIGNED_RED_RGTC1_Format:
        formatGPU = GPUTextureFormat.BC4RSnorm;
        break;
      case RED_GREEN_RGTC2_Format:
        formatGPU = GPUTextureFormat.BC5RGUnorm;
        break;
      case SIGNED_RED_GREEN_RGTC2_Format:
        formatGPU = GPUTextureFormat.BC5RGSnorm;
        break;
      case RGBA_BPTC_Format:
        formatGPU = transfer === SRGBTransfer ? GPUTextureFormat.BC7RGBAUnormSRGB : GPUTextureFormat.BC7RGBAUnorm;
        break;
      case RGB_ETC2_Format:
      case RGB_ETC1_Format:
        formatGPU = transfer === SRGBTransfer ? GPUTextureFormat.ETC2RGB8UnormSRGB : GPUTextureFormat.ETC2RGB8Unorm;
        break;
      case RGBA_ETC2_EAC_Format:
        formatGPU = transfer === SRGBTransfer ? GPUTextureFormat.ETC2RGBA8UnormSRGB : GPUTextureFormat.ETC2RGBA8Unorm;
        break;
      case RGBA_ASTC_4x4_Format:
        formatGPU = transfer === SRGBTransfer ? GPUTextureFormat.ASTC4x4UnormSRGB : GPUTextureFormat.ASTC4x4Unorm;
        break;
      case RGBA_ASTC_5x4_Format:
        formatGPU = transfer === SRGBTransfer ? GPUTextureFormat.ASTC5x4UnormSRGB : GPUTextureFormat.ASTC5x4Unorm;
        break;
      case RGBA_ASTC_5x5_Format:
        formatGPU = transfer === SRGBTransfer ? GPUTextureFormat.ASTC5x5UnormSRGB : GPUTextureFormat.ASTC5x5Unorm;
        break;
      case RGBA_ASTC_6x5_Format:
        formatGPU = transfer === SRGBTransfer ? GPUTextureFormat.ASTC6x5UnormSRGB : GPUTextureFormat.ASTC6x5Unorm;
        break;
      case RGBA_ASTC_6x6_Format:
        formatGPU = transfer === SRGBTransfer ? GPUTextureFormat.ASTC6x6UnormSRGB : GPUTextureFormat.ASTC6x6Unorm;
        break;
      case RGBA_ASTC_8x5_Format:
        formatGPU = transfer === SRGBTransfer ? GPUTextureFormat.ASTC8x5UnormSRGB : GPUTextureFormat.ASTC8x5Unorm;
        break;
      case RGBA_ASTC_8x6_Format:
        formatGPU = transfer === SRGBTransfer ? GPUTextureFormat.ASTC8x6UnormSRGB : GPUTextureFormat.ASTC8x6Unorm;
        break;
      case RGBA_ASTC_8x8_Format:
        formatGPU = transfer === SRGBTransfer ? GPUTextureFormat.ASTC8x8UnormSRGB : GPUTextureFormat.ASTC8x8Unorm;
        break;
      case RGBA_ASTC_10x5_Format:
        formatGPU = transfer === SRGBTransfer ? GPUTextureFormat.ASTC10x5UnormSRGB : GPUTextureFormat.ASTC10x5Unorm;
        break;
      case RGBA_ASTC_10x6_Format:
        formatGPU = transfer === SRGBTransfer ? GPUTextureFormat.ASTC10x6UnormSRGB : GPUTextureFormat.ASTC10x6Unorm;
        break;
      case RGBA_ASTC_10x8_Format:
        formatGPU = transfer === SRGBTransfer ? GPUTextureFormat.ASTC10x8UnormSRGB : GPUTextureFormat.ASTC10x8Unorm;
        break;
      case RGBA_ASTC_10x10_Format:
        formatGPU = transfer === SRGBTransfer ? GPUTextureFormat.ASTC10x10UnormSRGB : GPUTextureFormat.ASTC10x10Unorm;
        break;
      case RGBA_ASTC_12x10_Format:
        formatGPU = transfer === SRGBTransfer ? GPUTextureFormat.ASTC12x10UnormSRGB : GPUTextureFormat.ASTC12x10Unorm;
        break;
      case RGBA_ASTC_12x12_Format:
        formatGPU = transfer === SRGBTransfer ? GPUTextureFormat.ASTC12x12UnormSRGB : GPUTextureFormat.ASTC12x12Unorm;
        break;
      case RGBAFormat:
        formatGPU = transfer === SRGBTransfer ? GPUTextureFormat.RGBA8UnormSRGB : GPUTextureFormat.RGBA8Unorm;
        break;
      default:
        console.error("WebGPURenderer: Unsupported texture format.", format2);
    }
  } else {
    switch (format2) {
      case RGBAFormat:
        switch (type) {
          case ByteType:
            formatGPU = GPUTextureFormat.RGBA8Snorm;
            break;
          case ShortType:
            formatGPU = GPUTextureFormat.RGBA16Sint;
            break;
          case UnsignedShortType:
            formatGPU = GPUTextureFormat.RGBA16Uint;
            break;
          case UnsignedIntType:
            formatGPU = GPUTextureFormat.RGBA32Uint;
            break;
          case IntType:
            formatGPU = GPUTextureFormat.RGBA32Sint;
            break;
          case UnsignedByteType:
            formatGPU = transfer === SRGBTransfer ? GPUTextureFormat.RGBA8UnormSRGB : GPUTextureFormat.RGBA8Unorm;
            break;
          case HalfFloatType:
            formatGPU = GPUTextureFormat.RGBA16Float;
            break;
          case FloatType:
            formatGPU = GPUTextureFormat.RGBA32Float;
            break;
          default:
            console.error("WebGPURenderer: Unsupported texture type with RGBAFormat.", type);
        }
        break;
      case RGBFormat:
        switch (type) {
          case UnsignedInt5999Type:
            formatGPU = GPUTextureFormat.RGB9E5UFloat;
            break;
          case UnsignedInt101111Type:
            formatGPU = GPUTextureFormat.RG11B10UFloat;
            break;
          default:
            console.error("WebGPURenderer: Unsupported texture type with RGBFormat.", type);
        }
        break;
      case RedFormat:
        switch (type) {
          case ByteType:
            formatGPU = GPUTextureFormat.R8Snorm;
            break;
          case ShortType:
            formatGPU = GPUTextureFormat.R16Sint;
            break;
          case UnsignedShortType:
            formatGPU = GPUTextureFormat.R16Uint;
            break;
          case UnsignedIntType:
            formatGPU = GPUTextureFormat.R32Uint;
            break;
          case IntType:
            formatGPU = GPUTextureFormat.R32Sint;
            break;
          case UnsignedByteType:
            formatGPU = GPUTextureFormat.R8Unorm;
            break;
          case HalfFloatType:
            formatGPU = GPUTextureFormat.R16Float;
            break;
          case FloatType:
            formatGPU = GPUTextureFormat.R32Float;
            break;
          default:
            console.error("WebGPURenderer: Unsupported texture type with RedFormat.", type);
        }
        break;
      case RGFormat:
        switch (type) {
          case ByteType:
            formatGPU = GPUTextureFormat.RG8Snorm;
            break;
          case ShortType:
            formatGPU = GPUTextureFormat.RG16Sint;
            break;
          case UnsignedShortType:
            formatGPU = GPUTextureFormat.RG16Uint;
            break;
          case UnsignedIntType:
            formatGPU = GPUTextureFormat.RG32Uint;
            break;
          case IntType:
            formatGPU = GPUTextureFormat.RG32Sint;
            break;
          case UnsignedByteType:
            formatGPU = GPUTextureFormat.RG8Unorm;
            break;
          case HalfFloatType:
            formatGPU = GPUTextureFormat.RG16Float;
            break;
          case FloatType:
            formatGPU = GPUTextureFormat.RG32Float;
            break;
          default:
            console.error("WebGPURenderer: Unsupported texture type with RGFormat.", type);
        }
        break;
      case DepthFormat:
        switch (type) {
          case UnsignedShortType:
            formatGPU = GPUTextureFormat.Depth16Unorm;
            break;
          case UnsignedIntType:
            formatGPU = GPUTextureFormat.Depth24Plus;
            break;
          case FloatType:
            formatGPU = GPUTextureFormat.Depth32Float;
            break;
          default:
            console.error("WebGPURenderer: Unsupported texture type with DepthFormat.", type);
        }
        break;
      case DepthStencilFormat:
        switch (type) {
          case UnsignedInt248Type:
            formatGPU = GPUTextureFormat.Depth24PlusStencil8;
            break;
          case FloatType:
            if (device && device.features.has(GPUFeatureName.Depth32FloatStencil8) === false) {
              console.error('WebGPURenderer: Depth textures with DepthStencilFormat + FloatType can only be used with the "depth32float-stencil8" GPU feature.');
            }
            formatGPU = GPUTextureFormat.Depth32FloatStencil8;
            break;
          default:
            console.error("WebGPURenderer: Unsupported texture type with DepthStencilFormat.", type);
        }
        break;
      case RedIntegerFormat:
        switch (type) {
          case IntType:
            formatGPU = GPUTextureFormat.R32Sint;
            break;
          case UnsignedIntType:
            formatGPU = GPUTextureFormat.R32Uint;
            break;
          default:
            console.error("WebGPURenderer: Unsupported texture type with RedIntegerFormat.", type);
        }
        break;
      case RGIntegerFormat:
        switch (type) {
          case IntType:
            formatGPU = GPUTextureFormat.RG32Sint;
            break;
          case UnsignedIntType:
            formatGPU = GPUTextureFormat.RG32Uint;
            break;
          default:
            console.error("WebGPURenderer: Unsupported texture type with RGIntegerFormat.", type);
        }
        break;
      case RGBAIntegerFormat:
        switch (type) {
          case IntType:
            formatGPU = GPUTextureFormat.RGBA32Sint;
            break;
          case UnsignedIntType:
            formatGPU = GPUTextureFormat.RGBA32Uint;
            break;
          default:
            console.error("WebGPURenderer: Unsupported texture type with RGBAIntegerFormat.", type);
        }
        break;
      default:
        console.error("WebGPURenderer: Unsupported texture format.", format2);
    }
  }
  return formatGPU;
}
var declarationRegexp = /^[fn]*\s*([a-z_0-9]+)?\s*\(([\s\S]*?)\)\s*[\-\>]*\s*([a-z_0-9]+(?:<[\s\S]+?>)?)/i;
var propertiesRegexp = /([a-z_0-9]+)\s*:\s*([a-z_0-9]+(?:<[\s\S]+?>)?)/ig;
var wgslTypeLib$1 = {
  "f32": "float",
  "i32": "int",
  "u32": "uint",
  "bool": "bool",
  "vec2<f32>": "vec2",
  "vec2<i32>": "ivec2",
  "vec2<u32>": "uvec2",
  "vec2<bool>": "bvec2",
  "vec2f": "vec2",
  "vec2i": "ivec2",
  "vec2u": "uvec2",
  "vec2b": "bvec2",
  "vec3<f32>": "vec3",
  "vec3<i32>": "ivec3",
  "vec3<u32>": "uvec3",
  "vec3<bool>": "bvec3",
  "vec3f": "vec3",
  "vec3i": "ivec3",
  "vec3u": "uvec3",
  "vec3b": "bvec3",
  "vec4<f32>": "vec4",
  "vec4<i32>": "ivec4",
  "vec4<u32>": "uvec4",
  "vec4<bool>": "bvec4",
  "vec4f": "vec4",
  "vec4i": "ivec4",
  "vec4u": "uvec4",
  "vec4b": "bvec4",
  "mat2x2<f32>": "mat2",
  "mat2x2f": "mat2",
  "mat3x3<f32>": "mat3",
  "mat3x3f": "mat3",
  "mat4x4<f32>": "mat4",
  "mat4x4f": "mat4",
  "sampler": "sampler",
  "texture_1d": "texture",
  "texture_2d": "texture",
  "texture_2d_array": "texture",
  "texture_multisampled_2d": "cubeTexture",
  "texture_depth_2d": "depthTexture",
  "texture_depth_2d_array": "depthTexture",
  "texture_depth_multisampled_2d": "depthTexture",
  "texture_depth_cube": "depthTexture",
  "texture_depth_cube_array": "depthTexture",
  "texture_3d": "texture3D",
  "texture_cube": "cubeTexture",
  "texture_cube_array": "cubeTexture",
  "texture_storage_1d": "storageTexture",
  "texture_storage_2d": "storageTexture",
  "texture_storage_2d_array": "storageTexture",
  "texture_storage_3d": "storageTexture"
};
var parse = (source) => {
  source = source.trim();
  const declaration = source.match(declarationRegexp);
  if (declaration !== null && declaration.length === 4) {
    const inputsCode = declaration[2];
    const propsMatches = [];
    let match = null;
    while ((match = propertiesRegexp.exec(inputsCode)) !== null) {
      propsMatches.push({ name: match[1], type: match[2] });
    }
    const inputs = [];
    for (let i = 0; i < propsMatches.length; i++) {
      const { name: name2, type: type2 } = propsMatches[i];
      let resolvedType = type2;
      if (resolvedType.startsWith("ptr")) {
        resolvedType = "pointer";
      } else {
        if (resolvedType.startsWith("texture")) {
          resolvedType = type2.split("<")[0];
        }
        resolvedType = wgslTypeLib$1[resolvedType];
      }
      inputs.push(new NodeFunctionInput(resolvedType, name2));
    }
    const blockCode = source.substring(declaration[0].length);
    const outputType = declaration[3] || "void";
    const name = declaration[1] !== void 0 ? declaration[1] : "";
    const type = wgslTypeLib$1[outputType] || outputType;
    return {
      type,
      inputs,
      name,
      inputsCode,
      blockCode,
      outputType
    };
  } else {
    throw new Error("FunctionNode: Function is not a WGSL code.");
  }
};
var WGSLNodeFunction = class extends NodeFunction {
  /**
   * Constructs a new WGSL node function.
   *
   * @param {string} source - The WGSL source.
   */
  constructor(source) {
    const { type, inputs, name, inputsCode, blockCode, outputType } = parse(source);
    super(type, inputs, name);
    this.inputsCode = inputsCode;
    this.blockCode = blockCode;
    this.outputType = outputType;
  }
  /**
   * This method returns the WGSL code of the node function.
   *
   * @param {string} [name=this.name] - The function's name.
   * @return {string} The shader code.
   */
  getCode(name = this.name) {
    const outputType = this.outputType !== "void" ? "-> " + this.outputType : "";
    return `fn ${name} ( ${this.inputsCode.trim()} ) ${outputType}` + this.blockCode;
  }
};
var WGSLNodeParser = class extends NodeParser {
  /**
   * The method parses the given WGSL code an returns a node function.
   *
   * @param {string} source - The WGSL code.
   * @return {WGSLNodeFunction} A node function.
   */
  parseFunction(source) {
    return new WGSLNodeFunction(source);
  }
};
var GPUShaderStage = typeof self !== "undefined" ? self.GPUShaderStage : { VERTEX: 1, FRAGMENT: 2, COMPUTE: 4 };
var accessNames = {
  [NodeAccess.READ_ONLY]: "read",
  [NodeAccess.WRITE_ONLY]: "write",
  [NodeAccess.READ_WRITE]: "read_write"
};
var wrapNames = {
  [RepeatWrapping]: "repeat",
  [ClampToEdgeWrapping]: "clamp",
  [MirroredRepeatWrapping]: "mirror"
};
var gpuShaderStageLib = {
  "vertex": GPUShaderStage ? GPUShaderStage.VERTEX : 1,
  "fragment": GPUShaderStage ? GPUShaderStage.FRAGMENT : 2,
  "compute": GPUShaderStage ? GPUShaderStage.COMPUTE : 4
};
var supports = {
  instance: true,
  swizzleAssign: false,
  storageBuffer: true
};
var wgslFnOpLib = {
  "^^": "tsl_xor"
};
var wgslTypeLib = {
  float: "f32",
  int: "i32",
  uint: "u32",
  bool: "bool",
  color: "vec3<f32>",
  vec2: "vec2<f32>",
  ivec2: "vec2<i32>",
  uvec2: "vec2<u32>",
  bvec2: "vec2<bool>",
  vec3: "vec3<f32>",
  ivec3: "vec3<i32>",
  uvec3: "vec3<u32>",
  bvec3: "vec3<bool>",
  vec4: "vec4<f32>",
  ivec4: "vec4<i32>",
  uvec4: "vec4<u32>",
  bvec4: "vec4<bool>",
  mat2: "mat2x2<f32>",
  mat3: "mat3x3<f32>",
  mat4: "mat4x4<f32>"
};
var wgslCodeCache = {};
var wgslPolyfill = {
  tsl_xor: new CodeNode("fn tsl_xor( a : bool, b : bool ) -> bool { return ( a || b ) && !( a && b ); }"),
  mod_float: new CodeNode("fn tsl_mod_float( x : f32, y : f32 ) -> f32 { return x - y * floor( x / y ); }"),
  mod_vec2: new CodeNode("fn tsl_mod_vec2( x : vec2f, y : vec2f ) -> vec2f { return x - y * floor( x / y ); }"),
  mod_vec3: new CodeNode("fn tsl_mod_vec3( x : vec3f, y : vec3f ) -> vec3f { return x - y * floor( x / y ); }"),
  mod_vec4: new CodeNode("fn tsl_mod_vec4( x : vec4f, y : vec4f ) -> vec4f { return x - y * floor( x / y ); }"),
  equals_bool: new CodeNode("fn tsl_equals_bool( a : bool, b : bool ) -> bool { return a == b; }"),
  equals_bvec2: new CodeNode("fn tsl_equals_bvec2( a : vec2f, b : vec2f ) -> vec2<bool> { return vec2<bool>( a.x == b.x, a.y == b.y ); }"),
  equals_bvec3: new CodeNode("fn tsl_equals_bvec3( a : vec3f, b : vec3f ) -> vec3<bool> { return vec3<bool>( a.x == b.x, a.y == b.y, a.z == b.z ); }"),
  equals_bvec4: new CodeNode("fn tsl_equals_bvec4( a : vec4f, b : vec4f ) -> vec4<bool> { return vec4<bool>( a.x == b.x, a.y == b.y, a.z == b.z, a.w == b.w ); }"),
  repeatWrapping_float: new CodeNode("fn tsl_repeatWrapping_float( coord: f32 ) -> f32 { return fract( coord ); }"),
  mirrorWrapping_float: new CodeNode("fn tsl_mirrorWrapping_float( coord: f32 ) -> f32 { let mirrored = fract( coord * 0.5 ) * 2.0; return 1.0 - abs( 1.0 - mirrored ); }"),
  clampWrapping_float: new CodeNode("fn tsl_clampWrapping_float( coord: f32 ) -> f32 { return clamp( coord, 0.0, 1.0 ); }"),
  biquadraticTexture: new CodeNode(
    /* wgsl */
    `
fn tsl_biquadraticTexture( map : texture_2d<f32>, coord : vec2f, iRes : vec2u, level : u32 ) -> vec4f {

	let res = vec2f( iRes );

	let uvScaled = coord * res;
	let uvWrapping = ( ( uvScaled % res ) + res ) % res;

	// https://www.shadertoy.com/view/WtyXRy

	let uv = uvWrapping - 0.5;
	let iuv = floor( uv );
	let f = fract( uv );

	let rg1 = textureLoad( map, vec2u( iuv + vec2( 0.5, 0.5 ) ) % iRes, level );
	let rg2 = textureLoad( map, vec2u( iuv + vec2( 1.5, 0.5 ) ) % iRes, level );
	let rg3 = textureLoad( map, vec2u( iuv + vec2( 0.5, 1.5 ) ) % iRes, level );
	let rg4 = textureLoad( map, vec2u( iuv + vec2( 1.5, 1.5 ) ) % iRes, level );

	return mix( mix( rg1, rg2, f.x ), mix( rg3, rg4, f.x ), f.y );

}
`
  )
};
var wgslMethods = {
  dFdx: "dpdx",
  dFdy: "- dpdy",
  mod_float: "tsl_mod_float",
  mod_vec2: "tsl_mod_vec2",
  mod_vec3: "tsl_mod_vec3",
  mod_vec4: "tsl_mod_vec4",
  equals_bool: "tsl_equals_bool",
  equals_bvec2: "tsl_equals_bvec2",
  equals_bvec3: "tsl_equals_bvec3",
  equals_bvec4: "tsl_equals_bvec4",
  inversesqrt: "inverseSqrt",
  bitcast: "bitcast<f32>"
};
var diagnostics = "";
if ((typeof navigator !== "undefined" && /Firefox|Deno/g.test(navigator.userAgent)) !== true) {
  diagnostics += "diagnostic( off, derivative_uniformity );\n";
}
var WGSLNodeBuilder = class extends NodeBuilder {
  /**
   * Constructs a new WGSL node builder renderer.
   *
   * @param {Object3D} object - The 3D object.
   * @param {Renderer} renderer - The renderer.
   */
  constructor(object2, renderer) {
    super(object2, renderer, new WGSLNodeParser());
    this.uniformGroups = {};
    this.builtins = {};
    this.directives = {};
    this.scopedArrays = /* @__PURE__ */ new Map();
  }
  /**
   * Generates the WGSL snippet for sampled textures.
   *
   * @private
   * @param {Texture} texture - The texture.
   * @param {string} textureProperty - The name of the texture uniform in the shader.
   * @param {string} uvSnippet - A WGSL snippet that represents texture coordinates used for sampling.
   * @param {?string} depthSnippet - A WGSL snippet that represents 0-based texture array index to sample.
   * @param {?string} offsetSnippet - A WGSL snippet that represents the offset that will be applied to the unnormalized texture coordinate before sampling the texture.
   * @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.
   * @return {string} The WGSL snippet.
   */
  _generateTextureSample(texture3, textureProperty, uvSnippet, depthSnippet, offsetSnippet, shaderStage = this.shaderStage) {
    if (shaderStage === "fragment") {
      if (depthSnippet) {
        if (offsetSnippet) {
          return `textureSample( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet}, ${depthSnippet}, ${offsetSnippet} )`;
        }
        return `textureSample( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet}, ${depthSnippet} )`;
      } else {
        if (offsetSnippet) {
          return `textureSample( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet}, ${offsetSnippet} )`;
        }
        return `textureSample( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet} )`;
      }
    } else {
      return this.generateTextureSampleLevel(texture3, textureProperty, uvSnippet, "0", depthSnippet);
    }
  }
  /**
   * Generates the WGSL snippet when sampling textures with explicit mip level.
   *
   * @private
   * @param {Texture} texture - The texture.
   * @param {string} textureProperty - The name of the texture uniform in the shader.
   * @param {string} uvSnippet - A WGSL snippet that represents texture coordinates used for sampling.
   * @param {string} levelSnippet - A WGSL snippet that represents the mip level, with level 0 containing a full size version of the texture.
   * @param {string} depthSnippet - A WGSL snippet that represents 0-based texture array index to sample.
   * @param {?string} offsetSnippet - A WGSL snippet that represents the offset that will be applied to the unnormalized texture coordinate before sampling the texture.
   * @return {string} The WGSL snippet.
   */
  generateTextureSampleLevel(texture3, textureProperty, uvSnippet, levelSnippet, depthSnippet, offsetSnippet) {
    if (this.isUnfilterable(texture3) === false) {
      if (offsetSnippet) {
        return `textureSampleLevel( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet}, ${levelSnippet}, ${offsetSnippet} )`;
      }
      return `textureSampleLevel( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet}, ${levelSnippet} )`;
    } else if (this.isFilteredTexture(texture3)) {
      return this.generateFilteredTexture(texture3, textureProperty, uvSnippet, offsetSnippet, levelSnippet);
    } else {
      return this.generateTextureLod(texture3, textureProperty, uvSnippet, depthSnippet, offsetSnippet, levelSnippet);
    }
  }
  /**
   * Generates a wrap function used in context of textures.
   *
   * @param {Texture} texture - The texture to generate the function for.
   * @return {string} The name of the generated function.
   */
  generateWrapFunction(texture3) {
    const functionName = `tsl_coord_${wrapNames[texture3.wrapS]}S_${wrapNames[texture3.wrapT]}_${texture3.isData3DTexture ? "3d" : "2d"}T`;
    let nodeCode = wgslCodeCache[functionName];
    if (nodeCode === void 0) {
      const includes = [];
      const coordType = texture3.isData3DTexture ? "vec3f" : "vec2f";
      let code3 = `fn ${functionName}( coord : ${coordType} ) -> ${coordType} {

	return ${coordType}(
`;
      const addWrapSnippet = (wrap, axis) => {
        if (wrap === RepeatWrapping) {
          includes.push(wgslPolyfill.repeatWrapping_float);
          code3 += `		tsl_repeatWrapping_float( coord.${axis} )`;
        } else if (wrap === ClampToEdgeWrapping) {
          includes.push(wgslPolyfill.clampWrapping_float);
          code3 += `		tsl_clampWrapping_float( coord.${axis} )`;
        } else if (wrap === MirroredRepeatWrapping) {
          includes.push(wgslPolyfill.mirrorWrapping_float);
          code3 += `		tsl_mirrorWrapping_float( coord.${axis} )`;
        } else {
          code3 += `		coord.${axis}`;
          console.warn(`WebGPURenderer: Unsupported texture wrap type "${wrap}" for vertex shader.`);
        }
      };
      addWrapSnippet(texture3.wrapS, "x");
      code3 += ",\n";
      addWrapSnippet(texture3.wrapT, "y");
      if (texture3.isData3DTexture) {
        code3 += ",\n";
        addWrapSnippet(texture3.wrapR, "z");
      }
      code3 += "\n	);\n\n}\n";
      wgslCodeCache[functionName] = nodeCode = new CodeNode(code3, includes);
    }
    nodeCode.build(this);
    return functionName;
  }
  /**
   * Generates the array declaration string.
   *
   * @param {string} type - The type.
   * @param {?number} [count] - The count.
   * @return {string} The generated value as a shader string.
   */
  generateArrayDeclaration(type, count2) {
    return `array< ${this.getType(type)}, ${count2} >`;
  }
  /**
   * Generates a WGSL variable that holds the texture dimension of the given texture.
   * It also returns information about the number of layers (elements) of an arrayed
   * texture as well as the cube face count of cube textures.
   *
   * @param {Texture} texture - The texture to generate the function for.
   * @param {string} textureProperty - The name of the video texture uniform in the shader.
   * @param {string} levelSnippet - A WGSL snippet that represents the mip level, with level 0 containing a full size version of the texture.
   * @return {string} The name of the dimension variable.
   */
  generateTextureDimension(texture3, textureProperty, levelSnippet) {
    const textureData = this.getDataFromNode(texture3, this.shaderStage, this.globalCache);
    if (textureData.dimensionsSnippet === void 0) textureData.dimensionsSnippet = {};
    let textureDimensionNode = textureData.dimensionsSnippet[levelSnippet];
    if (textureData.dimensionsSnippet[levelSnippet] === void 0) {
      let textureDimensionsParams;
      let dimensionType;
      const { primarySamples } = this.renderer.backend.utils.getTextureSampleData(texture3);
      const isMultisampled = primarySamples > 1;
      if (texture3.isData3DTexture) {
        dimensionType = "vec3<u32>";
      } else {
        dimensionType = "vec2<u32>";
      }
      if (isMultisampled || texture3.isStorageTexture) {
        textureDimensionsParams = textureProperty;
      } else {
        textureDimensionsParams = `${textureProperty}${levelSnippet ? `, u32( ${levelSnippet} )` : ""}`;
      }
      textureDimensionNode = new VarNode(new ExpressionNode(`textureDimensions( ${textureDimensionsParams} )`, dimensionType));
      textureData.dimensionsSnippet[levelSnippet] = textureDimensionNode;
      if (texture3.isArrayTexture || texture3.isDataArrayTexture || texture3.isData3DTexture) {
        textureData.arrayLayerCount = new VarNode(
          new ExpressionNode(
            `textureNumLayers(${textureProperty})`,
            "u32"
          )
        );
      }
      if (texture3.isTextureCube) {
        textureData.cubeFaceCount = new VarNode(
          new ExpressionNode("6u", "u32")
        );
      }
    }
    return textureDimensionNode.build(this);
  }
  /**
   * Generates the WGSL snippet for a manual filtered texture.
   *
   * @param {Texture} texture - The texture.
   * @param {string} textureProperty - The name of the texture uniform in the shader.
   * @param {string} uvSnippet - A WGSL snippet that represents texture coordinates used for sampling.
   * @param {?string} offsetSnippet - A WGSL snippet that represents the offset that will be applied to the unnormalized texture coordinate before sampling the texture.
   * @param {string} [levelSnippet='0u'] - A WGSL snippet that represents the mip level, with level 0 containing a full size version of the texture.
   * @return {string} The WGSL snippet.
   */
  generateFilteredTexture(texture3, textureProperty, uvSnippet, offsetSnippet, levelSnippet = "0u") {
    this._include("biquadraticTexture");
    const wrapFunction = this.generateWrapFunction(texture3);
    const textureDimension = this.generateTextureDimension(texture3, textureProperty, levelSnippet);
    if (offsetSnippet) {
      uvSnippet = `${uvSnippet} + vec2<f32>(${offsetSnippet}) / ${textureDimension}`;
    }
    return `tsl_biquadraticTexture( ${textureProperty}, ${wrapFunction}( ${uvSnippet} ), ${textureDimension}, u32( ${levelSnippet} ) )`;
  }
  /**
   * Generates the WGSL snippet for a texture lookup with explicit level-of-detail.
   * Since it's a lookup, no sampling or filtering is applied.
   *
   * @param {Texture} texture - The texture.
   * @param {string} textureProperty - The name of the texture uniform in the shader.
   * @param {string} uvSnippet - A WGSL snippet that represents texture coordinates used for sampling.
   * @param {?string} depthSnippet - A WGSL snippet that represents 0-based texture array index to sample.
   * @param {?string} offsetSnippet - A WGSL snippet that represents the offset that will be applied to the unnormalized texture coordinate before sampling the texture.
   * @param {string} [levelSnippet='0u'] - A WGSL snippet that represents the mip level, with level 0 containing a full size version of the texture.
   * @return {string} The WGSL snippet.
   */
  generateTextureLod(texture3, textureProperty, uvSnippet, depthSnippet, offsetSnippet, levelSnippet = "0u") {
    const wrapFunction = this.generateWrapFunction(texture3);
    const textureDimension = this.generateTextureDimension(texture3, textureProperty, levelSnippet);
    const vecType = texture3.isData3DTexture ? "vec3" : "vec2";
    if (offsetSnippet) {
      uvSnippet = `${uvSnippet} + ${vecType}<f32>(${offsetSnippet}) / ${vecType}<f32>( ${textureDimension} )`;
    }
    const coordSnippet = `${vecType}<u32>( ${wrapFunction}( ${uvSnippet} ) * ${vecType}<f32>( ${textureDimension} ) )`;
    return this.generateTextureLoad(texture3, textureProperty, coordSnippet, depthSnippet, null, levelSnippet);
  }
  /**
   * Generates the WGSL snippet that reads a single texel from a texture without sampling or filtering.
   *
   * @param {Texture} texture - The texture.
   * @param {string} textureProperty - The name of the texture uniform in the shader.
   * @param {string} uvIndexSnippet - A WGSL snippet that represents texture coordinates used for sampling.
   * @param {?string} depthSnippet - A WGSL snippet that represents 0-based texture array index to sample.
   * @param {?string} offsetSnippet - A WGSL snippet that represents the offset that will be applied to the unnormalized texture coordinate before sampling the texture.
   * @param {string} [levelSnippet='0u'] - A WGSL snippet that represents the mip level, with level 0 containing a full size version of the texture.
   * @return {string} The WGSL snippet.
   */
  generateTextureLoad(texture3, textureProperty, uvIndexSnippet, depthSnippet, offsetSnippet, levelSnippet = "0u") {
    let snippet;
    if (offsetSnippet) {
      uvIndexSnippet = `${uvIndexSnippet} + ${offsetSnippet}`;
    }
    if (depthSnippet) {
      snippet = `textureLoad( ${textureProperty}, ${uvIndexSnippet}, ${depthSnippet}, u32( ${levelSnippet} ) )`;
    } else {
      snippet = `textureLoad( ${textureProperty}, ${uvIndexSnippet}, u32( ${levelSnippet} ) )`;
      if (this.renderer.backend.compatibilityMode && texture3.isDepthTexture) {
        snippet += ".x";
      }
    }
    return snippet;
  }
  /**
   * Generates the WGSL snippet that writes a single texel to a texture.
   *
   * @param {Texture} texture - The texture.
   * @param {string} textureProperty - The name of the texture uniform in the shader.
   * @param {string} uvIndexSnippet - A WGSL snippet that represents texture coordinates used for sampling.
   * @param {?string} depthSnippet - A WGSL snippet that represents 0-based texture array index to sample.
   * @param {string} valueSnippet - A WGSL snippet that represent the new texel value.
   * @return {string} The WGSL snippet.
   */
  generateTextureStore(texture3, textureProperty, uvIndexSnippet, depthSnippet, valueSnippet) {
    let snippet;
    if (depthSnippet) {
      snippet = `textureStore( ${textureProperty}, ${uvIndexSnippet}, ${depthSnippet}, ${valueSnippet} )`;
    } else {
      snippet = `textureStore( ${textureProperty}, ${uvIndexSnippet}, ${valueSnippet} )`;
    }
    return snippet;
  }
  /**
   * Returns `true` if the sampled values of the given texture should be compared against a reference value.
   *
   * @param {Texture} texture - The texture.
   * @return {boolean} Whether the sampled values of the given texture should be compared against a reference value or not.
   */
  isSampleCompare(texture3) {
    return texture3.isDepthTexture === true && texture3.compareFunction !== null;
  }
  /**
   * Returns `true` if the given texture is unfilterable.
   *
   * @param {Texture} texture - The texture.
   * @return {boolean} Whether the given texture is unfilterable or not.
   */
  isUnfilterable(texture3) {
    return this.getComponentTypeFromTexture(texture3) !== "float" || !this.isAvailable("float32Filterable") && texture3.isDataTexture === true && texture3.type === FloatType || this.isSampleCompare(texture3) === false && texture3.minFilter === NearestFilter && texture3.magFilter === NearestFilter || this.renderer.backend.utils.getTextureSampleData(texture3).primarySamples > 1;
  }
  /**
   * Generates the WGSL snippet for sampling/loading the given texture.
   *
   * @param {Texture} texture - The texture.
   * @param {string} textureProperty - The name of the texture uniform in the shader.
   * @param {string} uvSnippet - A WGSL snippet that represents texture coordinates used for sampling.
   * @param {?string} depthSnippet - A WGSL snippet that represents 0-based texture array index to sample.
   * @param {?string} offsetSnippet - A WGSL snippet that represents the offset that will be applied to the unnormalized texture coordinate before sampling the texture.
   * @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.
   * @return {string} The WGSL snippet.
   */
  generateTexture(texture3, textureProperty, uvSnippet, depthSnippet, offsetSnippet, shaderStage = this.shaderStage) {
    let snippet = null;
    if (this.isUnfilterable(texture3)) {
      snippet = this.generateTextureLod(texture3, textureProperty, uvSnippet, depthSnippet, offsetSnippet, "0", shaderStage);
    } else {
      snippet = this._generateTextureSample(texture3, textureProperty, uvSnippet, depthSnippet, offsetSnippet, shaderStage);
    }
    return snippet;
  }
  /**
   * Generates the WGSL snippet for sampling/loading the given texture using explicit gradients.
   *
   * @param {Texture} texture - The texture.
   * @param {string} textureProperty - The name of the texture uniform in the shader.
   * @param {string} uvSnippet - A WGSL snippet that represents texture coordinates used for sampling.
   * @param {Array<string>} gradSnippet - An array holding both gradient WGSL snippets.
   * @param {?string} depthSnippet - A WGSL snippet that represents 0-based texture array index to sample.
   * @param {?string} offsetSnippet - A WGSL snippet that represents the offset that will be applied to the unnormalized texture coordinate before sampling the texture.
   * @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.
   * @return {string} The WGSL snippet.
   */
  generateTextureGrad(texture3, textureProperty, uvSnippet, gradSnippet, depthSnippet, offsetSnippet, shaderStage = this.shaderStage) {
    if (shaderStage === "fragment") {
      if (offsetSnippet) {
        return `textureSampleGrad( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet},  ${gradSnippet[0]}, ${gradSnippet[1]}, ${offsetSnippet} )`;
      }
      return `textureSampleGrad( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet},  ${gradSnippet[0]}, ${gradSnippet[1]} )`;
    } else {
      console.error(`WebGPURenderer: THREE.TextureNode.gradient() does not support ${shaderStage} shader.`);
    }
  }
  /**
   * Generates the WGSL snippet for sampling a depth texture and comparing the sampled depth values
   * against a reference value.
   *
   * @param {Texture} texture - The texture.
   * @param {string} textureProperty - The name of the texture uniform in the shader.
   * @param {string} uvSnippet - A WGSL snippet that represents texture coordinates used for sampling.
   * @param {string} compareSnippet -  A WGSL snippet that represents the reference value.
   * @param {?string} depthSnippet - A WGSL snippet that represents 0-based texture array index to sample.
   * @param {?string} offsetSnippet - A WGSL snippet that represents the offset that will be applied to the unnormalized texture coordinate before sampling the texture.
   * @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.
   * @return {string} The WGSL snippet.
   */
  generateTextureCompare(texture3, textureProperty, uvSnippet, compareSnippet, depthSnippet, offsetSnippet, shaderStage = this.shaderStage) {
    if (shaderStage === "fragment") {
      if (texture3.isDepthTexture === true && texture3.isArrayTexture === true) {
        if (offsetSnippet) {
          return `textureSampleCompare( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet}, ${depthSnippet}, ${compareSnippet}, ${offsetSnippet} )`;
        }
        return `textureSampleCompare( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet}, ${depthSnippet}, ${compareSnippet} )`;
      }
      if (offsetSnippet) {
        return `textureSampleCompare( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet}, ${compareSnippet}, ${offsetSnippet} )`;
      }
      return `textureSampleCompare( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet}, ${compareSnippet} )`;
    } else {
      console.error(`WebGPURenderer: THREE.DepthTexture.compareFunction() does not support ${shaderStage} shader.`);
    }
  }
  /**
   * Generates the WGSL snippet when sampling textures with explicit mip level.
   *
   * @param {Texture} texture - The texture.
   * @param {string} textureProperty - The name of the texture uniform in the shader.
   * @param {string} uvSnippet - A WGSL snippet that represents texture coordinates used for sampling.
   * @param {string} levelSnippet - A WGSL snippet that represents the mip level, with level 0 containing a full size version of the texture.
   * @param {?string} depthSnippet - A WGSL snippet that represents 0-based texture array index to sample.
   * @param {?string} offsetSnippet - A WGSL snippet that represents the offset that will be applied to the unnormalized texture coordinate before sampling the texture.
   * @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.
   * @return {string} The WGSL snippet.
   */
  generateTextureLevel(texture3, textureProperty, uvSnippet, levelSnippet, depthSnippet, offsetSnippet) {
    if (this.isUnfilterable(texture3) === false) {
      if (offsetSnippet) {
        return `textureSampleLevel( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet}, ${levelSnippet}, ${offsetSnippet} )`;
      }
      return `textureSampleLevel( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet}, ${levelSnippet} )`;
    } else if (this.isFilteredTexture(texture3)) {
      return this.generateFilteredTexture(texture3, textureProperty, uvSnippet, offsetSnippet, levelSnippet);
    } else {
      return this.generateTextureLod(texture3, textureProperty, uvSnippet, depthSnippet, offsetSnippet, levelSnippet);
    }
  }
  /**
   * Generates the WGSL snippet when sampling textures with a bias to the mip level.
   *
   * @param {Texture} texture - The texture.
   * @param {string} textureProperty - The name of the texture uniform in the shader.
   * @param {string} uvSnippet - A WGSL snippet that represents texture coordinates used for sampling.
   * @param {string} biasSnippet - A WGSL snippet that represents the bias to apply to the mip level before sampling.
   * @param {?string} depthSnippet - A WGSL snippet that represents 0-based texture array index to sample.
   * @param {?string} offsetSnippet - A WGSL snippet that represents the offset that will be applied to the unnormalized texture coordinate before sampling the texture.
   * @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.
   * @return {string} The WGSL snippet.
   */
  generateTextureBias(texture3, textureProperty, uvSnippet, biasSnippet, depthSnippet, offsetSnippet, shaderStage = this.shaderStage) {
    if (shaderStage === "fragment") {
      if (offsetSnippet) {
        return `textureSampleBias( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet}, ${biasSnippet}, ${offsetSnippet} )`;
      }
      return `textureSampleBias( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet}, ${biasSnippet} )`;
    } else {
      console.error(`WebGPURenderer: THREE.TextureNode.biasNode does not support ${shaderStage} shader.`);
    }
  }
  /**
   * Returns a WGSL snippet that represents the property name of the given node.
   *
   * @param {Node} node - The node.
   * @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.
   * @return {string} The property name.
   */
  getPropertyName(node, shaderStage = this.shaderStage) {
    if (node.isNodeVarying === true && node.needsInterpolation === true) {
      if (shaderStage === "vertex") {
        return `varyings.${node.name}`;
      }
    } else if (node.isNodeUniform === true) {
      const name = node.name;
      const type = node.type;
      if (type === "texture" || type === "cubeTexture" || type === "storageTexture" || type === "texture3D") {
        return name;
      } else if (type === "buffer" || type === "storageBuffer" || type === "indirectStorageBuffer") {
        if (this.isCustomStruct(node)) {
          return name;
        }
        return name + ".value";
      } else {
        return node.groupNode.name + "." + name;
      }
    }
    return super.getPropertyName(node);
  }
  /**
   * Returns the output struct name.
   *
   * @return {string} The name of the output struct.
   */
  getOutputStructName() {
    return "output";
  }
  /**
   * Returns the native shader operator name for a given generic name.
   *
   * @param {string} op - The operator name to resolve.
   * @return {?string} The resolved operator name.
   */
  getFunctionOperator(op) {
    const fnOp = wgslFnOpLib[op];
    if (fnOp !== void 0) {
      this._include(fnOp);
      return fnOp;
    }
    return null;
  }
  /**
   * Returns the node access for the given node and shader stage.
   *
   * @param {StorageTextureNode|StorageBufferNode} node - The storage node.
   * @param {string} shaderStage - The shader stage.
   * @return {string} The node access.
   */
  getNodeAccess(node, shaderStage) {
    if (shaderStage !== "compute") {
      if (node.isAtomic === true) {
        console.warn("WebGPURenderer: Atomic operations are only supported in compute shaders.");
        return NodeAccess.READ_WRITE;
      }
      return NodeAccess.READ_ONLY;
    }
    return node.access;
  }
  /**
   * Returns A WGSL snippet representing the storage access.
   *
   * @param {StorageTextureNode|StorageBufferNode} node - The storage node.
   * @param {string} shaderStage - The shader stage.
   * @return {string} The WGSL snippet representing the storage access.
   */
  getStorageAccess(node, shaderStage) {
    return accessNames[this.getNodeAccess(node, shaderStage)];
  }
  /**
   * This method is one of the more important ones since it's responsible
   * for generating a matching binding instance for the given uniform node.
   *
   * These bindings are later used in the renderer to create bind groups
   * and layouts.
   *
   * @param {UniformNode} node - The uniform node.
   * @param {string} type - The node data type.
   * @param {string} shaderStage - The shader stage.
   * @param {?string} [name=null] - An optional uniform name.
   * @return {NodeUniform} The node uniform object.
   */
  getUniformFromNode(node, type, shaderStage, name = null) {
    const uniformNode = super.getUniformFromNode(node, type, shaderStage, name);
    const nodeData = this.getDataFromNode(node, shaderStage, this.globalCache);
    if (nodeData.uniformGPU === void 0) {
      let uniformGPU;
      const group2 = node.groupNode;
      const groupName = group2.name;
      const bindings = this.getBindGroupArray(groupName, shaderStage);
      if (type === "texture" || type === "cubeTexture" || type === "storageTexture" || type === "texture3D") {
        let texture3 = null;
        const access = this.getNodeAccess(node, shaderStage);
        if (type === "texture" || type === "storageTexture") {
          if (node.value.is3DTexture === true) {
            texture3 = new NodeSampledTexture3D(uniformNode.name, uniformNode.node, group2, access);
          } else {
            texture3 = new NodeSampledTexture(uniformNode.name, uniformNode.node, group2, access);
          }
        } else if (type === "cubeTexture") {
          texture3 = new NodeSampledCubeTexture(uniformNode.name, uniformNode.node, group2, access);
        } else if (type === "texture3D") {
          texture3 = new NodeSampledTexture3D(uniformNode.name, uniformNode.node, group2, access);
        }
        texture3.store = node.isStorageTextureNode === true;
        texture3.setVisibility(gpuShaderStageLib[shaderStage]);
        if (this.isUnfilterable(node.value) === false && texture3.store === false) {
          const sampler3 = new NodeSampler(`${uniformNode.name}_sampler`, uniformNode.node, group2);
          sampler3.setVisibility(gpuShaderStageLib[shaderStage]);
          bindings.push(sampler3, texture3);
          uniformGPU = [sampler3, texture3];
        } else {
          bindings.push(texture3);
          uniformGPU = [texture3];
        }
      } else if (type === "buffer" || type === "storageBuffer" || type === "indirectStorageBuffer") {
        const bufferClass = type === "buffer" ? NodeUniformBuffer : NodeStorageBuffer;
        const buffer3 = new bufferClass(node, group2);
        buffer3.setVisibility(gpuShaderStageLib[shaderStage]);
        bindings.push(buffer3);
        uniformGPU = buffer3;
        uniformNode.name = name ? name : "NodeBuffer_" + uniformNode.id;
      } else {
        const uniformsStage = this.uniformGroups[shaderStage] || (this.uniformGroups[shaderStage] = {});
        let uniformsGroup = uniformsStage[groupName];
        if (uniformsGroup === void 0) {
          uniformsGroup = new NodeUniformsGroup(groupName, group2);
          uniformsGroup.setVisibility(gpuShaderStageLib[shaderStage]);
          uniformsStage[groupName] = uniformsGroup;
          bindings.push(uniformsGroup);
        }
        uniformGPU = this.getNodeUniform(uniformNode, type);
        uniformsGroup.addUniform(uniformGPU);
      }
      nodeData.uniformGPU = uniformGPU;
    }
    return uniformNode;
  }
  /**
   * This method should be used whenever builtins are required in nodes.
   * The internal builtins data structure will make sure builtins are
   * defined in the WGSL source.
   *
   * @param {string} name - The builtin name.
   * @param {string} property - The property name.
   * @param {string} type - The node data type.
   * @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.
   * @return {string} The property name.
   */
  getBuiltin(name, property3, type, shaderStage = this.shaderStage) {
    const map4 = this.builtins[shaderStage] || (this.builtins[shaderStage] = /* @__PURE__ */ new Map());
    if (map4.has(name) === false) {
      map4.set(name, {
        name,
        property: property3,
        type
      });
    }
    return property3;
  }
  /**
   * Returns `true` if the given builtin is defined in the given shader stage.
   *
   * @param {string} name - The builtin name.
   * @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.
   * @return {boolean} Whether the given builtin is defined in the given shader stage or not.
   */
  hasBuiltin(name, shaderStage = this.shaderStage) {
    return this.builtins[shaderStage] !== void 0 && this.builtins[shaderStage].has(name);
  }
  /**
   * Returns the vertex index builtin.
   *
   * @return {string} The vertex index.
   */
  getVertexIndex() {
    if (this.shaderStage === "vertex") {
      return this.getBuiltin("vertex_index", "vertexIndex", "u32", "attribute");
    }
    return "vertexIndex";
  }
  /**
   * Builds the given shader node.
   *
   * @param {ShaderNodeInternal} shaderNode - The shader node.
   * @return {string} The WGSL function code.
   */
  buildFunctionCode(shaderNode) {
    const layout = shaderNode.layout;
    const flowData = this.flowShaderNode(shaderNode);
    const parameters = [];
    for (const input of layout.inputs) {
      parameters.push(input.name + " : " + this.getType(input.type));
    }
    let code3 = `fn ${layout.name}( ${parameters.join(", ")} ) -> ${this.getType(layout.type)} {
${flowData.vars}
${flowData.code}
`;
    if (flowData.result) {
      code3 += `	return ${flowData.result};
`;
    }
    code3 += "\n}\n";
    return code3;
  }
  /**
   * Returns the instance index builtin.
   *
   * @return {string} The instance index.
   */
  getInstanceIndex() {
    if (this.shaderStage === "vertex") {
      return this.getBuiltin("instance_index", "instanceIndex", "u32", "attribute");
    }
    return "instanceIndex";
  }
  /**
   * Returns the invocation local index builtin.
   *
   * @return {string} The invocation local index.
   */
  getInvocationLocalIndex() {
    return this.getBuiltin("local_invocation_index", "invocationLocalIndex", "u32", "attribute");
  }
  /**
   * Returns the subgroup size builtin.
   *
   * @return {string} The subgroup size.
   */
  getSubgroupSize() {
    this.enableSubGroups();
    return this.getBuiltin("subgroup_size", "subgroupSize", "u32", "attribute");
  }
  /**
   * Returns the invocation subgroup index builtin.
   *
   * @return {string} The invocation subgroup index.
   */
  getInvocationSubgroupIndex() {
    this.enableSubGroups();
    return this.getBuiltin("subgroup_invocation_id", "invocationSubgroupIndex", "u32", "attribute");
  }
  /**
   * Returns the subgroup index builtin.
   *
   * @return {string} The subgroup index.
   */
  getSubgroupIndex() {
    this.enableSubGroups();
    return this.getBuiltin("subgroup_id", "subgroupIndex", "u32", "attribute");
  }
  /**
   * Overwritten as a NOP since this method is intended for the WebGL 2 backend.
   *
   * @return {null} Null.
   */
  getDrawIndex() {
    return null;
  }
  /**
   * Returns the front facing builtin.
   *
   * @return {string} The front facing builtin.
   */
  getFrontFacing() {
    return this.getBuiltin("front_facing", "isFront", "bool");
  }
  /**
   * Returns the frag coord builtin.
   *
   * @return {string} The frag coord builtin.
   */
  getFragCoord() {
    return this.getBuiltin("position", "fragCoord", "vec4<f32>") + ".xy";
  }
  /**
   * Returns the frag depth builtin.
   *
   * @return {string} The frag depth builtin.
   */
  getFragDepth() {
    return "output." + this.getBuiltin("frag_depth", "depth", "f32", "output");
  }
  /**
   * Returns the clip distances builtin.
   *
   * @return {string} The clip distances builtin.
   */
  getClipDistance() {
    return "varyings.hw_clip_distances";
  }
  /**
   * Whether to flip texture data along its vertical axis or not.
   *
   * @return {boolean} Returns always `false` in context of WGSL.
   */
  isFlipY() {
    return false;
  }
  /**
   * Enables the given directive for the given shader stage.
   *
   * @param {string} name - The directive name.
   * @param {string} [shaderStage=this.shaderStage] - The shader stage to enable the directive for.
   */
  enableDirective(name, shaderStage = this.shaderStage) {
    const stage = this.directives[shaderStage] || (this.directives[shaderStage] = /* @__PURE__ */ new Set());
    stage.add(name);
  }
  /**
   * Returns the directives of the given shader stage as a WGSL string.
   *
   * @param {string} shaderStage - The shader stage.
   * @return {string} A WGSL snippet that enables the directives of the given stage.
   */
  getDirectives(shaderStage) {
    const snippets = [];
    const directives = this.directives[shaderStage];
    if (directives !== void 0) {
      for (const directive of directives) {
        snippets.push(`enable ${directive};`);
      }
    }
    return snippets.join("\n");
  }
  /**
   * Enables the 'subgroups' directive.
   */
  enableSubGroups() {
    this.enableDirective("subgroups");
  }
  /**
   * Enables the 'subgroups-f16' directive.
   */
  enableSubgroupsF16() {
    this.enableDirective("subgroups-f16");
  }
  /**
   * Enables the 'clip_distances' directive.
   */
  enableClipDistances() {
    this.enableDirective("clip_distances");
  }
  /**
   * Enables the 'f16' directive.
   */
  enableShaderF16() {
    this.enableDirective("f16");
  }
  /**
   * Enables the 'dual_source_blending' directive.
   */
  enableDualSourceBlending() {
    this.enableDirective("dual_source_blending");
  }
  /**
   * Enables hardware clipping.
   *
   * @param {string} planeCount - The clipping plane count.
   */
  enableHardwareClipping(planeCount) {
    this.enableClipDistances();
    this.getBuiltin("clip_distances", "hw_clip_distances", `array<f32, ${planeCount} >`, "vertex");
  }
  /**
   * Returns the builtins of the given shader stage as a WGSL string.
   *
   * @param {string} shaderStage - The shader stage.
   * @return {string} A WGSL snippet that represents the builtins of the given stage.
   */
  getBuiltins(shaderStage) {
    const snippets = [];
    const builtins = this.builtins[shaderStage];
    if (builtins !== void 0) {
      for (const { name, property: property3, type } of builtins.values()) {
        snippets.push(`@builtin( ${name} ) ${property3} : ${type}`);
      }
    }
    return snippets.join(",\n	");
  }
  /**
   * This method should be used when a new scoped buffer is used in context of
   * compute shaders. It adds the array to the internal data structure which is
   * later used to generate the respective WGSL.
   *
   * @param {string} name - The array name.
   * @param {string} scope - The scope.
   * @param {string} bufferType - The buffer type.
   * @param {string} bufferCount - The buffer count.
   * @return {string} The array name.
   */
  getScopedArray(name, scope, bufferType, bufferCount) {
    if (this.scopedArrays.has(name) === false) {
      this.scopedArrays.set(name, {
        name,
        scope,
        bufferType,
        bufferCount
      });
    }
    return name;
  }
  /**
   * Returns the scoped arrays of the given shader stage as a WGSL string.
   *
   * @param {string} shaderStage - The shader stage.
   * @return {string|undefined} The WGSL snippet that defines the scoped arrays.
   * Returns `undefined` when used in the vertex or fragment stage.
   */
  getScopedArrays(shaderStage) {
    if (shaderStage !== "compute") {
      return;
    }
    const snippets = [];
    for (const { name, scope, bufferType, bufferCount } of this.scopedArrays.values()) {
      const type = this.getType(bufferType);
      snippets.push(`var<${scope}> ${name}: array< ${type}, ${bufferCount} >;`);
    }
    return snippets.join("\n");
  }
  /**
   * Returns the shader attributes of the given shader stage as a WGSL string.
   *
   * @param {string} shaderStage - The shader stage.
   * @return {string} The WGSL snippet that defines the shader attributes.
   */
  getAttributes(shaderStage) {
    const snippets = [];
    if (shaderStage === "compute") {
      this.getBuiltin("global_invocation_id", "globalId", "vec3<u32>", "attribute");
      this.getBuiltin("workgroup_id", "workgroupId", "vec3<u32>", "attribute");
      this.getBuiltin("local_invocation_id", "localId", "vec3<u32>", "attribute");
      this.getBuiltin("num_workgroups", "numWorkgroups", "vec3<u32>", "attribute");
      if (this.renderer.hasFeature("subgroups")) {
        this.enableDirective("subgroups", shaderStage);
        this.getBuiltin("subgroup_size", "subgroupSize", "u32", "attribute");
      }
    }
    if (shaderStage === "vertex" || shaderStage === "compute") {
      const builtins = this.getBuiltins("attribute");
      if (builtins) snippets.push(builtins);
      const attributes = this.getAttributesArray();
      for (let index5 = 0, length3 = attributes.length; index5 < length3; index5++) {
        const attribute3 = attributes[index5];
        const name = attribute3.name;
        const type = this.getType(attribute3.type);
        snippets.push(`@location( ${index5} ) ${name} : ${type}`);
      }
    }
    return snippets.join(",\n	");
  }
  /**
   * Returns the members of the given struct type node as a WGSL string.
   *
   * @param {StructTypeNode} struct - The struct type node.
   * @return {string} The WGSL snippet that defines the struct members.
   */
  getStructMembers(struct3) {
    const snippets = [];
    for (const member of struct3.members) {
      const prefix = struct3.output ? "@location( " + member.index + " ) " : "";
      let type = this.getType(member.type);
      if (member.atomic) {
        type = "atomic< " + type + " >";
      }
      snippets.push(`	${prefix + member.name} : ${type}`);
    }
    if (struct3.output) {
      snippets.push(`	${this.getBuiltins("output")}`);
    }
    return snippets.join(",\n");
  }
  /**
   * Returns the structs of the given shader stage as a WGSL string.
   *
   * @param {string} shaderStage - The shader stage.
   * @return {string} The WGSL snippet that defines the structs.
   */
  getStructs(shaderStage) {
    let result = "";
    const structs = this.structs[shaderStage];
    if (structs.length > 0) {
      const snippets = [];
      for (const struct3 of structs) {
        let snippet = `struct ${struct3.name} {
`;
        snippet += this.getStructMembers(struct3);
        snippet += "\n};";
        snippets.push(snippet);
      }
      result = "\n" + snippets.join("\n\n") + "\n";
    }
    return result;
  }
  /**
   * Returns a WGSL string representing a variable.
   *
   * @param {string} type - The variable's type.
   * @param {string} name - The variable's name.
   * @param {?number} [count=null] - The array length.
   * @return {string} The WGSL snippet that defines a variable.
   */
  getVar(type, name, count2 = null) {
    let snippet = `var ${name} : `;
    if (count2 !== null) {
      snippet += this.generateArrayDeclaration(type, count2);
    } else {
      snippet += this.getType(type);
    }
    return snippet;
  }
  /**
   * Returns the variables of the given shader stage as a WGSL string.
   *
   * @param {string} shaderStage - The shader stage.
   * @return {string} The WGSL snippet that defines the variables.
   */
  getVars(shaderStage) {
    const snippets = [];
    const vars = this.vars[shaderStage];
    if (vars !== void 0) {
      for (const variable of vars) {
        snippets.push(`	${this.getVar(variable.type, variable.name, variable.count)};`);
      }
    }
    return `
${snippets.join("\n")}
`;
  }
  /**
   * Returns the varyings of the given shader stage as a WGSL string.
   *
   * @param {string} shaderStage - The shader stage.
   * @return {string} The WGSL snippet that defines the varyings.
   */
  getVaryings(shaderStage) {
    const snippets = [];
    if (shaderStage === "vertex") {
      this.getBuiltin("position", "Vertex", "vec4<f32>", "vertex");
    }
    if (shaderStage === "vertex" || shaderStage === "fragment") {
      const varyings = this.varyings;
      const vars = this.vars[shaderStage];
      for (let index5 = 0; index5 < varyings.length; index5++) {
        const varying3 = varyings[index5];
        if (varying3.needsInterpolation) {
          let attributesSnippet = `@location( ${index5} )`;
          if (varying3.interpolationType) {
            const samplingSnippet = varying3.interpolationSampling !== null ? `, ${varying3.interpolationSampling} )` : " )";
            attributesSnippet += ` @interpolate( ${varying3.interpolationType}${samplingSnippet}`;
          } else if (/^(int|uint|ivec|uvec)/.test(varying3.type)) {
            attributesSnippet += ` @interpolate( ${this.renderer.backend.compatibilityMode ? "flat, either" : "flat"} )`;
          }
          snippets.push(`${attributesSnippet} ${varying3.name} : ${this.getType(varying3.type)}`);
        } else if (shaderStage === "vertex" && vars.includes(varying3) === false) {
          vars.push(varying3);
        }
      }
    }
    const builtins = this.getBuiltins(shaderStage);
    if (builtins) snippets.push(builtins);
    const code3 = snippets.join(",\n	");
    return shaderStage === "vertex" ? this._getWGSLStruct("VaryingsStruct", "	" + code3) : code3;
  }
  isCustomStruct(nodeUniform) {
    const attribute3 = nodeUniform.value;
    const bufferNode = nodeUniform.node;
    const isAttributeStructType = (attribute3.isBufferAttribute || attribute3.isInstancedBufferAttribute) && bufferNode.structTypeNode !== null;
    const isStructArray = bufferNode.value && bufferNode.value.array && (typeof bufferNode.value.itemSize === "number" && bufferNode.value.array.length > bufferNode.value.itemSize);
    return isAttributeStructType && !isStructArray;
  }
  /**
   * Returns the uniforms of the given shader stage as a WGSL string.
   *
   * @param {string} shaderStage - The shader stage.
   * @return {string} The WGSL snippet that defines the uniforms.
   */
  getUniforms(shaderStage) {
    const uniforms = this.uniforms[shaderStage];
    const bindingSnippets = [];
    const bufferSnippets = [];
    const structSnippets = [];
    const uniformGroups = {};
    for (const uniform3 of uniforms) {
      const groupName = uniform3.groupNode.name;
      const uniformIndexes = this.bindingsIndexes[groupName];
      if (uniform3.type === "texture" || uniform3.type === "cubeTexture" || uniform3.type === "storageTexture" || uniform3.type === "texture3D") {
        const texture3 = uniform3.node.value;
        if (this.isUnfilterable(texture3) === false && uniform3.node.isStorageTextureNode !== true) {
          if (this.isSampleCompare(texture3)) {
            bindingSnippets.push(`@binding( ${uniformIndexes.binding++} ) @group( ${uniformIndexes.group} ) var ${uniform3.name}_sampler : sampler_comparison;`);
          } else {
            bindingSnippets.push(`@binding( ${uniformIndexes.binding++} ) @group( ${uniformIndexes.group} ) var ${uniform3.name}_sampler : sampler;`);
          }
        }
        let textureType;
        let multisampled = "";
        const { primarySamples } = this.renderer.backend.utils.getTextureSampleData(texture3);
        if (primarySamples > 1) {
          multisampled = "_multisampled";
        }
        if (texture3.isCubeTexture === true) {
          textureType = "texture_cube<f32>";
        } else if (texture3.isDepthTexture === true) {
          if (this.renderer.backend.compatibilityMode && texture3.compareFunction === null) {
            textureType = `texture${multisampled}_2d<f32>`;
          } else {
            textureType = `texture_depth${multisampled}_2d${texture3.isArrayTexture === true ? "_array" : ""}`;
          }
        } else if (uniform3.node.isStorageTextureNode === true) {
          const format2 = getFormat2(texture3);
          const access = this.getStorageAccess(uniform3.node, shaderStage);
          const is3D = uniform3.node.value.is3DTexture;
          const isArrayTexture = uniform3.node.value.isArrayTexture;
          const dimension = is3D ? "3d" : `2d${isArrayTexture ? "_array" : ""}`;
          textureType = `texture_storage_${dimension}<${format2}, ${access}>`;
        } else if (texture3.isArrayTexture === true || texture3.isDataArrayTexture === true || texture3.isCompressedArrayTexture === true) {
          textureType = "texture_2d_array<f32>";
        } else if (texture3.is3DTexture === true || texture3.isData3DTexture === true) {
          textureType = "texture_3d<f32>";
        } else {
          const componentPrefix = this.getComponentTypeFromTexture(texture3).charAt(0);
          textureType = `texture${multisampled}_2d<${componentPrefix}32>`;
        }
        bindingSnippets.push(`@binding( ${uniformIndexes.binding++} ) @group( ${uniformIndexes.group} ) var ${uniform3.name} : ${textureType};`);
      } else if (uniform3.type === "buffer" || uniform3.type === "storageBuffer" || uniform3.type === "indirectStorageBuffer") {
        const bufferNode = uniform3.node;
        const bufferType = this.getType(bufferNode.getNodeType(this));
        const bufferCount = bufferNode.bufferCount;
        const bufferCountSnippet = bufferCount > 0 && uniform3.type === "buffer" ? ", " + bufferCount : "";
        const bufferAccessMode = bufferNode.isStorageBufferNode ? `storage, ${this.getStorageAccess(bufferNode, shaderStage)}` : "uniform";
        if (this.isCustomStruct(uniform3)) {
          bufferSnippets.push(`@binding( ${uniformIndexes.binding++} ) @group( ${uniformIndexes.group} ) var<${bufferAccessMode}> ${uniform3.name} : ${bufferType};`);
        } else {
          const bufferTypeSnippet = bufferNode.isAtomic ? `atomic<${bufferType}>` : `${bufferType}`;
          const bufferSnippet = `	value : array< ${bufferTypeSnippet}${bufferCountSnippet} >`;
          bufferSnippets.push(this._getWGSLStructBinding(uniform3.name, bufferSnippet, bufferAccessMode, uniformIndexes.binding++, uniformIndexes.group));
        }
      } else {
        const vectorType = this.getType(this.getVectorType(uniform3.type));
        const groupName2 = uniform3.groupNode.name;
        const group2 = uniformGroups[groupName2] || (uniformGroups[groupName2] = {
          index: uniformIndexes.binding++,
          id: uniformIndexes.group,
          snippets: []
        });
        group2.snippets.push(`	${uniform3.name} : ${vectorType}`);
      }
    }
    for (const name in uniformGroups) {
      const group2 = uniformGroups[name];
      structSnippets.push(this._getWGSLStructBinding(name, group2.snippets.join(",\n"), "uniform", group2.index, group2.id));
    }
    let code3 = bindingSnippets.join("\n");
    code3 += bufferSnippets.join("\n");
    code3 += structSnippets.join("\n");
    return code3;
  }
  /**
   * Controls the code build of the shader stages.
   */
  buildCode() {
    const shadersData = this.material !== null ? { fragment: {}, vertex: {} } : { compute: {} };
    this.sortBindingGroups();
    for (const shaderStage in shadersData) {
      this.shaderStage = shaderStage;
      const stageData = shadersData[shaderStage];
      stageData.uniforms = this.getUniforms(shaderStage);
      stageData.attributes = this.getAttributes(shaderStage);
      stageData.varyings = this.getVaryings(shaderStage);
      stageData.structs = this.getStructs(shaderStage);
      stageData.vars = this.getVars(shaderStage);
      stageData.codes = this.getCodes(shaderStage);
      stageData.directives = this.getDirectives(shaderStage);
      stageData.scopedArrays = this.getScopedArrays(shaderStage);
      let flow = "// code\n\n";
      flow += this.flowCode[shaderStage];
      const flowNodes = this.flowNodes[shaderStage];
      const mainNode = flowNodes[flowNodes.length - 1];
      const outputNode = mainNode.outputNode;
      const isOutputStruct = outputNode !== void 0 && outputNode.isOutputStructNode === true;
      for (const node of flowNodes) {
        const flowSlotData = this.getFlowData(
          node
          /*, shaderStage*/
        );
        const slotName = node.name;
        if (slotName) {
          if (flow.length > 0) flow += "\n";
          flow += `	// flow -> ${slotName}
`;
        }
        flow += `${flowSlotData.code}
	`;
        if (node === mainNode && shaderStage !== "compute") {
          flow += "// result\n\n	";
          if (shaderStage === "vertex") {
            flow += `varyings.Vertex = ${flowSlotData.result};`;
          } else if (shaderStage === "fragment") {
            if (isOutputStruct) {
              stageData.returnType = outputNode.getNodeType(this);
              stageData.structs += "var<private> output : " + stageData.returnType + ";";
              flow += `return ${flowSlotData.result};`;
            } else {
              let structSnippet = "	@location(0) color: vec4<f32>";
              const builtins = this.getBuiltins("output");
              if (builtins) structSnippet += ",\n	" + builtins;
              stageData.returnType = "OutputStruct";
              stageData.structs += this._getWGSLStruct("OutputStruct", structSnippet);
              stageData.structs += "\nvar<private> output : OutputStruct;";
              flow += `output.color = ${flowSlotData.result};

	return output;`;
            }
          }
        }
      }
      stageData.flow = flow;
    }
    this.shaderStage = null;
    if (this.material !== null) {
      this.vertexShader = this._getWGSLVertexCode(shadersData.vertex);
      this.fragmentShader = this._getWGSLFragmentCode(shadersData.fragment);
    } else {
      const workgroupSize = this.object.workgroupSize;
      this.computeShader = this._getWGSLComputeCode(shadersData.compute, workgroupSize);
    }
  }
  /**
   * Returns the native shader method name for a given generic name.
   *
   * @param {string} method - The method name to resolve.
   * @param {?string} [output=null] - An optional output.
   * @return {string} The resolved WGSL method name.
   */
  getMethod(method, output3 = null) {
    let wgslMethod;
    if (output3 !== null) {
      wgslMethod = this._getWGSLMethod(method + "_" + output3);
    }
    if (wgslMethod === void 0) {
      wgslMethod = this._getWGSLMethod(method);
    }
    return wgslMethod || method;
  }
  /**
   * Returns the bitcast method name for a given input and outputType.
   *
   * @param {string} type - The output type to bitcast to.
   * @return {string} The resolved WGSL bitcast invocation.
   */
  getBitcastMethod(type) {
    const dataType = this.getType(type);
    return `bitcast<${dataType}>`;
  }
  /**
   * Returns the native snippet for a ternary operation.
   *
   * @param {string} condSnippet - The condition determining which expression gets resolved.
   * @param {string} ifSnippet - The expression to resolve to if the condition is true.
   * @param {string} elseSnippet - The expression to resolve to if the condition is false.
   * @return {string} The resolved method name.
   */
  getTernary(condSnippet, ifSnippet, elseSnippet) {
    return `select( ${elseSnippet}, ${ifSnippet}, ${condSnippet} )`;
  }
  /**
   * Returns the WGSL type of the given node data type.
   *
   * @param {string} type - The node data type.
   * @return {string} The WGSL type.
   */
  getType(type) {
    return wgslTypeLib[type] || type;
  }
  /**
   * Whether the requested feature is available or not.
   *
   * @param {string} name - The requested feature.
   * @return {boolean} Whether the requested feature is supported or not.
   */
  isAvailable(name) {
    let result = supports[name];
    if (result === void 0) {
      if (name === "float32Filterable") {
        result = this.renderer.hasFeature("float32-filterable");
      } else if (name === "clipDistance") {
        result = this.renderer.hasFeature("clip-distances");
      }
      supports[name] = result;
    }
    return result;
  }
  /**
   * Returns the native shader method name for a given generic name.
   *
   * @private
   * @param {string} method - The method name to resolve.
   * @return {string} The resolved WGSL method name.
   */
  _getWGSLMethod(method) {
    if (wgslPolyfill[method] !== void 0) {
      this._include(method);
    }
    return wgslMethods[method];
  }
  /**
   * Includes the given method name into the current
   * function node.
   *
   * @private
   * @param {string} name - The method name to include.
   * @return {CodeNode} The respective code node.
   */
  _include(name) {
    const codeNode = wgslPolyfill[name];
    codeNode.build(this);
    if (this.currentFunctionNode !== null) {
      this.currentFunctionNode.includes.push(codeNode);
    }
    return codeNode;
  }
  /**
   * Returns a WGSL vertex shader based on the given shader data.
   *
   * @private
   * @param {Object} shaderData - The shader data.
   * @return {string} The vertex shader.
   */
  _getWGSLVertexCode(shaderData) {
    return `${this.getSignature()}
// directives
${shaderData.directives}

// structs
${shaderData.structs}

// uniforms
${shaderData.uniforms}

// varyings
${shaderData.varyings}
var<private> varyings : VaryingsStruct;

// codes
${shaderData.codes}

@vertex
fn main( ${shaderData.attributes} ) -> VaryingsStruct {

	// vars
	${shaderData.vars}

	// flow
	${shaderData.flow}

	return varyings;

}
`;
  }
  /**
   * Returns a WGSL fragment shader based on the given shader data.
   *
   * @private
   * @param {Object} shaderData - The shader data.
   * @return {string} The vertex shader.
   */
  _getWGSLFragmentCode(shaderData) {
    return `${this.getSignature()}
// global
${diagnostics}

// structs
${shaderData.structs}

// uniforms
${shaderData.uniforms}

// codes
${shaderData.codes}

@fragment
fn main( ${shaderData.varyings} ) -> ${shaderData.returnType} {

	// vars
	${shaderData.vars}

	// flow
	${shaderData.flow}

}
`;
  }
  /**
   * Returns a WGSL compute shader based on the given shader data.
   *
   * @private
   * @param {Object} shaderData - The shader data.
   * @param {string} workgroupSize - The workgroup size.
   * @return {string} The vertex shader.
   */
  _getWGSLComputeCode(shaderData, workgroupSize) {
    const [workgroupSizeX, workgroupSizeY, workgroupSizeZ] = workgroupSize;
    return `${this.getSignature()}
// directives
${shaderData.directives}

// system
var<private> instanceIndex : u32;

// locals
${shaderData.scopedArrays}

// structs
${shaderData.structs}

// uniforms
${shaderData.uniforms}

// codes
${shaderData.codes}

@compute @workgroup_size( ${workgroupSizeX}, ${workgroupSizeY}, ${workgroupSizeZ} )
fn main( ${shaderData.attributes} ) {

	// system
	instanceIndex = globalId.x
		+ globalId.y * ( ${workgroupSizeX} * numWorkgroups.x )
		+ globalId.z * ( ${workgroupSizeX} * numWorkgroups.x ) * ( ${workgroupSizeY} * numWorkgroups.y );

	// vars
	${shaderData.vars}

	// flow
	${shaderData.flow}

}
`;
  }
  /**
   * Returns a WGSL struct based on the given name and variables.
   *
   * @private
   * @param {string} name - The struct name.
   * @param {string} vars - The struct variables.
   * @return {string} The WGSL snippet representing a struct.
   */
  _getWGSLStruct(name, vars) {
    return `
struct ${name} {
${vars}
};`;
  }
  /**
   * Returns a WGSL struct binding.
   *
   * @private
   * @param {string} name - The struct name.
   * @param {string} vars - The struct variables.
   * @param {string} access - The access.
   * @param {number} [binding=0] - The binding index.
   * @param {number} [group=0] - The group index.
   * @return {string} The WGSL snippet representing a struct binding.
   */
  _getWGSLStructBinding(name, vars, access, binding = 0, group2 = 0) {
    const structName = name + "Struct";
    const structSnippet = this._getWGSLStruct(structName, vars);
    return `${structSnippet}
@binding( ${binding} ) @group( ${group2} )
var<${access}> ${name} : ${structName};`;
  }
};
var WebGPUUtils = class {
  /**
   * Constructs a new utility object.
   *
   * @param {WebGPUBackend} backend - The WebGPU backend.
   */
  constructor(backend) {
    this.backend = backend;
  }
  /**
   * Returns the depth/stencil GPU format for the given render context.
   *
   * @param {RenderContext} renderContext - The render context.
   * @return {string} The depth/stencil GPU texture format.
   */
  getCurrentDepthStencilFormat(renderContext) {
    let format2;
    if (renderContext.depthTexture !== null) {
      format2 = this.getTextureFormatGPU(renderContext.depthTexture);
    } else if (renderContext.depth && renderContext.stencil) {
      format2 = GPUTextureFormat.Depth24PlusStencil8;
    } else if (renderContext.depth) {
      format2 = GPUTextureFormat.Depth24Plus;
    }
    return format2;
  }
  /**
   * Returns the GPU format for the given texture.
   *
   * @param {Texture} texture - The texture.
   * @return {string} The GPU texture format.
   */
  getTextureFormatGPU(texture3) {
    return this.backend.get(texture3).format;
  }
  /**
   * Returns an object that defines the multi-sampling state of the given texture.
   *
   * @param {Texture} texture - The texture.
   * @return {Object} The multi-sampling state.
   */
  getTextureSampleData(texture3) {
    let samples;
    if (texture3.isFramebufferTexture) {
      samples = 1;
    } else if (texture3.isDepthTexture && !texture3.renderTarget) {
      const renderer = this.backend.renderer;
      const renderTarget = renderer.getRenderTarget();
      samples = renderTarget ? renderTarget.samples : renderer.samples;
    } else if (texture3.renderTarget) {
      samples = texture3.renderTarget.samples;
    }
    samples = samples || 1;
    const isMSAA = samples > 1 && texture3.renderTarget !== null && (texture3.isDepthTexture !== true && texture3.isFramebufferTexture !== true);
    const primarySamples = isMSAA ? 1 : samples;
    return { samples, primarySamples, isMSAA };
  }
  /**
   * Returns the default color attachment's GPU format of the current render context.
   *
   * @param {RenderContext} renderContext - The render context.
   * @return {string} The GPU texture format of the default color attachment.
   */
  getCurrentColorFormat(renderContext) {
    let format2;
    if (renderContext.textures !== null) {
      format2 = this.getTextureFormatGPU(renderContext.textures[0]);
    } else {
      format2 = this.getPreferredCanvasFormat();
    }
    return format2;
  }
  /**
   * Returns the output color space of the current render context.
   *
   * @param {RenderContext} renderContext - The render context.
   * @return {string} The output color space.
   */
  getCurrentColorSpace(renderContext) {
    if (renderContext.textures !== null) {
      return renderContext.textures[0].colorSpace;
    }
    return this.backend.renderer.outputColorSpace;
  }
  /**
   * Returns GPU primitive topology for the given object and material.
   *
   * @param {Object3D} object - The 3D object.
   * @param {Material} material - The material.
   * @return {string} The GPU primitive topology.
   */
  getPrimitiveTopology(object2, material) {
    if (object2.isPoints) return GPUPrimitiveTopology.PointList;
    else if (object2.isLineSegments || object2.isMesh && material.wireframe === true) return GPUPrimitiveTopology.LineList;
    else if (object2.isLine) return GPUPrimitiveTopology.LineStrip;
    else if (object2.isMesh) return GPUPrimitiveTopology.TriangleList;
  }
  /**
   * Returns a modified sample count from the given sample count value.
   *
   * That is required since WebGPU only supports either 1 or 4.
   *
   * @param {number} sampleCount - The input sample count.
   * @return {number} The (potentially updated) output sample count.
   */
  getSampleCount(sampleCount) {
    return sampleCount >= 4 ? 4 : 1;
  }
  /**
   * Returns the sample count of the given render context.
   *
   * @param {RenderContext} renderContext - The render context.
   * @return {number} The sample count.
   */
  getSampleCountRenderContext(renderContext) {
    if (renderContext.textures !== null) {
      return this.getSampleCount(renderContext.sampleCount);
    }
    return this.getSampleCount(this.backend.renderer.samples);
  }
  /**
   * Returns the preferred canvas format.
   *
   * There is a separate method for this so it's possible to
   * honor edge cases for specific devices.
   *
   * @return {string} The GPU texture format of the canvas.
   */
  getPreferredCanvasFormat() {
    const outputType = this.backend.parameters.outputType;
    if (outputType === void 0) {
      return navigator.gpu.getPreferredCanvasFormat();
    } else if (outputType === UnsignedByteType) {
      return GPUTextureFormat.BGRA8Unorm;
    } else if (outputType === HalfFloatType) {
      return GPUTextureFormat.RGBA16Float;
    } else {
      throw new Error("Unsupported outputType");
    }
  }
};
var typedArraysToVertexFormatPrefix = /* @__PURE__ */ new Map([
  [Int8Array, ["sint8", "snorm8"]],
  [Uint8Array, ["uint8", "unorm8"]],
  [Int16Array, ["sint16", "snorm16"]],
  [Uint16Array, ["uint16", "unorm16"]],
  [Int32Array, ["sint32", "snorm32"]],
  [Uint32Array, ["uint32", "unorm32"]],
  [Float32Array, ["float32"]]
]);
if (typeof Float16Array !== "undefined") {
  typedArraysToVertexFormatPrefix.set(Float16Array, ["float16"]);
}
var typedAttributeToVertexFormatPrefix = /* @__PURE__ */ new Map([
  [Float16BufferAttribute, ["float16"]]
]);
var typeArraysToVertexFormatPrefixForItemSize1 = /* @__PURE__ */ new Map([
  [Int32Array, "sint32"],
  [Int16Array, "sint32"],
  // patch for INT16
  [Uint32Array, "uint32"],
  [Uint16Array, "uint32"],
  // patch for UINT16
  [Float32Array, "float32"]
]);
var WebGPUAttributeUtils = class {
  /**
   * Constructs a new utility object.
   *
   * @param {WebGPUBackend} backend - The WebGPU backend.
   */
  constructor(backend) {
    this.backend = backend;
  }
  /**
   * Creates the GPU buffer for the given buffer attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute.
   * @param {GPUBufferUsage} usage - A flag that indicates how the buffer may be used after its creation.
   */
  createAttribute(attribute3, usage) {
    const bufferAttribute3 = this._getBufferAttribute(attribute3);
    const backend = this.backend;
    const bufferData = backend.get(bufferAttribute3);
    let buffer3 = bufferData.buffer;
    if (buffer3 === void 0) {
      const device = backend.device;
      let array4 = bufferAttribute3.array;
      if (attribute3.normalized === false) {
        if (array4.constructor === Int16Array || array4.constructor === Int8Array) {
          array4 = new Int32Array(array4);
        } else if (array4.constructor === Uint16Array || array4.constructor === Uint8Array) {
          array4 = new Uint32Array(array4);
          if (usage & GPUBufferUsage.INDEX) {
            for (let i = 0; i < array4.length; i++) {
              if (array4[i] === 65535) array4[i] = 4294967295;
            }
          }
        }
      }
      bufferAttribute3.array = array4;
      if ((bufferAttribute3.isStorageBufferAttribute || bufferAttribute3.isStorageInstancedBufferAttribute) && bufferAttribute3.itemSize === 3) {
        array4 = new array4.constructor(bufferAttribute3.count * 4);
        for (let i = 0; i < bufferAttribute3.count; i++) {
          array4.set(bufferAttribute3.array.subarray(i * 3, i * 3 + 3), i * 4);
        }
        bufferAttribute3.itemSize = 4;
        bufferAttribute3.array = array4;
        bufferData._force3to4BytesAlignment = true;
      }
      const byteLength = array4.byteLength;
      const size = byteLength + (4 - byteLength % 4) % 4;
      buffer3 = device.createBuffer({
        label: bufferAttribute3.name,
        size,
        usage,
        mappedAtCreation: true
      });
      new array4.constructor(buffer3.getMappedRange()).set(array4);
      buffer3.unmap();
      bufferData.buffer = buffer3;
    }
  }
  /**
   * Updates the GPU buffer of the given buffer attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute.
   */
  updateAttribute(attribute3) {
    const bufferAttribute3 = this._getBufferAttribute(attribute3);
    const backend = this.backend;
    const device = backend.device;
    const bufferData = backend.get(bufferAttribute3);
    const buffer3 = backend.get(bufferAttribute3).buffer;
    let array4 = bufferAttribute3.array;
    if (bufferData._force3to4BytesAlignment === true) {
      array4 = new array4.constructor(bufferAttribute3.count * 4);
      for (let i = 0; i < bufferAttribute3.count; i++) {
        array4.set(bufferAttribute3.array.subarray(i * 3, i * 3 + 3), i * 4);
      }
      bufferAttribute3.array = array4;
    }
    const isTypedArray = this._isTypedArray(array4);
    const updateRanges = bufferAttribute3.updateRanges;
    if (updateRanges.length === 0) {
      device.queue.writeBuffer(
        buffer3,
        0,
        array4,
        0
      );
    } else {
      const byteOffsetFactor = isTypedArray ? 1 : array4.BYTES_PER_ELEMENT;
      for (let i = 0, l = updateRanges.length; i < l; i++) {
        const range5 = updateRanges[i];
        let dataOffset, size;
        if (bufferData._force3to4BytesAlignment === true) {
          const vertexStart = Math.floor(range5.start / 3);
          const vertexCount = Math.ceil(range5.count / 3);
          dataOffset = vertexStart * 4 * byteOffsetFactor;
          size = vertexCount * 4 * byteOffsetFactor;
        } else {
          dataOffset = range5.start * byteOffsetFactor;
          size = range5.count * byteOffsetFactor;
        }
        const bufferOffset = dataOffset * (isTypedArray ? array4.BYTES_PER_ELEMENT : 1);
        device.queue.writeBuffer(
          buffer3,
          bufferOffset,
          array4,
          dataOffset,
          size
        );
      }
      bufferAttribute3.clearUpdateRanges();
    }
  }
  /**
   * This method creates the vertex buffer layout data which are
   * require when creating a render pipeline for the given render object.
   *
   * @param {RenderObject} renderObject - The render object.
   * @return {Array<Object>} An array holding objects which describe the vertex buffer layout.
   */
  createShaderVertexBuffers(renderObject) {
    const attributes = renderObject.getAttributes();
    const vertexBuffers = /* @__PURE__ */ new Map();
    for (let slot = 0; slot < attributes.length; slot++) {
      const geometryAttribute = attributes[slot];
      const bytesPerElement = geometryAttribute.array.BYTES_PER_ELEMENT;
      const bufferAttribute3 = this._getBufferAttribute(geometryAttribute);
      let vertexBufferLayout = vertexBuffers.get(bufferAttribute3);
      if (vertexBufferLayout === void 0) {
        let arrayStride, stepMode;
        if (geometryAttribute.isInterleavedBufferAttribute === true) {
          arrayStride = geometryAttribute.data.stride * bytesPerElement;
          stepMode = geometryAttribute.data.isInstancedInterleavedBuffer ? GPUInputStepMode.Instance : GPUInputStepMode.Vertex;
        } else {
          arrayStride = geometryAttribute.itemSize * bytesPerElement;
          stepMode = geometryAttribute.isInstancedBufferAttribute ? GPUInputStepMode.Instance : GPUInputStepMode.Vertex;
        }
        if (geometryAttribute.normalized === false && (geometryAttribute.array.constructor === Int16Array || geometryAttribute.array.constructor === Uint16Array)) {
          arrayStride = 4;
        }
        vertexBufferLayout = {
          arrayStride,
          attributes: [],
          stepMode
        };
        vertexBuffers.set(bufferAttribute3, vertexBufferLayout);
      }
      const format2 = this._getVertexFormat(geometryAttribute);
      const offset = geometryAttribute.isInterleavedBufferAttribute === true ? geometryAttribute.offset * bytesPerElement : 0;
      vertexBufferLayout.attributes.push({
        shaderLocation: slot,
        offset,
        format: format2
      });
    }
    return Array.from(vertexBuffers.values());
  }
  /**
   * Destroys the GPU buffer of the given buffer attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute.
   */
  destroyAttribute(attribute3) {
    const backend = this.backend;
    const data = backend.get(this._getBufferAttribute(attribute3));
    data.buffer.destroy();
    backend.delete(attribute3);
  }
  /**
   * This method performs a readback operation by moving buffer data from
   * a storage buffer attribute from the GPU to the CPU.
   *
   * @async
   * @param {StorageBufferAttribute} attribute - The storage buffer attribute.
   * @return {Promise<ArrayBuffer>} A promise that resolves with the buffer data when the data are ready.
   */
  async getArrayBufferAsync(attribute3) {
    const backend = this.backend;
    const device = backend.device;
    const data = backend.get(this._getBufferAttribute(attribute3));
    const bufferGPU = data.buffer;
    const size = bufferGPU.size;
    const readBufferGPU = device.createBuffer({
      label: `${attribute3.name}_readback`,
      size,
      usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
    });
    const cmdEncoder = device.createCommandEncoder({
      label: `readback_encoder_${attribute3.name}`
    });
    cmdEncoder.copyBufferToBuffer(
      bufferGPU,
      0,
      readBufferGPU,
      0,
      size
    );
    const gpuCommands = cmdEncoder.finish();
    device.queue.submit([gpuCommands]);
    await readBufferGPU.mapAsync(GPUMapMode.READ);
    const arrayBuffer3 = readBufferGPU.getMappedRange();
    const dstBuffer = new attribute3.array.constructor(arrayBuffer3.slice(0));
    readBufferGPU.unmap();
    return dstBuffer.buffer;
  }
  /**
   * Returns the vertex format of the given buffer attribute.
   *
   * @private
   * @param {BufferAttribute} geometryAttribute - The buffer attribute.
   * @return {string|undefined} The vertex format (e.g. 'float32x3').
   */
  _getVertexFormat(geometryAttribute) {
    const { itemSize, normalized } = geometryAttribute;
    const ArrayType = geometryAttribute.array.constructor;
    const AttributeType2 = geometryAttribute.constructor;
    let format2;
    if (itemSize === 1) {
      format2 = typeArraysToVertexFormatPrefixForItemSize1.get(ArrayType);
    } else {
      const prefixOptions = typedAttributeToVertexFormatPrefix.get(AttributeType2) || typedArraysToVertexFormatPrefix.get(ArrayType);
      const prefix = prefixOptions[normalized ? 1 : 0];
      if (prefix) {
        const bytesPerUnit = ArrayType.BYTES_PER_ELEMENT * itemSize;
        const paddedBytesPerUnit = Math.floor((bytesPerUnit + 3) / 4) * 4;
        const paddedItemSize = paddedBytesPerUnit / ArrayType.BYTES_PER_ELEMENT;
        if (paddedItemSize % 1) {
          throw new Error("THREE.WebGPUAttributeUtils: Bad vertex format item size.");
        }
        format2 = `${prefix}x${paddedItemSize}`;
      }
    }
    if (!format2) {
      console.error("THREE.WebGPUAttributeUtils: Vertex format not supported yet.");
    }
    return format2;
  }
  /**
   * Returns `true` if the given array is a typed array.
   *
   * @private
   * @param {any} array - The array.
   * @return {boolean} Whether the given array is a typed array or not.
   */
  _isTypedArray(array4) {
    return ArrayBuffer.isView(array4) && !(array4 instanceof DataView);
  }
  /**
   * Utility method for handling interleaved buffer attributes correctly.
   * To process them, their `InterleavedBuffer` is returned.
   *
   * @private
   * @param {BufferAttribute} attribute - The attribute.
   * @return {BufferAttribute|InterleavedBuffer}
   */
  _getBufferAttribute(attribute3) {
    if (attribute3.isInterleavedBufferAttribute) attribute3 = attribute3.data;
    return attribute3;
  }
};
var WebGPUBindingUtils = class {
  /**
   * Constructs a new utility object.
   *
   * @param {WebGPUBackend} backend - The WebGPU backend.
   */
  constructor(backend) {
    this.backend = backend;
    this.bindGroupLayoutCache = /* @__PURE__ */ new WeakMap();
  }
  /**
   * Creates a GPU bind group layout for the given bind group.
   *
   * @param {BindGroup} bindGroup - The bind group.
   * @return {GPUBindGroupLayout} The GPU bind group layout.
   */
  createBindingsLayout(bindGroup) {
    const backend = this.backend;
    const device = backend.device;
    const entries = [];
    let index5 = 0;
    for (const binding of bindGroup.bindings) {
      const bindingGPU = {
        binding: index5++,
        visibility: binding.visibility
      };
      if (binding.isUniformBuffer || binding.isStorageBuffer) {
        const buffer3 = {};
        if (binding.isStorageBuffer) {
          if (binding.visibility & 4) {
            if (binding.access === NodeAccess.READ_WRITE || binding.access === NodeAccess.WRITE_ONLY) {
              buffer3.type = GPUBufferBindingType.Storage;
            } else {
              buffer3.type = GPUBufferBindingType.ReadOnlyStorage;
            }
          } else {
            buffer3.type = GPUBufferBindingType.ReadOnlyStorage;
          }
        }
        bindingGPU.buffer = buffer3;
      } else if (binding.isSampledTexture && binding.store) {
        const storageTexture3 = {};
        storageTexture3.format = this.backend.get(binding.texture).texture.format;
        const access = binding.access;
        if (access === NodeAccess.READ_WRITE) {
          storageTexture3.access = GPUStorageTextureAccess.ReadWrite;
        } else if (access === NodeAccess.WRITE_ONLY) {
          storageTexture3.access = GPUStorageTextureAccess.WriteOnly;
        } else {
          storageTexture3.access = GPUStorageTextureAccess.ReadOnly;
        }
        if (binding.texture.isArrayTexture) {
          storageTexture3.viewDimension = GPUTextureViewDimension.TwoDArray;
        } else if (binding.texture.is3DTexture) {
          storageTexture3.viewDimension = GPUTextureViewDimension.ThreeD;
        }
        bindingGPU.storageTexture = storageTexture3;
      } else if (binding.isSampledTexture) {
        const texture3 = {};
        const { primarySamples } = backend.utils.getTextureSampleData(binding.texture);
        if (primarySamples > 1) {
          texture3.multisampled = true;
          if (!binding.texture.isDepthTexture) {
            texture3.sampleType = GPUTextureSampleType.UnfilterableFloat;
          }
        }
        if (binding.texture.isDepthTexture) {
          if (backend.compatibilityMode && binding.texture.compareFunction === null) {
            texture3.sampleType = GPUTextureSampleType.UnfilterableFloat;
          } else {
            texture3.sampleType = GPUTextureSampleType.Depth;
          }
        } else if (binding.texture.isDataTexture || binding.texture.isDataArrayTexture || binding.texture.isData3DTexture) {
          const type = binding.texture.type;
          if (type === IntType) {
            texture3.sampleType = GPUTextureSampleType.SInt;
          } else if (type === UnsignedIntType) {
            texture3.sampleType = GPUTextureSampleType.UInt;
          } else if (type === FloatType) {
            if (this.backend.hasFeature("float32-filterable")) {
              texture3.sampleType = GPUTextureSampleType.Float;
            } else {
              texture3.sampleType = GPUTextureSampleType.UnfilterableFloat;
            }
          }
        }
        if (binding.isSampledCubeTexture) {
          texture3.viewDimension = GPUTextureViewDimension.Cube;
        } else if (binding.texture.isArrayTexture || binding.texture.isDataArrayTexture || binding.texture.isCompressedArrayTexture) {
          texture3.viewDimension = GPUTextureViewDimension.TwoDArray;
        } else if (binding.isSampledTexture3D) {
          texture3.viewDimension = GPUTextureViewDimension.ThreeD;
        }
        bindingGPU.texture = texture3;
      } else if (binding.isSampler) {
        const sampler3 = {};
        if (binding.texture.isDepthTexture) {
          if (binding.texture.compareFunction !== null) {
            sampler3.type = GPUSamplerBindingType.Comparison;
          } else if (backend.compatibilityMode) {
            sampler3.type = GPUSamplerBindingType.NonFiltering;
          }
        }
        bindingGPU.sampler = sampler3;
      } else {
        console.error(`WebGPUBindingUtils: Unsupported binding "${binding}".`);
      }
      entries.push(bindingGPU);
    }
    return device.createBindGroupLayout({ entries });
  }
  /**
   * Creates bindings from the given bind group definition.
   *
   * @param {BindGroup} bindGroup - The bind group.
   * @param {Array<BindGroup>} bindings - Array of bind groups.
   * @param {number} cacheIndex - The cache index.
   * @param {number} version - The version.
   */
  createBindings(bindGroup, bindings, cacheIndex, version = 0) {
    const { backend, bindGroupLayoutCache } = this;
    const bindingsData = backend.get(bindGroup);
    let bindLayoutGPU = bindGroupLayoutCache.get(bindGroup.bindingsReference);
    if (bindLayoutGPU === void 0) {
      bindLayoutGPU = this.createBindingsLayout(bindGroup);
      bindGroupLayoutCache.set(bindGroup.bindingsReference, bindLayoutGPU);
    }
    let bindGroupGPU;
    if (cacheIndex > 0) {
      if (bindingsData.groups === void 0) {
        bindingsData.groups = [];
        bindingsData.versions = [];
      }
      if (bindingsData.versions[cacheIndex] === version) {
        bindGroupGPU = bindingsData.groups[cacheIndex];
      }
    }
    if (bindGroupGPU === void 0) {
      bindGroupGPU = this.createBindGroup(bindGroup, bindLayoutGPU);
      if (cacheIndex > 0) {
        bindingsData.groups[cacheIndex] = bindGroupGPU;
        bindingsData.versions[cacheIndex] = version;
      }
    }
    bindingsData.group = bindGroupGPU;
    bindingsData.layout = bindLayoutGPU;
  }
  /**
   * Updates a buffer binding.
   *
   *  @param {Buffer} binding - The buffer binding to update.
   */
  updateBinding(binding) {
    const backend = this.backend;
    const device = backend.device;
    const buffer3 = binding.buffer;
    const bufferGPU = backend.get(binding).buffer;
    device.queue.writeBuffer(bufferGPU, 0, buffer3, 0);
  }
  /**
   * Creates a GPU bind group for the camera index.
   *
   * @param {Uint32Array} data - The index data.
   * @param {GPUBindGroupLayout} layout - The GPU bind group layout.
   * @return {GPUBindGroup} The GPU bind group.
   */
  createBindGroupIndex(data, layout) {
    const backend = this.backend;
    const device = backend.device;
    const usage = GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST;
    const index5 = data[0];
    const buffer3 = device.createBuffer({
      label: "bindingCameraIndex_" + index5,
      size: 16,
      // uint(4) * 4
      usage
    });
    device.queue.writeBuffer(buffer3, 0, data, 0);
    const entries = [{ binding: 0, resource: { buffer: buffer3 } }];
    return device.createBindGroup({
      label: "bindGroupCameraIndex_" + index5,
      layout,
      entries
    });
  }
  /**
   * Creates a GPU bind group for the given bind group and GPU layout.
   *
   * @param {BindGroup} bindGroup - The bind group.
   * @param {GPUBindGroupLayout} layoutGPU - The GPU bind group layout.
   * @return {GPUBindGroup} The GPU bind group.
   */
  createBindGroup(bindGroup, layoutGPU) {
    const backend = this.backend;
    const device = backend.device;
    let bindingPoint = 0;
    const entriesGPU = [];
    for (const binding of bindGroup.bindings) {
      if (binding.isUniformBuffer) {
        const bindingData = backend.get(binding);
        if (bindingData.buffer === void 0) {
          const byteLength = binding.byteLength;
          const usage = GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST;
          const bufferGPU = device.createBuffer({
            label: "bindingBuffer_" + binding.name,
            size: byteLength,
            usage
          });
          bindingData.buffer = bufferGPU;
        }
        entriesGPU.push({ binding: bindingPoint, resource: { buffer: bindingData.buffer } });
      } else if (binding.isStorageBuffer) {
        const bindingData = backend.get(binding);
        if (bindingData.buffer === void 0) {
          const attribute3 = binding.attribute;
          bindingData.buffer = backend.get(attribute3).buffer;
        }
        entriesGPU.push({ binding: bindingPoint, resource: { buffer: bindingData.buffer } });
      } else if (binding.isSampledTexture) {
        const textureData = backend.get(binding.texture);
        let resourceGPU;
        if (textureData.externalTexture !== void 0) {
          resourceGPU = device.importExternalTexture({ source: textureData.externalTexture });
        } else {
          const mipLevelCount = binding.store ? 1 : textureData.texture.mipLevelCount;
          let propertyName = `view-${textureData.texture.width}-${textureData.texture.height}`;
          if (textureData.texture.depthOrArrayLayers > 1) {
            propertyName += `-${textureData.texture.depthOrArrayLayers}`;
          }
          propertyName += `-${mipLevelCount}`;
          resourceGPU = textureData[propertyName];
          if (resourceGPU === void 0) {
            const aspectGPU = GPUTextureAspect.All;
            let dimensionViewGPU;
            if (binding.isSampledCubeTexture) {
              dimensionViewGPU = GPUTextureViewDimension.Cube;
            } else if (binding.isSampledTexture3D) {
              dimensionViewGPU = GPUTextureViewDimension.ThreeD;
            } else if (binding.texture.isArrayTexture || binding.texture.isDataArrayTexture || binding.texture.isCompressedArrayTexture) {
              dimensionViewGPU = GPUTextureViewDimension.TwoDArray;
            } else {
              dimensionViewGPU = GPUTextureViewDimension.TwoD;
            }
            resourceGPU = textureData[propertyName] = textureData.texture.createView({ aspect: aspectGPU, dimension: dimensionViewGPU, mipLevelCount });
          }
        }
        entriesGPU.push({ binding: bindingPoint, resource: resourceGPU });
      } else if (binding.isSampler) {
        const textureGPU = backend.get(binding.texture);
        entriesGPU.push({ binding: bindingPoint, resource: textureGPU.sampler });
      }
      bindingPoint++;
    }
    return device.createBindGroup({
      label: "bindGroup_" + bindGroup.name,
      layout: layoutGPU,
      entries: entriesGPU
    });
  }
};
var WebGPUPipelineUtils = class {
  /**
   * Constructs a new utility object.
   *
   * @param {WebGPUBackend} backend - The WebGPU backend.
   */
  constructor(backend) {
    this.backend = backend;
    this._activePipelines = /* @__PURE__ */ new WeakMap();
  }
  /**
   * Sets the given pipeline for the given pass. The method makes sure to only set the
   * pipeline when necessary.
   *
   * @param {(GPURenderPassEncoder|GPUComputePassEncoder)} pass - The pass encoder.
   * @param {(GPURenderPipeline|GPUComputePipeline)} pipeline - The pipeline.
   */
  setPipeline(pass3, pipeline) {
    const currentPipeline = this._activePipelines.get(pass3);
    if (currentPipeline !== pipeline) {
      pass3.setPipeline(pipeline);
      this._activePipelines.set(pass3, pipeline);
    }
  }
  /**
   * Returns the sample count derived from the given render context.
   *
   * @private
   * @param {RenderContext} renderContext - The render context.
   * @return {number} The sample count.
   */
  _getSampleCount(renderContext) {
    return this.backend.utils.getSampleCountRenderContext(renderContext);
  }
  /**
   * Creates a render pipeline for the given render object.
   *
   * @param {RenderObject} renderObject - The render object.
   * @param {Array<Promise>} promises - An array of compilation promises which are used in `compileAsync()`.
   */
  createRenderPipeline(renderObject, promises) {
    const { object: object2, material, geometry, pipeline } = renderObject;
    const { vertexProgram, fragmentProgram } = pipeline;
    const backend = this.backend;
    const device = backend.device;
    const utils = backend.utils;
    const pipelineData = backend.get(pipeline);
    const bindGroupLayouts = [];
    for (const bindGroup of renderObject.getBindings()) {
      const bindingsData = backend.get(bindGroup);
      bindGroupLayouts.push(bindingsData.layout);
    }
    const vertexBuffers = backend.attributeUtils.createShaderVertexBuffers(renderObject);
    let blending;
    if (material.blending !== NoBlending && (material.blending !== NormalBlending || material.transparent !== false)) {
      blending = this._getBlending(material);
    }
    let stencilFront = {};
    if (material.stencilWrite === true) {
      stencilFront = {
        compare: this._getStencilCompare(material),
        failOp: this._getStencilOperation(material.stencilFail),
        depthFailOp: this._getStencilOperation(material.stencilZFail),
        passOp: this._getStencilOperation(material.stencilZPass)
      };
    }
    const colorWriteMask = this._getColorWriteMask(material);
    const targets = [];
    if (renderObject.context.textures !== null) {
      const textures = renderObject.context.textures;
      for (let i = 0; i < textures.length; i++) {
        const colorFormat = utils.getTextureFormatGPU(textures[i]);
        targets.push({
          format: colorFormat,
          blend: blending,
          writeMask: colorWriteMask
        });
      }
    } else {
      const colorFormat = utils.getCurrentColorFormat(renderObject.context);
      targets.push({
        format: colorFormat,
        blend: blending,
        writeMask: colorWriteMask
      });
    }
    const vertexModule = backend.get(vertexProgram).module;
    const fragmentModule = backend.get(fragmentProgram).module;
    const primitiveState = this._getPrimitiveState(object2, geometry, material);
    const depthCompare = this._getDepthCompare(material);
    const depthStencilFormat = utils.getCurrentDepthStencilFormat(renderObject.context);
    const sampleCount = this._getSampleCount(renderObject.context);
    const pipelineDescriptor = {
      label: `renderPipeline_${material.name || material.type}_${material.id}`,
      vertex: Object.assign({}, vertexModule, { buffers: vertexBuffers }),
      fragment: Object.assign({}, fragmentModule, { targets }),
      primitive: primitiveState,
      multisample: {
        count: sampleCount,
        alphaToCoverageEnabled: material.alphaToCoverage && sampleCount > 1
      },
      layout: device.createPipelineLayout({
        bindGroupLayouts
      })
    };
    const depthStencil = {};
    const renderDepth = renderObject.context.depth;
    const renderStencil = renderObject.context.stencil;
    if (renderDepth === true || renderStencil === true) {
      if (renderDepth === true) {
        depthStencil.format = depthStencilFormat;
        depthStencil.depthWriteEnabled = material.depthWrite;
        depthStencil.depthCompare = depthCompare;
      }
      if (renderStencil === true) {
        depthStencil.stencilFront = stencilFront;
        depthStencil.stencilBack = {};
        depthStencil.stencilReadMask = material.stencilFuncMask;
        depthStencil.stencilWriteMask = material.stencilWriteMask;
      }
      if (material.polygonOffset === true) {
        depthStencil.depthBias = material.polygonOffsetUnits;
        depthStencil.depthBiasSlopeScale = material.polygonOffsetFactor;
        depthStencil.depthBiasClamp = 0;
      }
      pipelineDescriptor.depthStencil = depthStencil;
    }
    if (promises === null) {
      pipelineData.pipeline = device.createRenderPipeline(pipelineDescriptor);
    } else {
      const p = new Promise((resolve) => {
        device.createRenderPipelineAsync(pipelineDescriptor).then((pipeline2) => {
          pipelineData.pipeline = pipeline2;
          resolve();
        });
      });
      promises.push(p);
    }
  }
  /**
   * Creates GPU render bundle encoder for the given render context.
   *
   * @param {RenderContext} renderContext - The render context.
   * @param {?string} [label='renderBundleEncoder'] - The label.
   * @return {GPURenderBundleEncoder} The GPU render bundle encoder.
   */
  createBundleEncoder(renderContext, label3 = "renderBundleEncoder") {
    const backend = this.backend;
    const { utils, device } = backend;
    const depthStencilFormat = utils.getCurrentDepthStencilFormat(renderContext);
    const colorFormat = utils.getCurrentColorFormat(renderContext);
    const sampleCount = this._getSampleCount(renderContext);
    const descriptor = {
      label: label3,
      colorFormats: [colorFormat],
      depthStencilFormat,
      sampleCount
    };
    return device.createRenderBundleEncoder(descriptor);
  }
  /**
   * Creates a compute pipeline for the given compute node.
   *
   * @param {ComputePipeline} pipeline - The compute pipeline.
   * @param {Array<BindGroup>} bindings - The bindings.
   */
  createComputePipeline(pipeline, bindings) {
    const backend = this.backend;
    const device = backend.device;
    const computeProgram = backend.get(pipeline.computeProgram).module;
    const pipelineGPU = backend.get(pipeline);
    const bindGroupLayouts = [];
    for (const bindingsGroup of bindings) {
      const bindingsData = backend.get(bindingsGroup);
      bindGroupLayouts.push(bindingsData.layout);
    }
    pipelineGPU.pipeline = device.createComputePipeline({
      compute: computeProgram,
      layout: device.createPipelineLayout({
        bindGroupLayouts
      })
    });
  }
  /**
   * Returns the blending state as a descriptor object required
   * for the pipeline creation.
   *
   * @private
   * @param {Material} material - The material.
   * @return {Object} The blending state.
   */
  _getBlending(material) {
    let color4, alpha;
    const blending = material.blending;
    const blendSrc = material.blendSrc;
    const blendDst = material.blendDst;
    const blendEquation = material.blendEquation;
    if (blending === CustomBlending) {
      const blendSrcAlpha = material.blendSrcAlpha !== null ? material.blendSrcAlpha : blendSrc;
      const blendDstAlpha = material.blendDstAlpha !== null ? material.blendDstAlpha : blendDst;
      const blendEquationAlpha = material.blendEquationAlpha !== null ? material.blendEquationAlpha : blendEquation;
      color4 = {
        srcFactor: this._getBlendFactor(blendSrc),
        dstFactor: this._getBlendFactor(blendDst),
        operation: this._getBlendOperation(blendEquation)
      };
      alpha = {
        srcFactor: this._getBlendFactor(blendSrcAlpha),
        dstFactor: this._getBlendFactor(blendDstAlpha),
        operation: this._getBlendOperation(blendEquationAlpha)
      };
    } else {
      const premultipliedAlpha = material.premultipliedAlpha;
      const setBlend = (srcRGB, dstRGB, srcAlpha, dstAlpha) => {
        color4 = {
          srcFactor: srcRGB,
          dstFactor: dstRGB,
          operation: GPUBlendOperation.Add
        };
        alpha = {
          srcFactor: srcAlpha,
          dstFactor: dstAlpha,
          operation: GPUBlendOperation.Add
        };
      };
      if (premultipliedAlpha) {
        switch (blending) {
          case NormalBlending:
            setBlend(GPUBlendFactor.One, GPUBlendFactor.OneMinusSrcAlpha, GPUBlendFactor.One, GPUBlendFactor.OneMinusSrcAlpha);
            break;
          case AdditiveBlending:
            setBlend(GPUBlendFactor.One, GPUBlendFactor.One, GPUBlendFactor.One, GPUBlendFactor.One);
            break;
          case SubtractiveBlending:
            setBlend(GPUBlendFactor.Zero, GPUBlendFactor.OneMinusSrc, GPUBlendFactor.Zero, GPUBlendFactor.One);
            break;
          case MultiplyBlending:
            setBlend(GPUBlendFactor.Dst, GPUBlendFactor.OneMinusSrcAlpha, GPUBlendFactor.Zero, GPUBlendFactor.One);
            break;
        }
      } else {
        switch (blending) {
          case NormalBlending:
            setBlend(GPUBlendFactor.SrcAlpha, GPUBlendFactor.OneMinusSrcAlpha, GPUBlendFactor.One, GPUBlendFactor.OneMinusSrcAlpha);
            break;
          case AdditiveBlending:
            setBlend(GPUBlendFactor.SrcAlpha, GPUBlendFactor.One, GPUBlendFactor.One, GPUBlendFactor.One);
            break;
          case SubtractiveBlending:
            console.error("THREE.WebGPURenderer: SubtractiveBlending requires material.premultipliedAlpha = true");
            break;
          case MultiplyBlending:
            console.error("THREE.WebGPURenderer: MultiplyBlending requires material.premultipliedAlpha = true");
            break;
        }
      }
    }
    if (color4 !== void 0 && alpha !== void 0) {
      return { color: color4, alpha };
    } else {
      console.error("THREE.WebGPURenderer: Invalid blending: ", blending);
    }
  }
  /**
   * Returns the GPU blend factor which is required for the pipeline creation.
   *
   * @private
   * @param {number} blend - The blend factor as a three.js constant.
   * @return {string} The GPU blend factor.
   */
  _getBlendFactor(blend) {
    let blendFactor;
    switch (blend) {
      case ZeroFactor:
        blendFactor = GPUBlendFactor.Zero;
        break;
      case OneFactor:
        blendFactor = GPUBlendFactor.One;
        break;
      case SrcColorFactor:
        blendFactor = GPUBlendFactor.Src;
        break;
      case OneMinusSrcColorFactor:
        blendFactor = GPUBlendFactor.OneMinusSrc;
        break;
      case SrcAlphaFactor:
        blendFactor = GPUBlendFactor.SrcAlpha;
        break;
      case OneMinusSrcAlphaFactor:
        blendFactor = GPUBlendFactor.OneMinusSrcAlpha;
        break;
      case DstColorFactor:
        blendFactor = GPUBlendFactor.Dst;
        break;
      case OneMinusDstColorFactor:
        blendFactor = GPUBlendFactor.OneMinusDst;
        break;
      case DstAlphaFactor:
        blendFactor = GPUBlendFactor.DstAlpha;
        break;
      case OneMinusDstAlphaFactor:
        blendFactor = GPUBlendFactor.OneMinusDstAlpha;
        break;
      case SrcAlphaSaturateFactor:
        blendFactor = GPUBlendFactor.SrcAlphaSaturated;
        break;
      case BlendColorFactor:
        blendFactor = GPUBlendFactor.Constant;
        break;
      case OneMinusBlendColorFactor:
        blendFactor = GPUBlendFactor.OneMinusConstant;
        break;
      default:
        console.error("THREE.WebGPURenderer: Blend factor not supported.", blend);
    }
    return blendFactor;
  }
  /**
   * Returns the GPU stencil compare function which is required for the pipeline creation.
   *
   * @private
   * @param {Material} material - The material.
   * @return {string} The GPU stencil compare function.
   */
  _getStencilCompare(material) {
    let stencilCompare;
    const stencilFunc = material.stencilFunc;
    switch (stencilFunc) {
      case NeverStencilFunc:
        stencilCompare = GPUCompareFunction.Never;
        break;
      case AlwaysStencilFunc:
        stencilCompare = GPUCompareFunction.Always;
        break;
      case LessStencilFunc:
        stencilCompare = GPUCompareFunction.Less;
        break;
      case LessEqualStencilFunc:
        stencilCompare = GPUCompareFunction.LessEqual;
        break;
      case EqualStencilFunc:
        stencilCompare = GPUCompareFunction.Equal;
        break;
      case GreaterEqualStencilFunc:
        stencilCompare = GPUCompareFunction.GreaterEqual;
        break;
      case GreaterStencilFunc:
        stencilCompare = GPUCompareFunction.Greater;
        break;
      case NotEqualStencilFunc:
        stencilCompare = GPUCompareFunction.NotEqual;
        break;
      default:
        console.error("THREE.WebGPURenderer: Invalid stencil function.", stencilFunc);
    }
    return stencilCompare;
  }
  /**
   * Returns the GPU stencil operation which is required for the pipeline creation.
   *
   * @private
   * @param {number} op - A three.js constant defining the stencil operation.
   * @return {string} The GPU stencil operation.
   */
  _getStencilOperation(op) {
    let stencilOperation;
    switch (op) {
      case KeepStencilOp:
        stencilOperation = GPUStencilOperation.Keep;
        break;
      case ZeroStencilOp:
        stencilOperation = GPUStencilOperation.Zero;
        break;
      case ReplaceStencilOp:
        stencilOperation = GPUStencilOperation.Replace;
        break;
      case InvertStencilOp:
        stencilOperation = GPUStencilOperation.Invert;
        break;
      case IncrementStencilOp:
        stencilOperation = GPUStencilOperation.IncrementClamp;
        break;
      case DecrementStencilOp:
        stencilOperation = GPUStencilOperation.DecrementClamp;
        break;
      case IncrementWrapStencilOp:
        stencilOperation = GPUStencilOperation.IncrementWrap;
        break;
      case DecrementWrapStencilOp:
        stencilOperation = GPUStencilOperation.DecrementWrap;
        break;
      default:
        console.error("THREE.WebGPURenderer: Invalid stencil operation.", stencilOperation);
    }
    return stencilOperation;
  }
  /**
   * Returns the GPU blend operation which is required for the pipeline creation.
   *
   * @private
   * @param {number} blendEquation - A three.js constant defining the blend equation.
   * @return {string} The GPU blend operation.
   */
  _getBlendOperation(blendEquation) {
    let blendOperation;
    switch (blendEquation) {
      case AddEquation:
        blendOperation = GPUBlendOperation.Add;
        break;
      case SubtractEquation:
        blendOperation = GPUBlendOperation.Subtract;
        break;
      case ReverseSubtractEquation:
        blendOperation = GPUBlendOperation.ReverseSubtract;
        break;
      case MinEquation:
        blendOperation = GPUBlendOperation.Min;
        break;
      case MaxEquation:
        blendOperation = GPUBlendOperation.Max;
        break;
      default:
        console.error("THREE.WebGPUPipelineUtils: Blend equation not supported.", blendEquation);
    }
    return blendOperation;
  }
  /**
   * Returns the primitive state as a descriptor object required
   * for the pipeline creation.
   *
   * @private
   * @param {Object3D} object - The 3D object.
   * @param {BufferGeometry} geometry - The geometry.
   * @param {Material} material - The material.
   * @return {Object} The primitive state.
   */
  _getPrimitiveState(object2, geometry, material) {
    const descriptor = {};
    const utils = this.backend.utils;
    descriptor.topology = utils.getPrimitiveTopology(object2, material);
    if (geometry.index !== null && object2.isLine === true && object2.isLineSegments !== true) {
      descriptor.stripIndexFormat = geometry.index.array instanceof Uint16Array ? GPUIndexFormat.Uint16 : GPUIndexFormat.Uint32;
    }
    let flipSided = material.side === BackSide;
    if (object2.isMesh && object2.matrixWorld.determinant() < 0) flipSided = !flipSided;
    descriptor.frontFace = flipSided === true ? GPUFrontFace.CW : GPUFrontFace.CCW;
    descriptor.cullMode = material.side === DoubleSide ? GPUCullMode.None : GPUCullMode.Back;
    return descriptor;
  }
  /**
   * Returns the GPU color write mask which is required for the pipeline creation.
   *
   * @private
   * @param {Material} material - The material.
   * @return {number} The GPU color write mask.
   */
  _getColorWriteMask(material) {
    return material.colorWrite === true ? GPUColorWriteFlags.All : GPUColorWriteFlags.None;
  }
  /**
   * Returns the GPU depth compare function which is required for the pipeline creation.
   *
   * @private
   * @param {Material} material - The material.
   * @return {string} The GPU depth compare function.
   */
  _getDepthCompare(material) {
    let depthCompare;
    if (material.depthTest === false) {
      depthCompare = GPUCompareFunction.Always;
    } else {
      const depthFunc = material.depthFunc;
      switch (depthFunc) {
        case NeverDepth:
          depthCompare = GPUCompareFunction.Never;
          break;
        case AlwaysDepth:
          depthCompare = GPUCompareFunction.Always;
          break;
        case LessDepth:
          depthCompare = GPUCompareFunction.Less;
          break;
        case LessEqualDepth:
          depthCompare = GPUCompareFunction.LessEqual;
          break;
        case EqualDepth:
          depthCompare = GPUCompareFunction.Equal;
          break;
        case GreaterEqualDepth:
          depthCompare = GPUCompareFunction.GreaterEqual;
          break;
        case GreaterDepth:
          depthCompare = GPUCompareFunction.Greater;
          break;
        case NotEqualDepth:
          depthCompare = GPUCompareFunction.NotEqual;
          break;
        default:
          console.error("THREE.WebGPUPipelineUtils: Invalid depth function.", depthFunc);
      }
    }
    return depthCompare;
  }
};
var WebGPUTimestampQueryPool = class extends TimestampQueryPool {
  /**
   * Creates a new WebGPU timestamp query pool.
   *
   * @param {GPUDevice} device - The WebGPU device to create queries on.
   * @param {string} type - The type identifier for this query pool.
   * @param {number} [maxQueries=2048] - Maximum number of queries this pool can hold.
   */
  constructor(device, type, maxQueries = 2048) {
    super(maxQueries);
    this.device = device;
    this.type = type;
    this.querySet = this.device.createQuerySet({
      type: "timestamp",
      count: this.maxQueries,
      label: `queryset_global_timestamp_${type}`
    });
    const bufferSize = this.maxQueries * 8;
    this.resolveBuffer = this.device.createBuffer({
      label: `buffer_timestamp_resolve_${type}`,
      size: bufferSize,
      usage: GPUBufferUsage.QUERY_RESOLVE | GPUBufferUsage.COPY_SRC
    });
    this.resultBuffer = this.device.createBuffer({
      label: `buffer_timestamp_result_${type}`,
      size: bufferSize,
      usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
    });
  }
  /**
   * Allocates a pair of queries for a given render context.
   *
   * @param {string} uid - A unique identifier for the render context.
   * @returns {?number} The base offset for the allocated queries, or null if allocation failed.
   */
  allocateQueriesForContext(uid) {
    if (!this.trackTimestamp || this.isDisposed) return null;
    if (this.currentQueryIndex + 2 > this.maxQueries) {
      warnOnce(`WebGPUTimestampQueryPool [${this.type}]: Maximum number of queries exceeded, when using trackTimestamp it is necessary to resolves the queries via renderer.resolveTimestampsAsync( THREE.TimestampQuery.${this.type.toUpperCase()} ).`);
      return null;
    }
    const baseOffset = this.currentQueryIndex;
    this.currentQueryIndex += 2;
    this.queryOffsets.set(uid, baseOffset);
    return baseOffset;
  }
  /**
   * Asynchronously resolves all pending queries and returns the total duration.
   * If there's already a pending resolve operation, returns that promise instead.
   *
   * @async
   * @returns {Promise<number>} The total duration in milliseconds, or the last valid value if resolution fails.
   */
  async resolveQueriesAsync() {
    if (!this.trackTimestamp || this.currentQueryIndex === 0 || this.isDisposed) {
      return this.lastValue;
    }
    if (this.pendingResolve) {
      return this.pendingResolve;
    }
    this.pendingResolve = this._resolveQueries();
    try {
      const result = await this.pendingResolve;
      return result;
    } finally {
      this.pendingResolve = null;
    }
  }
  /**
   * Internal method to resolve queries and calculate total duration.
   *
   * @async
   * @private
   * @returns {Promise<number>} The total duration in milliseconds.
   */
  async _resolveQueries() {
    if (this.isDisposed) {
      return this.lastValue;
    }
    try {
      if (this.resultBuffer.mapState !== "unmapped") {
        return this.lastValue;
      }
      const currentOffsets = new Map(this.queryOffsets);
      const queryCount = this.currentQueryIndex;
      const bytesUsed = queryCount * 8;
      this.currentQueryIndex = 0;
      this.queryOffsets.clear();
      const commandEncoder = this.device.createCommandEncoder();
      commandEncoder.resolveQuerySet(
        this.querySet,
        0,
        queryCount,
        this.resolveBuffer,
        0
      );
      commandEncoder.copyBufferToBuffer(
        this.resolveBuffer,
        0,
        this.resultBuffer,
        0,
        bytesUsed
      );
      const commandBuffer = commandEncoder.finish();
      this.device.queue.submit([commandBuffer]);
      if (this.resultBuffer.mapState !== "unmapped") {
        return this.lastValue;
      }
      await this.resultBuffer.mapAsync(GPUMapMode.READ, 0, bytesUsed);
      if (this.isDisposed) {
        if (this.resultBuffer.mapState === "mapped") {
          this.resultBuffer.unmap();
        }
        return this.lastValue;
      }
      const times = new BigUint64Array(this.resultBuffer.getMappedRange(0, bytesUsed));
      let totalDuration = 0;
      for (const [, baseOffset] of currentOffsets) {
        const startTime = times[baseOffset];
        const endTime = times[baseOffset + 1];
        const duration = Number(endTime - startTime) / 1e6;
        totalDuration += duration;
      }
      this.resultBuffer.unmap();
      this.lastValue = totalDuration;
      return totalDuration;
    } catch (error) {
      console.error("Error resolving queries:", error);
      if (this.resultBuffer.mapState === "mapped") {
        this.resultBuffer.unmap();
      }
      return this.lastValue;
    }
  }
  /**
   * Dispose of the query pool.
   *
   * @async
   * @returns {Promise} A Promise that resolves when the dispose has been executed.
   */
  async dispose() {
    if (this.isDisposed) {
      return;
    }
    this.isDisposed = true;
    if (this.pendingResolve) {
      try {
        await this.pendingResolve;
      } catch (error) {
        console.error("Error waiting for pending resolve:", error);
      }
    }
    if (this.resultBuffer && this.resultBuffer.mapState === "mapped") {
      try {
        this.resultBuffer.unmap();
      } catch (error) {
        console.error("Error unmapping buffer:", error);
      }
    }
    if (this.querySet) {
      this.querySet.destroy();
      this.querySet = null;
    }
    if (this.resolveBuffer) {
      this.resolveBuffer.destroy();
      this.resolveBuffer = null;
    }
    if (this.resultBuffer) {
      this.resultBuffer.destroy();
      this.resultBuffer = null;
    }
    this.queryOffsets.clear();
    this.pendingResolve = null;
  }
};
var WebGPUBackend = class extends Backend {
  /**
   * WebGPUBackend options.
   *
   * @typedef {Object} WebGPUBackend~Options
   * @property {boolean} [logarithmicDepthBuffer=false] - Whether logarithmic depth buffer is enabled or not.
   * @property {boolean} [alpha=true] - Whether the default framebuffer (which represents the final contents of the canvas) should be transparent or opaque.
   * @property {boolean} [compatibilityMode=false] - Whether the backend should be in compatibility mode or not.
   * @property {boolean} [depth=true] - Whether the default framebuffer should have a depth buffer or not.
   * @property {boolean} [stencil=false] - Whether the default framebuffer should have a stencil buffer or not.
   * @property {boolean} [antialias=false] - Whether MSAA as the default anti-aliasing should be enabled or not.
   * @property {number} [samples=0] - When `antialias` is `true`, `4` samples are used by default. Set this parameter to any other integer value than 0 to overwrite the default.
   * @property {boolean} [forceWebGL=false] - If set to `true`, the renderer uses a WebGL 2 backend no matter if WebGPU is supported or not.
   * @property {boolean} [trackTimestamp=false] - Whether to track timestamps with a Timestamp Query API or not.
   * @property {string} [powerPreference=undefined] - The power preference.
   * @property {Object} [requiredLimits=undefined] - Specifies the limits that are required by the device request. The request will fail if the adapter cannot provide these limits.
   * @property {GPUDevice} [device=undefined] - If there is an existing GPU device on app level, it can be passed to the renderer as a parameter.
   * @property {number} [outputType=undefined] - Texture type for output to canvas. By default, device's preferred format is used; other formats may incur overhead.
   */
  /**
   * Constructs a new WebGPU backend.
   *
   * @param {WebGPUBackend~Options} [parameters] - The configuration parameter.
   */
  constructor(parameters = {}) {
    super(parameters);
    this.isWebGPUBackend = true;
    this.parameters.alpha = parameters.alpha === void 0 ? true : parameters.alpha;
    this.parameters.compatibilityMode = parameters.compatibilityMode === void 0 ? false : parameters.compatibilityMode;
    this.parameters.requiredLimits = parameters.requiredLimits === void 0 ? {} : parameters.requiredLimits;
    this.compatibilityMode = this.parameters.compatibilityMode;
    this.device = null;
    this.context = null;
    this.colorBuffer = null;
    this.defaultRenderPassdescriptor = null;
    this.utils = new WebGPUUtils(this);
    this.attributeUtils = new WebGPUAttributeUtils(this);
    this.bindingUtils = new WebGPUBindingUtils(this);
    this.pipelineUtils = new WebGPUPipelineUtils(this);
    this.textureUtils = new WebGPUTextureUtils(this);
    this.occludedResolveCache = /* @__PURE__ */ new Map();
  }
  /**
   * Initializes the backend so it is ready for usage.
   *
   * @async
   * @param {Renderer} renderer - The renderer.
   * @return {Promise} A Promise that resolves when the backend has been initialized.
   */
  async init(renderer) {
    await super.init(renderer);
    const parameters = this.parameters;
    let device;
    if (parameters.device === void 0) {
      const adapterOptions = {
        powerPreference: parameters.powerPreference,
        featureLevel: parameters.compatibilityMode ? "compatibility" : void 0
      };
      const adapter = typeof navigator !== "undefined" ? await navigator.gpu.requestAdapter(adapterOptions) : null;
      if (adapter === null) {
        throw new Error("WebGPUBackend: Unable to create WebGPU adapter.");
      }
      const features = Object.values(GPUFeatureName);
      const supportedFeatures = [];
      for (const name of features) {
        if (adapter.features.has(name)) {
          supportedFeatures.push(name);
        }
      }
      const deviceDescriptor = {
        requiredFeatures: supportedFeatures,
        requiredLimits: parameters.requiredLimits
      };
      device = await adapter.requestDevice(deviceDescriptor);
    } else {
      device = parameters.device;
    }
    device.lost.then((info) => {
      const deviceLossInfo = {
        api: "WebGPU",
        message: info.message || "Unknown reason",
        reason: info.reason || null,
        originalEvent: info
      };
      renderer.onDeviceLost(deviceLossInfo);
    });
    const context3 = parameters.context !== void 0 ? parameters.context : renderer.domElement.getContext("webgpu");
    this.device = device;
    this.context = context3;
    const alphaMode = parameters.alpha ? "premultiplied" : "opaque";
    const toneMappingMode = ColorManagement.getToneMappingMode(this.renderer.outputColorSpace);
    this.context.configure({
      device: this.device,
      format: this.utils.getPreferredCanvasFormat(),
      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,
      alphaMode,
      toneMapping: {
        mode: toneMappingMode
      }
    });
    this.trackTimestamp = this.trackTimestamp && this.hasFeature(GPUFeatureName.TimestampQuery);
    this.updateSize();
  }
  /**
   * The coordinate system of the backend.
   *
   * @type {number}
   * @readonly
   */
  get coordinateSystem() {
    return WebGPUCoordinateSystem;
  }
  /**
   * This method performs a readback operation by moving buffer data from
   * a storage buffer attribute from the GPU to the CPU.
   *
   * @async
   * @param {StorageBufferAttribute} attribute - The storage buffer attribute.
   * @return {Promise<ArrayBuffer>} A promise that resolves with the buffer data when the data are ready.
   */
  async getArrayBufferAsync(attribute3) {
    return await this.attributeUtils.getArrayBufferAsync(attribute3);
  }
  /**
   * Returns the backend's rendering context.
   *
   * @return {GPUCanvasContext} The rendering context.
   */
  getContext() {
    return this.context;
  }
  /**
   * Returns the default render pass descriptor.
   *
   * In WebGPU, the default framebuffer must be configured
   * like custom framebuffers so the backend needs a render
   * pass descriptor even when rendering directly to screen.
   *
   * @private
   * @return {Object} The render pass descriptor.
   */
  _getDefaultRenderPassDescriptor() {
    let descriptor = this.defaultRenderPassdescriptor;
    if (descriptor === null) {
      const renderer = this.renderer;
      descriptor = {
        colorAttachments: [{
          view: null
        }]
      };
      if (this.renderer.depth === true || this.renderer.stencil === true) {
        descriptor.depthStencilAttachment = {
          view: this.textureUtils.getDepthBuffer(renderer.depth, renderer.stencil).createView()
        };
      }
      const colorAttachment2 = descriptor.colorAttachments[0];
      if (this.renderer.samples > 0) {
        colorAttachment2.view = this.colorBuffer.createView();
      } else {
        colorAttachment2.resolveTarget = void 0;
      }
      this.defaultRenderPassdescriptor = descriptor;
    }
    const colorAttachment = descriptor.colorAttachments[0];
    if (this.renderer.samples > 0) {
      colorAttachment.resolveTarget = this.context.getCurrentTexture().createView();
    } else {
      colorAttachment.view = this.context.getCurrentTexture().createView();
    }
    return descriptor;
  }
  /**
   * Internal to determine if the current render target is a render target array with depth 2D array texture.
   *
   * @param {RenderContext} renderContext - The render context.
   * @return {boolean} Whether the render target is a render target array with depth 2D array texture.
   *
   * @private
   */
  _isRenderCameraDepthArray(renderContext) {
    return renderContext.depthTexture && renderContext.depthTexture.image.depth > 1 && renderContext.camera.isArrayCamera;
  }
  /**
   * Returns the render pass descriptor for the given render context.
   *
   * @private
   * @param {RenderContext} renderContext - The render context.
   * @param {Object} colorAttachmentsConfig - Configuration object for the color attachments.
   * @return {Object} The render pass descriptor.
   */
  _getRenderPassDescriptor(renderContext, colorAttachmentsConfig = {}) {
    const renderTarget = renderContext.renderTarget;
    const renderTargetData = this.get(renderTarget);
    let descriptors = renderTargetData.descriptors;
    if (descriptors === void 0 || renderTargetData.width !== renderTarget.width || renderTargetData.height !== renderTarget.height || renderTargetData.samples !== renderTarget.samples) {
      descriptors = {};
      renderTargetData.descriptors = descriptors;
    }
    const cacheKey = renderContext.getCacheKey();
    let descriptorBase = descriptors[cacheKey];
    if (descriptorBase === void 0) {
      const textures = renderContext.textures;
      const textureViews = [];
      let sliceIndex;
      const isRenderCameraDepthArray = this._isRenderCameraDepthArray(renderContext);
      for (let i = 0; i < textures.length; i++) {
        const textureData = this.get(textures[i]);
        const viewDescriptor = {
          label: `colorAttachment_${i}`,
          baseMipLevel: renderContext.activeMipmapLevel,
          mipLevelCount: 1,
          baseArrayLayer: renderContext.activeCubeFace,
          arrayLayerCount: 1,
          dimension: GPUTextureViewDimension.TwoD
        };
        if (renderTarget.isRenderTarget3D) {
          sliceIndex = renderContext.activeCubeFace;
          viewDescriptor.baseArrayLayer = 0;
          viewDescriptor.dimension = GPUTextureViewDimension.ThreeD;
          viewDescriptor.depthOrArrayLayers = textures[i].image.depth;
        } else if (renderTarget.isRenderTarget && textures[i].image.depth > 1) {
          if (isRenderCameraDepthArray === true) {
            const cameras = renderContext.camera.cameras;
            for (let layer = 0; layer < cameras.length; layer++) {
              const layerViewDescriptor = {
                ...viewDescriptor,
                baseArrayLayer: layer,
                arrayLayerCount: 1,
                dimension: GPUTextureViewDimension.TwoD
              };
              const textureView = textureData.texture.createView(layerViewDescriptor);
              textureViews.push({
                view: textureView,
                resolveTarget: void 0,
                depthSlice: void 0
              });
            }
          } else {
            viewDescriptor.dimension = GPUTextureViewDimension.TwoDArray;
            viewDescriptor.depthOrArrayLayers = textures[i].image.depth;
          }
        }
        if (isRenderCameraDepthArray !== true) {
          const textureView = textureData.texture.createView(viewDescriptor);
          let view, resolveTarget;
          if (textureData.msaaTexture !== void 0) {
            view = textureData.msaaTexture.createView();
            resolveTarget = textureView;
          } else {
            view = textureView;
            resolveTarget = void 0;
          }
          textureViews.push({
            view,
            resolveTarget,
            depthSlice: sliceIndex
          });
        }
      }
      descriptorBase = { textureViews };
      if (renderContext.depth) {
        const depthTextureData = this.get(renderContext.depthTexture);
        const options = {};
        if (renderContext.depthTexture.isArrayTexture) {
          options.dimension = GPUTextureViewDimension.TwoD;
          options.arrayLayerCount = 1;
          options.baseArrayLayer = renderContext.activeCubeFace;
        }
        descriptorBase.depthStencilView = depthTextureData.texture.createView(options);
      }
      descriptors[cacheKey] = descriptorBase;
      renderTargetData.width = renderTarget.width;
      renderTargetData.height = renderTarget.height;
      renderTargetData.samples = renderTarget.samples;
      renderTargetData.activeMipmapLevel = renderContext.activeMipmapLevel;
      renderTargetData.activeCubeFace = renderContext.activeCubeFace;
    }
    const descriptor = {
      colorAttachments: []
    };
    for (let i = 0; i < descriptorBase.textureViews.length; i++) {
      const viewInfo = descriptorBase.textureViews[i];
      let clearValue = { r: 0, g: 0, b: 0, a: 1 };
      if (i === 0 && colorAttachmentsConfig.clearValue) {
        clearValue = colorAttachmentsConfig.clearValue;
      }
      descriptor.colorAttachments.push({
        view: viewInfo.view,
        depthSlice: viewInfo.depthSlice,
        resolveTarget: viewInfo.resolveTarget,
        loadOp: colorAttachmentsConfig.loadOp || GPULoadOp.Load,
        storeOp: colorAttachmentsConfig.storeOp || GPUStoreOp.Store,
        clearValue
      });
    }
    if (descriptorBase.depthStencilView) {
      descriptor.depthStencilAttachment = {
        view: descriptorBase.depthStencilView
      };
    }
    return descriptor;
  }
  /**
   * This method is executed at the beginning of a render call and prepares
   * the WebGPU state for upcoming render calls
   *
   * @param {RenderContext} renderContext - The render context.
   */
  beginRender(renderContext) {
    const renderContextData = this.get(renderContext);
    renderContextData.frameCalls = this.renderer.info.render.frameCalls;
    const device = this.device;
    const occlusionQueryCount = renderContext.occlusionQueryCount;
    let occlusionQuerySet;
    if (occlusionQueryCount > 0) {
      if (renderContextData.currentOcclusionQuerySet) renderContextData.currentOcclusionQuerySet.destroy();
      if (renderContextData.currentOcclusionQueryBuffer) renderContextData.currentOcclusionQueryBuffer.destroy();
      renderContextData.currentOcclusionQuerySet = renderContextData.occlusionQuerySet;
      renderContextData.currentOcclusionQueryBuffer = renderContextData.occlusionQueryBuffer;
      renderContextData.currentOcclusionQueryObjects = renderContextData.occlusionQueryObjects;
      occlusionQuerySet = device.createQuerySet({ type: "occlusion", count: occlusionQueryCount, label: `occlusionQuerySet_${renderContext.id}` });
      renderContextData.occlusionQuerySet = occlusionQuerySet;
      renderContextData.occlusionQueryIndex = 0;
      renderContextData.occlusionQueryObjects = new Array(occlusionQueryCount);
      renderContextData.lastOcclusionObject = null;
    }
    let descriptor;
    if (renderContext.textures === null) {
      descriptor = this._getDefaultRenderPassDescriptor();
    } else {
      descriptor = this._getRenderPassDescriptor(renderContext, { loadOp: GPULoadOp.Load });
    }
    this.initTimestampQuery(TimestampQuery.RENDER, this.getTimestampUID(renderContext), descriptor);
    descriptor.occlusionQuerySet = occlusionQuerySet;
    const depthStencilAttachment = descriptor.depthStencilAttachment;
    if (renderContext.textures !== null) {
      const colorAttachments = descriptor.colorAttachments;
      for (let i = 0; i < colorAttachments.length; i++) {
        const colorAttachment = colorAttachments[i];
        if (renderContext.clearColor) {
          colorAttachment.clearValue = i === 0 ? renderContext.clearColorValue : { r: 0, g: 0, b: 0, a: 1 };
          colorAttachment.loadOp = GPULoadOp.Clear;
        } else {
          colorAttachment.loadOp = GPULoadOp.Load;
        }
        colorAttachment.storeOp = GPUStoreOp.Store;
      }
    } else {
      const colorAttachment = descriptor.colorAttachments[0];
      if (renderContext.clearColor) {
        colorAttachment.clearValue = renderContext.clearColorValue;
        colorAttachment.loadOp = GPULoadOp.Clear;
      } else {
        colorAttachment.loadOp = GPULoadOp.Load;
      }
      colorAttachment.storeOp = GPUStoreOp.Store;
    }
    if (renderContext.depth) {
      if (renderContext.clearDepth) {
        depthStencilAttachment.depthClearValue = renderContext.clearDepthValue;
        depthStencilAttachment.depthLoadOp = GPULoadOp.Clear;
      } else {
        depthStencilAttachment.depthLoadOp = GPULoadOp.Load;
      }
      depthStencilAttachment.depthStoreOp = GPUStoreOp.Store;
    }
    if (renderContext.stencil) {
      if (renderContext.clearStencil) {
        depthStencilAttachment.stencilClearValue = renderContext.clearStencilValue;
        depthStencilAttachment.stencilLoadOp = GPULoadOp.Clear;
      } else {
        depthStencilAttachment.stencilLoadOp = GPULoadOp.Load;
      }
      depthStencilAttachment.stencilStoreOp = GPUStoreOp.Store;
    }
    const encoder = device.createCommandEncoder({ label: "renderContext_" + renderContext.id });
    if (this._isRenderCameraDepthArray(renderContext) === true) {
      const cameras = renderContext.camera.cameras;
      if (!renderContextData.layerDescriptors || renderContextData.layerDescriptors.length !== cameras.length) {
        this._createDepthLayerDescriptors(renderContext, renderContextData, descriptor, cameras);
      } else {
        this._updateDepthLayerDescriptors(renderContext, renderContextData, cameras);
      }
      renderContextData.bundleEncoders = [];
      renderContextData.bundleSets = [];
      for (let i = 0; i < cameras.length; i++) {
        const bundleEncoder = this.pipelineUtils.createBundleEncoder(
          renderContext,
          "renderBundleArrayCamera_" + i
        );
        const bundleSets = {
          attributes: {},
          bindingGroups: [],
          pipeline: null,
          index: null
        };
        renderContextData.bundleEncoders.push(bundleEncoder);
        renderContextData.bundleSets.push(bundleSets);
      }
      renderContextData.currentPass = null;
    } else {
      const currentPass = encoder.beginRenderPass(descriptor);
      renderContextData.currentPass = currentPass;
      if (renderContext.viewport) {
        this.updateViewport(renderContext);
      }
      if (renderContext.scissor) {
        const { x, y, width, height } = renderContext.scissorValue;
        currentPass.setScissorRect(x, y, width, height);
      }
    }
    renderContextData.descriptor = descriptor;
    renderContextData.encoder = encoder;
    renderContextData.currentSets = { attributes: {}, bindingGroups: [], pipeline: null, index: null };
    renderContextData.renderBundles = [];
  }
  /**
   * This method creates layer descriptors for each camera in an array camera
   * to prepare for rendering to a depth array texture.
   *
   * @param {RenderContext} renderContext - The render context.
   * @param {Object} renderContextData - The render context data.
   * @param {Object} descriptor  - The render pass descriptor.
   * @param {ArrayCamera} cameras - The array camera.
   *
   * @private
   */
  _createDepthLayerDescriptors(renderContext, renderContextData, descriptor, cameras) {
    const depthStencilAttachment = descriptor.depthStencilAttachment;
    renderContextData.layerDescriptors = [];
    const depthTextureData = this.get(renderContext.depthTexture);
    if (!depthTextureData.viewCache) {
      depthTextureData.viewCache = [];
    }
    for (let i = 0; i < cameras.length; i++) {
      const layerDescriptor = {
        ...descriptor,
        colorAttachments: [{
          ...descriptor.colorAttachments[0],
          view: descriptor.colorAttachments[i].view
        }]
      };
      if (descriptor.depthStencilAttachment) {
        const layerIndex = i;
        if (!depthTextureData.viewCache[layerIndex]) {
          depthTextureData.viewCache[layerIndex] = depthTextureData.texture.createView({
            dimension: GPUTextureViewDimension.TwoD,
            baseArrayLayer: i,
            arrayLayerCount: 1
          });
        }
        layerDescriptor.depthStencilAttachment = {
          view: depthTextureData.viewCache[layerIndex],
          depthLoadOp: depthStencilAttachment.depthLoadOp || GPULoadOp.Clear,
          depthStoreOp: depthStencilAttachment.depthStoreOp || GPUStoreOp.Store,
          depthClearValue: depthStencilAttachment.depthClearValue || 1
        };
        if (renderContext.stencil) {
          layerDescriptor.depthStencilAttachment.stencilLoadOp = depthStencilAttachment.stencilLoadOp;
          layerDescriptor.depthStencilAttachment.stencilStoreOp = depthStencilAttachment.stencilStoreOp;
          layerDescriptor.depthStencilAttachment.stencilClearValue = depthStencilAttachment.stencilClearValue;
        }
      } else {
        layerDescriptor.depthStencilAttachment = { ...depthStencilAttachment };
      }
      renderContextData.layerDescriptors.push(layerDescriptor);
    }
  }
  /**
   * This method updates the layer descriptors for each camera in an array camera
   * to prepare for rendering to a depth array texture.
   *
   * @param {RenderContext} renderContext - The render context.
   * @param {Object} renderContextData - The render context data.
   * @param {ArrayCamera} cameras - The array camera.
   *
   */
  _updateDepthLayerDescriptors(renderContext, renderContextData, cameras) {
    for (let i = 0; i < cameras.length; i++) {
      const layerDescriptor = renderContextData.layerDescriptors[i];
      if (layerDescriptor.depthStencilAttachment) {
        const depthAttachment = layerDescriptor.depthStencilAttachment;
        if (renderContext.depth) {
          if (renderContext.clearDepth) {
            depthAttachment.depthClearValue = renderContext.clearDepthValue;
            depthAttachment.depthLoadOp = GPULoadOp.Clear;
          } else {
            depthAttachment.depthLoadOp = GPULoadOp.Load;
          }
        }
        if (renderContext.stencil) {
          if (renderContext.clearStencil) {
            depthAttachment.stencilClearValue = renderContext.clearStencilValue;
            depthAttachment.stencilLoadOp = GPULoadOp.Clear;
          } else {
            depthAttachment.stencilLoadOp = GPULoadOp.Load;
          }
        }
      }
    }
  }
  /**
   * This method is executed at the end of a render call and finalizes work
   * after draw calls.
   *
   * @param {RenderContext} renderContext - The render context.
   */
  finishRender(renderContext) {
    const renderContextData = this.get(renderContext);
    const occlusionQueryCount = renderContext.occlusionQueryCount;
    if (renderContextData.renderBundles.length > 0) {
      renderContextData.currentPass.executeBundles(renderContextData.renderBundles);
    }
    if (occlusionQueryCount > renderContextData.occlusionQueryIndex) {
      renderContextData.currentPass.endOcclusionQuery();
    }
    const encoder = renderContextData.encoder;
    if (this._isRenderCameraDepthArray(renderContext) === true) {
      const bundles = [];
      for (let i = 0; i < renderContextData.bundleEncoders.length; i++) {
        const bundleEncoder = renderContextData.bundleEncoders[i];
        bundles.push(bundleEncoder.finish());
      }
      for (let i = 0; i < renderContextData.layerDescriptors.length; i++) {
        if (i < bundles.length) {
          const layerDescriptor = renderContextData.layerDescriptors[i];
          const renderPass = encoder.beginRenderPass(layerDescriptor);
          if (renderContext.viewport) {
            const { x, y, width, height, minDepth, maxDepth: maxDepth2 } = renderContext.viewportValue;
            renderPass.setViewport(x, y, width, height, minDepth, maxDepth2);
          }
          if (renderContext.scissor) {
            const { x, y, width, height } = renderContext.scissorValue;
            renderPass.setScissorRect(x, y, width, height);
          }
          renderPass.executeBundles([bundles[i]]);
          renderPass.end();
        }
      }
    } else if (renderContextData.currentPass) {
      renderContextData.currentPass.end();
    }
    if (occlusionQueryCount > 0) {
      const bufferSize = occlusionQueryCount * 8;
      let queryResolveBuffer = this.occludedResolveCache.get(bufferSize);
      if (queryResolveBuffer === void 0) {
        queryResolveBuffer = this.device.createBuffer(
          {
            size: bufferSize,
            usage: GPUBufferUsage.QUERY_RESOLVE | GPUBufferUsage.COPY_SRC
          }
        );
        this.occludedResolveCache.set(bufferSize, queryResolveBuffer);
      }
      const readBuffer = this.device.createBuffer(
        {
          size: bufferSize,
          usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
        }
      );
      renderContextData.encoder.resolveQuerySet(renderContextData.occlusionQuerySet, 0, occlusionQueryCount, queryResolveBuffer, 0);
      renderContextData.encoder.copyBufferToBuffer(queryResolveBuffer, 0, readBuffer, 0, bufferSize);
      renderContextData.occlusionQueryBuffer = readBuffer;
      this.resolveOccludedAsync(renderContext);
    }
    this.device.queue.submit([renderContextData.encoder.finish()]);
    if (renderContext.textures !== null) {
      const textures = renderContext.textures;
      for (let i = 0; i < textures.length; i++) {
        const texture3 = textures[i];
        if (texture3.generateMipmaps === true) {
          this.textureUtils.generateMipmaps(texture3);
        }
      }
    }
  }
  /**
   * Returns `true` if the given 3D object is fully occluded by other
   * 3D objects in the scene.
   *
   * @param {RenderContext} renderContext - The render context.
   * @param {Object3D} object - The 3D object to test.
   * @return {boolean} Whether the 3D object is fully occluded or not.
   */
  isOccluded(renderContext, object2) {
    const renderContextData = this.get(renderContext);
    return renderContextData.occluded && renderContextData.occluded.has(object2);
  }
  /**
   * This method processes the result of occlusion queries and writes it
   * into render context data.
   *
   * @async
   * @param {RenderContext} renderContext - The render context.
   * @return {Promise} A Promise that resolves when the occlusion query results have been processed.
   */
  async resolveOccludedAsync(renderContext) {
    const renderContextData = this.get(renderContext);
    const { currentOcclusionQueryBuffer, currentOcclusionQueryObjects } = renderContextData;
    if (currentOcclusionQueryBuffer && currentOcclusionQueryObjects) {
      const occluded = /* @__PURE__ */ new WeakSet();
      renderContextData.currentOcclusionQueryObjects = null;
      renderContextData.currentOcclusionQueryBuffer = null;
      await currentOcclusionQueryBuffer.mapAsync(GPUMapMode.READ);
      const buffer3 = currentOcclusionQueryBuffer.getMappedRange();
      const results = new BigUint64Array(buffer3);
      for (let i = 0; i < currentOcclusionQueryObjects.length; i++) {
        if (results[i] === BigInt(0)) {
          occluded.add(currentOcclusionQueryObjects[i]);
        }
      }
      currentOcclusionQueryBuffer.destroy();
      renderContextData.occluded = occluded;
    }
  }
  /**
   * Updates the viewport with the values from the given render context.
   *
   * @param {RenderContext} renderContext - The render context.
   */
  updateViewport(renderContext) {
    const { currentPass } = this.get(renderContext);
    const { x, y, width, height, minDepth, maxDepth: maxDepth2 } = renderContext.viewportValue;
    currentPass.setViewport(x, y, width, height, minDepth, maxDepth2);
  }
  /**
   * Returns the clear color and alpha into a single
   * color object.
   *
   * @return {Color4} The clear color.
   */
  getClearColor() {
    const clearColor = super.getClearColor();
    if (this.renderer.alpha === true) {
      clearColor.r *= clearColor.a;
      clearColor.g *= clearColor.a;
      clearColor.b *= clearColor.a;
    }
    return clearColor;
  }
  /**
   * Performs a clear operation.
   *
   * @param {boolean} color - Whether the color buffer should be cleared or not.
   * @param {boolean} depth - Whether the depth buffer should be cleared or not.
   * @param {boolean} stencil - Whether the stencil buffer should be cleared or not.
   * @param {?RenderContext} [renderTargetContext=null] - The render context of the current set render target.
   */
  clear(color4, depth3, stencil, renderTargetContext = null) {
    const device = this.device;
    const renderer = this.renderer;
    let colorAttachments = [];
    let depthStencilAttachment;
    let clearValue;
    let supportsDepth;
    let supportsStencil;
    if (color4) {
      const clearColor = this.getClearColor();
      clearValue = { r: clearColor.r, g: clearColor.g, b: clearColor.b, a: clearColor.a };
    }
    if (renderTargetContext === null) {
      supportsDepth = renderer.depth;
      supportsStencil = renderer.stencil;
      const descriptor = this._getDefaultRenderPassDescriptor();
      if (color4) {
        colorAttachments = descriptor.colorAttachments;
        const colorAttachment = colorAttachments[0];
        colorAttachment.clearValue = clearValue;
        colorAttachment.loadOp = GPULoadOp.Clear;
        colorAttachment.storeOp = GPUStoreOp.Store;
      }
      if (supportsDepth || supportsStencil) {
        depthStencilAttachment = descriptor.depthStencilAttachment;
      }
    } else {
      supportsDepth = renderTargetContext.depth;
      supportsStencil = renderTargetContext.stencil;
      const clearConfig = {
        loadOp: color4 ? GPULoadOp.Clear : GPULoadOp.Load,
        clearValue: color4 ? clearValue : void 0
      };
      if (supportsDepth) {
        clearConfig.depthLoadOp = depth3 ? GPULoadOp.Clear : GPULoadOp.Load;
        clearConfig.depthClearValue = depth3 ? renderer.getClearDepth() : void 0;
        clearConfig.depthStoreOp = GPUStoreOp.Store;
      }
      if (supportsStencil) {
        clearConfig.stencilLoadOp = stencil ? GPULoadOp.Clear : GPULoadOp.Load;
        clearConfig.stencilClearValue = stencil ? renderer.getClearStencil() : void 0;
        clearConfig.stencilStoreOp = GPUStoreOp.Store;
      }
      const descriptor = this._getRenderPassDescriptor(renderTargetContext, clearConfig);
      colorAttachments = descriptor.colorAttachments;
      depthStencilAttachment = descriptor.depthStencilAttachment;
    }
    if (supportsDepth && depthStencilAttachment) {
      if (depth3) {
        depthStencilAttachment.depthLoadOp = GPULoadOp.Clear;
        depthStencilAttachment.depthClearValue = renderer.getClearDepth();
        depthStencilAttachment.depthStoreOp = GPUStoreOp.Store;
      } else {
        depthStencilAttachment.depthLoadOp = GPULoadOp.Load;
        depthStencilAttachment.depthStoreOp = GPUStoreOp.Store;
      }
    }
    if (supportsStencil && depthStencilAttachment) {
      if (stencil) {
        depthStencilAttachment.stencilLoadOp = GPULoadOp.Clear;
        depthStencilAttachment.stencilClearValue = renderer.getClearStencil();
        depthStencilAttachment.stencilStoreOp = GPUStoreOp.Store;
      } else {
        depthStencilAttachment.stencilLoadOp = GPULoadOp.Load;
        depthStencilAttachment.stencilStoreOp = GPUStoreOp.Store;
      }
    }
    const encoder = device.createCommandEncoder({ label: "clear" });
    const currentPass = encoder.beginRenderPass({
      colorAttachments,
      depthStencilAttachment
    });
    currentPass.end();
    device.queue.submit([encoder.finish()]);
  }
  // compute
  /**
   * This method is executed at the beginning of a compute call and
   * prepares the state for upcoming compute tasks.
   *
   * @param {Node|Array<Node>} computeGroup - The compute node(s).
   */
  beginCompute(computeGroup) {
    const groupGPU = this.get(computeGroup);
    groupGPU.frameCalls = this.renderer.info.compute.frameCalls;
    const descriptor = {
      label: "computeGroup_" + computeGroup.id
    };
    this.initTimestampQuery(TimestampQuery.COMPUTE, this.getTimestampUID(computeGroup), descriptor);
    groupGPU.cmdEncoderGPU = this.device.createCommandEncoder({ label: "computeGroup_" + computeGroup.id });
    groupGPU.passEncoderGPU = groupGPU.cmdEncoderGPU.beginComputePass(descriptor);
  }
  /**
   * Executes a compute command for the given compute node.
   *
   * @param {Node|Array<Node>} computeGroup - The group of compute nodes of a compute call. Can be a single compute node.
   * @param {Node} computeNode - The compute node.
   * @param {Array<BindGroup>} bindings - The bindings.
   * @param {ComputePipeline} pipeline - The compute pipeline.
   * @param {?(Array<number>|number)} [dispatchSizeOrCount=null] - Array with [ x, y, z ] values for dispatch or a single number for the count.
   */
  compute(computeGroup, computeNode, bindings, pipeline, dispatchSizeOrCount = null) {
    const computeNodeData = this.get(computeNode);
    const { passEncoderGPU } = this.get(computeGroup);
    const pipelineGPU = this.get(pipeline).pipeline;
    this.pipelineUtils.setPipeline(passEncoderGPU, pipelineGPU);
    for (let i = 0, l = bindings.length; i < l; i++) {
      const bindGroup = bindings[i];
      const bindingsData = this.get(bindGroup);
      passEncoderGPU.setBindGroup(i, bindingsData.group);
    }
    let dispatchSize;
    if (dispatchSizeOrCount === null) {
      dispatchSizeOrCount = computeNode.count;
    }
    if (typeof dispatchSizeOrCount === "number") {
      const count2 = dispatchSizeOrCount;
      if (computeNodeData.dispatchSize === void 0 || computeNodeData.count !== count2) {
        computeNodeData.dispatchSize = [0, 1, 1];
        computeNodeData.count = count2;
        const workgroupSize = computeNode.workgroupSize;
        let size = workgroupSize[0];
        for (let i = 1; i < workgroupSize.length; i++)
          size *= workgroupSize[i];
        const dispatchCount = Math.ceil(count2 / size);
        const maxComputeWorkgroupsPerDimension = this.device.limits.maxComputeWorkgroupsPerDimension;
        dispatchSize = [dispatchCount, 1, 1];
        if (dispatchCount > maxComputeWorkgroupsPerDimension) {
          dispatchSize[0] = Math.min(dispatchCount, maxComputeWorkgroupsPerDimension);
          dispatchSize[1] = Math.ceil(dispatchCount / maxComputeWorkgroupsPerDimension);
        }
        computeNodeData.dispatchSize = dispatchSize;
      }
      dispatchSize = computeNodeData.dispatchSize;
    } else {
      dispatchSize = dispatchSizeOrCount;
    }
    passEncoderGPU.dispatchWorkgroups(
      dispatchSize[0],
      dispatchSize[1] || 1,
      dispatchSize[2] || 1
    );
  }
  /**
   * This method is executed at the end of a compute call and
   * finalizes work after compute tasks.
   *
   * @param {Node|Array<Node>} computeGroup - The compute node(s).
   */
  finishCompute(computeGroup) {
    const groupData = this.get(computeGroup);
    groupData.passEncoderGPU.end();
    this.device.queue.submit([groupData.cmdEncoderGPU.finish()]);
  }
  /**
   * Can be used to synchronize CPU operations with GPU tasks. So when this method is called,
   * the CPU waits for the GPU to complete its operation (e.g. a compute task).
   *
   * @async
   * @return {Promise} A Promise that resolves when synchronization has been finished.
   */
  async waitForGPU() {
    await this.device.queue.onSubmittedWorkDone();
  }
  // render object
  /**
   * Executes a draw command for the given render object.
   *
   * @param {RenderObject} renderObject - The render object to draw.
   * @param {Info} info - Holds a series of statistical information about the GPU memory and the rendering process.
   */
  draw(renderObject, info) {
    const { object: object2, material, context: context3, pipeline } = renderObject;
    const bindings = renderObject.getBindings();
    const renderContextData = this.get(context3);
    const pipelineGPU = this.get(pipeline).pipeline;
    const index5 = renderObject.getIndex();
    const hasIndex = index5 !== null;
    const drawParams = renderObject.getDrawParameters();
    if (drawParams === null) return;
    const setPipelineAndBindings = (passEncoderGPU, currentSets) => {
      this.pipelineUtils.setPipeline(passEncoderGPU, pipelineGPU);
      currentSets.pipeline = pipelineGPU;
      const currentBindingGroups = currentSets.bindingGroups;
      for (let i = 0, l = bindings.length; i < l; i++) {
        const bindGroup = bindings[i];
        const bindingsData = this.get(bindGroup);
        if (currentBindingGroups[bindGroup.index] !== bindGroup.id) {
          passEncoderGPU.setBindGroup(bindGroup.index, bindingsData.group);
          currentBindingGroups[bindGroup.index] = bindGroup.id;
        }
      }
      if (hasIndex === true) {
        if (currentSets.index !== index5) {
          const buffer3 = this.get(index5).buffer;
          const indexFormat = index5.array instanceof Uint16Array ? GPUIndexFormat.Uint16 : GPUIndexFormat.Uint32;
          passEncoderGPU.setIndexBuffer(buffer3, indexFormat);
          currentSets.index = index5;
        }
      }
      const vertexBuffers = renderObject.getVertexBuffers();
      for (let i = 0, l = vertexBuffers.length; i < l; i++) {
        const vertexBuffer = vertexBuffers[i];
        if (currentSets.attributes[i] !== vertexBuffer) {
          const buffer3 = this.get(vertexBuffer).buffer;
          passEncoderGPU.setVertexBuffer(i, buffer3);
          currentSets.attributes[i] = vertexBuffer;
        }
      }
      if (context3.stencil === true && material.stencilWrite === true && renderContextData.currentStencilRef !== material.stencilRef) {
        passEncoderGPU.setStencilReference(material.stencilRef);
        renderContextData.currentStencilRef = material.stencilRef;
      }
    };
    const draw = (passEncoderGPU, currentSets) => {
      setPipelineAndBindings(passEncoderGPU, currentSets);
      if (object2.isBatchedMesh === true) {
        const starts = object2._multiDrawStarts;
        const counts = object2._multiDrawCounts;
        const drawCount = object2._multiDrawCount;
        const drawInstances = object2._multiDrawInstances;
        if (drawInstances !== null) {
          warnOnce("THREE.WebGPUBackend: renderMultiDrawInstances has been deprecated and will be removed in r184. Append to renderMultiDraw arguments and use indirection.");
        }
        for (let i = 0; i < drawCount; i++) {
          const count2 = drawInstances ? drawInstances[i] : 1;
          const firstInstance = count2 > 1 ? 0 : i;
          if (hasIndex === true) {
            passEncoderGPU.drawIndexed(counts[i], count2, starts[i] / index5.array.BYTES_PER_ELEMENT, 0, firstInstance);
          } else {
            passEncoderGPU.draw(counts[i], count2, starts[i], firstInstance);
          }
          info.update(object2, counts[i], count2);
        }
      } else if (hasIndex === true) {
        const { vertexCount: indexCount, instanceCount, firstVertex: firstIndex } = drawParams;
        const indirect = renderObject.getIndirect();
        if (indirect !== null) {
          const buffer3 = this.get(indirect).buffer;
          passEncoderGPU.drawIndexedIndirect(buffer3, 0);
        } else {
          passEncoderGPU.drawIndexed(indexCount, instanceCount, firstIndex, 0, 0);
        }
        info.update(object2, indexCount, instanceCount);
      } else {
        const { vertexCount, instanceCount, firstVertex } = drawParams;
        const indirect = renderObject.getIndirect();
        if (indirect !== null) {
          const buffer3 = this.get(indirect).buffer;
          passEncoderGPU.drawIndirect(buffer3, 0);
        } else {
          passEncoderGPU.draw(vertexCount, instanceCount, firstVertex, 0);
        }
        info.update(object2, vertexCount, instanceCount);
      }
    };
    if (renderObject.camera.isArrayCamera && renderObject.camera.cameras.length > 0) {
      const cameraData = this.get(renderObject.camera);
      const cameras = renderObject.camera.cameras;
      const cameraIndex3 = renderObject.getBindingGroup("cameraIndex");
      if (cameraData.indexesGPU === void 0 || cameraData.indexesGPU.length !== cameras.length) {
        const bindingsData = this.get(cameraIndex3);
        const indexesGPU = [];
        const data = new Uint32Array([0, 0, 0, 0]);
        for (let i = 0, len = cameras.length; i < len; i++) {
          data[0] = i;
          const bindGroupIndex = this.bindingUtils.createBindGroupIndex(data, bindingsData.layout);
          indexesGPU.push(bindGroupIndex);
        }
        cameraData.indexesGPU = indexesGPU;
      }
      const pixelRatio = this.renderer.getPixelRatio();
      for (let i = 0, len = cameras.length; i < len; i++) {
        const subCamera = cameras[i];
        if (object2.layers.test(subCamera.layers)) {
          const vp = subCamera.viewport;
          let pass3 = renderContextData.currentPass;
          let sets = renderContextData.currentSets;
          if (renderContextData.bundleEncoders) {
            const bundleEncoder = renderContextData.bundleEncoders[i];
            const bundleSets = renderContextData.bundleSets[i];
            pass3 = bundleEncoder;
            sets = bundleSets;
          }
          if (vp) {
            pass3.setViewport(
              Math.floor(vp.x * pixelRatio),
              Math.floor(vp.y * pixelRatio),
              Math.floor(vp.width * pixelRatio),
              Math.floor(vp.height * pixelRatio),
              context3.viewportValue.minDepth,
              context3.viewportValue.maxDepth
            );
          }
          if (cameraIndex3 && cameraData.indexesGPU) {
            pass3.setBindGroup(cameraIndex3.index, cameraData.indexesGPU[i]);
            sets.bindingGroups[cameraIndex3.index] = cameraIndex3.id;
          }
          draw(pass3, sets);
        }
      }
    } else {
      if (renderContextData.currentPass) {
        if (renderContextData.occlusionQuerySet !== void 0) {
          const lastObject = renderContextData.lastOcclusionObject;
          if (lastObject !== object2) {
            if (lastObject !== null && lastObject.occlusionTest === true) {
              renderContextData.currentPass.endOcclusionQuery();
              renderContextData.occlusionQueryIndex++;
            }
            if (object2.occlusionTest === true) {
              renderContextData.currentPass.beginOcclusionQuery(renderContextData.occlusionQueryIndex);
              renderContextData.occlusionQueryObjects[renderContextData.occlusionQueryIndex] = object2;
            }
            renderContextData.lastOcclusionObject = object2;
          }
        }
        draw(renderContextData.currentPass, renderContextData.currentSets);
      }
    }
  }
  // cache key
  /**
   * Returns `true` if the render pipeline requires an update.
   *
   * @param {RenderObject} renderObject - The render object.
   * @return {boolean} Whether the render pipeline requires an update or not.
   */
  needsRenderUpdate(renderObject) {
    const data = this.get(renderObject);
    const { object: object2, material } = renderObject;
    const utils = this.utils;
    const sampleCount = utils.getSampleCountRenderContext(renderObject.context);
    const colorSpace = utils.getCurrentColorSpace(renderObject.context);
    const colorFormat = utils.getCurrentColorFormat(renderObject.context);
    const depthStencilFormat = utils.getCurrentDepthStencilFormat(renderObject.context);
    const primitiveTopology = utils.getPrimitiveTopology(object2, material);
    let needsUpdate = false;
    if (data.material !== material || data.materialVersion !== material.version || data.transparent !== material.transparent || data.blending !== material.blending || data.premultipliedAlpha !== material.premultipliedAlpha || data.blendSrc !== material.blendSrc || data.blendDst !== material.blendDst || data.blendEquation !== material.blendEquation || data.blendSrcAlpha !== material.blendSrcAlpha || data.blendDstAlpha !== material.blendDstAlpha || data.blendEquationAlpha !== material.blendEquationAlpha || data.colorWrite !== material.colorWrite || data.depthWrite !== material.depthWrite || data.depthTest !== material.depthTest || data.depthFunc !== material.depthFunc || data.stencilWrite !== material.stencilWrite || data.stencilFunc !== material.stencilFunc || data.stencilFail !== material.stencilFail || data.stencilZFail !== material.stencilZFail || data.stencilZPass !== material.stencilZPass || data.stencilFuncMask !== material.stencilFuncMask || data.stencilWriteMask !== material.stencilWriteMask || data.side !== material.side || data.alphaToCoverage !== material.alphaToCoverage || data.sampleCount !== sampleCount || data.colorSpace !== colorSpace || data.colorFormat !== colorFormat || data.depthStencilFormat !== depthStencilFormat || data.primitiveTopology !== primitiveTopology || data.clippingContextCacheKey !== renderObject.clippingContextCacheKey) {
      data.material = material;
      data.materialVersion = material.version;
      data.transparent = material.transparent;
      data.blending = material.blending;
      data.premultipliedAlpha = material.premultipliedAlpha;
      data.blendSrc = material.blendSrc;
      data.blendDst = material.blendDst;
      data.blendEquation = material.blendEquation;
      data.blendSrcAlpha = material.blendSrcAlpha;
      data.blendDstAlpha = material.blendDstAlpha;
      data.blendEquationAlpha = material.blendEquationAlpha;
      data.colorWrite = material.colorWrite;
      data.depthWrite = material.depthWrite;
      data.depthTest = material.depthTest;
      data.depthFunc = material.depthFunc;
      data.stencilWrite = material.stencilWrite;
      data.stencilFunc = material.stencilFunc;
      data.stencilFail = material.stencilFail;
      data.stencilZFail = material.stencilZFail;
      data.stencilZPass = material.stencilZPass;
      data.stencilFuncMask = material.stencilFuncMask;
      data.stencilWriteMask = material.stencilWriteMask;
      data.side = material.side;
      data.alphaToCoverage = material.alphaToCoverage;
      data.sampleCount = sampleCount;
      data.colorSpace = colorSpace;
      data.colorFormat = colorFormat;
      data.depthStencilFormat = depthStencilFormat;
      data.primitiveTopology = primitiveTopology;
      data.clippingContextCacheKey = renderObject.clippingContextCacheKey;
      needsUpdate = true;
    }
    return needsUpdate;
  }
  /**
   * Returns a cache key that is used to identify render pipelines.
   *
   * @param {RenderObject} renderObject - The render object.
   * @return {string} The cache key.
   */
  getRenderCacheKey(renderObject) {
    const { object: object2, material } = renderObject;
    const utils = this.utils;
    const renderContext = renderObject.context;
    const frontFaceCW = object2.isMesh && object2.matrixWorld.determinant() < 0;
    return [
      material.transparent,
      material.blending,
      material.premultipliedAlpha,
      material.blendSrc,
      material.blendDst,
      material.blendEquation,
      material.blendSrcAlpha,
      material.blendDstAlpha,
      material.blendEquationAlpha,
      material.colorWrite,
      material.depthWrite,
      material.depthTest,
      material.depthFunc,
      material.stencilWrite,
      material.stencilFunc,
      material.stencilFail,
      material.stencilZFail,
      material.stencilZPass,
      material.stencilFuncMask,
      material.stencilWriteMask,
      material.side,
      frontFaceCW,
      utils.getSampleCountRenderContext(renderContext),
      utils.getCurrentColorSpace(renderContext),
      utils.getCurrentColorFormat(renderContext),
      utils.getCurrentDepthStencilFormat(renderContext),
      utils.getPrimitiveTopology(object2, material),
      renderObject.getGeometryCacheKey(),
      renderObject.clippingContextCacheKey
    ].join();
  }
  // textures
  /**
   * Creates a GPU sampler for the given texture.
   *
   * @param {Texture} texture - The texture to create the sampler for.
   */
  createSampler(texture3) {
    this.textureUtils.createSampler(texture3);
  }
  /**
   * Destroys the GPU sampler for the given texture.
   *
   * @param {Texture} texture - The texture to destroy the sampler for.
   */
  destroySampler(texture3) {
    this.textureUtils.destroySampler(texture3);
  }
  /**
   * Creates a default texture for the given texture that can be used
   * as a placeholder until the actual texture is ready for usage.
   *
   * @param {Texture} texture - The texture to create a default texture for.
   */
  createDefaultTexture(texture3) {
    this.textureUtils.createDefaultTexture(texture3);
  }
  /**
   * Defines a texture on the GPU for the given texture object.
   *
   * @param {Texture} texture - The texture.
   * @param {Object} [options={}] - Optional configuration parameter.
   */
  createTexture(texture3, options) {
    this.textureUtils.createTexture(texture3, options);
  }
  /**
   * Uploads the updated texture data to the GPU.
   *
   * @param {Texture} texture - The texture.
   * @param {Object} [options={}] - Optional configuration parameter.
   */
  updateTexture(texture3, options) {
    this.textureUtils.updateTexture(texture3, options);
  }
  /**
   * Generates mipmaps for the given texture.
   *
   * @param {Texture} texture - The texture.
   */
  generateMipmaps(texture3) {
    this.textureUtils.generateMipmaps(texture3);
  }
  /**
   * Destroys the GPU data for the given texture object.
   *
   * @param {Texture} texture - The texture.
   */
  destroyTexture(texture3) {
    this.textureUtils.destroyTexture(texture3);
  }
  /**
   * Returns texture data as a typed array.
   *
   * @async
   * @param {Texture} texture - The texture to copy.
   * @param {number} x - The x coordinate of the copy origin.
   * @param {number} y - The y coordinate of the copy origin.
   * @param {number} width - The width of the copy.
   * @param {number} height - The height of the copy.
   * @param {number} faceIndex - The face index.
   * @return {Promise<TypedArray>} A Promise that resolves with a typed array when the copy operation has finished.
   */
  async copyTextureToBuffer(texture3, x, y, width, height, faceIndex) {
    return this.textureUtils.copyTextureToBuffer(texture3, x, y, width, height, faceIndex);
  }
  /**
   * Inits a time stamp query for the given render context.
   *
   * @param {string} type - The type of the timestamp query (e.g. 'render', 'compute').
   * @param {number} uid - Unique id for the context (e.g. render context id).
   * @param {Object} descriptor - The query descriptor.
   */
  initTimestampQuery(type, uid, descriptor) {
    if (!this.trackTimestamp) return;
    if (!this.timestampQueryPool[type]) {
      this.timestampQueryPool[type] = new WebGPUTimestampQueryPool(this.device, type, 2048);
    }
    const timestampQueryPool = this.timestampQueryPool[type];
    const baseOffset = timestampQueryPool.allocateQueriesForContext(uid);
    descriptor.timestampWrites = {
      querySet: timestampQueryPool.querySet,
      beginningOfPassWriteIndex: baseOffset,
      endOfPassWriteIndex: baseOffset + 1
    };
  }
  // node builder
  /**
   * Returns a node builder for the given render object.
   *
   * @param {RenderObject} object - The render object.
   * @param {Renderer} renderer - The renderer.
   * @return {WGSLNodeBuilder} The node builder.
   */
  createNodeBuilder(object2, renderer) {
    return new WGSLNodeBuilder(object2, renderer);
  }
  // program
  /**
   * Creates a shader program from the given programmable stage.
   *
   * @param {ProgrammableStage} program - The programmable stage.
   */
  createProgram(program) {
    const programGPU = this.get(program);
    programGPU.module = {
      module: this.device.createShaderModule({ code: program.code, label: program.stage + (program.name !== "" ? `_${program.name}` : "") }),
      entryPoint: "main"
    };
  }
  /**
   * Destroys the shader program of the given programmable stage.
   *
   * @param {ProgrammableStage} program - The programmable stage.
   */
  destroyProgram(program) {
    this.delete(program);
  }
  // pipelines
  /**
   * Creates a render pipeline for the given render object.
   *
   * @param {RenderObject} renderObject - The render object.
   * @param {Array<Promise>} promises - An array of compilation promises which are used in `compileAsync()`.
   */
  createRenderPipeline(renderObject, promises) {
    this.pipelineUtils.createRenderPipeline(renderObject, promises);
  }
  /**
   * Creates a compute pipeline for the given compute node.
   *
   * @param {ComputePipeline} computePipeline - The compute pipeline.
   * @param {Array<BindGroup>} bindings - The bindings.
   */
  createComputePipeline(computePipeline, bindings) {
    this.pipelineUtils.createComputePipeline(computePipeline, bindings);
  }
  /**
   * Prepares the state for encoding render bundles.
   *
   * @param {RenderContext} renderContext - The render context.
   */
  beginBundle(renderContext) {
    const renderContextData = this.get(renderContext);
    renderContextData._currentPass = renderContextData.currentPass;
    renderContextData._currentSets = renderContextData.currentSets;
    renderContextData.currentSets = { attributes: {}, bindingGroups: [], pipeline: null, index: null };
    renderContextData.currentPass = this.pipelineUtils.createBundleEncoder(renderContext);
  }
  /**
   * After processing render bundles this method finalizes related work.
   *
   * @param {RenderContext} renderContext - The render context.
   * @param {RenderBundle} bundle - The render bundle.
   */
  finishBundle(renderContext, bundle) {
    const renderContextData = this.get(renderContext);
    const bundleEncoder = renderContextData.currentPass;
    const bundleGPU = bundleEncoder.finish();
    this.get(bundle).bundleGPU = bundleGPU;
    renderContextData.currentSets = renderContextData._currentSets;
    renderContextData.currentPass = renderContextData._currentPass;
  }
  /**
   * Adds a render bundle to the render context data.
   *
   * @param {RenderContext} renderContext - The render context.
   * @param {RenderBundle} bundle - The render bundle to add.
   */
  addBundle(renderContext, bundle) {
    const renderContextData = this.get(renderContext);
    renderContextData.renderBundles.push(this.get(bundle).bundleGPU);
  }
  // bindings
  /**
   * Creates bindings from the given bind group definition.
   *
   * @param {BindGroup} bindGroup - The bind group.
   * @param {Array<BindGroup>} bindings - Array of bind groups.
   * @param {number} cacheIndex - The cache index.
   * @param {number} version - The version.
   */
  createBindings(bindGroup, bindings, cacheIndex, version) {
    this.bindingUtils.createBindings(bindGroup, bindings, cacheIndex, version);
  }
  /**
   * Updates the given bind group definition.
   *
   * @param {BindGroup} bindGroup - The bind group.
   * @param {Array<BindGroup>} bindings - Array of bind groups.
   * @param {number} cacheIndex - The cache index.
   * @param {number} version - The version.
   */
  updateBindings(bindGroup, bindings, cacheIndex, version) {
    this.bindingUtils.createBindings(bindGroup, bindings, cacheIndex, version);
  }
  /**
   * Updates a buffer binding.
   *
   *  @param {Buffer} binding - The buffer binding to update.
   */
  updateBinding(binding) {
    this.bindingUtils.updateBinding(binding);
  }
  // attributes
  /**
   * Creates the buffer of an indexed shader attribute.
   *
   * @param {BufferAttribute} attribute - The indexed buffer attribute.
   */
  createIndexAttribute(attribute3) {
    let usage = GPUBufferUsage.INDEX | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST;
    if (attribute3.isStorageBufferAttribute || attribute3.isStorageInstancedBufferAttribute) {
      usage |= GPUBufferUsage.STORAGE;
    }
    this.attributeUtils.createAttribute(attribute3, usage);
  }
  /**
   * Creates the GPU buffer of a shader attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute.
   */
  createAttribute(attribute3) {
    this.attributeUtils.createAttribute(attribute3, GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST);
  }
  /**
   * Creates the GPU buffer of a storage attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute.
   */
  createStorageAttribute(attribute3) {
    this.attributeUtils.createAttribute(attribute3, GPUBufferUsage.STORAGE | GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST);
  }
  /**
   * Creates the GPU buffer of an indirect storage attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute.
   */
  createIndirectStorageAttribute(attribute3) {
    this.attributeUtils.createAttribute(attribute3, GPUBufferUsage.STORAGE | GPUBufferUsage.INDIRECT | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST);
  }
  /**
   * Updates the GPU buffer of a shader attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute to update.
   */
  updateAttribute(attribute3) {
    this.attributeUtils.updateAttribute(attribute3);
  }
  /**
   * Destroys the GPU buffer of a shader attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute to destroy.
   */
  destroyAttribute(attribute3) {
    this.attributeUtils.destroyAttribute(attribute3);
  }
  // canvas
  /**
   * Triggers an update of the default render pass descriptor.
   */
  updateSize() {
    this.colorBuffer = this.textureUtils.getColorBuffer();
    this.defaultRenderPassdescriptor = null;
  }
  // utils public
  /**
   * Returns the maximum anisotropy texture filtering value.
   *
   * @return {number} The maximum anisotropy texture filtering value.
   */
  getMaxAnisotropy() {
    return 16;
  }
  /**
   * Checks if the given feature is supported by the backend.
   *
   * @param {string} name - The feature's name.
   * @return {boolean} Whether the feature is supported or not.
   */
  hasFeature(name) {
    return this.device.features.has(name);
  }
  /**
   * Copies data of the given source texture to the given destination texture.
   *
   * @param {Texture} srcTexture - The source texture.
   * @param {Texture} dstTexture - The destination texture.
   * @param {?(Box3|Box2)} [srcRegion=null] - The region of the source texture to copy.
   * @param {?(Vector2|Vector3)} [dstPosition=null] - The destination position of the copy.
   * @param {number} [srcLevel=0] - The mipmap level to copy.
   * @param {number} [dstLevel=0] - The destination mip level to copy to.
   */
  copyTextureToTexture(srcTexture, dstTexture, srcRegion = null, dstPosition = null, srcLevel = 0, dstLevel = 0) {
    let dstX = 0;
    let dstY = 0;
    let dstZ = 0;
    let srcX = 0;
    let srcY = 0;
    let srcZ = 0;
    let srcWidth = srcTexture.image.width;
    let srcHeight = srcTexture.image.height;
    let srcDepth = 1;
    if (srcRegion !== null) {
      if (srcRegion.isBox3 === true) {
        srcX = srcRegion.min.x;
        srcY = srcRegion.min.y;
        srcZ = srcRegion.min.z;
        srcWidth = srcRegion.max.x - srcRegion.min.x;
        srcHeight = srcRegion.max.y - srcRegion.min.y;
        srcDepth = srcRegion.max.z - srcRegion.min.z;
      } else {
        srcX = srcRegion.min.x;
        srcY = srcRegion.min.y;
        srcWidth = srcRegion.max.x - srcRegion.min.x;
        srcHeight = srcRegion.max.y - srcRegion.min.y;
        srcDepth = 1;
      }
    }
    if (dstPosition !== null) {
      dstX = dstPosition.x;
      dstY = dstPosition.y;
      dstZ = dstPosition.z || 0;
    }
    const encoder = this.device.createCommandEncoder({ label: "copyTextureToTexture_" + srcTexture.id + "_" + dstTexture.id });
    const sourceGPU = this.get(srcTexture).texture;
    const destinationGPU = this.get(dstTexture).texture;
    encoder.copyTextureToTexture(
      {
        texture: sourceGPU,
        mipLevel: srcLevel,
        origin: { x: srcX, y: srcY, z: srcZ }
      },
      {
        texture: destinationGPU,
        mipLevel: dstLevel,
        origin: { x: dstX, y: dstY, z: dstZ }
      },
      [
        srcWidth,
        srcHeight,
        srcDepth
      ]
    );
    this.device.queue.submit([encoder.finish()]);
    if (dstLevel === 0 && dstTexture.generateMipmaps) {
      this.textureUtils.generateMipmaps(dstTexture);
    }
  }
  /**
   * Copies the current bound framebuffer to the given texture.
   *
   * @param {Texture} texture - The destination texture.
   * @param {RenderContext} renderContext - The render context.
   * @param {Vector4} rectangle - A four dimensional vector defining the origin and dimension of the copy.
   */
  copyFramebufferToTexture(texture3, renderContext, rectangle) {
    const renderContextData = this.get(renderContext);
    let sourceGPU = null;
    if (renderContext.renderTarget) {
      if (texture3.isDepthTexture) {
        sourceGPU = this.get(renderContext.depthTexture).texture;
      } else {
        sourceGPU = this.get(renderContext.textures[0]).texture;
      }
    } else {
      if (texture3.isDepthTexture) {
        sourceGPU = this.textureUtils.getDepthBuffer(renderContext.depth, renderContext.stencil);
      } else {
        sourceGPU = this.context.getCurrentTexture();
      }
    }
    const destinationGPU = this.get(texture3).texture;
    if (sourceGPU.format !== destinationGPU.format) {
      console.error("WebGPUBackend: copyFramebufferToTexture: Source and destination formats do not match.", sourceGPU.format, destinationGPU.format);
      return;
    }
    let encoder;
    if (renderContextData.currentPass) {
      renderContextData.currentPass.end();
      encoder = renderContextData.encoder;
    } else {
      encoder = this.device.createCommandEncoder({ label: "copyFramebufferToTexture_" + texture3.id });
    }
    encoder.copyTextureToTexture(
      {
        texture: sourceGPU,
        origin: [rectangle.x, rectangle.y, 0]
      },
      {
        texture: destinationGPU
      },
      [
        rectangle.z,
        rectangle.w
      ]
    );
    if (renderContextData.currentPass) {
      const { descriptor } = renderContextData;
      for (let i = 0; i < descriptor.colorAttachments.length; i++) {
        descriptor.colorAttachments[i].loadOp = GPULoadOp.Load;
      }
      if (renderContext.depth) descriptor.depthStencilAttachment.depthLoadOp = GPULoadOp.Load;
      if (renderContext.stencil) descriptor.depthStencilAttachment.stencilLoadOp = GPULoadOp.Load;
      renderContextData.currentPass = encoder.beginRenderPass(descriptor);
      renderContextData.currentSets = { attributes: {}, bindingGroups: [], pipeline: null, index: null };
      if (renderContext.viewport) {
        this.updateViewport(renderContext);
      }
      if (renderContext.scissor) {
        const { x, y, width, height } = renderContext.scissorValue;
        renderContextData.currentPass.setScissorRect(x, y, width, height);
      }
    } else {
      this.device.queue.submit([encoder.finish()]);
    }
    if (texture3.generateMipmaps) {
      this.textureUtils.generateMipmaps(texture3);
    }
  }
};
var IESSpotLight = class extends SpotLight {
  /**
   * Constructs a new IES spot light.
   *
   * @param {(number|Color|string)} [color=0xffffff] - The light's color.
   * @param {number} [intensity=1] - The light's strength/intensity measured in candela (cd).
   * @param {number} [distance=0] - Maximum range of the light. `0` means no limit.
   * @param {number} [angle=Math.PI/3] - Maximum angle of light dispersion from its direction whose upper bound is `Math.PI/2`.
   * @param {number} [penumbra=0] - Percent of the spotlight cone that is attenuated due to penumbra. Value range is `[0,1]`.
   * @param {number} [decay=2] - The amount the light dims along the distance of the light.
   */
  constructor(color4, intensity, distance4, angle2, penumbra, decay) {
    super(color4, intensity, distance4, angle2, penumbra, decay);
    this.iesMap = null;
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.iesMap = source.iesMap;
    return this;
  }
};
var ProjectorLight = class extends SpotLight {
  /**
   * Constructs a new projector light.
   *
   * @param {(number|Color|string)} [color=0xffffff] - The light's color.
   * @param {number} [intensity=1] - The light's strength/intensity measured in candela (cd).
   * @param {number} [distance=0] - Maximum range of the light. `0` means no limit.
   * @param {number} [angle=Math.PI/3] - Maximum angle of light dispersion from its direction whose upper bound is `Math.PI/2`.
   * @param {number} [penumbra=0] - Percent of the spotlight cone that is attenuated due to penumbra. Value range is `[0,1]`.
   * @param {number} [decay=2] - The amount the light dims along the distance of the light.
   */
  constructor(color4, intensity, distance4, angle2, penumbra, decay) {
    super(color4, intensity, distance4, angle2, penumbra, decay);
    this.aspect = null;
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.aspect = source.aspect;
    return this;
  }
};
var StandardNodeLibrary = class extends NodeLibrary {
  /**
   * Constructs a new standard node library.
   */
  constructor() {
    super();
    this.addMaterial(MeshPhongNodeMaterial, "MeshPhongMaterial");
    this.addMaterial(MeshStandardNodeMaterial, "MeshStandardMaterial");
    this.addMaterial(MeshPhysicalNodeMaterial, "MeshPhysicalMaterial");
    this.addMaterial(MeshToonNodeMaterial, "MeshToonMaterial");
    this.addMaterial(MeshBasicNodeMaterial, "MeshBasicMaterial");
    this.addMaterial(MeshLambertNodeMaterial, "MeshLambertMaterial");
    this.addMaterial(MeshNormalNodeMaterial, "MeshNormalMaterial");
    this.addMaterial(MeshMatcapNodeMaterial, "MeshMatcapMaterial");
    this.addMaterial(LineBasicNodeMaterial, "LineBasicMaterial");
    this.addMaterial(LineDashedNodeMaterial, "LineDashedMaterial");
    this.addMaterial(PointsNodeMaterial, "PointsMaterial");
    this.addMaterial(SpriteNodeMaterial, "SpriteMaterial");
    this.addMaterial(ShadowNodeMaterial, "ShadowMaterial");
    this.addLight(PointLightNode, PointLight);
    this.addLight(DirectionalLightNode, DirectionalLight);
    this.addLight(RectAreaLightNode, RectAreaLight);
    this.addLight(SpotLightNode, SpotLight);
    this.addLight(AmbientLightNode, AmbientLight);
    this.addLight(HemisphereLightNode, HemisphereLight);
    this.addLight(LightProbeNode, LightProbe);
    this.addLight(IESSpotLightNode, IESSpotLight);
    this.addLight(ProjectorLightNode, ProjectorLight);
    this.addToneMapping(linearToneMapping, LinearToneMapping);
    this.addToneMapping(reinhardToneMapping, ReinhardToneMapping);
    this.addToneMapping(cineonToneMapping, CineonToneMapping);
    this.addToneMapping(acesFilmicToneMapping, ACESFilmicToneMapping);
    this.addToneMapping(agxToneMapping, AgXToneMapping);
    this.addToneMapping(neutralToneMapping, NeutralToneMapping);
  }
};
var WebGPURenderer = class extends Renderer {
  /**
   * WebGPURenderer options.
   *
   * @typedef {Object} WebGPURenderer~Options
   * @property {boolean} [logarithmicDepthBuffer=false] - Whether logarithmic depth buffer is enabled or not.
   * @property {boolean} [alpha=true] - Whether the default framebuffer (which represents the final contents of the canvas) should be transparent or opaque.
   * @property {boolean} [depth=true] - Whether the default framebuffer should have a depth buffer or not.
   * @property {boolean} [stencil=false] - Whether the default framebuffer should have a stencil buffer or not.
   * @property {boolean} [antialias=false] - Whether MSAA as the default anti-aliasing should be enabled or not.
   * @property {number} [samples=0] - When `antialias` is `true`, `4` samples are used by default. Set this parameter to any other integer value than 0 to overwrite the default.
   * @property {boolean} [forceWebGL=false] - If set to `true`, the renderer uses a WebGL 2 backend no matter if WebGPU is supported or not.
   * @property {boolean} [multiview=false] - If set to `true`, the renderer will use multiview during WebXR rendering if supported.
   * @property {number} [outputType=undefined] - Texture type for output to canvas. By default, device's preferred format is used; other formats may incur overhead.
   * @property {number} [colorBufferType=HalfFloatType] - Defines the type of color buffers. The default `HalfFloatType` is recommend for best
   * quality. To save memory and bandwidth, `UnsignedByteType` might be used. This will reduce rendering quality though.
   */
  /**
   * Constructs a new WebGPU renderer.
   *
   * @param {WebGPURenderer~Options} [parameters] - The configuration parameter.
   */
  constructor(parameters = {}) {
    let BackendClass;
    if (parameters.forceWebGL) {
      BackendClass = WebGLBackend;
    } else {
      BackendClass = WebGPUBackend;
      parameters.getFallback = () => {
        console.warn("THREE.WebGPURenderer: WebGPU is not available, running under WebGL2 backend.");
        return new WebGLBackend(parameters);
      };
    }
    const backend = new BackendClass(parameters);
    super(backend, parameters);
    this.library = new StandardNodeLibrary();
    this.isWebGPURenderer = true;
    if (typeof __THREE_DEVTOOLS__ !== "undefined") {
      __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
    }
  }
};

// node_modules/three/build/three.tsl.js
var BRDF_GGX2 = TSL.BRDF_GGX;
var BRDF_Lambert2 = TSL.BRDF_Lambert;
var BasicPointShadowFilter2 = TSL.BasicPointShadowFilter;
var BasicShadowFilter2 = TSL.BasicShadowFilter;
var Break2 = TSL.Break;
var Const2 = TSL.Const;
var Continue2 = TSL.Continue;
var DFGApprox2 = TSL.DFGApprox;
var D_GGX2 = TSL.D_GGX;
var Discard2 = TSL.Discard;
var EPSILON3 = TSL.EPSILON;
var F_Schlick2 = TSL.F_Schlick;
var Fn2 = TSL.Fn;
var INFINITY2 = TSL.INFINITY;
var If2 = TSL.If;
var Loop2 = TSL.Loop;
var NodeAccess2 = TSL.NodeAccess;
var NodeShaderStage2 = TSL.NodeShaderStage;
var NodeType2 = TSL.NodeType;
var NodeUpdateType2 = TSL.NodeUpdateType;
var PCFShadowFilter2 = TSL.PCFShadowFilter;
var PCFSoftShadowFilter2 = TSL.PCFSoftShadowFilter;
var PI3 = TSL.PI;
var PI22 = TSL.PI2;
var PointShadowFilter2 = TSL.PointShadowFilter;
var Return2 = TSL.Return;
var Schlick_to_F02 = TSL.Schlick_to_F0;
var ScriptableNodeResources2 = TSL.ScriptableNodeResources;
var ShaderNode2 = TSL.ShaderNode;
var Stack2 = TSL.Stack;
var Switch2 = TSL.Switch;
var TBNViewMatrix2 = TSL.TBNViewMatrix;
var VSMShadowFilter2 = TSL.VSMShadowFilter;
var V_GGX_SmithCorrelated2 = TSL.V_GGX_SmithCorrelated;
var Var2 = TSL.Var;
var VarIntent2 = TSL.VarIntent;
var abs3 = TSL.abs;
var acesFilmicToneMapping2 = TSL.acesFilmicToneMapping;
var acos3 = TSL.acos;
var add4 = TSL.add;
var addMethodChaining2 = TSL.addMethodChaining;
var addNodeElement2 = TSL.addNodeElement;
var agxToneMapping2 = TSL.agxToneMapping;
var all2 = TSL.all;
var alphaT2 = TSL.alphaT;
var and2 = TSL.and;
var anisotropy2 = TSL.anisotropy;
var anisotropyB2 = TSL.anisotropyB;
var anisotropyT2 = TSL.anisotropyT;
var any2 = TSL.any;
var append2 = TSL.append;
var array3 = TSL.array;
var arrayBuffer2 = TSL.arrayBuffer;
var asin4 = TSL.asin;
var assign2 = TSL.assign;
var atan4 = TSL.atan;
var atan24 = TSL.atan2;
var atomicAdd2 = TSL.atomicAdd;
var atomicAnd2 = TSL.atomicAnd;
var atomicFunc2 = TSL.atomicFunc;
var atomicLoad2 = TSL.atomicLoad;
var atomicMax2 = TSL.atomicMax;
var atomicMin2 = TSL.atomicMin;
var atomicOr2 = TSL.atomicOr;
var atomicStore2 = TSL.atomicStore;
var atomicSub2 = TSL.atomicSub;
var atomicXor2 = TSL.atomicXor;
var attenuationColor2 = TSL.attenuationColor;
var attenuationDistance2 = TSL.attenuationDistance;
var attribute2 = TSL.attribute;
var attributeArray2 = TSL.attributeArray;
var backgroundBlurriness2 = TSL.backgroundBlurriness;
var backgroundIntensity2 = TSL.backgroundIntensity;
var backgroundRotation2 = TSL.backgroundRotation;
var batch2 = TSL.batch;
var bentNormalView2 = TSL.bentNormalView;
var billboarding2 = TSL.billboarding;
var bitAnd2 = TSL.bitAnd;
var bitNot2 = TSL.bitNot;
var bitOr2 = TSL.bitOr;
var bitXor2 = TSL.bitXor;
var bitangentGeometry2 = TSL.bitangentGeometry;
var bitangentLocal2 = TSL.bitangentLocal;
var bitangentView2 = TSL.bitangentView;
var bitangentWorld2 = TSL.bitangentWorld;
var bitcast2 = TSL.bitcast;
var blendBurn2 = TSL.blendBurn;
var blendColor2 = TSL.blendColor;
var blendDodge2 = TSL.blendDodge;
var blendOverlay2 = TSL.blendOverlay;
var blendScreen2 = TSL.blendScreen;
var blur4 = TSL.blur;
var bool2 = TSL.bool;
var buffer2 = TSL.buffer;
var bufferAttribute2 = TSL.bufferAttribute;
var bumpMap2 = TSL.bumpMap;
var burn2 = TSL.burn;
var builtin2 = TSL.builtin;
var bvec22 = TSL.bvec2;
var bvec32 = TSL.bvec3;
var bvec42 = TSL.bvec4;
var bypass2 = TSL.bypass;
var cache2 = TSL.cache;
var call2 = TSL.call;
var cameraFar2 = TSL.cameraFar;
var cameraIndex2 = TSL.cameraIndex;
var cameraNear2 = TSL.cameraNear;
var cameraNormalMatrix2 = TSL.cameraNormalMatrix;
var cameraPosition2 = TSL.cameraPosition;
var cameraProjectionMatrix2 = TSL.cameraProjectionMatrix;
var cameraProjectionMatrixInverse2 = TSL.cameraProjectionMatrixInverse;
var cameraViewMatrix2 = TSL.cameraViewMatrix;
var cameraViewport2 = TSL.cameraViewport;
var cameraWorldMatrix2 = TSL.cameraWorldMatrix;
var cbrt2 = TSL.cbrt;
var cdl2 = TSL.cdl;
var ceil3 = TSL.ceil;
var checker2 = TSL.checker;
var cineonToneMapping2 = TSL.cineonToneMapping;
var clamp2 = TSL.clamp;
var clearcoat2 = TSL.clearcoat;
var clearcoatNormalView2 = TSL.clearcoatNormalView;
var clearcoatRoughness2 = TSL.clearcoatRoughness;
var code2 = TSL.code;
var color3 = TSL.color;
var colorSpaceToWorking2 = TSL.colorSpaceToWorking;
var colorToDirection2 = TSL.colorToDirection;
var compute2 = TSL.compute;
var computeKernel2 = TSL.computeKernel;
var computeSkinning2 = TSL.computeSkinning;
var context2 = TSL.context;
var convert2 = TSL.convert;
var convertColorSpace2 = TSL.convertColorSpace;
var convertToTexture2 = TSL.convertToTexture;
var cos4 = TSL.cos;
var cross3 = TSL.cross;
var cubeTexture2 = TSL.cubeTexture;
var cubeTextureBase2 = TSL.cubeTextureBase;
var cubeToUV2 = TSL.cubeToUV;
var dFdx2 = TSL.dFdx;
var dFdy2 = TSL.dFdy;
var dashSize2 = TSL.dashSize;
var debug2 = TSL.debug;
var decrement2 = TSL.decrement;
var decrementBefore2 = TSL.decrementBefore;
var defaultBuildStages2 = TSL.defaultBuildStages;
var defaultShaderStages2 = TSL.defaultShaderStages;
var defined2 = TSL.defined;
var degrees6 = TSL.degrees;
var deltaTime2 = TSL.deltaTime;
var densityFog2 = TSL.densityFog;
var densityFogFactor2 = TSL.densityFogFactor;
var depth2 = TSL.depth;
var depthPass2 = TSL.depthPass;
var determinant2 = TSL.determinant;
var difference3 = TSL.difference;
var diffuseColor2 = TSL.diffuseColor;
var directPointLight2 = TSL.directPointLight;
var directionToColor2 = TSL.directionToColor;
var directionToFaceDirection2 = TSL.directionToFaceDirection;
var dispersion2 = TSL.dispersion;
var distance3 = TSL.distance;
var div2 = TSL.div;
var dodge2 = TSL.dodge;
var dot2 = TSL.dot;
var drawIndex2 = TSL.drawIndex;
var dynamicBufferAttribute2 = TSL.dynamicBufferAttribute;
var element2 = TSL.element;
var emissive2 = TSL.emissive;
var equal2 = TSL.equal;
var equals3 = TSL.equals;
var equirectUV2 = TSL.equirectUV;
var exp3 = TSL.exp;
var exp23 = TSL.exp2;
var expression2 = TSL.expression;
var faceDirection2 = TSL.faceDirection;
var faceForward2 = TSL.faceForward;
var faceforward2 = TSL.faceforward;
var float2 = TSL.float;
var floatBitsToInt2 = TSL.floatBitsToInt;
var floatBitsToUint2 = TSL.floatBitsToUint;
var floor2 = TSL.floor;
var fog2 = TSL.fog;
var fract2 = TSL.fract;
var frameGroup2 = TSL.frameGroup;
var frameId2 = TSL.frameId;
var frontFacing2 = TSL.frontFacing;
var fwidth2 = TSL.fwidth;
var gain2 = TSL.gain;
var gapSize2 = TSL.gapSize;
var getConstNodeType2 = TSL.getConstNodeType;
var getCurrentStack2 = TSL.getCurrentStack;
var getDirection2 = TSL.getDirection;
var getDistanceAttenuation2 = TSL.getDistanceAttenuation;
var getGeometryRoughness2 = TSL.getGeometryRoughness;
var getNormalFromDepth2 = TSL.getNormalFromDepth;
var getParallaxCorrectNormal2 = TSL.getParallaxCorrectNormal;
var getRoughness2 = TSL.getRoughness;
var getScreenPosition2 = TSL.getScreenPosition;
var getShIrradianceAt2 = TSL.getShIrradianceAt;
var getShadowMaterial2 = TSL.getShadowMaterial;
var getShadowRenderObjectFunction2 = TSL.getShadowRenderObjectFunction;
var getTextureIndex2 = TSL.getTextureIndex;
var getViewPosition2 = TSL.getViewPosition;
var globalId2 = TSL.globalId;
var glsl2 = TSL.glsl;
var glslFn2 = TSL.glslFn;
var grayscale2 = TSL.grayscale;
var greaterThan2 = TSL.greaterThan;
var greaterThanEqual2 = TSL.greaterThanEqual;
var hash2 = TSL.hash;
var highpModelNormalViewMatrix2 = TSL.highpModelNormalViewMatrix;
var highpModelViewMatrix2 = TSL.highpModelViewMatrix;
var hue3 = TSL.hue;
var increment2 = TSL.increment;
var incrementBefore2 = TSL.incrementBefore;
var instance2 = TSL.instance;
var instanceIndex2 = TSL.instanceIndex;
var instancedArray2 = TSL.instancedArray;
var instancedBufferAttribute2 = TSL.instancedBufferAttribute;
var instancedDynamicBufferAttribute2 = TSL.instancedDynamicBufferAttribute;
var instancedMesh2 = TSL.instancedMesh;
var int2 = TSL.int;
var intBitsToFloat2 = TSL.intBitsToFloat;
var inverse2 = TSL.inverse;
var inverseSqrt2 = TSL.inverseSqrt;
var inversesqrt2 = TSL.inversesqrt;
var invocationLocalIndex2 = TSL.invocationLocalIndex;
var invocationSubgroupIndex2 = TSL.invocationSubgroupIndex;
var ior2 = TSL.ior;
var iridescence2 = TSL.iridescence;
var iridescenceIOR2 = TSL.iridescenceIOR;
var iridescenceThickness2 = TSL.iridescenceThickness;
var ivec22 = TSL.ivec2;
var ivec32 = TSL.ivec3;
var ivec42 = TSL.ivec4;
var js2 = TSL.js;
var label2 = TSL.label;
var length2 = TSL.length;
var lengthSq2 = TSL.lengthSq;
var lessThan2 = TSL.lessThan;
var lessThanEqual2 = TSL.lessThanEqual;
var lightPosition2 = TSL.lightPosition;
var lightProjectionUV2 = TSL.lightProjectionUV;
var lightShadowMatrix2 = TSL.lightShadowMatrix;
var lightTargetDirection2 = TSL.lightTargetDirection;
var lightTargetPosition2 = TSL.lightTargetPosition;
var lightViewPosition2 = TSL.lightViewPosition;
var lightingContext2 = TSL.lightingContext;
var lights2 = TSL.lights;
var linearDepth2 = TSL.linearDepth;
var linearToneMapping2 = TSL.linearToneMapping;
var localId2 = TSL.localId;
var log4 = TSL.log;
var log23 = TSL.log2;
var logarithmicDepthToViewZ2 = TSL.logarithmicDepthToViewZ;
var luminance2 = TSL.luminance;
var mat22 = TSL.mat2;
var mat32 = TSL.mat3;
var mat42 = TSL.mat4;
var matcapUV2 = TSL.matcapUV;
var materialAO2 = TSL.materialAO;
var materialAlphaTest2 = TSL.materialAlphaTest;
var materialAnisotropy2 = TSL.materialAnisotropy;
var materialAnisotropyVector2 = TSL.materialAnisotropyVector;
var materialAttenuationColor2 = TSL.materialAttenuationColor;
var materialAttenuationDistance2 = TSL.materialAttenuationDistance;
var materialClearcoat2 = TSL.materialClearcoat;
var materialClearcoatNormal2 = TSL.materialClearcoatNormal;
var materialClearcoatRoughness2 = TSL.materialClearcoatRoughness;
var materialColor2 = TSL.materialColor;
var materialDispersion2 = TSL.materialDispersion;
var materialEmissive2 = TSL.materialEmissive;
var materialEnvIntensity2 = TSL.materialEnvIntensity;
var materialEnvRotation2 = TSL.materialEnvRotation;
var materialIOR2 = TSL.materialIOR;
var materialIridescence2 = TSL.materialIridescence;
var materialIridescenceIOR2 = TSL.materialIridescenceIOR;
var materialIridescenceThickness2 = TSL.materialIridescenceThickness;
var materialLightMap2 = TSL.materialLightMap;
var materialLineDashOffset2 = TSL.materialLineDashOffset;
var materialLineDashSize2 = TSL.materialLineDashSize;
var materialLineGapSize2 = TSL.materialLineGapSize;
var materialLineScale2 = TSL.materialLineScale;
var materialLineWidth2 = TSL.materialLineWidth;
var materialMetalness2 = TSL.materialMetalness;
var materialNormal2 = TSL.materialNormal;
var materialOpacity2 = TSL.materialOpacity;
var materialPointSize2 = TSL.materialPointSize;
var materialReference2 = TSL.materialReference;
var materialReflectivity2 = TSL.materialReflectivity;
var materialRefractionRatio2 = TSL.materialRefractionRatio;
var materialRotation2 = TSL.materialRotation;
var materialRoughness2 = TSL.materialRoughness;
var materialSheen2 = TSL.materialSheen;
var materialSheenRoughness2 = TSL.materialSheenRoughness;
var materialShininess2 = TSL.materialShininess;
var materialSpecular2 = TSL.materialSpecular;
var materialSpecularColor2 = TSL.materialSpecularColor;
var materialSpecularIntensity2 = TSL.materialSpecularIntensity;
var materialSpecularStrength2 = TSL.materialSpecularStrength;
var materialThickness2 = TSL.materialThickness;
var materialTransmission2 = TSL.materialTransmission;
var max4 = TSL.max;
var maxMipLevel2 = TSL.maxMipLevel;
var mediumpModelViewMatrix2 = TSL.mediumpModelViewMatrix;
var metalness2 = TSL.metalness;
var min4 = TSL.min;
var mix2 = TSL.mix;
var mixElement2 = TSL.mixElement;
var mod2 = TSL.mod;
var modInt2 = TSL.modInt;
var modelDirection2 = TSL.modelDirection;
var modelNormalMatrix2 = TSL.modelNormalMatrix;
var modelPosition2 = TSL.modelPosition;
var modelRadius2 = TSL.modelRadius;
var modelScale2 = TSL.modelScale;
var modelViewMatrix2 = TSL.modelViewMatrix;
var modelViewPosition2 = TSL.modelViewPosition;
var modelViewProjection2 = TSL.modelViewProjection;
var modelWorldMatrix2 = TSL.modelWorldMatrix;
var modelWorldMatrixInverse2 = TSL.modelWorldMatrixInverse;
var morphReference2 = TSL.morphReference;
var mrt2 = TSL.mrt;
var mul2 = TSL.mul;
var mx_aastep2 = TSL.mx_aastep;
var mx_add2 = TSL.mx_add;
var mx_atan22 = TSL.mx_atan2;
var mx_cell_noise_float2 = TSL.mx_cell_noise_float;
var mx_contrast2 = TSL.mx_contrast;
var mx_divide2 = TSL.mx_divide;
var mx_fractal_noise_float2 = TSL.mx_fractal_noise_float;
var mx_fractal_noise_vec22 = TSL.mx_fractal_noise_vec2;
var mx_fractal_noise_vec32 = TSL.mx_fractal_noise_vec3;
var mx_fractal_noise_vec42 = TSL.mx_fractal_noise_vec4;
var mx_frame2 = TSL.mx_frame;
var mx_heighttonormal2 = TSL.mx_heighttonormal;
var mx_hsvtorgb2 = TSL.mx_hsvtorgb;
var mx_ifequal2 = TSL.mx_ifequal;
var mx_ifgreater2 = TSL.mx_ifgreater;
var mx_ifgreatereq2 = TSL.mx_ifgreatereq;
var mx_invert2 = TSL.mx_invert;
var mx_modulo2 = TSL.mx_modulo;
var mx_multiply2 = TSL.mx_multiply;
var mx_noise_float2 = TSL.mx_noise_float;
var mx_noise_vec32 = TSL.mx_noise_vec3;
var mx_noise_vec42 = TSL.mx_noise_vec4;
var mx_place2d2 = TSL.mx_place2d;
var mx_power2 = TSL.mx_power;
var mx_ramp42 = TSL.mx_ramp4;
var mx_ramplr2 = TSL.mx_ramplr;
var mx_ramptb2 = TSL.mx_ramptb;
var mx_rgbtohsv2 = TSL.mx_rgbtohsv;
var mx_rotate2d2 = TSL.mx_rotate2d;
var mx_rotate3d2 = TSL.mx_rotate3d;
var mx_safepower2 = TSL.mx_safepower;
var mx_separate2 = TSL.mx_separate;
var mx_splitlr2 = TSL.mx_splitlr;
var mx_splittb2 = TSL.mx_splittb;
var mx_srgb_texture_to_lin_rec7092 = TSL.mx_srgb_texture_to_lin_rec709;
var mx_subtract2 = TSL.mx_subtract;
var mx_timer2 = TSL.mx_timer;
var mx_transform_uv2 = TSL.mx_transform_uv;
var mx_unifiednoise2d2 = TSL.mx_unifiednoise2d;
var mx_unifiednoise3d2 = TSL.mx_unifiednoise3d;
var mx_worley_noise_float2 = TSL.mx_worley_noise_float;
var mx_worley_noise_vec22 = TSL.mx_worley_noise_vec2;
var mx_worley_noise_vec32 = TSL.mx_worley_noise_vec3;
var negate3 = TSL.negate;
var neutralToneMapping2 = TSL.neutralToneMapping;
var nodeArray2 = TSL.nodeArray;
var nodeImmutable2 = TSL.nodeImmutable;
var nodeObject2 = TSL.nodeObject;
var nodeObjectIntent2 = TSL.nodeObjectIntent;
var nodeObjects2 = TSL.nodeObjects;
var nodeProxy2 = TSL.nodeProxy;
var nodeProxyIntent2 = TSL.nodeProxyIntent;
var normalFlat2 = TSL.normalFlat;
var normalGeometry2 = TSL.normalGeometry;
var normalLocal2 = TSL.normalLocal;
var normalMap2 = TSL.normalMap;
var normalView2 = TSL.normalView;
var normalViewGeometry2 = TSL.normalViewGeometry;
var normalWorld2 = TSL.normalWorld;
var normalWorldGeometry2 = TSL.normalWorldGeometry;
var normalize3 = TSL.normalize;
var not2 = TSL.not;
var notEqual2 = TSL.notEqual;
var numWorkgroups2 = TSL.numWorkgroups;
var objectDirection2 = TSL.objectDirection;
var objectGroup2 = TSL.objectGroup;
var objectPosition2 = TSL.objectPosition;
var objectRadius2 = TSL.objectRadius;
var objectScale2 = TSL.objectScale;
var objectViewPosition2 = TSL.objectViewPosition;
var objectWorldMatrix2 = TSL.objectWorldMatrix;
var OnObjectUpdate2 = TSL.OnObjectUpdate;
var OnMaterialUpdate2 = TSL.OnMaterialUpdate;
var oneMinus2 = TSL.oneMinus;
var or2 = TSL.or;
var orthographicDepthToViewZ2 = TSL.orthographicDepthToViewZ;
var oscSawtooth2 = TSL.oscSawtooth;
var oscSine2 = TSL.oscSine;
var oscSquare2 = TSL.oscSquare;
var oscTriangle2 = TSL.oscTriangle;
var output2 = TSL.output;
var outputStruct2 = TSL.outputStruct;
var overlay2 = TSL.overlay;
var overloadingFn2 = TSL.overloadingFn;
var parabola2 = TSL.parabola;
var parallaxDirection2 = TSL.parallaxDirection;
var parallaxUV2 = TSL.parallaxUV;
var parameter2 = TSL.parameter;
var pass2 = TSL.pass;
var passTexture2 = TSL.passTexture;
var pcurve2 = TSL.pcurve;
var perspectiveDepthToViewZ2 = TSL.perspectiveDepthToViewZ;
var pmremTexture2 = TSL.pmremTexture;
var pointShadow2 = TSL.pointShadow;
var pointUV2 = TSL.pointUV;
var pointWidth2 = TSL.pointWidth;
var positionGeometry2 = TSL.positionGeometry;
var positionLocal2 = TSL.positionLocal;
var positionPrevious2 = TSL.positionPrevious;
var positionView2 = TSL.positionView;
var positionViewDirection2 = TSL.positionViewDirection;
var positionWorld2 = TSL.positionWorld;
var positionWorldDirection2 = TSL.positionWorldDirection;
var posterize2 = TSL.posterize;
var pow5 = TSL.pow;
var pow23 = TSL.pow2;
var pow33 = TSL.pow3;
var pow43 = TSL.pow4;
var premultiplyAlpha2 = TSL.premultiplyAlpha;
var property2 = TSL.property;
var radians5 = TSL.radians;
var rand2 = TSL.rand;
var range4 = TSL.range;
var rangeFog2 = TSL.rangeFog;
var rangeFogFactor2 = TSL.rangeFogFactor;
var reciprocal2 = TSL.reciprocal;
var reference2 = TSL.reference;
var referenceBuffer2 = TSL.referenceBuffer;
var reflect2 = TSL.reflect;
var reflectVector2 = TSL.reflectVector;
var reflectView2 = TSL.reflectView;
var reflector2 = TSL.reflector;
var refract2 = TSL.refract;
var refractVector2 = TSL.refractVector;
var refractView2 = TSL.refractView;
var reinhardToneMapping2 = TSL.reinhardToneMapping;
var remap2 = TSL.remap;
var remapClamp2 = TSL.remapClamp;
var renderGroup2 = TSL.renderGroup;
var renderOutput2 = TSL.renderOutput;
var rendererReference2 = TSL.rendererReference;
var rotate2 = TSL.rotate;
var rotateUV2 = TSL.rotateUV;
var roughness2 = TSL.roughness;
var round2 = TSL.round;
var rtt2 = TSL.rtt;
var sRGBTransferEOTF2 = TSL.sRGBTransferEOTF;
var sRGBTransferOETF2 = TSL.sRGBTransferOETF;
var sample2 = TSL.sample;
var sampler2 = TSL.sampler;
var samplerComparison2 = TSL.samplerComparison;
var saturate3 = TSL.saturate;
var saturation2 = TSL.saturation;
var screen2 = TSL.screen;
var screenCoordinate2 = TSL.screenCoordinate;
var screenDPR2 = TSL.screenDPR;
var screenSize2 = TSL.screenSize;
var screenUV2 = TSL.screenUV;
var scriptable2 = TSL.scriptable;
var scriptableValue2 = TSL.scriptableValue;
var select2 = TSL.select;
var setCurrentStack2 = TSL.setCurrentStack;
var setName2 = TSL.setName;
var shaderStages2 = TSL.shaderStages;
var shadow2 = TSL.shadow;
var shadowPositionWorld2 = TSL.shadowPositionWorld;
var shapeCircle2 = TSL.shapeCircle;
var sharedUniformGroup2 = TSL.sharedUniformGroup;
var sheen2 = TSL.sheen;
var sheenRoughness2 = TSL.sheenRoughness;
var shiftLeft2 = TSL.shiftLeft;
var shiftRight2 = TSL.shiftRight;
var shininess2 = TSL.shininess;
var sign5 = TSL.sign;
var sin4 = TSL.sin;
var sinc2 = TSL.sinc;
var skinning2 = TSL.skinning;
var smoothstep2 = TSL.smoothstep;
var smoothstepElement2 = TSL.smoothstepElement;
var specularColor2 = TSL.specularColor;
var specularF902 = TSL.specularF90;
var spherizeUV2 = TSL.spherizeUV;
var split2 = TSL.split;
var spritesheetUV2 = TSL.spritesheetUV;
var sqrt5 = TSL.sqrt;
var stack2 = TSL.stack;
var step2 = TSL.step;
var stepElement2 = TSL.stepElement;
var storage2 = TSL.storage;
var storageBarrier2 = TSL.storageBarrier;
var storageObject2 = TSL.storageObject;
var storageTexture2 = TSL.storageTexture;
var string2 = TSL.string;
var struct2 = TSL.struct;
var sub2 = TSL.sub;
var subgroupAdd2 = TSL.subgroupAdd;
var subgroupAll2 = TSL.subgroupAll;
var subgroupAnd2 = TSL.subgroupAnd;
var subgroupAny2 = TSL.subgroupAny;
var subgroupBallot2 = TSL.subgroupBallot;
var subgroupBroadcast2 = TSL.subgroupBroadcast;
var subgroupBroadcastFirst2 = TSL.subgroupBroadcastFirst;
var subBuild2 = TSL.subBuild;
var subgroupElect2 = TSL.subgroupElect;
var subgroupExclusiveAdd2 = TSL.subgroupExclusiveAdd;
var subgroupExclusiveMul2 = TSL.subgroupExclusiveMul;
var subgroupInclusiveAdd2 = TSL.subgroupInclusiveAdd;
var subgroupInclusiveMul2 = TSL.subgroupInclusiveMul;
var subgroupIndex2 = TSL.subgroupIndex;
var subgroupMax2 = TSL.subgroupMax;
var subgroupMin2 = TSL.subgroupMin;
var subgroupMul2 = TSL.subgroupMul;
var subgroupOr2 = TSL.subgroupOr;
var subgroupShuffle2 = TSL.subgroupShuffle;
var subgroupShuffleDown2 = TSL.subgroupShuffleDown;
var subgroupShuffleUp2 = TSL.subgroupShuffleUp;
var subgroupShuffleXor2 = TSL.subgroupShuffleXor;
var subgroupSize2 = TSL.subgroupSize;
var subgroupXor2 = TSL.subgroupXor;
var tan3 = TSL.tan;
var tangentGeometry2 = TSL.tangentGeometry;
var tangentLocal2 = TSL.tangentLocal;
var tangentView2 = TSL.tangentView;
var tangentWorld2 = TSL.tangentWorld;
var texture2 = TSL.texture;
var texture3D2 = TSL.texture3D;
var textureBarrier2 = TSL.textureBarrier;
var textureBicubic2 = TSL.textureBicubic;
var textureBicubicLevel2 = TSL.textureBicubicLevel;
var textureCubeUV2 = TSL.textureCubeUV;
var textureLoad2 = TSL.textureLoad;
var textureSize2 = TSL.textureSize;
var textureStore2 = TSL.textureStore;
var thickness2 = TSL.thickness;
var time3 = TSL.time;
var toneMapping2 = TSL.toneMapping;
var toneMappingExposure2 = TSL.toneMappingExposure;
var toonOutlinePass2 = TSL.toonOutlinePass;
var transformDirection2 = TSL.transformDirection;
var transformNormal2 = TSL.transformNormal;
var transformNormalToView2 = TSL.transformNormalToView;
var transformedClearcoatNormalView2 = TSL.transformedClearcoatNormalView;
var transformedNormalView2 = TSL.transformedNormalView;
var transformedNormalWorld2 = TSL.transformedNormalWorld;
var transmission2 = TSL.transmission;
var transpose3 = TSL.transpose;
var triNoise3D2 = TSL.triNoise3D;
var triplanarTexture2 = TSL.triplanarTexture;
var triplanarTextures2 = TSL.triplanarTextures;
var trunc2 = TSL.trunc;
var uint2 = TSL.uint;
var uintBitsToFloat2 = TSL.uintBitsToFloat;
var uniform2 = TSL.uniform;
var uniformArray2 = TSL.uniformArray;
var uniformCubeTexture2 = TSL.uniformCubeTexture;
var uniformGroup2 = TSL.uniformGroup;
var uniformFlow2 = TSL.uniformFlow;
var uniformTexture2 = TSL.uniformTexture;
var unpremultiplyAlpha2 = TSL.unpremultiplyAlpha;
var userData2 = TSL.userData;
var uv2 = TSL.uv;
var uvec22 = TSL.uvec2;
var uvec32 = TSL.uvec3;
var uvec42 = TSL.uvec4;
var varying2 = TSL.varying;
var varyingProperty2 = TSL.varyingProperty;
var vec22 = TSL.vec2;
var vec32 = TSL.vec3;
var vec42 = TSL.vec4;
var vectorComponents2 = TSL.vectorComponents;
var velocity2 = TSL.velocity;
var vertexColor2 = TSL.vertexColor;
var vertexIndex2 = TSL.vertexIndex;
var vertexStage2 = TSL.vertexStage;
var vibrance2 = TSL.vibrance;
var viewZToLogarithmicDepth2 = TSL.viewZToLogarithmicDepth;
var viewZToOrthographicDepth2 = TSL.viewZToOrthographicDepth;
var viewZToPerspectiveDepth2 = TSL.viewZToPerspectiveDepth;
var viewport2 = TSL.viewport;
var viewportCoordinate2 = TSL.viewportCoordinate;
var viewportDepthTexture2 = TSL.viewportDepthTexture;
var viewportLinearDepth2 = TSL.viewportLinearDepth;
var viewportMipTexture2 = TSL.viewportMipTexture;
var viewportResolution2 = TSL.viewportResolution;
var viewportSafeUV2 = TSL.viewportSafeUV;
var viewportSharedTexture2 = TSL.viewportSharedTexture;
var viewportSize2 = TSL.viewportSize;
var viewportTexture2 = TSL.viewportTexture;
var viewportUV2 = TSL.viewportUV;
var wgsl2 = TSL.wgsl;
var wgslFn2 = TSL.wgslFn;
var workgroupArray2 = TSL.workgroupArray;
var workgroupBarrier2 = TSL.workgroupBarrier;
var workgroupId2 = TSL.workgroupId;
var workingToColorSpace2 = TSL.workingToColorSpace;
var xor2 = TSL.xor;

// node_modules/three/examples/jsm/lines/LineSegmentsGeometry.js
var _box = new Box3();
var _vector = new Vector3();
var LineSegmentsGeometry = class extends InstancedBufferGeometry {
  /**
   * Constructs a new line segments geometry.
   */
  constructor() {
    super();
    this.isLineSegmentsGeometry = true;
    this.type = "LineSegmentsGeometry";
    const positions = [-1, 2, 0, 1, 2, 0, -1, 1, 0, 1, 1, 0, -1, 0, 0, 1, 0, 0, -1, -1, 0, 1, -1, 0];
    const uvs = [-1, 2, 1, 2, -1, 1, 1, 1, -1, -1, 1, -1, -1, -2, 1, -2];
    const index5 = [0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5];
    this.setIndex(index5);
    this.setAttribute("position", new Float32BufferAttribute(positions, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
  }
  /**
   * Applies the given 4x4 transformation matrix to the geometry.
   *
   * @param {Matrix4} matrix - The matrix to apply.
   * @return {LineSegmentsGeometry} A reference to this instance.
   */
  applyMatrix4(matrix) {
    const start = this.attributes.instanceStart;
    const end = this.attributes.instanceEnd;
    if (start !== void 0) {
      start.applyMatrix4(matrix);
      end.applyMatrix4(matrix);
      start.needsUpdate = true;
    }
    if (this.boundingBox !== null) {
      this.computeBoundingBox();
    }
    if (this.boundingSphere !== null) {
      this.computeBoundingSphere();
    }
    return this;
  }
  /**
   * Sets the given line positions for this geometry. The length must be a multiple of six since
   * each line segment is defined by a start end vertex in the pattern `(xyz xyz)`.
   *
   * @param {Float32Array|Array<number>} array - The position data to set.
   * @return {LineSegmentsGeometry} A reference to this geometry.
   */
  setPositions(array4) {
    let lineSegments;
    if (array4 instanceof Float32Array) {
      lineSegments = array4;
    } else if (Array.isArray(array4)) {
      lineSegments = new Float32Array(array4);
    }
    const instanceBuffer = new InstancedInterleavedBuffer(lineSegments, 6, 1);
    this.setAttribute("instanceStart", new InterleavedBufferAttribute(instanceBuffer, 3, 0));
    this.setAttribute("instanceEnd", new InterleavedBufferAttribute(instanceBuffer, 3, 3));
    this.instanceCount = this.attributes.instanceStart.count;
    this.computeBoundingBox();
    this.computeBoundingSphere();
    return this;
  }
  /**
   * Sets the given line colors for this geometry. The length must be a multiple of six since
   * each line segment is defined by a start end color in the pattern `(rgb rgb)`.
   *
   * @param {Float32Array|Array<number>} array - The position data to set.
   * @return {LineSegmentsGeometry} A reference to this geometry.
   */
  setColors(array4) {
    let colors;
    if (array4 instanceof Float32Array) {
      colors = array4;
    } else if (Array.isArray(array4)) {
      colors = new Float32Array(array4);
    }
    const instanceColorBuffer = new InstancedInterleavedBuffer(colors, 6, 1);
    this.setAttribute("instanceColorStart", new InterleavedBufferAttribute(instanceColorBuffer, 3, 0));
    this.setAttribute("instanceColorEnd", new InterleavedBufferAttribute(instanceColorBuffer, 3, 3));
    return this;
  }
  /**
   * Setups this line segments geometry from the given wireframe geometry.
   *
   * @param {WireframeGeometry} geometry - The geometry that should be used as a data source for this geometry.
   * @return {LineSegmentsGeometry} A reference to this geometry.
   */
  fromWireframeGeometry(geometry) {
    this.setPositions(geometry.attributes.position.array);
    return this;
  }
  /**
   * Setups this line segments geometry from the given edges geometry.
   *
   * @param {EdgesGeometry} geometry - The geometry that should be used as a data source for this geometry.
   * @return {LineSegmentsGeometry} A reference to this geometry.
   */
  fromEdgesGeometry(geometry) {
    this.setPositions(geometry.attributes.position.array);
    return this;
  }
  /**
   * Setups this line segments geometry from the given mesh.
   *
   * @param {Mesh} mesh - The mesh geometry that should be used as a data source for this geometry.
   * @return {LineSegmentsGeometry} A reference to this geometry.
   */
  fromMesh(mesh) {
    this.fromWireframeGeometry(new WireframeGeometry(mesh.geometry));
    return this;
  }
  /**
   * Setups this line segments geometry from the given line segments.
   *
   * @param {LineSegments} lineSegments - The line segments that should be used as a data source for this geometry.
   * Assumes the source geometry is not using indices.
   * @return {LineSegmentsGeometry} A reference to this geometry.
   */
  fromLineSegments(lineSegments) {
    const geometry = lineSegments.geometry;
    this.setPositions(geometry.attributes.position.array);
    return this;
  }
  computeBoundingBox() {
    if (this.boundingBox === null) {
      this.boundingBox = new Box3();
    }
    const start = this.attributes.instanceStart;
    const end = this.attributes.instanceEnd;
    if (start !== void 0 && end !== void 0) {
      this.boundingBox.setFromBufferAttribute(start);
      _box.setFromBufferAttribute(end);
      this.boundingBox.union(_box);
    }
  }
  computeBoundingSphere() {
    if (this.boundingSphere === null) {
      this.boundingSphere = new Sphere();
    }
    if (this.boundingBox === null) {
      this.computeBoundingBox();
    }
    const start = this.attributes.instanceStart;
    const end = this.attributes.instanceEnd;
    if (start !== void 0 && end !== void 0) {
      const center = this.boundingSphere.center;
      this.boundingBox.getCenter(center);
      let maxRadiusSq = 0;
      for (let i = 0, il = start.count; i < il; i++) {
        _vector.fromBufferAttribute(start, i);
        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector));
        _vector.fromBufferAttribute(end, i);
        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector));
      }
      this.boundingSphere.radius = Math.sqrt(maxRadiusSq);
      if (isNaN(this.boundingSphere.radius)) {
        console.error("THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.", this);
      }
    }
  }
  toJSON() {
  }
};

// node_modules/three/examples/jsm/lines/LineMaterial.js
UniformsLib.line = {
  worldUnits: { value: 1 },
  linewidth: { value: 1 },
  resolution: { value: new Vector2(1, 1) },
  dashOffset: { value: 0 },
  dashScale: { value: 1 },
  dashSize: { value: 1 },
  gapSize: { value: 1 }
  // todo FIX - maybe change to totalSize
};
ShaderLib["line"] = {
  uniforms: UniformsUtils.merge([
    UniformsLib.common,
    UniformsLib.fog,
    UniformsLib.line
  ]),
  vertexShader: (
    /* glsl */
    `
		#include <common>
		#include <color_pars_vertex>
		#include <fog_pars_vertex>
		#include <logdepthbuf_pars_vertex>
		#include <clipping_planes_pars_vertex>

		uniform float linewidth;
		uniform vec2 resolution;

		attribute vec3 instanceStart;
		attribute vec3 instanceEnd;

		attribute vec3 instanceColorStart;
		attribute vec3 instanceColorEnd;

		#ifdef WORLD_UNITS

			varying vec4 worldPos;
			varying vec3 worldStart;
			varying vec3 worldEnd;

			#ifdef USE_DASH

				varying vec2 vUv;

			#endif

		#else

			varying vec2 vUv;

		#endif

		#ifdef USE_DASH

			uniform float dashScale;
			attribute float instanceDistanceStart;
			attribute float instanceDistanceEnd;
			varying float vLineDistance;

		#endif

		void trimSegment( const in vec4 start, inout vec4 end ) {

			// trim end segment so it terminates between the camera plane and the near plane

			// conservative estimate of the near plane
			float a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column
			float b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column
			float nearEstimate = - 0.5 * b / a;

			float alpha = ( nearEstimate - start.z ) / ( end.z - start.z );

			end.xyz = mix( start.xyz, end.xyz, alpha );

		}

		void main() {

			#ifdef USE_COLOR

				vColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;

			#endif

			#ifdef USE_DASH

				vLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;
				vUv = uv;

			#endif

			float aspect = resolution.x / resolution.y;

			// camera space
			vec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );
			vec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );

			#ifdef WORLD_UNITS

				worldStart = start.xyz;
				worldEnd = end.xyz;

			#else

				vUv = uv;

			#endif

			// special case for perspective projection, and segments that terminate either in, or behind, the camera plane
			// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space
			// but we need to perform ndc-space calculations in the shader, so we must address this issue directly
			// perhaps there is a more elegant solution -- WestLangley

			bool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column

			if ( perspective ) {

				if ( start.z < 0.0 && end.z >= 0.0 ) {

					trimSegment( start, end );

				} else if ( end.z < 0.0 && start.z >= 0.0 ) {

					trimSegment( end, start );

				}

			}

			// clip space
			vec4 clipStart = projectionMatrix * start;
			vec4 clipEnd = projectionMatrix * end;

			// ndc space
			vec3 ndcStart = clipStart.xyz / clipStart.w;
			vec3 ndcEnd = clipEnd.xyz / clipEnd.w;

			// direction
			vec2 dir = ndcEnd.xy - ndcStart.xy;

			// account for clip-space aspect ratio
			dir.x *= aspect;
			dir = normalize( dir );

			#ifdef WORLD_UNITS

				vec3 worldDir = normalize( end.xyz - start.xyz );
				vec3 tmpFwd = normalize( mix( start.xyz, end.xyz, 0.5 ) );
				vec3 worldUp = normalize( cross( worldDir, tmpFwd ) );
				vec3 worldFwd = cross( worldDir, worldUp );
				worldPos = position.y < 0.5 ? start: end;

				// height offset
				float hw = linewidth * 0.5;
				worldPos.xyz += position.x < 0.0 ? hw * worldUp : - hw * worldUp;

				// don't extend the line if we're rendering dashes because we
				// won't be rendering the endcaps
				#ifndef USE_DASH

					// cap extension
					worldPos.xyz += position.y < 0.5 ? - hw * worldDir : hw * worldDir;

					// add width to the box
					worldPos.xyz += worldFwd * hw;

					// endcaps
					if ( position.y > 1.0 || position.y < 0.0 ) {

						worldPos.xyz -= worldFwd * 2.0 * hw;

					}

				#endif

				// project the worldpos
				vec4 clip = projectionMatrix * worldPos;

				// shift the depth of the projected points so the line
				// segments overlap neatly
				vec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;
				clip.z = clipPose.z * clip.w;

			#else

				vec2 offset = vec2( dir.y, - dir.x );
				// undo aspect ratio adjustment
				dir.x /= aspect;
				offset.x /= aspect;

				// sign flip
				if ( position.x < 0.0 ) offset *= - 1.0;

				// endcaps
				if ( position.y < 0.0 ) {

					offset += - dir;

				} else if ( position.y > 1.0 ) {

					offset += dir;

				}

				// adjust for linewidth
				offset *= linewidth;

				// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...
				offset /= resolution.y;

				// select end
				vec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;

				// back to clip space
				offset *= clip.w;

				clip.xy += offset;

			#endif

			gl_Position = clip;

			vec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation

			#include <logdepthbuf_vertex>
			#include <clipping_planes_vertex>
			#include <fog_vertex>

		}
		`
  ),
  fragmentShader: (
    /* glsl */
    `
		uniform vec3 diffuse;
		uniform float opacity;
		uniform float linewidth;

		#ifdef USE_DASH

			uniform float dashOffset;
			uniform float dashSize;
			uniform float gapSize;

		#endif

		varying float vLineDistance;

		#ifdef WORLD_UNITS

			varying vec4 worldPos;
			varying vec3 worldStart;
			varying vec3 worldEnd;

			#ifdef USE_DASH

				varying vec2 vUv;

			#endif

		#else

			varying vec2 vUv;

		#endif

		#include <common>
		#include <color_pars_fragment>
		#include <fog_pars_fragment>
		#include <logdepthbuf_pars_fragment>
		#include <clipping_planes_pars_fragment>

		vec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {

			float mua;
			float mub;

			vec3 p13 = p1 - p3;
			vec3 p43 = p4 - p3;

			vec3 p21 = p2 - p1;

			float d1343 = dot( p13, p43 );
			float d4321 = dot( p43, p21 );
			float d1321 = dot( p13, p21 );
			float d4343 = dot( p43, p43 );
			float d2121 = dot( p21, p21 );

			float denom = d2121 * d4343 - d4321 * d4321;

			float numer = d1343 * d4321 - d1321 * d4343;

			mua = numer / denom;
			mua = clamp( mua, 0.0, 1.0 );
			mub = ( d1343 + d4321 * ( mua ) ) / d4343;
			mub = clamp( mub, 0.0, 1.0 );

			return vec2( mua, mub );

		}

		void main() {

			float alpha = opacity;
			vec4 diffuseColor = vec4( diffuse, alpha );

			#include <clipping_planes_fragment>

			#ifdef USE_DASH

				if ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps

				if ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX

			#endif

			#ifdef WORLD_UNITS

				// Find the closest points on the view ray and the line segment
				vec3 rayEnd = normalize( worldPos.xyz ) * 1e5;
				vec3 lineDir = worldEnd - worldStart;
				vec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );

				vec3 p1 = worldStart + lineDir * params.x;
				vec3 p2 = rayEnd * params.y;
				vec3 delta = p1 - p2;
				float len = length( delta );
				float norm = len / linewidth;

				#ifndef USE_DASH

					#ifdef USE_ALPHA_TO_COVERAGE

						float dnorm = fwidth( norm );
						alpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );

					#else

						if ( norm > 0.5 ) {

							discard;

						}

					#endif

				#endif

			#else

				#ifdef USE_ALPHA_TO_COVERAGE

					// artifacts appear on some hardware if a derivative is taken within a conditional
					float a = vUv.x;
					float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
					float len2 = a * a + b * b;
					float dlen = fwidth( len2 );

					if ( abs( vUv.y ) > 1.0 ) {

						alpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );

					}

				#else

					if ( abs( vUv.y ) > 1.0 ) {

						float a = vUv.x;
						float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
						float len2 = a * a + b * b;

						if ( len2 > 1.0 ) discard;

					}

				#endif

			#endif

			#include <logdepthbuf_fragment>
			#include <color_fragment>

			gl_FragColor = vec4( diffuseColor.rgb, alpha );

			#include <tonemapping_fragment>
			#include <colorspace_fragment>
			#include <fog_fragment>
			#include <premultiplied_alpha_fragment>

		}
		`
  )
};
var LineMaterial = class extends ShaderMaterial {
  /**
   * Constructs a new line segments geometry.
   *
   * @param {Object} [parameters] - An object with one or more properties
   * defining the material's appearance. Any property of the material
   * (including any property from inherited materials) can be passed
   * in here. Color values can be passed any type of value accepted
   * by {@link Color#set}.
   */
  constructor(parameters) {
    super({
      type: "LineMaterial",
      uniforms: UniformsUtils.clone(ShaderLib["line"].uniforms),
      vertexShader: ShaderLib["line"].vertexShader,
      fragmentShader: ShaderLib["line"].fragmentShader,
      clipping: true
      // required for clipping support
    });
    this.isLineMaterial = true;
    this.setValues(parameters);
  }
  /**
   * The material's color.
   *
   * @type {Color}
   * @default (1,1,1)
   */
  get color() {
    return this.uniforms.diffuse.value;
  }
  set color(value) {
    this.uniforms.diffuse.value = value;
  }
  /**
   * Whether the material's sizes (width, dash gaps) are in world units.
   *
   * @type {boolean}
   * @default false
   */
  get worldUnits() {
    return "WORLD_UNITS" in this.defines;
  }
  set worldUnits(value) {
    if (value === true) {
      this.defines.WORLD_UNITS = "";
    } else {
      delete this.defines.WORLD_UNITS;
    }
  }
  /**
   * Controls line thickness in CSS pixel units when `worldUnits` is `false` (default),
   * or in world units when `worldUnits` is `true`.
   *
   * @type {number}
   * @default 1
   */
  get linewidth() {
    return this.uniforms.linewidth.value;
  }
  set linewidth(value) {
    if (!this.uniforms.linewidth) return;
    this.uniforms.linewidth.value = value;
  }
  /**
   * Whether the line is dashed, or solid.
   *
   * @type {boolean}
   * @default false
   */
  get dashed() {
    return "USE_DASH" in this.defines;
  }
  set dashed(value) {
    if (value === true !== this.dashed) {
      this.needsUpdate = true;
    }
    if (value === true) {
      this.defines.USE_DASH = "";
    } else {
      delete this.defines.USE_DASH;
    }
  }
  /**
   * The scale of the dashes and gaps.
   *
   * @type {number}
   * @default 1
   */
  get dashScale() {
    return this.uniforms.dashScale.value;
  }
  set dashScale(value) {
    this.uniforms.dashScale.value = value;
  }
  /**
   * The size of the dash.
   *
   * @type {number}
   * @default 1
   */
  get dashSize() {
    return this.uniforms.dashSize.value;
  }
  set dashSize(value) {
    this.uniforms.dashSize.value = value;
  }
  /**
   * Where in the dash cycle the dash starts.
   *
   * @type {number}
   * @default 0
   */
  get dashOffset() {
    return this.uniforms.dashOffset.value;
  }
  set dashOffset(value) {
    this.uniforms.dashOffset.value = value;
  }
  /**
   * The size of the gap.
   *
   * @type {number}
   * @default 0
   */
  get gapSize() {
    return this.uniforms.gapSize.value;
  }
  set gapSize(value) {
    this.uniforms.gapSize.value = value;
  }
  /**
   * The opacity.
   *
   * @type {number}
   * @default 1
   */
  get opacity() {
    return this.uniforms.opacity.value;
  }
  set opacity(value) {
    if (!this.uniforms) return;
    this.uniforms.opacity.value = value;
  }
  /**
   * The size of the viewport, in screen pixels. This must be kept updated to make
   * screen-space rendering accurate.The `LineSegments2.onBeforeRender` callback
   * performs the update for visible objects.
   *
   * @type {Vector2}
   */
  get resolution() {
    return this.uniforms.resolution.value;
  }
  set resolution(value) {
    this.uniforms.resolution.value.copy(value);
  }
  /**
   * Whether to use alphaToCoverage or not. When enabled, this can improve the
   * anti-aliasing of line edges when using MSAA.
   *
   * @type {boolean}
   */
  get alphaToCoverage() {
    return "USE_ALPHA_TO_COVERAGE" in this.defines;
  }
  set alphaToCoverage(value) {
    if (!this.defines) return;
    if (value === true !== this.alphaToCoverage) {
      this.needsUpdate = true;
    }
    if (value === true) {
      this.defines.USE_ALPHA_TO_COVERAGE = "";
    } else {
      delete this.defines.USE_ALPHA_TO_COVERAGE;
    }
  }
};

// node_modules/three/examples/jsm/lines/LineSegments2.js
var _viewport2 = new Vector4();
var _start = new Vector3();
var _end = new Vector3();
var _start4 = new Vector4();
var _end4 = new Vector4();
var _ssOrigin = new Vector4();
var _ssOrigin3 = new Vector3();
var _mvMatrix = new Matrix4();
var _line = new Line3();
var _closestPoint = new Vector3();
var _box2 = new Box3();
var _sphere2 = new Sphere();
var _clipToWorldVector = new Vector4();
var _ray;
var _lineWidth;
function getWorldSpaceHalfWidth(camera, distance4, resolution2) {
  _clipToWorldVector.set(0, 0, -distance4, 1).applyMatrix4(camera.projectionMatrix);
  _clipToWorldVector.multiplyScalar(1 / _clipToWorldVector.w);
  _clipToWorldVector.x = _lineWidth / resolution2.width;
  _clipToWorldVector.y = _lineWidth / resolution2.height;
  _clipToWorldVector.applyMatrix4(camera.projectionMatrixInverse);
  _clipToWorldVector.multiplyScalar(1 / _clipToWorldVector.w);
  return Math.abs(Math.max(_clipToWorldVector.x, _clipToWorldVector.y));
}
function raycastWorldUnits(lineSegments, intersects2) {
  const matrixWorld = lineSegments.matrixWorld;
  const geometry = lineSegments.geometry;
  const instanceStart = geometry.attributes.instanceStart;
  const instanceEnd = geometry.attributes.instanceEnd;
  const segmentCount = Math.min(geometry.instanceCount, instanceStart.count);
  for (let i = 0, l = segmentCount; i < l; i++) {
    _line.start.fromBufferAttribute(instanceStart, i);
    _line.end.fromBufferAttribute(instanceEnd, i);
    _line.applyMatrix4(matrixWorld);
    const pointOnLine = new Vector3();
    const point2 = new Vector3();
    _ray.distanceSqToSegment(_line.start, _line.end, point2, pointOnLine);
    const isInside = point2.distanceTo(pointOnLine) < _lineWidth * 0.5;
    if (isInside) {
      intersects2.push({
        point: point2,
        pointOnLine,
        distance: _ray.origin.distanceTo(point2),
        object: lineSegments,
        face: null,
        faceIndex: i,
        uv: null,
        uv1: null
      });
    }
  }
}
function raycastScreenSpace(lineSegments, camera, intersects2) {
  const projectionMatrix = camera.projectionMatrix;
  const material = lineSegments.material;
  const resolution2 = material.resolution;
  const matrixWorld = lineSegments.matrixWorld;
  const geometry = lineSegments.geometry;
  const instanceStart = geometry.attributes.instanceStart;
  const instanceEnd = geometry.attributes.instanceEnd;
  const segmentCount = Math.min(geometry.instanceCount, instanceStart.count);
  const near = -camera.near;
  _ray.at(1, _ssOrigin);
  _ssOrigin.w = 1;
  _ssOrigin.applyMatrix4(camera.matrixWorldInverse);
  _ssOrigin.applyMatrix4(projectionMatrix);
  _ssOrigin.multiplyScalar(1 / _ssOrigin.w);
  _ssOrigin.x *= resolution2.x / 2;
  _ssOrigin.y *= resolution2.y / 2;
  _ssOrigin.z = 0;
  _ssOrigin3.copy(_ssOrigin);
  _mvMatrix.multiplyMatrices(camera.matrixWorldInverse, matrixWorld);
  for (let i = 0, l = segmentCount; i < l; i++) {
    _start4.fromBufferAttribute(instanceStart, i);
    _end4.fromBufferAttribute(instanceEnd, i);
    _start4.w = 1;
    _end4.w = 1;
    _start4.applyMatrix4(_mvMatrix);
    _end4.applyMatrix4(_mvMatrix);
    const isBehindCameraNear = _start4.z > near && _end4.z > near;
    if (isBehindCameraNear) {
      continue;
    }
    if (_start4.z > near) {
      const deltaDist = _start4.z - _end4.z;
      const t = (_start4.z - near) / deltaDist;
      _start4.lerp(_end4, t);
    } else if (_end4.z > near) {
      const deltaDist = _end4.z - _start4.z;
      const t = (_end4.z - near) / deltaDist;
      _end4.lerp(_start4, t);
    }
    _start4.applyMatrix4(projectionMatrix);
    _end4.applyMatrix4(projectionMatrix);
    _start4.multiplyScalar(1 / _start4.w);
    _end4.multiplyScalar(1 / _end4.w);
    _start4.x *= resolution2.x / 2;
    _start4.y *= resolution2.y / 2;
    _end4.x *= resolution2.x / 2;
    _end4.y *= resolution2.y / 2;
    _line.start.copy(_start4);
    _line.start.z = 0;
    _line.end.copy(_end4);
    _line.end.z = 0;
    const param = _line.closestPointToPointParameter(_ssOrigin3, true);
    _line.at(param, _closestPoint);
    const zPos = MathUtils.lerp(_start4.z, _end4.z, param);
    const isInClipSpace = zPos >= -1 && zPos <= 1;
    const isInside = _ssOrigin3.distanceTo(_closestPoint) < _lineWidth * 0.5;
    if (isInClipSpace && isInside) {
      _line.start.fromBufferAttribute(instanceStart, i);
      _line.end.fromBufferAttribute(instanceEnd, i);
      _line.start.applyMatrix4(matrixWorld);
      _line.end.applyMatrix4(matrixWorld);
      const pointOnLine = new Vector3();
      const point2 = new Vector3();
      _ray.distanceSqToSegment(_line.start, _line.end, point2, pointOnLine);
      intersects2.push({
        point: point2,
        pointOnLine,
        distance: _ray.origin.distanceTo(point2),
        object: lineSegments,
        face: null,
        faceIndex: i,
        uv: null,
        uv1: null
      });
    }
  }
}
var LineSegments2 = class extends Mesh {
  /**
   * Constructs a new wide line.
   *
   * @param {LineSegmentsGeometry} [geometry] - The line geometry.
   * @param {LineMaterial} [material] - The line material.
   */
  constructor(geometry = new LineSegmentsGeometry(), material = new LineMaterial({ color: Math.random() * 16777215 })) {
    super(geometry, material);
    this.isLineSegments2 = true;
    this.type = "LineSegments2";
  }
  /**
   * Computes an array of distance values which are necessary for rendering dashed lines.
   * For each vertex in the geometry, the method calculates the cumulative length from the
   * current point to the very beginning of the line.
   *
   * @return {LineSegments2} A reference to this instance.
   */
  computeLineDistances() {
    const geometry = this.geometry;
    const instanceStart = geometry.attributes.instanceStart;
    const instanceEnd = geometry.attributes.instanceEnd;
    const lineDistances = new Float32Array(2 * instanceStart.count);
    for (let i = 0, j = 0, l = instanceStart.count; i < l; i++, j += 2) {
      _start.fromBufferAttribute(instanceStart, i);
      _end.fromBufferAttribute(instanceEnd, i);
      lineDistances[j] = j === 0 ? 0 : lineDistances[j - 1];
      lineDistances[j + 1] = lineDistances[j] + _start.distanceTo(_end);
    }
    const instanceDistanceBuffer = new InstancedInterleavedBuffer(lineDistances, 2, 1);
    geometry.setAttribute("instanceDistanceStart", new InterleavedBufferAttribute(instanceDistanceBuffer, 1, 0));
    geometry.setAttribute("instanceDistanceEnd", new InterleavedBufferAttribute(instanceDistanceBuffer, 1, 1));
    return this;
  }
  /**
   * Computes intersection points between a casted ray and this instance.
   *
   * @param {Raycaster} raycaster - The raycaster.
   * @param {Array<Object>} intersects - The target array that holds the intersection points.
   */
  raycast(raycaster, intersects2) {
    const worldUnits = this.material.worldUnits;
    const camera = raycaster.camera;
    if (camera === null && !worldUnits) {
      console.error('LineSegments2: "Raycaster.camera" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.');
    }
    const threshold2 = raycaster.params.Line2 !== void 0 ? raycaster.params.Line2.threshold || 0 : 0;
    _ray = raycaster.ray;
    const matrixWorld = this.matrixWorld;
    const geometry = this.geometry;
    const material = this.material;
    _lineWidth = material.linewidth + threshold2;
    if (geometry.boundingSphere === null) {
      geometry.computeBoundingSphere();
    }
    _sphere2.copy(geometry.boundingSphere).applyMatrix4(matrixWorld);
    let sphereMargin;
    if (worldUnits) {
      sphereMargin = _lineWidth * 0.5;
    } else {
      const distanceToSphere = Math.max(camera.near, _sphere2.distanceToPoint(_ray.origin));
      sphereMargin = getWorldSpaceHalfWidth(camera, distanceToSphere, material.resolution);
    }
    _sphere2.radius += sphereMargin;
    if (_ray.intersectsSphere(_sphere2) === false) {
      return;
    }
    if (geometry.boundingBox === null) {
      geometry.computeBoundingBox();
    }
    _box2.copy(geometry.boundingBox).applyMatrix4(matrixWorld);
    let boxMargin;
    if (worldUnits) {
      boxMargin = _lineWidth * 0.5;
    } else {
      const distanceToBox = Math.max(camera.near, _box2.distanceToPoint(_ray.origin));
      boxMargin = getWorldSpaceHalfWidth(camera, distanceToBox, material.resolution);
    }
    _box2.expandByScalar(boxMargin);
    if (_ray.intersectsBox(_box2) === false) {
      return;
    }
    if (worldUnits) {
      raycastWorldUnits(this, intersects2);
    } else {
      raycastScreenSpace(this, camera, intersects2);
    }
  }
  onBeforeRender(renderer) {
    const uniforms = this.material.uniforms;
    if (uniforms && uniforms.resolution) {
      renderer.getViewport(_viewport2);
      this.material.uniforms.resolution.value.set(_viewport2.z, _viewport2.w);
    }
  }
};

// node_modules/three/examples/jsm/lines/LineGeometry.js
var LineGeometry = class extends LineSegmentsGeometry {
  /**
   * Constructs a new line geometry.
   */
  constructor() {
    super();
    this.isLineGeometry = true;
    this.type = "LineGeometry";
  }
  /**
   * Sets the given line positions for this geometry.
   *
   * @param {Float32Array|Array<number>} array - The position data to set.
   * @return {LineGeometry} A reference to this geometry.
   */
  setPositions(array4) {
    const length3 = array4.length - 3;
    const points = new Float32Array(2 * length3);
    for (let i = 0; i < length3; i += 3) {
      points[2 * i] = array4[i];
      points[2 * i + 1] = array4[i + 1];
      points[2 * i + 2] = array4[i + 2];
      points[2 * i + 3] = array4[i + 3];
      points[2 * i + 4] = array4[i + 4];
      points[2 * i + 5] = array4[i + 5];
    }
    super.setPositions(points);
    return this;
  }
  /**
   * Sets the given line colors for this geometry.
   *
   * @param {Float32Array|Array<number>} array - The position data to set.
   * @return {LineGeometry} A reference to this geometry.
   */
  setColors(array4) {
    const length3 = array4.length - 3;
    const colors = new Float32Array(2 * length3);
    for (let i = 0; i < length3; i += 3) {
      colors[2 * i] = array4[i];
      colors[2 * i + 1] = array4[i + 1];
      colors[2 * i + 2] = array4[i + 2];
      colors[2 * i + 3] = array4[i + 3];
      colors[2 * i + 4] = array4[i + 4];
      colors[2 * i + 5] = array4[i + 5];
    }
    super.setColors(colors);
    return this;
  }
  /**
   * Setups this line segments geometry from the given sequence of points.
   *
   * @param {Array<Vector3|Vector2>} points - An array of points in 2D or 3D space.
   * @return {LineGeometry} A reference to this geometry.
   */
  setFromPoints(points) {
    const length3 = points.length - 1;
    const positions = new Float32Array(6 * length3);
    for (let i = 0; i < length3; i++) {
      positions[6 * i] = points[i].x;
      positions[6 * i + 1] = points[i].y;
      positions[6 * i + 2] = points[i].z || 0;
      positions[6 * i + 3] = points[i + 1].x;
      positions[6 * i + 4] = points[i + 1].y;
      positions[6 * i + 5] = points[i + 1].z || 0;
    }
    super.setPositions(positions);
    return this;
  }
  /**
   * Setups this line segments geometry from the given line.
   *
   * @param {Line} line - The line that should be used as a data source for this geometry.
   * @return {LineGeometry} A reference to this geometry.
   */
  fromLine(line) {
    const geometry = line.geometry;
    this.setPositions(geometry.attributes.position.array);
    return this;
  }
};

// node_modules/three/examples/jsm/lines/Line2.js
var Line2 = class extends LineSegments2 {
  /**
   * Constructs a new wide line.
   *
   * @param {LineGeometry} [geometry] - The line geometry.
   * @param {LineMaterial} [material] - The line material.
   */
  constructor(geometry = new LineGeometry(), material = new LineMaterial({ color: Math.random() * 16777215 })) {
    super(geometry, material);
    this.isLine2 = true;
    this.type = "Line2";
  }
};

// node_modules/three/examples/jsm/geometries/TextGeometry.js
var TextGeometry = class extends ExtrudeGeometry {
  /**
   * Constructs a new text geometry.
   *
   * @param {string} text - The text that should be transformed into a geometry.
   * @param {TextGeometry~Options} [parameters] - The text settings.
   */
  constructor(text, parameters = {}) {
    const font = parameters.font;
    if (font === void 0) {
      super();
    } else {
      const shapes = font.generateShapes(text, parameters.size);
      if (parameters.depth === void 0) parameters.depth = 50;
      if (parameters.bevelThickness === void 0) parameters.bevelThickness = 10;
      if (parameters.bevelSize === void 0) parameters.bevelSize = 8;
      if (parameters.bevelEnabled === void 0) parameters.bevelEnabled = false;
      super(shapes, parameters);
    }
    this.type = "TextGeometry";
  }
};

// node_modules/three/examples/jsm/loaders/FontLoader.js
var Font = class {
  /**
   * Constructs a new font.
   *
   * @param {Object} data - The font data as JSON.
   */
  constructor(data) {
    this.isFont = true;
    this.type = "Font";
    this.data = data;
  }
  /**
   * Generates geometry shapes from the given text and size. The result of this method
   * should be used with {@link ShapeGeometry} to generate the actual geometry data.
   *
   * @param {string} text - The text.
   * @param {number} [size=100] - The text size.
   * @return {Array<Shape>} An array of shapes representing the text.
   */
  generateShapes(text, size = 100) {
    const shapes = [];
    const paths = createPaths(text, size, this.data);
    for (let p = 0, pl = paths.length; p < pl; p++) {
      shapes.push(...paths[p].toShapes());
    }
    return shapes;
  }
};
function createPaths(text, size, data) {
  const chars = Array.from(text);
  const scale3 = size / data.resolution;
  const line_height = (data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness) * scale3;
  const paths = [];
  let offsetX = 0, offsetY = 0;
  for (let i = 0; i < chars.length; i++) {
    const char = chars[i];
    if (char === "\n") {
      offsetX = 0;
      offsetY -= line_height;
    } else {
      const ret = createPath(char, scale3, offsetX, offsetY, data);
      offsetX += ret.offsetX;
      paths.push(ret.path);
    }
  }
  return paths;
}
function createPath(char, scale3, offsetX, offsetY, data) {
  const glyph = data.glyphs[char] || data.glyphs["?"];
  if (!glyph) {
    console.error('THREE.Font: character "' + char + '" does not exists in font family ' + data.familyName + ".");
    return;
  }
  const path = new ShapePath();
  let x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2;
  if (glyph.o) {
    const outline = glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(" "));
    for (let i = 0, l = outline.length; i < l; ) {
      const action = outline[i++];
      switch (action) {
        case "m":
          x = outline[i++] * scale3 + offsetX;
          y = outline[i++] * scale3 + offsetY;
          path.moveTo(x, y);
          break;
        case "l":
          x = outline[i++] * scale3 + offsetX;
          y = outline[i++] * scale3 + offsetY;
          path.lineTo(x, y);
          break;
        case "q":
          cpx = outline[i++] * scale3 + offsetX;
          cpy = outline[i++] * scale3 + offsetY;
          cpx1 = outline[i++] * scale3 + offsetX;
          cpy1 = outline[i++] * scale3 + offsetY;
          path.quadraticCurveTo(cpx1, cpy1, cpx, cpy);
          break;
        case "b":
          cpx = outline[i++] * scale3 + offsetX;
          cpy = outline[i++] * scale3 + offsetY;
          cpx1 = outline[i++] * scale3 + offsetX;
          cpy1 = outline[i++] * scale3 + offsetY;
          cpx2 = outline[i++] * scale3 + offsetX;
          cpy2 = outline[i++] * scale3 + offsetY;
          path.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy);
          break;
      }
    }
  }
  return { offsetX: glyph.ha * scale3, path };
}

// node_modules/three/examples/jsm/renderers/CSS2DRenderer.js
var CSS2DObject = class extends Object3D {
  /**
   * Constructs a new CSS2D object.
   *
   * @param {DOMElement} [element] - The DOM element.
   */
  constructor(element3 = document.createElement("div")) {
    super();
    this.isCSS2DObject = true;
    this.element = element3;
    this.element.style.position = "absolute";
    this.element.style.userSelect = "none";
    this.element.setAttribute("draggable", false);
    this.center = new Vector2(0.5, 0.5);
    this.addEventListener("removed", function() {
      this.traverse(function(object2) {
        if (object2.element instanceof object2.element.ownerDocument.defaultView.Element && object2.element.parentNode !== null) {
          object2.element.remove();
        }
      });
    });
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.element = source.element.cloneNode(true);
    this.center = source.center;
    return this;
  }
};
var _vector3 = new Vector3();
var _viewMatrix = new Matrix4();
var _viewProjectionMatrix = new Matrix4();
var _a = new Vector3();
var _b = new Vector3();

// node_modules/three-globe/dist/three-globe.mjs
function _arrayLikeToArray7(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}
function _arrayWithHoles7(r) {
  if (Array.isArray(r)) return r;
}
function _arrayWithoutHoles6(r) {
  if (Array.isArray(r)) return _arrayLikeToArray7(r);
}
function _assertClassBrand3(e, t, n) {
  if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n;
  throw new TypeError("Private element is not present on this object");
}
function _assertThisInitialized4(e) {
  if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function asyncGeneratorStep(n, t, e, r, o, a, c3) {
  try {
    var i = n[a](c3), u4 = i.value;
  } catch (n2) {
    return void e(n2);
  }
  i.done ? t(u4) : Promise.resolve(u4).then(r, o);
}
function _asyncToGenerator(n) {
  return function() {
    var t = this, e = arguments;
    return new Promise(function(r, o) {
      var a = n.apply(t, e);
      function _next(n2) {
        asyncGeneratorStep(a, r, o, _next, _throw, "next", n2);
      }
      function _throw(n2) {
        asyncGeneratorStep(a, r, o, _next, _throw, "throw", n2);
      }
      _next(void 0);
    });
  };
}
function _callSuper4(t, o, e) {
  return o = _getPrototypeOf4(o), _possibleConstructorReturn4(t, _isNativeReflectConstruct4() ? Reflect.construct(o, e || [], _getPrototypeOf4(t).constructor) : o.apply(t, e));
}
function _checkPrivateRedeclaration3(e, t) {
  if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object");
}
function _classCallCheck6(a, n) {
  if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
}
function _classPrivateFieldGet23(s, a) {
  return s.get(_assertClassBrand3(s, a));
}
function _classPrivateFieldInitSpec3(e, t, a) {
  _checkPrivateRedeclaration3(e, t), t.set(e, a);
}
function _classPrivateFieldSet23(s, a, r) {
  return s.set(_assertClassBrand3(s, a), r), r;
}
function _construct(t, e, r) {
  if (_isNativeReflectConstruct4()) return Reflect.construct.apply(null, arguments);
  var o = [null];
  o.push.apply(o, e);
  var p = new (t.bind.apply(t, o))();
  return p;
}
function _defineProperties3(e, r) {
  for (var t = 0; t < r.length; t++) {
    var o = r[t];
    o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey4(o.key), o);
  }
}
function _createClass6(e, r, t) {
  return r && _defineProperties3(e.prototype, r), Object.defineProperty(e, "prototype", {
    writable: false
  }), e;
}
function _defineProperty2(e, r, t) {
  return (r = _toPropertyKey4(r)) in e ? Object.defineProperty(e, r, {
    value: t,
    enumerable: true,
    configurable: true,
    writable: true
  }) : e[r] = t, e;
}
function _get() {
  return _get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function(e, t, r) {
    var p = _superPropBase(e, t);
    if (p) {
      var n = Object.getOwnPropertyDescriptor(p, t);
      return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value;
    }
  }, _get.apply(null, arguments);
}
function _getPrototypeOf4(t) {
  return _getPrototypeOf4 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t4) {
    return t4.__proto__ || Object.getPrototypeOf(t4);
  }, _getPrototypeOf4(t);
}
function _inherits4(t, e) {
  if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
  t.prototype = Object.create(e && e.prototype, {
    constructor: {
      value: t,
      writable: true,
      configurable: true
    }
  }), Object.defineProperty(t, "prototype", {
    writable: false
  }), e && _setPrototypeOf4(t, e);
}
function _isNativeReflectConstruct4() {
  try {
    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (t4) {
  }
  return (_isNativeReflectConstruct4 = function() {
    return !!t;
  })();
}
function _iterableToArray6(r) {
  if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
}
function _iterableToArrayLimit7(r, l) {
  var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (null != t) {
    var e, n, i, u4, a = [], f = true, o = false;
    try {
      if (i = (t = t.call(r)).next, 0 === l) {
        if (Object(t) !== t) return;
        f = false;
      } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = true) ;
    } catch (r2) {
      o = true, n = r2;
    } finally {
      try {
        if (!f && null != t.return && (u4 = t.return(), Object(u4) !== u4)) return;
      } finally {
        if (o) throw n;
      }
    }
    return a;
  }
}
function _nonIterableRest7() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _nonIterableSpread6() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function ownKeys(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread2(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
      _defineProperty2(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _objectWithoutProperties2(e, t) {
  if (null == e) return {};
  var o, r, i = _objectWithoutPropertiesLoose2(e, t);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(e);
    for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
  }
  return i;
}
function _objectWithoutPropertiesLoose2(r, e) {
  if (null == r) return {};
  var t = {};
  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
    if (-1 !== e.indexOf(n)) continue;
    t[n] = r[n];
  }
  return t;
}
function _possibleConstructorReturn4(t, e) {
  if (e && ("object" == typeof e || "function" == typeof e)) return e;
  if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
  return _assertThisInitialized4(t);
}
function _regenerator() {
  var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag";
  function i(r2, n2, o2, i2) {
    var c4 = n2 && n2.prototype instanceof Generator ? n2 : Generator, u5 = Object.create(c4.prototype);
    return _regeneratorDefine(u5, "_invoke", function(r3, n3, o3) {
      var i3, c5, u6, f2 = 0, p = o3 || [], y = false, G = {
        p: 0,
        n: 0,
        v: e,
        a: d,
        f: d.bind(e, 4),
        d: function(t4, r4) {
          return i3 = t4, c5 = 0, u6 = e, G.n = r4, a;
        }
      };
      function d(r4, n4) {
        for (c5 = r4, u6 = n4, t = 0; !y && f2 && !o4 && t < p.length; t++) {
          var o4, i4 = p[t], d2 = G.p, l = i4[2];
          r4 > 3 ? (o4 = l === n4) && (u6 = i4[(c5 = i4[4]) ? 5 : (c5 = 3, 3)], i4[4] = i4[5] = e) : i4[0] <= d2 && ((o4 = r4 < 2 && d2 < i4[1]) ? (c5 = 0, G.v = n4, G.n = i4[1]) : d2 < l && (o4 = r4 < 3 || i4[0] > n4 || n4 > l) && (i4[4] = r4, i4[5] = n4, G.n = l, c5 = 0));
        }
        if (o4 || r4 > 1) return a;
        throw y = true, n4;
      }
      return function(o4, p2, l) {
        if (f2 > 1) throw TypeError("Generator is already running");
        for (y && 1 === p2 && d(p2, l), c5 = p2, u6 = l; (t = c5 < 2 ? e : u6) || !y; ) {
          i3 || (c5 ? c5 < 3 ? (c5 > 1 && (G.n = -1), d(c5, u6)) : G.n = u6 : G.v = u6);
          try {
            if (f2 = 2, i3) {
              if (c5 || (o4 = "next"), t = i3[o4]) {
                if (!(t = t.call(i3, u6))) throw TypeError("iterator result is not an object");
                if (!t.done) return t;
                u6 = t.value, c5 < 2 && (c5 = 0);
              } else 1 === c5 && (t = i3.return) && t.call(i3), c5 < 2 && (u6 = TypeError("The iterator does not provide a '" + o4 + "' method"), c5 = 1);
              i3 = e;
            } else if ((t = (y = G.n < 0) ? u6 : r3.call(n3, G)) !== a) break;
          } catch (t4) {
            i3 = e, c5 = 1, u6 = t4;
          } finally {
            f2 = 1;
          }
        }
        return {
          value: t,
          done: y
        };
      };
    }(r2, o2, i2), true), u5;
  }
  var a = {};
  function Generator() {
  }
  function GeneratorFunction() {
  }
  function GeneratorFunctionPrototype() {
  }
  t = Object.getPrototypeOf;
  var c3 = [][n] ? t(t([][n]())) : (_regeneratorDefine(t = {}, n, function() {
    return this;
  }), t), u4 = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c3);
  function f(e3) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(e3, GeneratorFunctionPrototype) : (e3.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine(e3, o, "GeneratorFunction")), e3.prototype = Object.create(u4), e3;
  }
  return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine(u4, "constructor", GeneratorFunctionPrototype), _regeneratorDefine(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", _regeneratorDefine(GeneratorFunctionPrototype, o, "GeneratorFunction"), _regeneratorDefine(u4), _regeneratorDefine(u4, o, "Generator"), _regeneratorDefine(u4, n, function() {
    return this;
  }), _regeneratorDefine(u4, "toString", function() {
    return "[object Generator]";
  }), (_regenerator = function() {
    return {
      w: i,
      m: f
    };
  })();
}
function _regeneratorDefine(e, r, n, t) {
  var i = Object.defineProperty;
  try {
    i({}, "", {});
  } catch (e3) {
    i = 0;
  }
  _regeneratorDefine = function(e3, r2, n2, t4) {
    function o(r3, n3) {
      _regeneratorDefine(e3, r3, function(e4) {
        return this._invoke(r3, n3, e4);
      });
    }
    r2 ? i ? i(e3, r2, {
      value: n2,
      enumerable: !t4,
      configurable: !t4,
      writable: !t4
    }) : e3[r2] = n2 : (o("next", 0), o("throw", 1), o("return", 2));
  }, _regeneratorDefine(e, r, n, t);
}
function _setPrototypeOf4(t, e) {
  return _setPrototypeOf4 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t4, e3) {
    return t4.__proto__ = e3, t4;
  }, _setPrototypeOf4(t, e);
}
function _slicedToArray7(r, e) {
  return _arrayWithHoles7(r) || _iterableToArrayLimit7(r, e) || _unsupportedIterableToArray7(r, e) || _nonIterableRest7();
}
function _superPropBase(t, o) {
  for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf4(t)); ) ;
  return t;
}
function _superPropGet(t, o, e, r) {
  var p = _get(_getPrototypeOf4(t.prototype), o, e);
  return "function" == typeof p ? function(t4) {
    return p.apply(e, t4);
  } : p;
}
function _toConsumableArray6(r) {
  return _arrayWithoutHoles6(r) || _iterableToArray6(r) || _unsupportedIterableToArray7(r) || _nonIterableSpread6();
}
function _toPrimitive4(t, r) {
  if ("object" != typeof t || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r);
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function _toPropertyKey4(t) {
  var i = _toPrimitive4(t, "string");
  return "symbol" == typeof i ? i : i + "";
}
function _unsupportedIterableToArray7(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray7(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray7(r, a) : void 0;
  }
}
var _materialDispose2 = function materialDispose2(material) {
  if (material instanceof Array) {
    material.forEach(_materialDispose2);
  } else {
    if (material.map) {
      material.map.dispose();
    }
    material.dispose();
  }
};
var _deallocate2 = function deallocate2(obj) {
  if (obj.geometry) {
    obj.geometry.dispose();
  }
  if (obj.material) {
    _materialDispose2(obj.material);
  }
  if (obj.texture) {
    obj.texture.dispose();
  }
  if (obj.children) {
    obj.children.forEach(_deallocate2);
  }
};
var emptyObject3 = function emptyObject4(obj) {
  if (obj && obj.children) while (obj.children.length) {
    var childObj = obj.children[0];
    obj.remove(childObj);
    _deallocate2(childObj);
  }
};
function linkKapsule(kapsulePropName, kapsuleType) {
  var dummyK = new kapsuleType();
  return {
    linkProp: function linkProp(prop) {
      return {
        "default": dummyK[prop](),
        onChange: function onChange10(v2, state) {
          state[kapsulePropName][prop](v2);
        },
        triggerUpdate: false
      };
    },
    linkMethod: function linkMethod(method) {
      return function(state) {
        var kapsuleInstance = state[kapsulePropName];
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }
        var returnVal = kapsuleInstance[method].apply(kapsuleInstance, args);
        return returnVal === kapsuleInstance ? this : returnVal;
      };
    }
  };
}
var GLOBE_RADIUS = 100;
function getGlobeRadius() {
  return GLOBE_RADIUS;
}
function polar2Cartesian4(lat, lng) {
  var relAltitude = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
  var phi = (90 - lat) * Math.PI / 180;
  var theta = (90 - lng) * Math.PI / 180;
  var r = GLOBE_RADIUS * (1 + relAltitude);
  var phiSin = Math.sin(phi);
  return {
    x: r * phiSin * Math.cos(theta),
    y: r * Math.cos(phi),
    z: r * phiSin * Math.sin(theta)
  };
}
function cartesian2Polar2(_ref) {
  var x = _ref.x, y = _ref.y, z = _ref.z;
  var r = Math.sqrt(x * x + y * y + z * z);
  var phi = Math.acos(y / r);
  var theta = Math.atan2(z, x);
  return {
    lat: 90 - phi * 180 / Math.PI,
    lng: 90 - theta * 180 / Math.PI - (theta < -Math.PI / 2 ? 360 : 0),
    // keep within [-180, 180] boundaries
    altitude: r / GLOBE_RADIUS - 1
  };
}
function deg2Rad$1(deg) {
  return deg * Math.PI / 180;
}
var THREE$i = window.THREE ? window.THREE : {
  BackSide,
  BufferAttribute,
  Color,
  Mesh,
  ShaderMaterial
};
var vertexShader = "\nuniform float hollowRadius;\n\nvarying vec3 vVertexWorldPosition;\nvarying vec3 vVertexNormal;\nvarying float vCameraDistanceToObjCenter;\nvarying float vVertexAngularDistanceToHollowRadius;\n\nvoid main() {    \n  vVertexNormal	= normalize(normalMatrix * normal);\n  vVertexWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;\n  \n  vec4 objCenterViewPosition = modelViewMatrix * vec4(0.0, 0.0, 0.0, 1.0);\n  vCameraDistanceToObjCenter = length(objCenterViewPosition);\n  \n  float edgeAngle = atan(hollowRadius / vCameraDistanceToObjCenter);\n  float vertexAngle = acos(dot(normalize(modelViewMatrix * vec4(position, 1.0)), normalize(objCenterViewPosition)));\n  vVertexAngularDistanceToHollowRadius = vertexAngle - edgeAngle;\n\n  gl_Position	= projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}";
var fragmentShader = "\nuniform vec3 color;\nuniform float coefficient;\nuniform float power;\nuniform float hollowRadius;\n\nvarying vec3 vVertexNormal;\nvarying vec3 vVertexWorldPosition;\nvarying float vCameraDistanceToObjCenter;\nvarying float vVertexAngularDistanceToHollowRadius;\n\nvoid main() {\n  if (vCameraDistanceToObjCenter < hollowRadius) discard; // inside the hollowRadius\n  if (vVertexAngularDistanceToHollowRadius < 0.0) discard; // frag position is within the hollow radius\n\n  vec3 worldCameraToVertex = vVertexWorldPosition - cameraPosition;\n  vec3 viewCameraToVertex	= (viewMatrix * vec4(worldCameraToVertex, 0.0)).xyz;\n  viewCameraToVertex = normalize(viewCameraToVertex);\n  float intensity	= pow(\n    coefficient + dot(vVertexNormal, viewCameraToVertex),\n    power\n  );\n  gl_FragColor = vec4(color, intensity);\n}";
function createGlowMaterial(coefficient, color4, power, hollowRadius) {
  return new THREE$i.ShaderMaterial({
    depthWrite: false,
    transparent: true,
    vertexShader,
    fragmentShader,
    uniforms: {
      coefficient: {
        value: coefficient
      },
      color: {
        value: new THREE$i.Color(color4)
      },
      power: {
        value: power
      },
      hollowRadius: {
        value: hollowRadius
      }
    }
  });
}
function createGlowGeometry(geometry, size) {
  var glowGeometry = geometry.clone();
  var position = new Float32Array(geometry.attributes.position.count * 3);
  for (var idx = 0, len = position.length; idx < len; idx++) {
    var normal2 = geometry.attributes.normal.array[idx];
    var curPos = geometry.attributes.position.array[idx];
    position[idx] = curPos + normal2 * size;
  }
  glowGeometry.setAttribute("position", new THREE$i.BufferAttribute(position, 3));
  return glowGeometry;
}
var GlowMesh = function(_THREE$Mesh) {
  function GlowMesh2(geometry) {
    var _this;
    var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$color = _ref.color, color4 = _ref$color === void 0 ? "gold" : _ref$color, _ref$size = _ref.size, size = _ref$size === void 0 ? 2 : _ref$size, _ref$coefficient = _ref.coefficient, coefficient = _ref$coefficient === void 0 ? 0.5 : _ref$coefficient, _ref$power = _ref.power, power = _ref$power === void 0 ? 1 : _ref$power, _ref$hollowRadius = _ref.hollowRadius, hollowRadius = _ref$hollowRadius === void 0 ? 0 : _ref$hollowRadius, _ref$backside = _ref.backside, backside = _ref$backside === void 0 ? true : _ref$backside;
    _classCallCheck6(this, GlowMesh2);
    _this = _callSuper4(this, GlowMesh2);
    var glowGeometry = createGlowGeometry(geometry, size);
    var glowMaterial = createGlowMaterial(coefficient, color4, power, hollowRadius);
    backside && (glowMaterial.side = THREE$i.BackSide);
    _this.geometry = glowGeometry;
    _this.material = glowMaterial;
    return _this;
  }
  _inherits4(GlowMesh2, _THREE$Mesh);
  return _createClass6(GlowMesh2);
}(THREE$i.Mesh);
var THREE$h = window.THREE ? window.THREE : {
  Color,
  Group,
  LineBasicMaterial,
  LineSegments,
  Mesh,
  MeshPhongMaterial,
  SphereGeometry,
  SRGBColorSpace,
  TextureLoader
};
var GlobeLayerKapsule = index({
  props: {
    globeImageUrl: {},
    bumpImageUrl: {},
    showGlobe: {
      "default": true,
      onChange: function onChange(showGlobe, state) {
        state.globeGroup.visible = !!showGlobe;
      },
      triggerUpdate: false
    },
    showGraticules: {
      "default": false,
      onChange: function onChange2(showGraticules, state) {
        state.graticulesObj.visible = !!showGraticules;
      },
      triggerUpdate: false
    },
    showAtmosphere: {
      "default": true,
      onChange: function onChange3(showAtmosphere, state) {
        state.atmosphereObj && (state.atmosphereObj.visible = !!showAtmosphere);
      },
      triggerUpdate: false
    },
    atmosphereColor: {
      "default": "lightskyblue"
    },
    atmosphereAltitude: {
      "default": 0.15
    },
    globeCurvatureResolution: {
      "default": 4
    },
    globeTileEngineUrl: {
      onChange: function onChange4(v2, state) {
        state.tileEngine.tileUrl = v2;
      }
    },
    globeTileEngineMaxLevel: {
      "default": 17,
      onChange: function onChange5(v2, state) {
        state.tileEngine.maxLevel = v2;
      },
      triggerUpdate: false
    },
    updatePov: {
      onChange: function onChange6(v2, state) {
        state.tileEngine.updatePov(v2);
      },
      triggerUpdate: false
    },
    onReady: {
      "default": function _default() {
      },
      triggerUpdate: false
    }
  },
  methods: {
    globeMaterial: function globeMaterial(state, _globeMaterial) {
      if (_globeMaterial !== void 0) {
        state.globeObj.material = _globeMaterial || state.defaultGlobeMaterial;
        return this;
      }
      return state.globeObj.material;
    },
    globeTileEngineClearCache: function globeTileEngineClearCache(state) {
      state.tileEngine.clearTiles();
    },
    _destructor: function _destructor(state) {
      emptyObject3(state.globeObj);
      emptyObject3(state.tileEngine);
      emptyObject3(state.graticulesObj);
    }
  },
  stateInit: function stateInit() {
    var defaultGlobeMaterial = new THREE$h.MeshPhongMaterial({
      color: 0
    });
    var globeObj = new THREE$h.Mesh(void 0, defaultGlobeMaterial);
    globeObj.rotation.y = -Math.PI / 2;
    var tileEngine = new ThreeSlippyMapGlobe(GLOBE_RADIUS);
    var globeGroup = new THREE$h.Group();
    globeGroup.__globeObjType = "globe";
    globeGroup.add(globeObj);
    globeGroup.add(tileEngine);
    var graticulesObj = new THREE$h.LineSegments(new GeoJsonGeometry(graticule10(), GLOBE_RADIUS, 2), new THREE$h.LineBasicMaterial({
      color: "lightgrey",
      transparent: true,
      opacity: 0.1
    }));
    return {
      globeGroup,
      globeObj,
      graticulesObj,
      defaultGlobeMaterial,
      tileEngine
    };
  },
  init: function init(threeObj, state) {
    emptyObject3(threeObj);
    state.scene = threeObj;
    state.scene.add(state.globeGroup);
    state.scene.add(state.graticulesObj);
    state.ready = false;
  },
  update: function update2(state, changedProps) {
    var globeMaterial2 = state.globeObj.material;
    state.tileEngine.visible = !(state.globeObj.visible = !state.globeTileEngineUrl);
    if (changedProps.hasOwnProperty("globeCurvatureResolution")) {
      var _state$globeObj$geome;
      (_state$globeObj$geome = state.globeObj.geometry) === null || _state$globeObj$geome === void 0 || _state$globeObj$geome.dispose();
      var widthSegments = Math.max(4, Math.round(360 / state.globeCurvatureResolution));
      state.globeObj.geometry = new THREE$h.SphereGeometry(GLOBE_RADIUS, widthSegments, widthSegments / 2);
      state.tileEngine.curvatureResolution = state.globeCurvatureResolution;
    }
    if (changedProps.hasOwnProperty("globeImageUrl")) {
      if (!state.globeImageUrl) {
        !globeMaterial2.color && (globeMaterial2.color = new THREE$h.Color(0));
      } else {
        new THREE$h.TextureLoader().load(state.globeImageUrl, function(texture3) {
          texture3.colorSpace = THREE$h.SRGBColorSpace;
          globeMaterial2.map = texture3;
          globeMaterial2.color = null;
          globeMaterial2.needsUpdate = true;
          !state.ready && (state.ready = true) && setTimeout(state.onReady);
        });
      }
    }
    if (changedProps.hasOwnProperty("bumpImageUrl")) {
      if (!state.bumpImageUrl) {
        globeMaterial2.bumpMap = null;
        globeMaterial2.needsUpdate = true;
      } else {
        state.bumpImageUrl && new THREE$h.TextureLoader().load(state.bumpImageUrl, function(texture3) {
          globeMaterial2.bumpMap = texture3;
          globeMaterial2.needsUpdate = true;
        });
      }
    }
    if (changedProps.hasOwnProperty("atmosphereColor") || changedProps.hasOwnProperty("atmosphereAltitude")) {
      if (state.atmosphereObj) {
        state.scene.remove(state.atmosphereObj);
        emptyObject3(state.atmosphereObj);
      }
      if (state.atmosphereColor && state.atmosphereAltitude) {
        var obj = state.atmosphereObj = new GlowMesh(state.globeObj.geometry, {
          color: state.atmosphereColor,
          size: GLOBE_RADIUS * state.atmosphereAltitude,
          hollowRadius: GLOBE_RADIUS,
          coefficient: 0.1,
          power: 3.5
          // dispersion
        });
        obj.visible = !!state.showAtmosphere;
        obj.__globeObjType = "atmosphere";
        state.scene.add(obj);
      }
    }
    if (!state.ready && (!state.globeImageUrl || state.globeTileEngineUrl)) {
      state.ready = true;
      state.onReady();
    }
  }
});
var colorStr2Hex = function colorStr2Hex2(str) {
  return isNaN(str) ? parseInt(tinycolor(str).toHex(), 16) : str;
};
var colorAlpha = function colorAlpha2(str) {
  return str && isNaN(str) ? color(str).opacity : 1;
};
var color2ShaderArr = function color2ShaderArr2(str) {
  var includeAlpha = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
  var sRGBColorSpace = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  var color4;
  var alpha = 1;
  var rgbaMatch = /^rgba\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*([\d.eE+-]+)\s*\)$/.exec(str.trim().toLowerCase());
  if (rgbaMatch) {
    var _rgbaMatch$slice = rgbaMatch.slice(1), _rgbaMatch$slice2 = _slicedToArray7(_rgbaMatch$slice, 4), r = _rgbaMatch$slice2[0], g = _rgbaMatch$slice2[1], b = _rgbaMatch$slice2[2], a = _rgbaMatch$slice2[3];
    color4 = new Color("rgb(".concat(+r, ",").concat(+g, ",").concat(+b, ")"));
    alpha = Math.min(+a, 1);
  } else {
    color4 = new Color(str);
  }
  sRGBColorSpace && color4.convertLinearToSRGB();
  var rgbArr = color4.toArray();
  return includeAlpha ? [].concat(_toConsumableArray6(rgbArr), [alpha]) : rgbArr;
};
function setMaterialOpacity(material, opacity, depthWrite) {
  material.opacity = opacity;
  material.transparent = opacity < 1;
  material.depthWrite = opacity >= 1;
  return material;
}
var THREE$g = window.THREE ? window.THREE : {
  BufferAttribute
};
function array2BufferAttr(data) {
  var itemSize = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
  var ArrayClass = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Float32Array;
  if (itemSize === 1) {
    return new THREE$g.BufferAttribute(new ArrayClass(data), itemSize);
  }
  var ba = new THREE$g.BufferAttribute(new ArrayClass(data.length * itemSize), itemSize);
  for (var idx = 0, l = data.length; idx < l; idx++) {
    ba.set(data[idx], idx * itemSize);
  }
  return ba;
}
function bufferAttr2Array(ba) {
  var itemSize = ba.itemSize;
  var res = [];
  for (var i = 0; i < ba.count; i++) {
    res.push(ba.array.slice(i * itemSize, (i + 1) * itemSize));
  }
  return res;
}
var _dataBindAttr = /* @__PURE__ */ new WeakMap();
var _objBindAttr = /* @__PURE__ */ new WeakMap();
var _removeDelay = /* @__PURE__ */ new WeakMap();
var ThreeDigest = function(_DataBindMapper) {
  function ThreeDigest2(scene) {
    var _this;
    var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$dataBindAttr = _ref.dataBindAttr, dataBindAttr = _ref$dataBindAttr === void 0 ? "__data" : _ref$dataBindAttr, _ref$objBindAttr = _ref.objBindAttr, objBindAttr = _ref$objBindAttr === void 0 ? "__threeObj" : _ref$objBindAttr, _ref$removeDelay = _ref.removeDelay, removeDelay = _ref$removeDelay === void 0 ? 0 : _ref$removeDelay;
    _classCallCheck6(this, ThreeDigest2);
    _this = _callSuper4(this, ThreeDigest2);
    _defineProperty2(_this, "scene", void 0);
    _classPrivateFieldInitSpec3(_this, _dataBindAttr, void 0);
    _classPrivateFieldInitSpec3(_this, _objBindAttr, void 0);
    _classPrivateFieldInitSpec3(_this, _removeDelay, void 0);
    _this.scene = scene;
    _classPrivateFieldSet23(_dataBindAttr, _this, dataBindAttr);
    _classPrivateFieldSet23(_objBindAttr, _this, objBindAttr);
    _classPrivateFieldSet23(_removeDelay, _this, removeDelay);
    _this.onRemoveObj(function() {
    });
    return _this;
  }
  _inherits4(ThreeDigest2, _DataBindMapper);
  return _createClass6(ThreeDigest2, [{
    key: "onCreateObj",
    value: function onCreateObj(fn) {
      var _this2 = this;
      _superPropGet(ThreeDigest2, "onCreateObj", this)([function(d) {
        var obj = fn(d);
        d[_classPrivateFieldGet23(_objBindAttr, _this2)] = obj;
        obj[_classPrivateFieldGet23(_dataBindAttr, _this2)] = d;
        _this2.scene.add(obj);
        return obj;
      }]);
      return this;
    }
  }, {
    key: "onRemoveObj",
    value: function onRemoveObj(fn) {
      var _this3 = this;
      _superPropGet(ThreeDigest2, "onRemoveObj", this)([function(obj, dId) {
        var d = _superPropGet(ThreeDigest2, "getData", _this3)([obj]);
        fn(obj, dId);
        var removeFn = function removeFn2() {
          _this3.scene.remove(obj);
          emptyObject3(obj);
          delete d[_classPrivateFieldGet23(_objBindAttr, _this3)];
        };
        _classPrivateFieldGet23(_removeDelay, _this3) ? setTimeout(removeFn, _classPrivateFieldGet23(_removeDelay, _this3)) : removeFn();
      }]);
      return this;
    }
  }]);
}(DataBindMapper);
var THREE$f = window.THREE ? window.THREE : {
  BufferGeometry,
  CylinderGeometry,
  Matrix4,
  Mesh,
  MeshLambertMaterial,
  Object3D,
  Vector3
};
var bfg$2 = Object.assign({}, BufferGeometryUtils_exports);
var BufferGeometryUtils$2 = bfg$2.BufferGeometryUtils || bfg$2;
var PointsLayerKapsule = index({
  props: {
    pointsData: {
      "default": []
    },
    pointLat: {
      "default": "lat"
    },
    pointLng: {
      "default": "lng"
    },
    pointColor: {
      "default": function _default2() {
        return "#ffffaa";
      }
    },
    pointAltitude: {
      "default": 0.1
    },
    // in units of globe radius
    pointRadius: {
      "default": 0.25
    },
    // in deg
    pointResolution: {
      "default": 12,
      triggerUpdate: false
    },
    // how many slice segments in the cylinder's circumference
    pointsMerge: {
      "default": false
    },
    // boolean. Whether to merge all points into a single mesh for rendering performance
    pointsTransitionDuration: {
      "default": 1e3,
      triggerUpdate: false
    }
    // ms
  },
  init: function init2(threeObj, state, _ref) {
    var tweenGroup = _ref.tweenGroup;
    emptyObject3(threeObj);
    state.scene = threeObj;
    state.tweenGroup = tweenGroup;
    state.dataMapper = new ThreeDigest(threeObj, {
      objBindAttr: "__threeObjPoint"
    });
  },
  update: function update3(state, changedProps) {
    var latAccessor = index3(state.pointLat);
    var lngAccessor = index3(state.pointLng);
    var altitudeAccessor = index3(state.pointAltitude);
    var radiusAccessor = index3(state.pointRadius);
    var colorAccessor = index3(state.pointColor);
    var pointGeometry = new THREE$f.CylinderGeometry(1, 1, 1, state.pointResolution);
    pointGeometry.applyMatrix4(new THREE$f.Matrix4().makeRotationX(Math.PI / 2));
    pointGeometry.applyMatrix4(new THREE$f.Matrix4().makeTranslation(0, 0, -0.5));
    var pxPerDeg = 2 * Math.PI * GLOBE_RADIUS / 360;
    var pointMaterials = {};
    if (!state.pointsMerge && changedProps.hasOwnProperty("pointsMerge")) {
      emptyObject3(state.scene);
    }
    state.dataMapper.scene = state.pointsMerge ? new THREE$f.Object3D() : state.scene;
    state.dataMapper.onCreateObj(createObj).onUpdateObj(updateObj).digest(state.pointsData);
    if (state.pointsMerge) {
      var pointsGeometry = !state.pointsData.length ? new THREE$f.BufferGeometry() : (BufferGeometryUtils$2.mergeGeometries || BufferGeometryUtils$2.mergeBufferGeometries)(state.pointsData.map(function(d) {
        var obj = state.dataMapper.getObj(d);
        var geom = obj.geometry.clone();
        obj.updateMatrix();
        geom.applyMatrix4(obj.matrix);
        var color4 = color2ShaderArr(colorAccessor(d));
        geom.setAttribute("color", array2BufferAttr(Array(geom.getAttribute("position").count).fill(color4), 4));
        return geom;
      }));
      var points = new THREE$f.Mesh(pointsGeometry, new THREE$f.MeshLambertMaterial({
        color: 16777215,
        transparent: true,
        vertexColors: true
      }));
      points.__globeObjType = "points";
      points.__data = state.pointsData;
      state.dataMapper.clear();
      emptyObject3(state.scene);
      state.scene.add(points);
    }
    function createObj() {
      var obj = new THREE$f.Mesh(pointGeometry);
      obj.__globeObjType = "point";
      return obj;
    }
    function updateObj(obj, d) {
      var applyUpdate = function applyUpdate2(td) {
        var _obj$__currentTargetD = obj.__currentTargetD = td, r = _obj$__currentTargetD.r, alt = _obj$__currentTargetD.alt, lat = _obj$__currentTargetD.lat, lng = _obj$__currentTargetD.lng;
        Object.assign(obj.position, polar2Cartesian4(lat, lng));
        var globeCenter = state.pointsMerge ? new THREE$f.Vector3(0, 0, 0) : state.scene.localToWorld(new THREE$f.Vector3(0, 0, 0));
        obj.lookAt(globeCenter);
        obj.scale.x = obj.scale.y = Math.min(30, r) * pxPerDeg;
        obj.scale.z = Math.max(alt * GLOBE_RADIUS, 0.1);
      };
      var targetD = {
        alt: +altitudeAccessor(d),
        r: +radiusAccessor(d),
        lat: +latAccessor(d),
        lng: +lngAccessor(d)
      };
      var currentTargetD = obj.__currentTargetD || Object.assign({}, targetD, {
        alt: -1e-3
      });
      if (Object.keys(targetD).some(function(k) {
        return currentTargetD[k] !== targetD[k];
      })) {
        if (state.pointsMerge || !state.pointsTransitionDuration || state.pointsTransitionDuration < 0) {
          applyUpdate(targetD);
        } else {
          state.tweenGroup.add(new Tween(currentTargetD).to(targetD, state.pointsTransitionDuration).easing(Easing.Quadratic.InOut).onUpdate(applyUpdate).start());
        }
      }
      if (!state.pointsMerge) {
        var color4 = colorAccessor(d);
        var opacity = color4 ? colorAlpha(color4) : 0;
        var showCyl = !!opacity;
        obj.visible = showCyl;
        if (showCyl) {
          if (!pointMaterials.hasOwnProperty(color4)) {
            pointMaterials[color4] = new THREE$f.MeshLambertMaterial({
              color: colorStr2Hex(color4),
              transparent: opacity < 1,
              opacity
            });
          }
          obj.material = pointMaterials[color4];
        }
      }
    }
  }
});
var dashedLineShaders = function dashedLineShaders2() {
  return {
    uniforms: {
      // dash param defaults, all relative to full length
      dashOffset: {
        value: 0
      },
      dashSize: {
        value: 1
      },
      gapSize: {
        value: 0
      },
      dashTranslate: {
        value: 0
      }
      // used for animating the dash
    },
    vertexShader: "\n    ".concat(ShaderChunk.common, "\n    ").concat(ShaderChunk.logdepthbuf_pars_vertex, "\n  \n    uniform float dashTranslate; \n\n    attribute vec4 color;\n    varying vec4 vColor;\n    \n    attribute float relDistance;\n    varying float vRelDistance;\n\n    void main() {\n      // pass through colors and distances\n      vColor = color;\n      vRelDistance = relDistance + dashTranslate;\n      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n  \n      ").concat(ShaderChunk.logdepthbuf_vertex, "\n    }\n  "),
    fragmentShader: "\n    ".concat(ShaderChunk.logdepthbuf_pars_fragment, "\n\n    uniform float dashOffset; \n    uniform float dashSize;\n    uniform float gapSize; \n    \n    varying vec4 vColor;\n    varying float vRelDistance;\n    \n    void main() {\n      // ignore pixels in the gap\n      if (vRelDistance < dashOffset) discard;\n      if (mod(vRelDistance - dashOffset, dashSize + gapSize) > dashSize) discard;\n    \n      // set px color: [r, g, b, a], interpolated between vertices \n      gl_FragColor = vColor; \n  \n      ").concat(ShaderChunk.logdepthbuf_fragment, "\n    }\n  ")
  };
};
var invisibleUndergroundShaderExtend = function invisibleUndergroundShaderExtend2(shader) {
  shader.uniforms.uSurfaceRadius = {
    type: "float",
    value: 0
  };
  shader.vertexShader = ("attribute float surfaceRadius;\nvarying float vSurfaceRadius;\nvarying vec3 vPos;\n" + shader.vertexShader).replace("void main() {", ["void main() {", "vSurfaceRadius = surfaceRadius;", "vPos = position;"].join("\n"));
  shader.fragmentShader = ("uniform float uSurfaceRadius;\nvarying float vSurfaceRadius;\nvarying vec3 vPos;\n" + shader.fragmentShader).replace("void main() {", ["void main() {", "if (length(vPos) < max(uSurfaceRadius, vSurfaceRadius)) discard;"].join("\n"));
  return shader;
};
var setRadiusShaderExtend = function setRadiusShaderExtend2(shader) {
  shader.vertexShader = "\n    attribute float r;\n    \n    const float PI = 3.1415926535897932384626433832795;\n    float toRad(in float a) {\n      return a * PI / 180.0;\n    }\n    \n    vec3 Polar2Cartesian(in vec3 c) { // [lat, lng, r]\n      float phi = toRad(90.0 - c.x);\n      float theta = toRad(90.0 - c.y);\n      float r = c.z;\n      return vec3( // x,y,z\n        r * sin(phi) * cos(theta),\n        r * cos(phi),\n        r * sin(phi) * sin(theta)\n      );\n    }\n    \n    vec2 Cartesian2Polar(in vec3 p) {\n      float r = sqrt(p.x * p.x + p.y * p.y + p.z * p.z);\n      float phi = acos(p.y / r);\n      float theta = atan(p.z, p.x);\n      return vec2( // lat,lng\n        90.0 - phi * 180.0 / PI,\n        90.0 - theta * 180.0 / PI - (theta < -PI / 2.0 ? 360.0 : 0.0)\n      );\n    }\n    ".concat(shader.vertexShader.replace("}", "                  \n        vec3 pos = Polar2Cartesian(vec3(Cartesian2Polar(position), r));\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n      }\n    "), "\n  ");
  return shader;
};
var applyShaderExtensionToMaterial = function applyShaderExtensionToMaterial2(material, extensionFn) {
  material.onBeforeCompile = function(shader) {
    material.userData.shader = extensionFn(shader);
  };
  return material;
};
var setExtendedMaterialUniforms = function setExtendedMaterialUniforms2(material) {
  var uniformsFn = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : function(u4) {
    return u4;
  };
  if (material.userData.shader) {
    uniformsFn(material.userData.shader.uniforms);
  } else {
    var curFn = material.onBeforeCompile;
    material.onBeforeCompile = function(shader) {
      curFn(shader);
      uniformsFn(shader.uniforms);
    };
  }
};
var _excluded = ["stroke"];
var THREE$e = window.THREE ? window.THREE : {
  BufferGeometry,
  CubicBezierCurve3,
  Curve,
  Group,
  Line,
  Mesh,
  NormalBlending,
  ShaderMaterial,
  TubeGeometry,
  Vector3
};
var FrameTicker$2 = import_frame_ticker.default["default"] || import_frame_ticker.default;
var ArcsLayerKapsule = index({
  props: {
    arcsData: {
      "default": []
    },
    arcStartLat: {
      "default": "startLat"
    },
    arcStartLng: {
      "default": "startLng"
    },
    arcStartAltitude: {
      "default": 0
    },
    arcEndLat: {
      "default": "endLat"
    },
    arcEndLng: {
      "default": "endLng"
    },
    arcEndAltitude: {
      "default": 0
    },
    arcColor: {
      "default": function _default3() {
        return "#ffffaa";
      }
    },
    // single color, array of colors or color interpolation fn
    arcAltitude: {},
    // in units of globe radius
    arcAltitudeAutoScale: {
      "default": 0.5
    },
    // scale altitude proportional to great-arc distance between the two points
    arcStroke: {},
    // in deg
    arcCurveResolution: {
      "default": 64,
      triggerUpdate: false
    },
    // how many straight segments in the curve
    arcCircularResolution: {
      "default": 6,
      triggerUpdate: false
    },
    // how many slice segments in the tube's circumference
    arcDashLength: {
      "default": 1
    },
    // in units of line length
    arcDashGap: {
      "default": 0
    },
    arcDashInitialGap: {
      "default": 0
    },
    arcDashAnimateTime: {
      "default": 0
    },
    // ms
    arcsTransitionDuration: {
      "default": 1e3,
      triggerUpdate: false
    }
    // ms
  },
  methods: {
    pauseAnimation: function pauseAnimation(state) {
      var _state$ticker;
      (_state$ticker = state.ticker) === null || _state$ticker === void 0 || _state$ticker.pause();
    },
    resumeAnimation: function resumeAnimation(state) {
      var _state$ticker2;
      (_state$ticker2 = state.ticker) === null || _state$ticker2 === void 0 || _state$ticker2.resume();
    },
    _destructor: function _destructor2(state) {
      var _state$ticker3;
      state.sharedMaterial.dispose();
      (_state$ticker3 = state.ticker) === null || _state$ticker3 === void 0 || _state$ticker3.dispose();
    }
  },
  stateInit: function stateInit2(_ref) {
    var tweenGroup = _ref.tweenGroup;
    return {
      tweenGroup,
      ticker: new FrameTicker$2(),
      sharedMaterial: new THREE$e.ShaderMaterial(_objectSpread2(_objectSpread2({}, dashedLineShaders()), {}, {
        transparent: true,
        blending: THREE$e.NormalBlending
      }))
    };
  },
  init: function init3(threeObj, state) {
    emptyObject3(threeObj);
    state.scene = threeObj;
    state.dataMapper = new ThreeDigest(threeObj, {
      objBindAttr: "__threeObjArc"
    }).onCreateObj(function() {
      var obj = new THREE$e.Group();
      obj.__globeObjType = "arc";
      return obj;
    });
    state.ticker.onTick.add(function(_, timeDelta) {
      state.dataMapper.entries().map(function(_ref2) {
        var _ref3 = _slicedToArray7(_ref2, 2), obj = _ref3[1];
        return obj;
      }).filter(function(o) {
        return o.children.length && o.children[0].material && o.children[0].__dashAnimateStep;
      }).forEach(function(o) {
        var obj = o.children[0];
        var step3 = obj.__dashAnimateStep * timeDelta;
        var curTranslate = obj.material.uniforms.dashTranslate.value % 1e9;
        obj.material.uniforms.dashTranslate.value = curTranslate + step3;
      });
    });
  },
  update: function update4(state) {
    var startLatAccessor = index3(state.arcStartLat);
    var startLngAccessor = index3(state.arcStartLng);
    var startAltAccessor = index3(state.arcStartAltitude);
    var endLatAccessor = index3(state.arcEndLat);
    var endLngAccessor = index3(state.arcEndLng);
    var endAltAccessor = index3(state.arcEndAltitude);
    var altitudeAccessor = index3(state.arcAltitude);
    var altitudeAutoScaleAccessor = index3(state.arcAltitudeAutoScale);
    var strokeAccessor = index3(state.arcStroke);
    var colorAccessor = index3(state.arcColor);
    var dashLengthAccessor = index3(state.arcDashLength);
    var dashGapAccessor = index3(state.arcDashGap);
    var dashInitialGapAccessor = index3(state.arcDashInitialGap);
    var dashAnimateTimeAccessor = index3(state.arcDashAnimateTime);
    state.dataMapper.onUpdateObj(function(group2, arc) {
      var stroke = strokeAccessor(arc);
      var useTube = stroke !== null && stroke !== void 0;
      if (!group2.children.length || useTube !== (group2.children[0].type === "Mesh")) {
        emptyObject3(group2);
        var _obj = useTube ? new THREE$e.Mesh() : new THREE$e.Line(new THREE$e.BufferGeometry());
        _obj.material = state.sharedMaterial.clone();
        group2.add(_obj);
      }
      var obj = group2.children[0];
      Object.assign(obj.material.uniforms, {
        dashSize: {
          value: dashLengthAccessor(arc)
        },
        gapSize: {
          value: dashGapAccessor(arc)
        },
        dashOffset: {
          value: dashInitialGapAccessor(arc)
        }
      });
      var dashAnimateTime = dashAnimateTimeAccessor(arc);
      obj.__dashAnimateStep = dashAnimateTime > 0 ? 1e3 / dashAnimateTime : 0;
      var vertexColorArray = calcColorVertexArray(
        colorAccessor(arc),
        // single, array of colors or interpolator
        state.arcCurveResolution,
        // numSegments
        useTube ? state.arcCircularResolution + 1 : 1
        // num vertices per segment
      );
      var vertexRelDistanceArray = calcVertexRelDistances(
        state.arcCurveResolution,
        // numSegments
        useTube ? state.arcCircularResolution + 1 : 1,
        // num vertices per segment
        true
        // run from end to start, to animate in the correct direction
      );
      obj.geometry.setAttribute("color", vertexColorArray);
      obj.geometry.setAttribute("relDistance", vertexRelDistanceArray);
      var applyUpdate = function applyUpdate2(td) {
        var _group$__currentTarge = group2.__currentTargetD = td, stroke2 = _group$__currentTarge.stroke, curveD = _objectWithoutProperties2(_group$__currentTarge, _excluded);
        var curve = calcCurve(curveD);
        if (useTube) {
          obj.geometry && obj.geometry.dispose();
          obj.geometry = new THREE$e.TubeGeometry(curve, state.arcCurveResolution, stroke2 / 2, state.arcCircularResolution);
          obj.geometry.setAttribute("color", vertexColorArray);
          obj.geometry.setAttribute("relDistance", vertexRelDistanceArray);
        } else {
          obj.geometry.setFromPoints(curve.getPoints(state.arcCurveResolution));
        }
      };
      var targetD = {
        stroke,
        alt: altitudeAccessor(arc),
        altAutoScale: +altitudeAutoScaleAccessor(arc),
        startLat: +startLatAccessor(arc),
        startLng: +startLngAccessor(arc),
        startAlt: +startAltAccessor(arc),
        endLat: +endLatAccessor(arc),
        endLng: +endLngAccessor(arc),
        endAlt: +endAltAccessor(arc)
      };
      var currentTargetD = group2.__currentTargetD || Object.assign({}, targetD, {
        altAutoScale: -1e-3
      });
      if (Object.keys(targetD).some(function(k) {
        return currentTargetD[k] !== targetD[k];
      })) {
        if (!state.arcsTransitionDuration || state.arcsTransitionDuration < 0) {
          applyUpdate(targetD);
        } else {
          state.tweenGroup.add(new Tween(currentTargetD).to(targetD, state.arcsTransitionDuration).easing(Easing.Quadratic.InOut).onUpdate(applyUpdate).start());
        }
      }
    }).digest(state.arcsData);
    function calcCurve(_ref4) {
      var alt = _ref4.alt, altAutoScale = _ref4.altAutoScale, startLat = _ref4.startLat, startLng = _ref4.startLng, startAlt = _ref4.startAlt, endLat = _ref4.endLat, endLng = _ref4.endLng, endAlt = _ref4.endAlt;
      var getVec = function getVec2(_ref5) {
        var _ref6 = _slicedToArray7(_ref5, 3), lng = _ref6[0], lat = _ref6[1], alt2 = _ref6[2];
        var _polar2Cartesian = polar2Cartesian4(lat, lng, alt2), x = _polar2Cartesian.x, y = _polar2Cartesian.y, z = _polar2Cartesian.z;
        return new THREE$e.Vector3(x, y, z);
      };
      var startPnt = [startLng, startLat];
      var endPnt = [endLng, endLat];
      var altitude = alt;
      (altitude === null || altitude === void 0) && // by default set altitude proportional to the great-arc distance
      (altitude = distance_default(startPnt, endPnt) / 2 * altAutoScale + Math.max(startAlt, endAlt));
      if (altitude || startAlt || endAlt) {
        var interpolate = interpolate_default(startPnt, endPnt);
        var calcAltCp = function calcAltCp2(a0, a1) {
          return a1 + (a1 - a0) * (a0 < a1 ? 0.5 : 0.25);
        };
        var _map = [0.25, 0.75].map(function(t) {
          return [].concat(_toConsumableArray6(interpolate(t)), [calcAltCp(t < 0.5 ? startAlt : endAlt, altitude)]);
        }), _map2 = _slicedToArray7(_map, 2), m1Pnt = _map2[0], m2Pnt = _map2[1];
        var curve = _construct(THREE$e.CubicBezierCurve3, _toConsumableArray6([[].concat(startPnt, [startAlt]), m1Pnt, m2Pnt, [].concat(endPnt, [endAlt])].map(getVec)));
        return curve;
      } else {
        var _alt = 1e-3;
        return calcSphereArc.apply(void 0, _toConsumableArray6([[].concat(startPnt, [_alt]), [].concat(endPnt, [_alt])].map(getVec)));
      }
      function calcSphereArc(startVec, endVec) {
        var angle2 = startVec.angleTo(endVec);
        var getGreatCirclePoint = angle2 === 0 ? function() {
          return startVec.clone();
        } : function(t) {
          return new THREE$e.Vector3().addVectors(startVec.clone().multiplyScalar(Math.sin((1 - t) * angle2)), endVec.clone().multiplyScalar(Math.sin(t * angle2))).divideScalar(Math.sin(angle2));
        };
        var sphereArc = new THREE$e.Curve();
        sphereArc.getPoint = getGreatCirclePoint;
        return sphereArc;
      }
    }
    function calcColorVertexArray(colors, numSegments) {
      var numVerticesPerSegment = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
      var numVerticesGroup = numSegments + 1;
      var getVertexColor;
      if (colors instanceof Array || colors instanceof Function) {
        var colorInterpolator = colors instanceof Array ? linear2().domain(colors.map(function(_, idx) {
          return idx / (colors.length - 1);
        })).range(colors) : colors;
        getVertexColor = function getVertexColor2(t) {
          return color2ShaderArr(colorInterpolator(t), true, true);
        };
      } else {
        var vertexColor3 = color2ShaderArr(colors, true, true);
        getVertexColor = function getVertexColor2() {
          return vertexColor3;
        };
      }
      var vertexColors = [];
      for (var v2 = 0, l = numVerticesGroup; v2 < l; v2++) {
        var _vertexColor = getVertexColor(v2 / (l - 1));
        for (var s = 0; s < numVerticesPerSegment; s++) {
          vertexColors.push(_vertexColor);
        }
      }
      return array2BufferAttr(vertexColors, 4);
    }
    function calcVertexRelDistances(numSegments) {
      var numVerticesPerSegment = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
      var invert = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      var numVerticesGroup = numSegments + 1;
      var vertexDistances = [];
      for (var v2 = 0, l = numVerticesGroup; v2 < l; v2++) {
        var relDistance = v2 / (l - 1);
        for (var s = 0; s < numVerticesPerSegment; s++) {
          vertexDistances.push(relDistance);
        }
      }
      invert && vertexDistances.reverse();
      return array2BufferAttr(vertexDistances, 1);
    }
  }
});
var THREE$d = window.THREE ? window.THREE : {
  BufferGeometry,
  DoubleSide,
  Mesh,
  MeshLambertMaterial,
  Object3D
};
var bfg$1 = Object.assign({}, BufferGeometryUtils_exports);
var BufferGeometryUtils$1 = bfg$1.BufferGeometryUtils || bfg$1;
var HexBinLayerKapsule = index({
  props: {
    hexBinPointsData: {
      "default": []
    },
    hexBinPointLat: {
      "default": "lat"
    },
    hexBinPointLng: {
      "default": "lng"
    },
    hexBinPointWeight: {
      "default": 1
    },
    hexBinResolution: {
      "default": 4
    },
    // 0-15. Level 0 partitions the earth in 122 (mostly) hexagonal cells. Each subsequent level sub-divides the previous in roughly 7 hexagons.
    hexMargin: {
      "default": 0.2
    },
    // in fraction of diameter
    hexTopCurvatureResolution: {
      "default": 5
    },
    // in angular degrees
    hexTopColor: {
      "default": function _default4() {
        return "#ffffaa";
      }
    },
    hexSideColor: {
      "default": function _default5() {
        return "#ffffaa";
      }
    },
    hexAltitude: {
      "default": function _default6(_ref) {
        var sumWeight = _ref.sumWeight;
        return sumWeight * 0.01;
      }
    },
    // in units of globe radius
    hexBinMerge: {
      "default": false
    },
    // boolean. Whether to merge all hex geometries into a single mesh for rendering performance
    hexTransitionDuration: {
      "default": 1e3,
      triggerUpdate: false
    }
    // ms
  },
  init: function init4(threeObj, state, _ref2) {
    var tweenGroup = _ref2.tweenGroup;
    emptyObject3(threeObj);
    state.scene = threeObj;
    state.tweenGroup = tweenGroup;
    state.dataMapper = new ThreeDigest(threeObj, {
      objBindAttr: "__threeObjHexbin"
    });
  },
  update: function update5(state, changedProps) {
    var latAccessor = index3(state.hexBinPointLat);
    var lngAccessor = index3(state.hexBinPointLng);
    var weightAccessor = index3(state.hexBinPointWeight);
    var altitudeAccessor = index3(state.hexAltitude);
    var topColorAccessor = index3(state.hexTopColor);
    var sideColorAccessor = index3(state.hexSideColor);
    var marginAccessor = index3(state.hexMargin);
    var byH3Idx = index4(state.hexBinPointsData.map(function(d) {
      return _objectSpread2(_objectSpread2({}, d), {}, {
        h3Idx: latLngToCell(latAccessor(d), lngAccessor(d), state.hexBinResolution)
      });
    }), "h3Idx");
    var hexBins = Object.entries(byH3Idx).map(function(_ref3) {
      var _ref4 = _slicedToArray7(_ref3, 2), h3Idx = _ref4[0], points = _ref4[1];
      return {
        h3Idx,
        points,
        sumWeight: points.reduce(function(agg, d) {
          return agg + +weightAccessor(d);
        }, 0)
      };
    });
    var hexMaterials = {};
    if (!state.hexBinMerge && changedProps.hasOwnProperty("hexBinMerge")) {
      emptyObject3(state.scene);
    }
    state.dataMapper.scene = state.hexBinMerge ? new THREE$d.Object3D() : state.scene;
    state.dataMapper.id(function(d) {
      return d.h3Idx;
    }).onCreateObj(createObj).onUpdateObj(updateObj).digest(hexBins);
    if (state.hexBinMerge) {
      var hexPointsGeometry = !hexBins.length ? new THREE$d.BufferGeometry() : (BufferGeometryUtils$1.mergeGeometries || BufferGeometryUtils$1.mergeBufferGeometries)(hexBins.map(function(d) {
        var obj = state.dataMapper.getObj(d);
        var geom = obj.geometry.toNonIndexed();
        obj.updateMatrix();
        geom.applyMatrix4(obj.matrix);
        var topColor = color2ShaderArr(topColorAccessor(d));
        var sideColor = color2ShaderArr(sideColorAccessor(d));
        var nVertices = geom.getAttribute("position").count;
        var topFaceIdx = geom.groups[0].count;
        geom.setAttribute("color", array2BufferAttr(_toConsumableArray6(new Array(nVertices)).map(function(_, idx) {
          return idx >= topFaceIdx ? topColor : sideColor;
        }), 4));
        return geom;
      }));
      var hexMaterial = new THREE$d.MeshLambertMaterial({
        color: 16777215,
        transparent: true,
        vertexColors: true,
        side: THREE$d.DoubleSide
      });
      hexMaterial.onBeforeCompile = function(shader) {
        hexMaterial.userData.shader = invisibleUndergroundShaderExtend(shader);
      };
      var hexPoints = new THREE$d.Mesh(hexPointsGeometry, hexMaterial);
      hexPoints.__globeObjType = "hexBinPoints";
      hexPoints.__data = hexBins;
      state.dataMapper.clear();
      emptyObject3(state.scene);
      state.scene.add(hexPoints);
    }
    function createObj(d) {
      var obj = new THREE$d.Mesh();
      obj.__hexCenter = cellToLatLng(d.h3Idx);
      obj.__hexGeoJson = cellToBoundary(d.h3Idx, true).reverse();
      var centerLng = obj.__hexCenter[1];
      obj.__hexGeoJson.forEach(function(d2) {
        var edgeLng = d2[0];
        if (Math.abs(centerLng - edgeLng) > 170) {
          d2[0] += centerLng > edgeLng ? 360 : -360;
        }
      });
      obj.__globeObjType = "hexbin";
      return obj;
    }
    function updateObj(obj, d) {
      var relNum = function relNum2(st, end, rat) {
        return st - (st - end) * rat;
      };
      var margin = Math.max(0, Math.min(1, +marginAccessor(d)));
      var _obj$__hexCenter = _slicedToArray7(obj.__hexCenter, 2), clat = _obj$__hexCenter[0], clng = _obj$__hexCenter[1];
      var geoJson = margin === 0 ? obj.__hexGeoJson : obj.__hexGeoJson.map(function(_ref5) {
        var _ref6 = _slicedToArray7(_ref5, 2), elng = _ref6[0], elat = _ref6[1];
        return [[elng, clng], [elat, clat]].map(function(_ref7) {
          var _ref8 = _slicedToArray7(_ref7, 2), st = _ref8[0], end = _ref8[1];
          return relNum(st, end, margin);
        });
      });
      var topCurvatureResolution = state.hexTopCurvatureResolution;
      obj.geometry && obj.geometry.dispose();
      obj.geometry = new ConicPolygonGeometry([geoJson], 0, GLOBE_RADIUS, false, true, true, topCurvatureResolution);
      var targetD = {
        alt: +altitudeAccessor(d)
      };
      var applyUpdate = function applyUpdate2(td) {
        var _obj$__currentTargetD = obj.__currentTargetD = td, alt = _obj$__currentTargetD.alt;
        obj.scale.x = obj.scale.y = obj.scale.z = 1 + alt;
        var vertexSurfaceRadius = GLOBE_RADIUS / (alt + 1);
        obj.geometry.setAttribute("surfaceRadius", array2BufferAttr(Array(obj.geometry.getAttribute("position").count).fill(vertexSurfaceRadius), 1));
      };
      var currentTargetD = obj.__currentTargetD || Object.assign({}, targetD, {
        alt: -1e-3
      });
      if (Object.keys(targetD).some(function(k) {
        return currentTargetD[k] !== targetD[k];
      })) {
        if (state.hexBinMerge || !state.hexTransitionDuration || state.hexTransitionDuration < 0) {
          applyUpdate(targetD);
        } else {
          state.tweenGroup.add(new Tween(currentTargetD).to(targetD, state.hexTransitionDuration).easing(Easing.Quadratic.InOut).onUpdate(applyUpdate).start());
        }
      }
      if (!state.hexBinMerge) {
        var sideColor = sideColorAccessor(d);
        var topColor = topColorAccessor(d);
        [sideColor, topColor].forEach(function(color4) {
          if (!hexMaterials.hasOwnProperty(color4)) {
            var opacity = colorAlpha(color4);
            hexMaterials[color4] = applyShaderExtensionToMaterial(new THREE$d.MeshLambertMaterial({
              color: colorStr2Hex(color4),
              transparent: opacity < 1,
              opacity,
              side: THREE$d.DoubleSide
            }), invisibleUndergroundShaderExtend);
          }
        });
        obj.material = [sideColor, topColor].map(function(color4) {
          return hexMaterials[color4];
        });
      }
    }
  }
});
var sq = function sq2(x) {
  return x * x;
};
var toRad = function toRad2(x) {
  return x * Math.PI / 180;
};
function geoDistance(a, b) {
  var sqrt6 = Math.sqrt;
  var cos5 = Math.cos;
  var hav = function hav2(x) {
    return sq(Math.sin(x / 2));
  };
  var latA = toRad(a[1]);
  var latB = toRad(b[1]);
  var lngA = toRad(a[0]);
  var lngB = toRad(b[0]);
  return 2 * Math.asin(sqrt6(hav(latB - latA) + cos5(latA) * cos5(latB) * hav(lngB - lngA)));
}
var sqrt2PI = Math.sqrt(2 * Math.PI);
function gaussianKernel(x, bw) {
  return Math.exp(-sq(x / bw) / 2) / (bw * sqrt2PI);
}
var getGeoKDE = function getGeoKDE2(_ref) {
  var _ref2 = _slicedToArray7(_ref, 2), lng = _ref2[0], lat = _ref2[1];
  var data = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  var _ref3 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, _ref3$lngAccessor = _ref3.lngAccessor, lngAccessor = _ref3$lngAccessor === void 0 ? function(d) {
    return d[0];
  } : _ref3$lngAccessor, _ref3$latAccessor = _ref3.latAccessor, latAccessor = _ref3$latAccessor === void 0 ? function(d) {
    return d[1];
  } : _ref3$latAccessor, _ref3$weightAccessor = _ref3.weightAccessor, weightAccessor = _ref3$weightAccessor === void 0 ? function() {
    return 1;
  } : _ref3$weightAccessor, bandwidth = _ref3.bandwidth;
  var pnt = [lng, lat];
  var bwRad = bandwidth * Math.PI / 180;
  return sum(data.map(function(d) {
    var weight = weightAccessor(d);
    if (!weight) return 0;
    var dist2 = geoDistance(pnt, [lngAccessor(d), latAccessor(d)]);
    return gaussianKernel(dist2, bwRad) * weight;
  }));
};
var computeGeoKde = function() {
  var _ref4 = _asyncToGenerator(_regenerator().m(function _callee(vertexGeoCoords) {
    var _navigator;
    var data, _ref5, _ref5$lngAccessor, lngAccessor, _ref5$latAccessor, latAccessor, _ref5$weightAccessor, weightAccessor, bandwidth, BW_RADIUS_INFLUENCE, Fn3, If3, uniform3, storage3, _float, instanceIndex3, Loop3, sqrt6, sin5, cos5, asin5, exp4, negate4, sCoords, sData, res, sRes, PI4, sqrt2PI2, sq3, hav, geoDistance2, gaussianKernel2, bwRad, maxRRad, n, computeShaderFn, computeNode, renderer, _args = arguments, _t, _t2, _t3;
    return _regenerator().w(function(_context) {
      while (1) switch (_context.n) {
        case 0:
          data = _args.length > 1 && _args[1] !== void 0 ? _args[1] : [];
          _ref5 = _args.length > 2 && _args[2] !== void 0 ? _args[2] : {}, _ref5$lngAccessor = _ref5.lngAccessor, lngAccessor = _ref5$lngAccessor === void 0 ? function(d) {
            return d[0];
          } : _ref5$lngAccessor, _ref5$latAccessor = _ref5.latAccessor, latAccessor = _ref5$latAccessor === void 0 ? function(d) {
            return d[1];
          } : _ref5$latAccessor, _ref5$weightAccessor = _ref5.weightAccessor, weightAccessor = _ref5$weightAccessor === void 0 ? function() {
            return 1;
          } : _ref5$weightAccessor, bandwidth = _ref5.bandwidth;
          if ((_navigator = navigator) !== null && _navigator !== void 0 && _navigator.gpu) {
            _context.n = 1;
            break;
          }
          console.warn("WebGPU not enabled in browser. Please consider enabling it to improve performance.");
          return _context.a(2, vertexGeoCoords.map(function(coords) {
            return getGeoKDE(coords, data, {
              lngAccessor,
              latAccessor,
              weightAccessor,
              bandwidth
            });
          }));
        case 1:
          BW_RADIUS_INFLUENCE = 4;
          Fn3 = Fn2, If3 = If2, uniform3 = uniform2, storage3 = storage2, _float = float2, instanceIndex3 = instanceIndex2, Loop3 = Loop2, sqrt6 = sqrt5, sin5 = sin4, cos5 = cos4, asin5 = asin4, exp4 = exp3, negate4 = negate3;
          sCoords = storage3(new StorageInstancedBufferAttribute(new Float32Array(vertexGeoCoords.flat().map(toRad)), 2), "vec2", vertexGeoCoords.length);
          sData = storage3(new StorageInstancedBufferAttribute(new Float32Array(data.map(function(d) {
            return [toRad(lngAccessor(d)), toRad(latAccessor(d)), weightAccessor(d)];
          }).flat()), 3), "vec3", data.length);
          res = new StorageInstancedBufferAttribute(vertexGeoCoords.length, 1);
          sRes = storage3(res, "float", vertexGeoCoords.length);
          PI4 = _float(Math.PI);
          sqrt2PI2 = sqrt6(PI4.mul(2));
          sq3 = function sq4(x) {
            return x.mul(x);
          };
          hav = function hav2(x) {
            return sq3(sin5(x.div(2)));
          };
          geoDistance2 = function geoDistance3(a, b) {
            var latA = _float(a[1]);
            var latB = _float(b[1]);
            var lngA = _float(a[0]);
            var lngB = _float(b[0]);
            return _float(2).mul(asin5(sqrt6(hav(latB.sub(latA)).add(cos5(latA).mul(cos5(latB)).mul(hav(lngB.sub(lngA)))))));
          };
          gaussianKernel2 = function gaussianKernel3(x, bw) {
            return exp4(negate4(sq3(x.div(bw)).div(2))).div(bw.mul(sqrt2PI2));
          };
          bwRad = uniform3(toRad(bandwidth));
          maxRRad = uniform3(toRad(bandwidth * BW_RADIUS_INFLUENCE));
          n = uniform3(data.length);
          computeShaderFn = Fn3(function() {
            var coords = sCoords.element(instanceIndex3);
            var res2 = sRes.element(instanceIndex3);
            res2.assign(0);
            Loop3(n, function(_ref6) {
              var i = _ref6.i;
              var d = sData.element(i);
              var weight = d.z;
              If3(weight, function() {
                var dist2 = geoDistance2(d.xy, coords.xy);
                If3(dist2 && dist2.lessThan(maxRRad), function() {
                  res2.addAssign(gaussianKernel2(dist2, bwRad).mul(weight));
                });
              });
            });
          });
          computeNode = computeShaderFn().compute(vertexGeoCoords.length);
          renderer = new WebGPURenderer();
          _context.n = 2;
          return renderer.computeAsync(computeNode);
        case 2:
          _t = Array;
          _t2 = Float32Array;
          _context.n = 3;
          return renderer.getArrayBufferAsync(res);
        case 3:
          _t3 = _context.v;
          return _context.a(2, _t.from.call(_t, new _t2(_t3)));
      }
    }, _callee);
  }));
  return function computeGeoKde2(_x) {
    return _ref4.apply(this, arguments);
  };
}();
var THREE$c = window.THREE ? window.THREE : {
  Mesh,
  MeshLambertMaterial,
  SphereGeometry
};
var RES_BW_FACTOR = 3.5;
var MIN_RESOLUTION = 0.1;
var NUM_COLORS = 100;
var defaultColorInterpolator = function defaultColorInterpolator2(t) {
  var c3 = color(turbo_default(t));
  c3.opacity = Math.cbrt(t);
  return c3.formatRgb();
};
var HeatmapsLayerKapsule = index({
  props: {
    heatmapsData: {
      "default": []
    },
    heatmapPoints: {
      "default": function _default7(pnts) {
        return pnts;
      }
    },
    heatmapPointLat: {
      "default": function _default8(d) {
        return d[0];
      }
    },
    heatmapPointLng: {
      "default": function _default9(d) {
        return d[1];
      }
    },
    heatmapPointWeight: {
      "default": 1
    },
    heatmapBandwidth: {
      "default": 2.5
    },
    // Gaussian kernel bandwidth, in angular degrees
    heatmapColorFn: {
      "default": function _default10() {
        return defaultColorInterpolator;
      }
    },
    heatmapColorSaturation: {
      "default": 1.5
    },
    // multiplier for color scale max
    heatmapBaseAltitude: {
      "default": 0.01
    },
    // in units of globe radius
    heatmapTopAltitude: {},
    // in units of globe radius
    heatmapsTransitionDuration: {
      "default": 0,
      triggerUpdate: false
    }
    // ms
  },
  init: function init5(threeObj, state, _ref) {
    var tweenGroup = _ref.tweenGroup;
    emptyObject3(threeObj);
    state.scene = threeObj;
    state.tweenGroup = tweenGroup;
    state.dataMapper = new ThreeDigest(threeObj, {
      objBindAttr: "__threeObjHeatmap"
    }).onCreateObj(function() {
      var obj = new THREE$c.Mesh(new THREE$c.SphereGeometry(GLOBE_RADIUS), applyShaderExtensionToMaterial(new THREE$c.MeshLambertMaterial({
        vertexColors: true,
        transparent: true
      }), setRadiusShaderExtend));
      obj.__globeObjType = "heatmap";
      return obj;
    });
  },
  update: function update6(state) {
    var pointsAccessor = index3(state.heatmapPoints);
    var latPntAccessor = index3(state.heatmapPointLat);
    var lngPntAccessor = index3(state.heatmapPointLng);
    var weightPntAccessor = index3(state.heatmapPointWeight);
    var bandwidthAccessor = index3(state.heatmapBandwidth);
    var colorFnAccessor = index3(state.heatmapColorFn);
    var saturationAccessor = index3(state.heatmapColorSaturation);
    var baseAltitudeAccessor = index3(state.heatmapBaseAltitude);
    var topAltitudeAccessor = index3(state.heatmapTopAltitude);
    state.dataMapper.onUpdateObj(function(obj, d) {
      var bandwidth = bandwidthAccessor(d);
      var colorFn = colorFnAccessor(d);
      var saturation3 = saturationAccessor(d);
      var baseAlt = baseAltitudeAccessor(d);
      var topAlt = topAltitudeAccessor(d);
      var pnts = pointsAccessor(d).map(function(pnt) {
        var lat = latPntAccessor(pnt);
        var lng = lngPntAccessor(pnt);
        var _polar2Cartesian = polar2Cartesian4(lat, lng), x = _polar2Cartesian.x, y = _polar2Cartesian.y, z = _polar2Cartesian.z;
        return {
          x,
          y,
          z,
          lat,
          lng,
          weight: weightPntAccessor(pnt)
        };
      });
      var resolution2 = Math.max(MIN_RESOLUTION, bandwidth / RES_BW_FACTOR);
      var equatorNumSegments = Math.ceil(360 / (resolution2 || -1));
      if (obj.geometry.parameters.widthSegments !== equatorNumSegments) {
        obj.geometry.dispose();
        obj.geometry = new THREE$c.SphereGeometry(GLOBE_RADIUS, equatorNumSegments, equatorNumSegments / 2);
      }
      var vertexCoords = bufferAttr2Array(obj.geometry.getAttribute("position"));
      var vertexGeoCoords = vertexCoords.map(function(_ref2) {
        var _ref3 = _slicedToArray7(_ref2, 3), x = _ref3[0], y = _ref3[1], z = _ref3[2];
        var _cartesian2Polar = cartesian2Polar2({
          x,
          y,
          z
        }), lng = _cartesian2Polar.lng, lat = _cartesian2Polar.lat;
        return [lng, lat];
      });
      computeGeoKde(vertexGeoCoords, pnts, {
        latAccessor: function latAccessor(d2) {
          return d2.lat;
        },
        lngAccessor: function lngAccessor(d2) {
          return d2.lng;
        },
        weightAccessor: function weightAccessor(d2) {
          return d2.weight;
        },
        bandwidth
      }).then(function(kdeVals) {
        var colors = _toConsumableArray6(new Array(NUM_COLORS)).map(function(_, idx) {
          return color2ShaderArr(colorFn(idx / (NUM_COLORS - 1)));
        });
        var applyUpdate = function applyUpdate2(td) {
          var _obj$__currentTargetD = obj.__currentTargetD = td, kdeVals2 = _obj$__currentTargetD.kdeVals, topAlt2 = _obj$__currentTargetD.topAlt, saturation4 = _obj$__currentTargetD.saturation;
          var maxVal = max(kdeVals2.map(Math.abs)) || 1e-15;
          var colorScale = quantize([0, maxVal / saturation4], colors);
          obj.geometry.setAttribute("color", array2BufferAttr(kdeVals2.map(function(v2) {
            return colorScale(Math.abs(v2));
          }), 4));
          var rScale = linear2([0, maxVal], [GLOBE_RADIUS * (1 + baseAlt), GLOBE_RADIUS * (1 + (topAlt2 || baseAlt))]);
          obj.geometry.setAttribute("r", array2BufferAttr(kdeVals2.map(rScale)));
        };
        var targetD = {
          kdeVals,
          topAlt,
          saturation: saturation3
        };
        var currentTargetD = obj.__currentTargetD || Object.assign({}, targetD, {
          kdeVals: kdeVals.map(function() {
            return 0;
          }),
          topAlt: !topAlt ? topAlt : baseAlt,
          saturation: 0.5
        });
        currentTargetD.kdeVals.length !== kdeVals.length && (currentTargetD.kdeVals = kdeVals.slice());
        if (Object.keys(targetD).some(function(k) {
          return currentTargetD[k] !== targetD[k];
        })) {
          if (!state.heatmapsTransitionDuration || state.heatmapsTransitionDuration < 0) {
            applyUpdate(targetD);
          } else {
            state.tweenGroup.add(new Tween(currentTargetD).to(targetD, state.heatmapsTransitionDuration).easing(Easing.Quadratic.InOut).onUpdate(applyUpdate).start());
          }
        }
      });
    }).digest(state.heatmapsData);
  }
});
var THREE$b = window.THREE ? window.THREE : {
  DoubleSide,
  Group,
  LineBasicMaterial,
  LineSegments,
  Mesh,
  MeshBasicMaterial
};
var PolygonsLayerKapsule = index({
  props: {
    polygonsData: {
      "default": []
    },
    polygonGeoJsonGeometry: {
      "default": "geometry"
    },
    polygonSideColor: {
      "default": function _default11() {
        return "#ffffaa";
      }
    },
    polygonSideMaterial: {},
    polygonCapColor: {
      "default": function _default12() {
        return "#ffffaa";
      }
    },
    polygonCapMaterial: {},
    polygonStrokeColor: {},
    polygonAltitude: {
      "default": 0.01
    },
    // in units of globe radius
    polygonCapCurvatureResolution: {
      "default": 5
    },
    // in angular degrees
    polygonsTransitionDuration: {
      "default": 1e3,
      triggerUpdate: false
    }
    // ms
  },
  init: function init6(threeObj, state, _ref) {
    var tweenGroup = _ref.tweenGroup;
    emptyObject3(threeObj);
    state.scene = threeObj;
    state.tweenGroup = tweenGroup;
    state.dataMapper = new ThreeDigest(threeObj, {
      objBindAttr: "__threeObjPolygon"
    }).id(function(d) {
      return d.id;
    }).onCreateObj(function() {
      var obj = new THREE$b.Group();
      obj.__defaultSideMaterial = applyShaderExtensionToMaterial(new THREE$b.MeshBasicMaterial({
        side: THREE$b.DoubleSide,
        depthWrite: true
      }), invisibleUndergroundShaderExtend);
      obj.__defaultCapMaterial = new THREE$b.MeshBasicMaterial({
        side: THREE$b.DoubleSide,
        depthWrite: true
      });
      obj.add(new THREE$b.Mesh(void 0, [
        obj.__defaultSideMaterial,
        // side material
        obj.__defaultCapMaterial
        // cap material
      ]));
      obj.add(new THREE$b.LineSegments(void 0, new THREE$b.LineBasicMaterial()));
      obj.__globeObjType = "polygon";
      return obj;
    });
  },
  update: function update7(state) {
    var geoJsonAccessor = index3(state.polygonGeoJsonGeometry);
    var altitudeAccessor = index3(state.polygonAltitude);
    var capCurvatureResolutionAccessor = index3(state.polygonCapCurvatureResolution);
    var capColorAccessor = index3(state.polygonCapColor);
    var capMaterialAccessor = index3(state.polygonCapMaterial);
    var sideColorAccessor = index3(state.polygonSideColor);
    var sideMaterialAccessor = index3(state.polygonSideMaterial);
    var strokeColorAccessor = index3(state.polygonStrokeColor);
    var singlePolygons = [];
    state.polygonsData.forEach(function(polygon) {
      var objAttrs = {
        data: polygon,
        capColor: capColorAccessor(polygon),
        capMaterial: capMaterialAccessor(polygon),
        sideColor: sideColorAccessor(polygon),
        sideMaterial: sideMaterialAccessor(polygon),
        strokeColor: strokeColorAccessor(polygon),
        altitude: +altitudeAccessor(polygon),
        capCurvatureResolution: +capCurvatureResolutionAccessor(polygon)
      };
      var geoJson = geoJsonAccessor(polygon);
      var geoId = polygon.__id || "".concat(Math.round(Math.random() * 1e9));
      polygon.__id = geoId;
      if (geoJson.type === "Polygon") {
        singlePolygons.push(_objectSpread2({
          id: "".concat(geoId, "_0"),
          coords: geoJson.coordinates
        }, objAttrs));
      } else if (geoJson.type === "MultiPolygon") {
        singlePolygons.push.apply(singlePolygons, _toConsumableArray6(geoJson.coordinates.map(function(coords, idx) {
          return _objectSpread2({
            id: "".concat(geoId, "_").concat(idx),
            coords
          }, objAttrs);
        })));
      } else {
        console.warn("Unsupported GeoJson geometry type: ".concat(geoJson.type, ". Skipping geometry..."));
      }
    });
    state.dataMapper.onUpdateObj(function(obj, _ref2) {
      var coords = _ref2.coords, capColor = _ref2.capColor, capMaterial = _ref2.capMaterial, sideColor = _ref2.sideColor, sideMaterial = _ref2.sideMaterial, strokeColor = _ref2.strokeColor, altitude = _ref2.altitude, capCurvatureResolution = _ref2.capCurvatureResolution;
      var _obj$children = _slicedToArray7(obj.children, 2), conicObj = _obj$children[0], strokeObj = _obj$children[1];
      var addStroke = !!strokeColor;
      strokeObj.visible = addStroke;
      var hasCap = !!(capColor || capMaterial);
      var hasSide = !!(sideColor || sideMaterial);
      if (!objMatch(conicObj.geometry.parameters || {}, {
        polygonGeoJson: coords,
        curvatureResolution: capCurvatureResolution,
        closedTop: hasCap,
        includeSides: hasSide
      })) {
        conicObj.geometry && conicObj.geometry.dispose();
        conicObj.geometry = new ConicPolygonGeometry(coords, 0, GLOBE_RADIUS, false, hasCap, hasSide, capCurvatureResolution);
      }
      if (addStroke && (!strokeObj.geometry.parameters || strokeObj.geometry.parameters.geoJson.coordinates !== coords || strokeObj.geometry.parameters.resolution !== capCurvatureResolution)) {
        strokeObj.geometry && strokeObj.geometry.dispose();
        strokeObj.geometry = new GeoJsonGeometry({
          type: "Polygon",
          coordinates: coords
        }, GLOBE_RADIUS, capCurvatureResolution);
      }
      var sideIdx = hasSide ? 0 : -1;
      var capIdx = !hasCap ? -1 : hasSide ? 1 : 0;
      sideIdx >= 0 && (conicObj.material[sideIdx] = sideMaterial || obj.__defaultSideMaterial);
      capIdx >= 0 && (conicObj.material[capIdx] = capMaterial || obj.__defaultCapMaterial);
      [[!sideMaterial && sideColor, sideIdx], [!capMaterial && capColor, capIdx]].forEach(function(_ref3) {
        var _ref4 = _slicedToArray7(_ref3, 2), color4 = _ref4[0], materialIdx = _ref4[1];
        if (!color4 || materialIdx < 0) return;
        var material2 = conicObj.material[materialIdx];
        var opacity2 = colorAlpha(color4);
        material2.color.set(colorStr2Hex(color4));
        material2.transparent = opacity2 < 1;
        material2.opacity = opacity2;
      });
      if (addStroke) {
        var material = strokeObj.material;
        var opacity = colorAlpha(strokeColor);
        material.color.set(colorStr2Hex(strokeColor));
        material.transparent = opacity < 1;
        material.opacity = opacity;
      }
      var targetD = {
        alt: altitude
      };
      var applyUpdate = function applyUpdate2(td) {
        var _obj$__currentTargetD = obj.__currentTargetD = td, alt = _obj$__currentTargetD.alt;
        conicObj.scale.x = conicObj.scale.y = conicObj.scale.z = 1 + alt;
        addStroke && (strokeObj.scale.x = strokeObj.scale.y = strokeObj.scale.z = 1 + alt + 1e-4);
        setExtendedMaterialUniforms(obj.__defaultSideMaterial, function(uniforms) {
          return uniforms.uSurfaceRadius.value = GLOBE_RADIUS / (alt + 1);
        });
      };
      var currentTargetD = obj.__currentTargetD || Object.assign({}, targetD, {
        alt: -1e-3
      });
      if (Object.keys(targetD).some(function(k) {
        return currentTargetD[k] !== targetD[k];
      })) {
        if (!state.polygonsTransitionDuration || state.polygonsTransitionDuration < 0 || currentTargetD.alt === targetD.alt) {
          applyUpdate(targetD);
        } else {
          state.tweenGroup.add(new Tween(currentTargetD).to(targetD, state.polygonsTransitionDuration).easing(Easing.Quadratic.InOut).onUpdate(applyUpdate).start());
        }
      }
    }).digest(singlePolygons);
  }
});
function objMatch(obj, attrs) {
  var compFn = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : function() {
    return function(a, b) {
      return a === b;
    };
  };
  return Object.entries(attrs).every(function(_ref5) {
    var _ref6 = _slicedToArray7(_ref5, 2), k = _ref6[0], v2 = _ref6[1];
    return obj.hasOwnProperty(k) && compFn(k)(obj[k], v2);
  });
}
var THREE$a = window.THREE ? window.THREE : {
  BufferGeometry,
  DoubleSide,
  Mesh,
  MeshLambertMaterial,
  Vector3
};
var bfg = Object.assign({}, BufferGeometryUtils_exports);
var BufferGeometryUtils = bfg.BufferGeometryUtils || bfg;
var HexedPolygonsLayerKapsule = index({
  props: {
    hexPolygonsData: {
      "default": []
    },
    hexPolygonGeoJsonGeometry: {
      "default": "geometry"
    },
    hexPolygonColor: {
      "default": function _default13() {
        return "#ffffaa";
      }
    },
    hexPolygonAltitude: {
      "default": 1e-3
    },
    // in units of globe radius
    hexPolygonResolution: {
      "default": 3
    },
    // 0-15. Level 0 partitions the earth in 122 (mostly) hexagonal cells. Each subsequent level sub-divides the previous in roughly 7 hexagons.
    hexPolygonMargin: {
      "default": 0.2
    },
    // in fraction of hex diameter
    hexPolygonUseDots: {
      "default": false
    },
    // if points should be circular instead of hexagonal
    hexPolygonCurvatureResolution: {
      "default": 5
    },
    // in angular degrees, only relevant for hex tops
    hexPolygonDotResolution: {
      "default": 12
    },
    // how many slice segments in the dot circle's circumference
    hexPolygonsTransitionDuration: {
      "default": 0,
      triggerUpdate: false
    }
    // ms
  },
  init: function init7(threeObj, state, _ref) {
    var tweenGroup = _ref.tweenGroup;
    emptyObject3(threeObj);
    state.scene = threeObj;
    state.tweenGroup = tweenGroup;
    state.dataMapper = new ThreeDigest(threeObj, {
      objBindAttr: "__threeObjHexPolygon"
    }).onCreateObj(function() {
      var obj = new THREE$a.Mesh(void 0, new THREE$a.MeshLambertMaterial({
        side: THREE$a.DoubleSide
      }));
      obj.__globeObjType = "hexPolygon";
      return obj;
    });
  },
  update: function update8(state) {
    var geoJsonAccessor = index3(state.hexPolygonGeoJsonGeometry);
    var colorAccessor = index3(state.hexPolygonColor);
    var altitudeAccessor = index3(state.hexPolygonAltitude);
    var resolutionAccessor = index3(state.hexPolygonResolution);
    var marginAccessor = index3(state.hexPolygonMargin);
    var useDotsAccessor = index3(state.hexPolygonUseDots);
    var curvatureResolutionAccessor = index3(state.hexPolygonCurvatureResolution);
    var dotResolutionAccessor = index3(state.hexPolygonDotResolution);
    state.dataMapper.onUpdateObj(function(obj, d) {
      var geoJson = geoJsonAccessor(d);
      var h3Res = resolutionAccessor(d);
      var alt = altitudeAccessor(d);
      var margin = Math.max(0, Math.min(1, +marginAccessor(d)));
      var useDots = useDotsAccessor(d);
      var curvatureResolution = curvatureResolutionAccessor(d);
      var dotResolution = dotResolutionAccessor(d);
      var color4 = colorAccessor(d);
      var opacity = colorAlpha(color4);
      obj.material.color.set(colorStr2Hex(color4));
      obj.material.transparent = opacity < 1;
      obj.material.opacity = opacity;
      var targetD = {
        alt,
        margin,
        curvatureResolution
      };
      var memD = {
        geoJson,
        h3Res
      };
      var currentTargetD = obj.__currentTargetD || Object.assign({}, targetD, {
        alt: -1e-3
      });
      var currentMemD = obj.__currentMemD || memD;
      if (Object.keys(targetD).some(function(k) {
        return currentTargetD[k] !== targetD[k];
      }) || Object.keys(memD).some(function(k) {
        return currentMemD[k] !== memD[k];
      })) {
        obj.__currentMemD = memD;
        var h3Idxs = [];
        if (geoJson.type === "Polygon") {
          polygonToCells(geoJson.coordinates, h3Res, true).forEach(function(idx) {
            return h3Idxs.push(idx);
          });
        } else if (geoJson.type === "MultiPolygon") {
          geoJson.coordinates.forEach(function(coords) {
            return polygonToCells(coords, h3Res, true).forEach(function(idx) {
              return h3Idxs.push(idx);
            });
          });
        } else {
          console.warn("Unsupported GeoJson geometry type: ".concat(geoJson.type, ". Skipping geometry..."));
        }
        var hexBins = h3Idxs.map(function(h3Idx) {
          var hexCenter = cellToLatLng(h3Idx);
          var hexGeoJson = cellToBoundary(h3Idx, true).reverse();
          var centerLng = hexCenter[1];
          hexGeoJson.forEach(function(d2) {
            var edgeLng = d2[0];
            if (Math.abs(centerLng - edgeLng) > 170) {
              d2[0] += centerLng > edgeLng ? 360 : -360;
            }
          });
          return {
            h3Idx,
            hexCenter,
            hexGeoJson
          };
        });
        var applyUpdate = function applyUpdate2(td) {
          var _obj$__currentTargetD = obj.__currentTargetD = td, alt2 = _obj$__currentTargetD.alt, margin2 = _obj$__currentTargetD.margin, curvatureResolution2 = _obj$__currentTargetD.curvatureResolution;
          obj.geometry && obj.geometry.dispose();
          obj.geometry = !hexBins.length ? new THREE$a.BufferGeometry() : (BufferGeometryUtils.mergeGeometries || BufferGeometryUtils.mergeBufferGeometries)(hexBins.map(function(h) {
            var _h$hexCenter = _slicedToArray7(h.hexCenter, 2), clat = _h$hexCenter[0], clng = _h$hexCenter[1];
            if (useDots) {
              var centerPos = polar2Cartesian4(clat, clng, alt2);
              var edgePos = polar2Cartesian4(h.hexGeoJson[0][1], h.hexGeoJson[0][0], alt2);
              var r = 0.85 * (1 - margin2) * new THREE$a.Vector3(centerPos.x, centerPos.y, centerPos.z).distanceTo(new THREE$a.Vector3(edgePos.x, edgePos.y, edgePos.z));
              var geometry = new CircleGeometry(r, dotResolution);
              geometry.rotateX(deg2Rad$1(-clat));
              geometry.rotateY(deg2Rad$1(clng));
              geometry.translate(centerPos.x, centerPos.y, centerPos.z);
              return geometry;
            } else {
              var relNum = function relNum2(st, end, rat) {
                return st - (st - end) * rat;
              };
              var _geoJson = margin2 === 0 ? h.hexGeoJson : h.hexGeoJson.map(function(_ref2) {
                var _ref3 = _slicedToArray7(_ref2, 2), elng = _ref3[0], elat = _ref3[1];
                return [[elng, clng], [elat, clat]].map(function(_ref4) {
                  var _ref5 = _slicedToArray7(_ref4, 2), st = _ref5[0], end = _ref5[1];
                  return relNum(st, end, margin2);
                });
              });
              return new ConicPolygonGeometry([_geoJson], GLOBE_RADIUS, GLOBE_RADIUS * (1 + alt2), false, true, false, curvatureResolution2);
            }
          }));
        };
        if (!state.hexPolygonsTransitionDuration || state.hexPolygonsTransitionDuration < 0) {
          applyUpdate(targetD);
        } else {
          state.tweenGroup.add(new Tween(currentTargetD).to(targetD, state.hexPolygonsTransitionDuration).easing(Easing.Quadratic.InOut).onUpdate(applyUpdate).start());
        }
      }
    }).digest(state.hexPolygonsData);
  }
});
var THREE$9 = window.THREE ? window.THREE : {
  Vector3
};
function interpolateVectors(fromPnts, toPnts) {
  var extendArr = function extendArr2(arr, length3) {
    var repeatItem = arr[arr.length - 1];
    return [].concat(_toConsumableArray6(arr), _toConsumableArray6(Array(length3 - arr.length).fill(repeatItem)));
  };
  var arrLength = Math.max(fromPnts.length, toPnts.length);
  var interpolator = array_default.apply(void 0, _toConsumableArray6([fromPnts, toPnts].map(function(pnts) {
    return pnts.map(function(_ref) {
      var x = _ref.x, y = _ref.y, z = _ref.z;
      return [x, y, z];
    });
  }).map(function(arr) {
    return extendArr(arr, arrLength);
  })));
  return function(k) {
    return k === 0 ? fromPnts : k === 1 ? toPnts : interpolator(k).map(function(_ref2) {
      var _ref3 = _slicedToArray7(_ref2, 3), x = _ref3[0], y = _ref3[1], z = _ref3[2];
      return new THREE$9.Vector3(x, y, z);
    });
  };
}
var THREE$8 = window.THREE ? window.THREE : {
  BufferGeometry,
  Color,
  Group,
  Line,
  NormalBlending,
  ShaderMaterial,
  Vector3
};
var FrameTicker$1 = import_frame_ticker.default["default"] || import_frame_ticker.default;
var PathsLayerKapsule = index({
  props: {
    pathsData: {
      "default": []
    },
    pathPoints: {
      "default": function _default14(pnts) {
        return pnts;
      }
    },
    pathPointLat: {
      "default": function _default15(arr) {
        return arr[0];
      }
    },
    pathPointLng: {
      "default": function _default16(arr) {
        return arr[1];
      }
    },
    pathPointAlt: {
      "default": 1e-3
    },
    pathResolution: {
      "default": 2
    },
    // in deg
    pathColor: {
      "default": function _default17() {
        return "#ffffaa";
      }
    },
    // single color, array of colors or color interpolation fn
    pathStroke: {},
    // in deg
    pathDashLength: {
      "default": 1
    },
    // in units of line length
    pathDashGap: {
      "default": 0
    },
    pathDashInitialGap: {
      "default": 0
    },
    pathDashAnimateTime: {
      "default": 0
    },
    // ms
    pathTransitionDuration: {
      "default": 1e3,
      triggerUpdate: false
    },
    // ms
    rendererSize: {}
    // necessary to set correct fatline proportions
  },
  methods: {
    pauseAnimation: function pauseAnimation2(state) {
      var _state$ticker;
      (_state$ticker = state.ticker) === null || _state$ticker === void 0 || _state$ticker.pause();
    },
    resumeAnimation: function resumeAnimation2(state) {
      var _state$ticker2;
      (_state$ticker2 = state.ticker) === null || _state$ticker2 === void 0 || _state$ticker2.resume();
    },
    _destructor: function _destructor3(state) {
      var _state$ticker3;
      (_state$ticker3 = state.ticker) === null || _state$ticker3 === void 0 || _state$ticker3.dispose();
    }
  },
  stateInit: function stateInit3(_ref) {
    var tweenGroup = _ref.tweenGroup;
    return {
      tweenGroup,
      ticker: new FrameTicker$1(),
      sharedMaterial: new THREE$8.ShaderMaterial(_objectSpread2(_objectSpread2({}, dashedLineShaders()), {}, {
        transparent: true,
        blending: THREE$8.NormalBlending
      }))
    };
  },
  init: function init8(threeObj, state) {
    emptyObject3(threeObj);
    state.scene = threeObj;
    state.dataMapper = new ThreeDigest(threeObj, {
      objBindAttr: "__threeObjPath"
    }).onCreateObj(function() {
      var obj = new THREE$8.Group();
      obj.__globeObjType = "path";
      return obj;
    });
    state.ticker.onTick.add(function(_, timeDelta) {
      state.dataMapper.entries().map(function(_ref2) {
        var _ref3 = _slicedToArray7(_ref2, 2), obj = _ref3[1];
        return obj;
      }).filter(function(o) {
        return o.children.length && o.children[0].material && o.children[0].__dashAnimateStep;
      }).forEach(function(o) {
        var obj = o.children[0];
        var step3 = obj.__dashAnimateStep * timeDelta;
        if (obj.type === "Line") {
          var curTranslate = obj.material.uniforms.dashTranslate.value % 1e9;
          obj.material.uniforms.dashTranslate.value = curTranslate + step3;
        } else if (obj.type === "Line2") {
          var offset = obj.material.dashOffset - step3;
          var dashLength = obj.material.dashSize + obj.material.gapSize;
          while (offset <= -dashLength) offset += dashLength;
          obj.material.dashOffset = offset;
        }
      });
    });
  },
  update: function update9(state) {
    var pointsAccessor = index3(state.pathPoints);
    var pointLatAccessor = index3(state.pathPointLat);
    var pointLngAccessor = index3(state.pathPointLng);
    var pointAltAccessor = index3(state.pathPointAlt);
    var strokeAccessor = index3(state.pathStroke);
    var colorAccessor = index3(state.pathColor);
    var dashLengthAccessor = index3(state.pathDashLength);
    var dashGapAccessor = index3(state.pathDashGap);
    var dashInitialGapAccessor = index3(state.pathDashInitialGap);
    var dashAnimateTimeAccessor = index3(state.pathDashAnimateTime);
    state.dataMapper.onUpdateObj(function(group2, path) {
      var stroke = strokeAccessor(path);
      var useFatLine = stroke !== null && stroke !== void 0;
      if (!group2.children.length || useFatLine === (group2.children[0].type === "Line")) {
        emptyObject3(group2);
        var _obj = useFatLine ? new Line2(new LineGeometry(), new LineMaterial()) : new THREE$8.Line(
          new THREE$8.BufferGeometry(),
          state.sharedMaterial.clone()
          // Separate material instance per object to have dedicated uniforms (but shared shaders)
        );
        group2.add(_obj);
      }
      var obj = group2.children[0];
      var points = calcPath(pointsAccessor(path), pointLatAccessor, pointLngAccessor, pointAltAccessor, state.pathResolution);
      var dashAnimateTime = dashAnimateTimeAccessor(path);
      obj.__dashAnimateStep = dashAnimateTime > 0 ? 1e3 / dashAnimateTime : 0;
      if (!useFatLine) {
        Object.assign(obj.material.uniforms, {
          dashSize: {
            value: dashLengthAccessor(path)
          },
          gapSize: {
            value: dashGapAccessor(path)
          },
          dashOffset: {
            value: dashInitialGapAccessor(path)
          }
        });
        var vertexColorArray = calcColorVertexArray(
          colorAccessor(path),
          // single, array of colors or interpolator
          points.length
          // numSegments
        );
        var vertexRelDistanceArray = calcVertexRelDistances(
          points.length,
          // numSegments
          1,
          // num vertices per segment
          true
          // run from end to start, to animate in the correct direction
        );
        obj.geometry.setAttribute("color", vertexColorArray);
        obj.geometry.setAttribute("relDistance", vertexRelDistanceArray);
      } else {
        obj.material.resolution = state.rendererSize;
        {
          var dashLength = dashLengthAccessor(path);
          var dashGap = dashGapAccessor(path);
          var dashInitialGap = dashInitialGapAccessor(path);
          obj.material.dashed = dashGap > 0;
          obj.material.dashed ? obj.material.defines.USE_DASH = "" : delete obj.material.defines.USE_DASH;
          if (obj.material.dashed) {
            obj.material.dashScale = 1 / calcLineDistance(points);
            obj.material.dashSize = dashLength;
            obj.material.gapSize = dashGap;
            obj.material.dashOffset = -dashInitialGap;
          }
        }
        {
          var colors = colorAccessor(path);
          if (colors instanceof Array) {
            var _vertexColorArray = calcColorVertexArray(
              colorAccessor(path),
              // single, array of colors or interpolator
              points.length - 1,
              // numSegments
              1,
              // num vertices per segment
              false
            );
            obj.geometry.setColors(_vertexColorArray.array);
            obj.material.vertexColors = true;
          } else {
            var color4 = colors;
            var opacity = colorAlpha(color4);
            obj.material.color = new THREE$8.Color(colorStr2Hex(color4));
            obj.material.transparent = opacity < 1;
            obj.material.opacity = opacity;
            obj.material.vertexColors = false;
          }
        }
        obj.material.needsUpdate = true;
      }
      var pointsInterpolator = interpolateVectors(group2.__currentTargetD && group2.__currentTargetD.points || [points[0]], points);
      var applyUpdate = function applyUpdate2(td) {
        var _group$__currentTarge = group2.__currentTargetD = td, stroke2 = _group$__currentTarge.stroke, interpolK = _group$__currentTarge.interpolK;
        var kPoints = group2.__currentTargetD.points = pointsInterpolator(interpolK);
        if (useFatLine) {
          var _ref4;
          obj.geometry.setPositions((_ref4 = []).concat.apply(_ref4, _toConsumableArray6(kPoints.map(function(_ref5) {
            var x = _ref5.x, y = _ref5.y, z = _ref5.z;
            return [x, y, z];
          }))));
          obj.material.linewidth = stroke2;
          obj.material.dashed && obj.computeLineDistances();
        } else {
          obj.geometry.setFromPoints(kPoints);
          obj.geometry.computeBoundingSphere();
        }
      };
      var targetD = {
        stroke,
        interpolK: 1
      };
      var currentTargetD = Object.assign({}, group2.__currentTargetD || targetD, {
        interpolK: 0
      });
      if (Object.keys(targetD).some(function(k) {
        return currentTargetD[k] !== targetD[k];
      })) {
        if (!state.pathTransitionDuration || state.pathTransitionDuration < 0) {
          applyUpdate(targetD);
        } else {
          state.tweenGroup.add(new Tween(currentTargetD).to(targetD, state.pathTransitionDuration).easing(Easing.Quadratic.InOut).onUpdate(applyUpdate).start());
        }
      }
    }).digest(state.pathsData);
    function calcLineDistance(pnts) {
      var totalDist = 0;
      var prevPnt;
      pnts.forEach(function(pnt) {
        prevPnt && (totalDist += prevPnt.distanceTo(pnt));
        prevPnt = pnt;
      });
      return totalDist;
    }
    function calcPath(points, latAccessor, lngAccessor, altAccessor, angularResolution) {
      var getInterpolatedVals = function getInterpolatedVals2(start, end, numPnts) {
        var result = [];
        for (var i = 1; i <= numPnts; i++) {
          result.push(start + (end - start) * i / (numPnts + 1));
        }
        return result;
      };
      var interpolateLine3 = function interpolateLine4() {
        var lineCoords = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
        var maxDegDistance = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
        var result = [];
        var prevPnt = null;
        lineCoords.forEach(function(pnt) {
          if (prevPnt) {
            while (Math.abs(prevPnt[1] - pnt[1]) > 180) prevPnt[1] += 360 * (prevPnt[1] < pnt[1] ? 1 : -1);
            var dist2 = Math.sqrt(Math.pow(pnt[0] - prevPnt[0], 2) + Math.pow(pnt[1] - prevPnt[1], 2));
            if (dist2 > maxDegDistance) {
              var numAdditionalPnts = Math.floor(dist2 / maxDegDistance);
              var lats = getInterpolatedVals(prevPnt[0], pnt[0], numAdditionalPnts);
              var lngs = getInterpolatedVals(prevPnt[1], pnt[1], numAdditionalPnts);
              var alts = getInterpolatedVals(prevPnt[2], pnt[2], numAdditionalPnts);
              for (var i = 0, len = lats.length; i < len; i++) {
                result.push([lats[i], lngs[i], alts[i]]);
              }
            }
          }
          result.push(prevPnt = pnt);
        });
        return result;
      };
      var getVec = function getVec2(_ref6) {
        var _ref7 = _slicedToArray7(_ref6, 3), lat = _ref7[0], lng = _ref7[1], alt = _ref7[2];
        var _polar2Cartesian = polar2Cartesian4(lat, lng, alt), x = _polar2Cartesian.x, y = _polar2Cartesian.y, z = _polar2Cartesian.z;
        return new THREE$8.Vector3(x, y, z);
      };
      return interpolateLine3(points.map(function(pnt) {
        return [latAccessor(pnt), lngAccessor(pnt), altAccessor(pnt)];
      }), angularResolution).map(getVec);
    }
    function calcColorVertexArray(colors, numSegments) {
      var numVerticesPerSegment = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
      var includeAlpha = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
      var numVerticesGroup = numSegments + 1;
      var getVertexColor;
      if (colors instanceof Array || colors instanceof Function) {
        var colorInterpolator = colors instanceof Array ? linear2().domain(colors.map(function(_, idx) {
          return idx / (colors.length - 1);
        })).range(colors) : colors;
        getVertexColor = function getVertexColor2(t) {
          return color2ShaderArr(colorInterpolator(t), includeAlpha, true);
        };
      } else {
        var vertexColor3 = color2ShaderArr(colors, includeAlpha, true);
        getVertexColor = function getVertexColor2() {
          return vertexColor3;
        };
      }
      var vertexColors = [];
      for (var v2 = 0, l = numVerticesGroup; v2 < l; v2++) {
        var _vertexColor = getVertexColor(v2 / (l - 1));
        for (var s = 0; s < numVerticesPerSegment; s++) {
          vertexColors.push(_vertexColor);
        }
      }
      return array2BufferAttr(vertexColors, includeAlpha ? 4 : 3);
    }
    function calcVertexRelDistances(numSegments) {
      var numVerticesPerSegment = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
      var invert = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      var numVerticesGroup = numSegments + 1;
      var vertexDistances = [];
      for (var v2 = 0, l = numVerticesGroup; v2 < l; v2++) {
        var relDistance = v2 / (l - 1);
        for (var s = 0; s < numVerticesPerSegment; s++) {
          vertexDistances.push(relDistance);
        }
      }
      invert && vertexDistances.reverse();
      return array2BufferAttr(vertexDistances, 1);
    }
  }
});
var THREE$7 = window.THREE ? window.THREE : {
  Euler,
  Mesh,
  MeshLambertMaterial,
  SphereGeometry
};
var TilesLayerKapsule = index({
  props: {
    tilesData: {
      "default": []
    },
    tileLat: {
      "default": "lat"
    },
    // tile centroid
    tileLng: {
      "default": "lng"
    },
    tileAltitude: {
      "default": 0.01
    },
    // in units of globe radius
    tileWidth: {
      "default": 1
    },
    // in lng degrees
    tileHeight: {
      "default": 1
    },
    // in lat degrees
    tileUseGlobeProjection: {
      "default": true
    },
    // whether to size tiles relative to the globe coordinate system, or independently
    tileMaterial: {
      "default": function _default18() {
        return new THREE$7.MeshLambertMaterial({
          color: "#ffbb88",
          opacity: 0.4,
          transparent: true
        });
      }
    },
    tileCurvatureResolution: {
      "default": 5
    },
    // in angular degrees
    tilesTransitionDuration: {
      "default": 1e3,
      triggerUpdate: false
    }
    // ms
  },
  init: function init9(threeObj, state, _ref) {
    var tweenGroup = _ref.tweenGroup;
    emptyObject3(threeObj);
    state.scene = threeObj;
    state.tweenGroup = tweenGroup;
    state.dataMapper = new ThreeDigest(threeObj, {
      objBindAttr: "__threeObjTile"
    }).onCreateObj(function() {
      var obj = new THREE$7.Mesh();
      obj.__globeObjType = "tile";
      return obj;
    });
  },
  update: function update10(state) {
    var latAccessor = index3(state.tileLat);
    var lngAccessor = index3(state.tileLng);
    var altitudeAccessor = index3(state.tileAltitude);
    var widthAccessor = index3(state.tileWidth);
    var heightAccessor = index3(state.tileHeight);
    var useGlobeProjectionAccessor = index3(state.tileUseGlobeProjection);
    var materialAccessor = index3(state.tileMaterial);
    var curvatureResolutionAccessor = index3(state.tileCurvatureResolution);
    state.dataMapper.onUpdateObj(function(obj, d) {
      obj.material = materialAccessor(d);
      var useGlobeProjection = useGlobeProjectionAccessor(d);
      var curvatureResolution = curvatureResolutionAccessor(d);
      var applyPosition = function applyPosition2(td) {
        var _obj$__currentTargetD = obj.__currentTargetD = td, lat = _obj$__currentTargetD.lat, lng = _obj$__currentTargetD.lng, alt = _obj$__currentTargetD.alt, width = _obj$__currentTargetD.width, height = _obj$__currentTargetD.height;
        var rotLng = deg2Rad2(lng);
        var rotLat = deg2Rad2(-lat);
        obj.geometry && obj.geometry.dispose();
        obj.geometry = new THREE$7.SphereGeometry(GLOBE_RADIUS * (1 + alt), Math.ceil(width / (curvatureResolution || -1)), Math.ceil(height / (curvatureResolution || -1)), deg2Rad2(90 - width / 2) + (useGlobeProjection ? rotLng : 0), deg2Rad2(width), deg2Rad2(90 - height / 2) + (useGlobeProjection ? rotLat : 0), deg2Rad2(height));
        if (!useGlobeProjection) {
          obj.setRotationFromEuler(new THREE$7.Euler(rotLat, rotLng, 0, "YXZ"));
        }
      };
      var targetD = {
        lat: +latAccessor(d),
        lng: +lngAccessor(d),
        alt: +altitudeAccessor(d),
        width: +widthAccessor(d),
        height: +heightAccessor(d)
      };
      var currentTargetD = obj.__currentTargetD || Object.assign({}, targetD, {
        width: 0,
        height: 0
      });
      if (Object.keys(targetD).some(function(k) {
        return currentTargetD[k] !== targetD[k];
      })) {
        if (!state.tilesTransitionDuration || state.tilesTransitionDuration < 0) {
          applyPosition(targetD);
        } else {
          state.tweenGroup.add(new Tween(currentTargetD).to(targetD, state.tilesTransitionDuration).easing(Easing.Quadratic.InOut).onUpdate(applyPosition).start());
        }
      }
    }).digest(state.tilesData);
  }
});
var deg2Rad2 = function deg2Rad3(deg) {
  return deg * Math.PI / 180;
};
var THREE$6 = window.THREE ? window.THREE : {
  BufferGeometry,
  Color,
  Points,
  PointsMaterial
};
var ParticlesLayerKapsule = index({
  props: {
    particlesData: {
      "default": []
    },
    particlesList: {
      "default": function _default19(d) {
        return d;
      }
    },
    // arrays of arrays
    particleLat: {
      "default": "lat"
    },
    particleLng: {
      "default": "lng"
    },
    particleAltitude: {
      "default": 0.01
    },
    // in units of globe radius
    particlesSize: {
      "default": 0.5
    },
    particlesSizeAttenuation: {
      "default": true
    },
    particlesColor: {
      "default": function _default20() {
        return "white";
      }
    },
    particlesTexture: {}
  },
  init: function init10(threeObj, state) {
    emptyObject3(threeObj);
    state.scene = threeObj;
    state.dataMapper = new ThreeDigest(threeObj, {
      objBindAttr: "__threeObjParticles"
    }).onCreateObj(function() {
      var obj = new THREE$6.Points(new THREE$6.BufferGeometry(), new THREE$6.PointsMaterial());
      obj.__globeObjType = "particles";
      return obj;
    }).onUpdateObj(function(obj, d) {
      var particlesListAccessor = index3(state.particlesList);
      var latAccessor = index3(state.particleLat);
      var lngAccessor = index3(state.particleLng);
      var altitudeAccessor = index3(state.particleAltitude);
      obj.geometry.setAttribute("position", array2BufferAttr(particlesListAccessor(d).map(function(p) {
        return Object.values(polar2Cartesian4(latAccessor(p), lngAccessor(p), altitudeAccessor(p)));
      }), 3));
    });
  },
  update: function update11(state, changedProps) {
    if (["particlesData", "particlesList", "particleLat", "particleLng", "particleAltitude"].some(function(p) {
      return changedProps.hasOwnProperty(p);
    })) {
      state.dataMapper.digest(state.particlesData);
    }
    var colorAccessor = index3(state.particlesColor);
    var sizeAccessor = index3(state.particlesSize);
    var sizeAttenuationAccessor = index3(state.particlesSizeAttenuation);
    var textureAccessor = index3(state.particlesTexture);
    state.dataMapper.entries().forEach(function(_ref) {
      var _ref2 = _slicedToArray7(_ref, 2), d = _ref2[0], obj = _ref2[1];
      obj.material.size = sizeAccessor(d);
      obj.material.sizeAttenuation = sizeAttenuationAccessor(d);
      if (!state.particlesTexture) {
        var color4 = colorAccessor(d);
        var opacity = colorAlpha(color4);
        obj.material.color = new THREE$6.Color(colorStr2Hex(color4));
        obj.material.transparent = opacity < 1;
        obj.material.opacity = opacity;
        obj.material.alphaTest = 0;
      } else {
        obj.material.color = new THREE$6.Color(16777215);
        obj.material.transparent = false;
        obj.material.alphaTest = 0.5;
        obj.material.map = textureAccessor(d);
      }
    });
  }
});
var THREE$5 = window.THREE ? window.THREE : {
  BufferGeometry
};
var CircleLineGeometry = function(_THREE$BufferGeometry) {
  function CircleLineGeometry2() {
    var _this;
    var radius = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1;
    var segmentCount = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 32;
    _classCallCheck6(this, CircleLineGeometry2);
    _this = _callSuper4(this, CircleLineGeometry2);
    _this.type = "CircleLineGeometry";
    _this.parameters = {
      radius,
      segmentCount
    };
    var points = [];
    for (var i = 0; i <= segmentCount; i++) {
      var theta = (i / segmentCount - 0.25) * Math.PI * 2;
      points.push({
        x: Math.cos(theta) * radius,
        y: Math.sin(theta) * radius,
        z: 0
      });
    }
    _this.setFromPoints(points);
    return _this;
  }
  _inherits4(CircleLineGeometry2, _THREE$BufferGeometry);
  return _createClass6(CircleLineGeometry2);
}(THREE$5.BufferGeometry);
var THREE$4 = window.THREE ? window.THREE : {
  Color,
  Group,
  Line,
  LineBasicMaterial,
  Vector3
};
var FrameTicker = import_frame_ticker.default["default"] || import_frame_ticker.default;
var RingsLayerKapsule = index({
  props: {
    ringsData: {
      "default": []
    },
    ringLat: {
      "default": "lat"
    },
    ringLng: {
      "default": "lng"
    },
    ringAltitude: {
      "default": 15e-4
    },
    ringColor: {
      "default": function _default21() {
        return "#ffffaa";
      },
      triggerUpdate: false
    },
    // single color, array of colors or color interpolation fn
    ringResolution: {
      "default": 64,
      triggerUpdate: false
    },
    // how many slice segments in each circle's circumference
    ringMaxRadius: {
      "default": 2,
      triggerUpdate: false
    },
    // degrees
    ringPropagationSpeed: {
      "default": 1,
      triggerUpdate: false
    },
    // degrees/s
    ringRepeatPeriod: {
      "default": 700,
      triggerUpdate: false
    }
    // ms
  },
  methods: {
    pauseAnimation: function pauseAnimation3(state) {
      var _state$ticker;
      (_state$ticker = state.ticker) === null || _state$ticker === void 0 || _state$ticker.pause();
    },
    resumeAnimation: function resumeAnimation3(state) {
      var _state$ticker2;
      (_state$ticker2 = state.ticker) === null || _state$ticker2 === void 0 || _state$ticker2.resume();
    },
    _destructor: function _destructor4(state) {
      var _state$ticker3;
      (_state$ticker3 = state.ticker) === null || _state$ticker3 === void 0 || _state$ticker3.dispose();
    }
  },
  init: function init11(threeObj, state, _ref) {
    var tweenGroup = _ref.tweenGroup;
    emptyObject3(threeObj);
    state.scene = threeObj;
    state.tweenGroup = tweenGroup;
    state.dataMapper = new ThreeDigest(threeObj, {
      objBindAttr: "__threeObjRing",
      removeDelay: 3e4
      // wait until all rings are gone
    }).onCreateObj(function() {
      var obj = new THREE$4.Group();
      obj.__globeObjType = "ring";
      return obj;
    });
    state.ticker = new FrameTicker();
    state.ticker.onTick.add(function(time4) {
      if (!state.ringsData.length) return;
      var colorAccessor = index3(state.ringColor);
      var altitudeAccessor = index3(state.ringAltitude);
      var maxRadiusAccessor = index3(state.ringMaxRadius);
      var propagationSpeedAccessor = index3(state.ringPropagationSpeed);
      var repeatPeriodAccessor = index3(state.ringRepeatPeriod);
      state.dataMapper.entries().filter(function(_ref2) {
        var _ref3 = _slicedToArray7(_ref2, 2), o = _ref3[1];
        return o;
      }).forEach(function(_ref4) {
        var _ref5 = _slicedToArray7(_ref4, 2), d = _ref5[0], obj = _ref5[1];
        if ((obj.__nextRingTime || 0) <= time4) {
          var periodSecs = repeatPeriodAccessor(d) / 1e3;
          obj.__nextRingTime = time4 + (periodSecs <= 0 ? Infinity : periodSecs);
          var circleObj = new THREE$4.Line(new CircleLineGeometry(1, state.ringResolution), new THREE$4.LineBasicMaterial());
          var colors = colorAccessor(d);
          var isMultiColor = colors instanceof Array || colors instanceof Function;
          var colorInterpolator;
          if (!isMultiColor) {
            circleObj.material.color = new THREE$4.Color(colorStr2Hex(colors));
            setMaterialOpacity(circleObj.material, colorAlpha(colors));
          } else {
            if (colors instanceof Array) {
              colorInterpolator = linear2().domain(colors.map(function(_, idx) {
                return idx / (colors.length - 1);
              })).range(colors);
              circleObj.material.transparent = colors.some(function(c3) {
                return colorAlpha(c3) < 1;
              });
            } else {
              colorInterpolator = colors;
              circleObj.material.transparent = true;
            }
          }
          var curveR = GLOBE_RADIUS * (1 + altitudeAccessor(d));
          var maxRadius = maxRadiusAccessor(d);
          var maxAngle = maxRadius * Math.PI / 180;
          var propagationSpeed = propagationSpeedAccessor(d);
          var isReverse = propagationSpeed <= 0;
          var updateFn = function updateFn2(_ref6) {
            var t = _ref6.t;
            var ang = (isReverse ? 1 - t : t) * maxAngle;
            circleObj.scale.x = circleObj.scale.y = curveR * Math.sin(ang);
            circleObj.position.z = curveR * (1 - Math.cos(ang));
            if (isMultiColor) {
              var color4 = colorInterpolator(t);
              circleObj.material.color = new THREE$4.Color(colorStr2Hex(color4));
              circleObj.material.transparent && (circleObj.material.opacity = colorAlpha(color4));
            }
          };
          if (propagationSpeed === 0) {
            updateFn({
              t: 0
            });
            obj.add(circleObj);
          } else {
            var transitionTime = Math.abs(maxRadius / propagationSpeed) * 1e3;
            state.tweenGroup.add(new Tween({
              t: 0
            }).to({
              t: 1
            }, transitionTime).onUpdate(updateFn).onStart(function() {
              return obj.add(circleObj);
            }).onComplete(function() {
              obj.remove(circleObj);
              _deallocate2(circleObj);
            }).start());
          }
        }
      });
    });
  },
  update: function update12(state) {
    var latAccessor = index3(state.ringLat);
    var lngAccessor = index3(state.ringLng);
    var altitudeAccessor = index3(state.ringAltitude);
    var globeCenter = state.scene.localToWorld(new THREE$4.Vector3(0, 0, 0));
    state.dataMapper.onUpdateObj(function(obj, d) {
      var lat = latAccessor(d);
      var lng = lngAccessor(d);
      var alt = altitudeAccessor(d);
      Object.assign(obj.position, polar2Cartesian4(lat, lng, alt));
      obj.lookAt(globeCenter);
    }).digest(state.ringsData);
  }
});
var glyphs = { "0": { x_min: 73, x_max: 715, ha: 792, o: "m 394 -29 q 153 129 242 -29 q 73 479 73 272 q 152 829 73 687 q 394 989 241 989 q 634 829 545 989 q 715 479 715 684 q 635 129 715 270 q 394 -29 546 -29 m 394 89 q 546 211 489 89 q 598 479 598 322 q 548 748 598 640 q 394 871 491 871 q 241 748 298 871 q 190 479 190 637 q 239 211 190 319 q 394 89 296 89 " }, "1": { x_min: 215.671875, x_max: 574, ha: 792, o: "m 574 0 l 442 0 l 442 697 l 215 697 l 215 796 q 386 833 330 796 q 475 986 447 875 l 574 986 l 574 0 " }, "2": { x_min: 59, x_max: 731, ha: 792, o: "m 731 0 l 59 0 q 197 314 59 188 q 457 487 199 315 q 598 691 598 580 q 543 819 598 772 q 411 867 488 867 q 272 811 328 867 q 209 630 209 747 l 81 630 q 182 901 81 805 q 408 986 271 986 q 629 909 536 986 q 731 694 731 826 q 613 449 731 541 q 378 316 495 383 q 201 122 235 234 l 731 122 l 731 0 " }, "3": { x_min: 54, x_max: 737, ha: 792, o: "m 737 284 q 635 55 737 141 q 399 -25 541 -25 q 156 52 248 -25 q 54 308 54 140 l 185 308 q 245 147 185 202 q 395 96 302 96 q 539 140 484 96 q 602 280 602 190 q 510 429 602 390 q 324 454 451 454 l 324 565 q 487 584 441 565 q 565 719 565 617 q 515 835 565 791 q 395 879 466 879 q 255 824 307 879 q 203 661 203 769 l 78 661 q 166 909 78 822 q 387 992 250 992 q 603 921 513 992 q 701 723 701 844 q 669 607 701 656 q 578 524 637 558 q 696 434 655 499 q 737 284 737 369 " }, "4": { x_min: 48, x_max: 742.453125, ha: 792, o: "m 742 243 l 602 243 l 602 0 l 476 0 l 476 243 l 48 243 l 48 368 l 476 958 l 602 958 l 602 354 l 742 354 l 742 243 m 476 354 l 476 792 l 162 354 l 476 354 " }, "5": { x_min: 54.171875, x_max: 738, ha: 792, o: "m 738 314 q 626 60 738 153 q 382 -23 526 -23 q 155 47 248 -23 q 54 256 54 125 l 183 256 q 259 132 204 174 q 382 91 314 91 q 533 149 471 91 q 602 314 602 213 q 538 469 602 411 q 386 528 475 528 q 284 506 332 528 q 197 439 237 484 l 81 439 l 159 958 l 684 958 l 684 840 l 254 840 l 214 579 q 306 627 258 612 q 407 643 354 643 q 636 552 540 643 q 738 314 738 457 " }, "6": { x_min: 53, x_max: 739, ha: 792, o: "m 739 312 q 633 62 739 162 q 400 -31 534 -31 q 162 78 257 -31 q 53 439 53 206 q 178 859 53 712 q 441 986 284 986 q 643 912 559 986 q 732 713 732 833 l 601 713 q 544 830 594 786 q 426 875 494 875 q 268 793 331 875 q 193 517 193 697 q 301 597 240 570 q 427 624 362 624 q 643 540 552 624 q 739 312 739 451 m 603 298 q 540 461 603 400 q 404 516 484 516 q 268 461 323 516 q 207 300 207 401 q 269 137 207 198 q 405 83 325 83 q 541 137 486 83 q 603 298 603 197 " }, "7": { x_min: 58.71875, x_max: 730.953125, ha: 792, o: "m 730 839 q 469 448 560 641 q 335 0 378 255 l 192 0 q 328 441 235 252 q 593 830 421 630 l 58 830 l 58 958 l 730 958 l 730 839 " }, "8": { x_min: 55, x_max: 736, ha: 792, o: "m 571 527 q 694 424 652 491 q 736 280 736 358 q 648 71 736 158 q 395 -26 551 -26 q 142 69 238 -26 q 55 279 55 157 q 96 425 55 359 q 220 527 138 491 q 120 615 153 562 q 88 726 88 668 q 171 904 88 827 q 395 986 261 986 q 618 905 529 986 q 702 727 702 830 q 670 616 702 667 q 571 527 638 565 m 394 565 q 519 610 475 565 q 563 717 563 655 q 521 823 563 781 q 392 872 474 872 q 265 824 312 872 q 224 720 224 783 q 265 613 224 656 q 394 565 312 565 m 395 91 q 545 150 488 91 q 597 280 597 204 q 546 408 597 355 q 395 465 492 465 q 244 408 299 465 q 194 280 194 356 q 244 150 194 203 q 395 91 299 91 " }, "9": { x_min: 53, x_max: 739, ha: 792, o: "m 739 524 q 619 94 739 241 q 362 -32 516 -32 q 150 47 242 -32 q 59 244 59 126 l 191 244 q 246 129 191 176 q 373 82 301 82 q 526 161 466 82 q 597 440 597 255 q 363 334 501 334 q 130 432 216 334 q 53 650 53 521 q 134 880 53 786 q 383 986 226 986 q 659 841 566 986 q 739 524 739 719 m 388 449 q 535 514 480 449 q 585 658 585 573 q 535 805 585 744 q 388 873 480 873 q 242 809 294 873 q 191 658 191 745 q 239 514 191 572 q 388 449 292 449 " }, "": { x_min: 0, x_max: 712, ha: 815, o: "m 356 -25 q 96 88 192 -25 q 0 368 0 201 q 92 642 0 533 q 356 761 192 761 q 617 644 517 761 q 712 368 712 533 q 619 91 712 201 q 356 -25 520 -25 m 356 85 q 527 175 465 85 q 583 369 583 255 q 528 562 583 484 q 356 651 466 651 q 189 560 250 651 q 135 369 135 481 q 187 177 135 257 q 356 85 250 85 " }, S: { x_min: 0, x_max: 788, ha: 890, o: "m 788 291 q 662 54 788 144 q 397 -26 550 -26 q 116 68 226 -26 q 0 337 0 168 l 131 337 q 200 152 131 220 q 384 85 269 85 q 557 129 479 85 q 650 270 650 183 q 490 429 650 379 q 194 513 341 470 q 33 739 33 584 q 142 964 33 881 q 388 1041 242 1041 q 644 957 543 1041 q 756 716 756 867 l 625 716 q 561 874 625 816 q 395 933 497 933 q 243 891 309 933 q 164 759 164 841 q 325 609 164 656 q 625 526 475 568 q 788 291 788 454 " }, "": { x_min: 343, x_max: 449, ha: 792, o: "m 449 462 l 343 462 l 343 986 l 449 986 l 449 462 m 449 -242 l 343 -242 l 343 280 l 449 280 l 449 -242 " }, "/": { x_min: 183.25, x_max: 608.328125, ha: 792, o: "m 608 1041 l 266 -129 l 183 -129 l 520 1041 l 608 1041 " }, "": { x_min: -0.4375, x_max: 777.453125, ha: 839, o: "m 777 893 l 458 893 l 458 0 l 319 0 l 319 892 l 0 892 l 0 1013 l 777 1013 l 777 893 " }, y: { x_min: 0, x_max: 684.78125, ha: 771, o: "m 684 738 l 388 -83 q 311 -216 356 -167 q 173 -279 252 -279 q 97 -266 133 -279 l 97 -149 q 132 -155 109 -151 q 168 -160 155 -160 q 240 -114 213 -160 q 274 -26 248 -98 l 0 738 l 137 737 l 341 139 l 548 737 l 684 738 " }, "": { x_min: 0, x_max: 803, ha: 917, o: "m 803 0 l 667 0 l 667 886 l 140 886 l 140 0 l 0 0 l 0 1012 l 803 1012 l 803 0 " }, "": { x_min: -111, x_max: 339, ha: 361, o: "m 339 800 l 229 800 l 229 925 l 339 925 l 339 800 m -1 800 l -111 800 l -111 925 l -1 925 l -1 800 m 284 3 q 233 -10 258 -5 q 182 -15 207 -15 q 85 26 119 -15 q 42 200 42 79 l 42 737 l 167 737 l 168 215 q 172 141 168 157 q 226 101 183 101 q 248 103 239 101 q 284 112 257 104 l 284 3 m 302 1040 l 113 819 l 30 819 l 165 1040 l 302 1040 " }, g: { x_min: 0, x_max: 686, ha: 838, o: "m 686 34 q 586 -213 686 -121 q 331 -306 487 -306 q 131 -252 216 -306 q 31 -84 31 -190 l 155 -84 q 228 -174 166 -138 q 345 -207 284 -207 q 514 -109 454 -207 q 564 89 564 -27 q 461 6 521 36 q 335 -23 401 -23 q 88 100 184 -23 q 0 370 0 215 q 87 634 0 522 q 330 758 183 758 q 457 728 398 758 q 564 644 515 699 l 564 737 l 686 737 l 686 34 m 582 367 q 529 560 582 481 q 358 652 468 652 q 189 561 250 652 q 135 369 135 482 q 189 176 135 255 q 361 85 251 85 q 529 176 468 85 q 582 367 582 255 " }, "": { x_min: 0, x_max: 442, ha: 539, o: "m 442 383 l 0 383 q 91 566 0 492 q 260 668 176 617 q 354 798 354 727 q 315 875 354 845 q 227 905 277 905 q 136 869 173 905 q 99 761 99 833 l 14 761 q 82 922 14 864 q 232 974 141 974 q 379 926 316 974 q 442 797 442 878 q 351 635 442 704 q 183 539 321 611 q 92 455 92 491 l 442 455 l 442 383 " }, "": { x_min: 0, x_max: 705.5625, ha: 803, o: "m 705 334 l 0 334 l 0 410 l 705 410 l 705 334 " }, "": { x_min: 0, x_max: 819.5625, ha: 893, o: "m 819 0 l 650 0 l 294 509 l 139 356 l 139 0 l 0 0 l 0 1013 l 139 1013 l 139 526 l 626 1013 l 809 1013 l 395 600 l 819 0 " }, "": { x_min: -46.265625, x_max: 392, ha: 513, o: "m 392 651 l 259 651 l 79 -279 l -46 -278 l 134 651 l 14 651 l 14 751 l 135 751 q 151 948 135 900 q 304 1041 185 1041 q 334 1040 319 1041 q 392 1034 348 1039 l 392 922 q 337 931 360 931 q 271 883 287 931 q 260 793 260 853 l 260 751 l 392 751 l 392 651 " }, e: { x_min: 0, x_max: 714, ha: 813, o: "m 714 326 l 140 326 q 200 157 140 227 q 359 87 260 87 q 488 130 431 87 q 561 245 545 174 l 697 245 q 577 48 670 123 q 358 -26 484 -26 q 97 85 195 -26 q 0 363 0 197 q 94 642 0 529 q 358 765 195 765 q 626 627 529 765 q 714 326 714 503 m 576 429 q 507 583 564 522 q 355 650 445 650 q 206 583 266 650 q 140 429 152 522 l 576 429 " }, "": { x_min: 0, x_max: 712, ha: 815, o: "m 356 -25 q 94 91 194 -25 q 0 368 0 202 q 92 642 0 533 q 356 761 192 761 q 617 644 517 761 q 712 368 712 533 q 619 91 712 201 q 356 -25 520 -25 m 356 85 q 527 175 465 85 q 583 369 583 255 q 528 562 583 484 q 356 651 466 651 q 189 560 250 651 q 135 369 135 481 q 187 177 135 257 q 356 85 250 85 m 576 1040 l 387 819 l 303 819 l 438 1040 l 576 1040 " }, J: { x_min: 0, x_max: 588, ha: 699, o: "m 588 279 q 287 -26 588 -26 q 58 73 126 -26 q 0 327 0 158 l 133 327 q 160 172 133 227 q 288 96 198 96 q 426 171 391 96 q 449 336 449 219 l 449 1013 l 588 1013 l 588 279 " }, "": { x_min: -1, x_max: 503, ha: 601, o: "m 503 302 l 280 136 l 281 256 l 429 373 l 281 486 l 280 608 l 503 440 l 503 302 m 221 302 l 0 136 l 0 255 l 145 372 l 0 486 l -1 608 l 221 440 l 221 302 " }, "": { x_min: -3, x_max: 1008, ha: 1106, o: "m 502 -7 q 123 151 263 -7 q -3 501 -3 294 q 123 851 -3 706 q 502 1011 263 1011 q 881 851 739 1011 q 1008 501 1008 708 q 883 151 1008 292 q 502 -7 744 -7 m 502 60 q 830 197 709 60 q 940 501 940 322 q 831 805 940 681 q 502 944 709 944 q 174 805 296 944 q 65 501 65 680 q 173 197 65 320 q 502 60 294 60 m 741 394 q 661 246 731 302 q 496 190 591 190 q 294 285 369 190 q 228 497 228 370 q 295 714 228 625 q 499 813 370 813 q 656 762 588 813 q 733 625 724 711 l 634 625 q 589 704 629 673 q 498 735 550 735 q 377 666 421 735 q 334 504 334 597 q 374 340 334 408 q 490 272 415 272 q 589 304 549 272 q 638 394 628 337 l 741 394 " }, "": { x_min: 0, x_max: 922, ha: 1030, o: "m 687 1040 l 498 819 l 415 819 l 549 1040 l 687 1040 m 922 339 q 856 97 922 203 q 650 -26 780 -26 q 538 9 587 -26 q 461 103 489 44 q 387 12 436 46 q 277 -22 339 -22 q 69 97 147 -22 q 0 338 0 202 q 45 551 0 444 q 161 737 84 643 l 302 737 q 175 552 219 647 q 124 336 124 446 q 155 179 124 248 q 275 88 197 88 q 375 163 341 88 q 400 294 400 219 l 400 572 l 524 572 l 524 294 q 561 135 524 192 q 643 88 591 88 q 762 182 719 88 q 797 341 797 257 q 745 555 797 450 q 619 737 705 637 l 760 737 q 874 551 835 640 q 922 339 922 444 " }, "^": { x_min: 193.0625, x_max: 598.609375, ha: 792, o: "m 598 772 l 515 772 l 395 931 l 277 772 l 193 772 l 326 1013 l 462 1013 l 598 772 " }, "": { x_min: 0, x_max: 507.203125, ha: 604, o: "m 506 136 l 284 302 l 284 440 l 506 608 l 507 485 l 360 371 l 506 255 l 506 136 m 222 136 l 0 302 l 0 440 l 222 608 l 221 486 l 73 373 l 222 256 l 222 136 " }, D: { x_min: 0, x_max: 828, ha: 935, o: "m 389 1013 q 714 867 593 1013 q 828 521 828 729 q 712 161 828 309 q 382 0 587 0 l 0 0 l 0 1013 l 389 1013 m 376 124 q 607 247 523 124 q 681 510 681 355 q 607 771 681 662 q 376 896 522 896 l 139 896 l 139 124 l 376 124 " }, "": { x_min: 0, x_max: 142, ha: 239, o: "m 142 585 l 0 585 l 0 738 l 142 738 l 142 585 " }, "": { x_min: 0, x_max: 47, ha: 125, o: "m 47 3 q 37 -7 47 -7 q 28 0 30 -7 q 39 -4 32 -4 q 45 3 45 -1 l 37 0 q 28 9 28 0 q 39 19 28 19 l 47 16 l 47 19 l 47 3 m 37 1 q 44 8 44 1 q 37 16 44 16 q 30 8 30 16 q 37 1 30 1 m 26 1 l 23 22 l 14 0 l 3 22 l 3 3 l 0 25 l 13 1 l 22 25 l 26 1 " }, w: { x_min: 0, x_max: 1009.71875, ha: 1100, o: "m 1009 738 l 783 0 l 658 0 l 501 567 l 345 0 l 222 0 l 0 738 l 130 738 l 284 174 l 432 737 l 576 738 l 721 173 l 881 737 l 1009 738 " }, $: { x_min: 0, x_max: 700, ha: 793, o: "m 664 717 l 542 717 q 490 825 531 785 q 381 872 450 865 l 381 551 q 620 446 540 522 q 700 241 700 370 q 618 45 700 116 q 381 -25 536 -25 l 381 -152 l 307 -152 l 307 -25 q 81 62 162 -25 q 0 297 0 149 l 124 297 q 169 146 124 204 q 307 81 215 89 l 307 441 q 80 536 148 469 q 13 725 13 603 q 96 910 13 839 q 307 982 180 982 l 307 1077 l 381 1077 l 381 982 q 574 917 494 982 q 664 717 664 845 m 307 565 l 307 872 q 187 831 233 872 q 142 724 142 791 q 180 618 142 656 q 307 565 218 580 m 381 76 q 562 237 562 96 q 517 361 562 313 q 381 423 472 409 l 381 76 " }, "\\": { x_min: -0.015625, x_max: 425.0625, ha: 522, o: "m 425 -129 l 337 -129 l 0 1041 l 83 1041 l 425 -129 " }, "": { x_min: 0, x_max: 697.21875, ha: 747, o: "m 697 -4 q 629 -14 658 -14 q 498 97 513 -14 q 422 9 470 41 q 313 -23 374 -23 q 207 4 258 -23 q 119 81 156 32 l 119 -278 l 0 -278 l 0 738 l 124 738 l 124 343 q 165 173 124 246 q 308 83 216 83 q 452 178 402 83 q 493 359 493 255 l 493 738 l 617 738 l 617 214 q 623 136 617 160 q 673 92 637 92 q 697 96 684 92 l 697 -4 " }, "": { x_min: 42, x_max: 181, ha: 297, o: "m 181 0 l 42 0 l 42 1013 l 181 1013 l 181 0 " }, "": { x_min: 0, x_max: 1144.5, ha: 1214, o: "m 1144 1012 l 807 416 l 807 0 l 667 0 l 667 416 l 325 1012 l 465 1012 l 736 533 l 1004 1012 l 1144 1012 m 277 1040 l 83 799 l 0 799 l 140 1040 l 277 1040 " }, "": { x_min: 0, x_max: 139, ha: 236, o: "m 139 851 q 102 737 139 784 q 0 669 65 690 l 0 734 q 59 787 42 741 q 72 873 72 821 l 0 873 l 0 1013 l 139 1013 l 139 851 " }, "": { x_min: 0, x_max: 801, ha: 915, o: "m 801 0 l 651 0 l 131 822 l 131 0 l 0 0 l 0 1013 l 151 1013 l 670 191 l 670 1013 l 801 1013 l 801 0 " }, "-": { x_min: 8.71875, x_max: 350.390625, ha: 478, o: "m 350 317 l 8 317 l 8 428 l 350 428 l 350 317 " }, Q: { x_min: 0, x_max: 968, ha: 1072, o: "m 954 5 l 887 -79 l 744 35 q 622 -11 687 2 q 483 -26 556 -26 q 127 130 262 -26 q 0 504 0 279 q 127 880 0 728 q 484 1041 262 1041 q 841 884 708 1041 q 968 507 968 735 q 933 293 968 398 q 832 104 899 188 l 954 5 m 723 191 q 802 330 777 248 q 828 499 828 412 q 744 790 828 673 q 483 922 650 922 q 228 791 322 922 q 142 505 142 673 q 227 221 142 337 q 487 91 323 91 q 632 123 566 91 l 520 215 l 587 301 l 723 191 " }, "": { x_min: 1, x_max: 676.28125, ha: 740, o: "m 676 460 l 551 460 q 498 595 542 546 q 365 651 448 651 q 199 578 263 651 q 136 401 136 505 q 266 178 136 241 q 508 106 387 142 q 640 -50 640 62 q 625 -158 640 -105 q 583 -278 611 -211 l 465 -278 q 498 -182 490 -211 q 515 -80 515 -126 q 381 12 515 -15 q 134 91 197 51 q 1 388 1 179 q 100 651 1 542 q 354 761 199 761 q 587 680 498 761 q 676 460 676 599 " }, M: { x_min: 0, x_max: 954, ha: 1067, o: "m 954 0 l 819 0 l 819 869 l 537 0 l 405 0 l 128 866 l 128 0 l 0 0 l 0 1013 l 200 1013 l 472 160 l 757 1013 l 954 1013 l 954 0 " }, "": { x_min: 0, x_max: 1006, ha: 1094, o: "m 1006 678 q 914 319 1006 429 q 571 200 814 200 l 571 0 l 433 0 l 433 200 q 92 319 194 200 q 0 678 0 429 l 0 1013 l 139 1013 l 139 679 q 191 417 139 492 q 433 326 255 326 l 433 1013 l 571 1013 l 571 326 l 580 326 q 813 423 747 326 q 868 679 868 502 l 868 1013 l 1006 1013 l 1006 678 " }, C: { x_min: 0, x_max: 886, ha: 944, o: "m 886 379 q 760 87 886 201 q 455 -26 634 -26 q 112 136 236 -26 q 0 509 0 283 q 118 882 0 737 q 469 1041 245 1041 q 748 955 630 1041 q 879 708 879 859 l 745 708 q 649 862 724 805 q 473 920 573 920 q 219 791 312 920 q 136 509 136 675 q 217 229 136 344 q 470 99 311 99 q 672 179 591 99 q 753 379 753 259 l 886 379 " }, "!": { x_min: 0, x_max: 138, ha: 236, o: "m 138 684 q 116 409 138 629 q 105 244 105 299 l 33 244 q 16 465 33 313 q 0 684 0 616 l 0 1013 l 138 1013 l 138 684 m 138 0 l 0 0 l 0 151 l 138 151 l 138 0 " }, "{": { x_min: 0, x_max: 480.5625, ha: 578, o: "m 480 -286 q 237 -213 303 -286 q 187 -45 187 -159 q 194 48 187 -15 q 201 141 201 112 q 164 264 201 225 q 0 314 118 314 l 0 417 q 164 471 119 417 q 201 605 201 514 q 199 665 201 644 q 193 772 193 769 q 241 941 193 887 q 480 1015 308 1015 l 480 915 q 336 866 375 915 q 306 742 306 828 q 310 662 306 717 q 314 577 314 606 q 288 452 314 500 q 176 365 256 391 q 289 275 257 337 q 314 143 314 226 q 313 84 314 107 q 310 -11 310 -5 q 339 -131 310 -94 q 480 -182 377 -182 l 480 -286 " }, X: { x_min: -0.015625, x_max: 854.15625, ha: 940, o: "m 854 0 l 683 0 l 423 409 l 166 0 l 0 0 l 347 519 l 18 1013 l 186 1013 l 428 637 l 675 1013 l 836 1013 l 504 520 l 854 0 " }, "#": { x_min: 0, x_max: 963.890625, ha: 1061, o: "m 963 690 l 927 590 l 719 590 l 655 410 l 876 410 l 840 310 l 618 310 l 508 -3 l 393 -2 l 506 309 l 329 310 l 215 -2 l 102 -3 l 212 310 l 0 310 l 36 410 l 248 409 l 312 590 l 86 590 l 120 690 l 347 690 l 459 1006 l 573 1006 l 462 690 l 640 690 l 751 1006 l 865 1006 l 754 690 l 963 690 m 606 590 l 425 590 l 362 410 l 543 410 l 606 590 " }, "": { x_min: 42, x_max: 284, ha: 361, o: "m 284 3 q 233 -10 258 -5 q 182 -15 207 -15 q 85 26 119 -15 q 42 200 42 79 l 42 738 l 167 738 l 168 215 q 172 141 168 157 q 226 101 183 101 q 248 103 239 101 q 284 112 257 104 l 284 3 " }, "": { x_min: 0, x_max: 906.953125, ha: 982, o: "m 283 1040 l 88 799 l 5 799 l 145 1040 l 283 1040 m 906 0 l 756 0 l 650 303 l 251 303 l 143 0 l 0 0 l 376 1012 l 529 1012 l 906 0 m 609 421 l 452 866 l 293 421 l 609 421 " }, ")": { x_min: 0, x_max: 318, ha: 415, o: "m 318 365 q 257 25 318 191 q 87 -290 197 -141 l 0 -290 q 140 21 93 -128 q 193 360 193 189 q 141 704 193 537 q 0 1024 97 850 l 87 1024 q 257 706 197 871 q 318 365 318 542 " }, "": { x_min: 0, x_max: 634.71875, ha: 714, o: "m 634 234 q 527 38 634 110 q 300 -25 433 -25 q 98 29 183 -25 q 0 204 0 93 q 37 314 0 265 q 128 390 67 353 q 56 460 82 419 q 26 555 26 505 q 114 712 26 654 q 295 763 191 763 q 499 700 416 763 q 589 515 589 631 l 478 515 q 419 618 464 580 q 307 657 374 657 q 207 630 253 657 q 151 547 151 598 q 238 445 151 469 q 389 434 280 434 l 389 331 l 349 331 q 206 315 255 331 q 125 210 125 287 q 183 107 125 145 q 302 76 233 76 q 436 117 379 76 q 509 234 493 159 l 634 234 " }, "": { x_min: 0, x_max: 952.78125, ha: 1028, o: "m 952 0 l 0 0 l 400 1013 l 551 1013 l 952 0 m 762 124 l 476 867 l 187 124 l 762 124 " }, "}": { x_min: 0, x_max: 481, ha: 578, o: "m 481 314 q 318 262 364 314 q 282 136 282 222 q 284 65 282 97 q 293 -58 293 -48 q 241 -217 293 -166 q 0 -286 174 -286 l 0 -182 q 143 -130 105 -182 q 171 -2 171 -93 q 168 81 171 22 q 165 144 165 140 q 188 275 165 229 q 306 365 220 339 q 191 455 224 391 q 165 588 165 505 q 168 681 165 624 q 171 742 171 737 q 141 865 171 827 q 0 915 102 915 l 0 1015 q 243 942 176 1015 q 293 773 293 888 q 287 675 293 741 q 282 590 282 608 q 318 466 282 505 q 481 417 364 417 l 481 314 " }, "": { x_min: -3, x_max: 1672, ha: 1821, o: "m 846 0 q 664 76 732 0 q 603 244 603 145 q 662 412 603 344 q 846 489 729 489 q 1027 412 959 489 q 1089 244 1089 343 q 1029 76 1089 144 q 846 0 962 0 m 845 103 q 945 143 910 103 q 981 243 981 184 q 947 340 981 301 q 845 385 910 385 q 745 342 782 385 q 709 243 709 300 q 742 147 709 186 q 845 103 781 103 m 888 986 l 284 -25 l 199 -25 l 803 986 l 888 986 m 241 468 q 58 545 126 468 q -3 715 -3 615 q 56 881 -3 813 q 238 958 124 958 q 421 881 353 958 q 483 712 483 813 q 423 544 483 612 q 241 468 356 468 m 241 855 q 137 811 175 855 q 100 710 100 768 q 136 612 100 653 q 240 572 172 572 q 344 614 306 572 q 382 713 382 656 q 347 810 382 771 q 241 855 308 855 m 1428 0 q 1246 76 1314 0 q 1185 244 1185 145 q 1244 412 1185 344 q 1428 489 1311 489 q 1610 412 1542 489 q 1672 244 1672 343 q 1612 76 1672 144 q 1428 0 1545 0 m 1427 103 q 1528 143 1492 103 q 1564 243 1564 184 q 1530 340 1564 301 q 1427 385 1492 385 q 1327 342 1364 385 q 1291 243 1291 300 q 1324 147 1291 186 q 1427 103 1363 103 " }, a: { x_min: 0, x_max: 698.609375, ha: 794, o: "m 698 0 q 661 -12 679 -7 q 615 -17 643 -17 q 536 12 564 -17 q 500 96 508 41 q 384 6 456 37 q 236 -25 312 -25 q 65 31 130 -25 q 0 194 0 88 q 118 390 0 334 q 328 435 180 420 q 488 483 476 451 q 495 523 495 504 q 442 619 495 584 q 325 654 389 654 q 209 617 257 654 q 152 513 161 580 l 33 513 q 123 705 33 633 q 332 772 207 772 q 528 712 448 772 q 617 531 617 645 l 617 163 q 624 108 617 126 q 664 90 632 90 l 698 94 l 698 0 m 491 262 l 491 372 q 272 329 350 347 q 128 201 128 294 q 166 113 128 144 q 264 83 205 83 q 414 130 346 83 q 491 262 491 183 " }, "": { x_min: 0, x_max: 941.671875, ha: 1039, o: "m 941 334 l 0 334 l 0 410 l 941 410 l 941 334 " }, "=": { x_min: 8.71875, x_max: 780.953125, ha: 792, o: "m 780 510 l 8 510 l 8 606 l 780 606 l 780 510 m 780 235 l 8 235 l 8 332 l 780 332 l 780 235 " }, N: { x_min: 0, x_max: 801, ha: 914, o: "m 801 0 l 651 0 l 131 823 l 131 0 l 0 0 l 0 1013 l 151 1013 l 670 193 l 670 1013 l 801 1013 l 801 0 " }, "": { x_min: 0, x_max: 712, ha: 797, o: "m 712 369 q 620 94 712 207 q 362 -26 521 -26 q 230 2 292 -26 q 119 83 167 30 l 119 -278 l 0 -278 l 0 362 q 91 643 0 531 q 355 764 190 764 q 617 647 517 764 q 712 369 712 536 m 583 366 q 530 559 583 480 q 359 651 469 651 q 190 562 252 651 q 135 370 135 483 q 189 176 135 257 q 359 85 250 85 q 528 175 466 85 q 583 366 583 254 " }, "": { x_min: 0, x_max: 941.671875, ha: 938, o: "m 941 1033 l 0 1033 l 0 1109 l 941 1109 l 941 1033 " }, Z: { x_min: 0, x_max: 779, ha: 849, o: "m 779 0 l 0 0 l 0 113 l 621 896 l 40 896 l 40 1013 l 779 1013 l 778 887 l 171 124 l 779 124 l 779 0 " }, u: { x_min: 0, x_max: 617, ha: 729, o: "m 617 0 l 499 0 l 499 110 q 391 10 460 45 q 246 -25 322 -25 q 61 58 127 -25 q 0 258 0 136 l 0 738 l 125 738 l 125 284 q 156 148 125 202 q 273 82 197 82 q 433 165 369 82 q 493 340 493 243 l 493 738 l 617 738 l 617 0 " }, k: { x_min: 0, x_max: 612.484375, ha: 697, o: "m 612 738 l 338 465 l 608 0 l 469 0 l 251 382 l 121 251 l 121 0 l 0 0 l 0 1013 l 121 1013 l 121 402 l 456 738 l 612 738 " }, "": { x_min: 0, x_max: 803, ha: 917, o: "m 803 0 l 667 0 l 667 475 l 140 475 l 140 0 l 0 0 l 0 1013 l 140 1013 l 140 599 l 667 599 l 667 1013 l 803 1013 l 803 0 " }, "": { x_min: 0, x_max: 906.953125, ha: 985, o: "m 906 0 l 756 0 l 650 303 l 251 303 l 143 0 l 0 0 l 376 1013 l 529 1013 l 906 0 m 609 421 l 452 866 l 293 421 l 609 421 " }, s: { x_min: 0, x_max: 604, ha: 697, o: "m 604 217 q 501 36 604 104 q 292 -23 411 -23 q 86 43 166 -23 q 0 238 0 114 l 121 237 q 175 122 121 164 q 300 85 223 85 q 415 112 363 85 q 479 207 479 147 q 361 309 479 276 q 140 372 141 370 q 21 544 21 426 q 111 708 21 647 q 298 761 190 761 q 492 705 413 761 q 583 531 583 643 l 462 531 q 412 625 462 594 q 298 657 363 657 q 199 636 242 657 q 143 558 143 608 q 262 454 143 486 q 484 394 479 397 q 604 217 604 341 " }, B: { x_min: 0, x_max: 778, ha: 876, o: "m 580 546 q 724 469 670 535 q 778 311 778 403 q 673 83 778 171 q 432 0 575 0 l 0 0 l 0 1013 l 411 1013 q 629 957 541 1013 q 732 768 732 892 q 691 633 732 693 q 580 546 650 572 m 393 899 l 139 899 l 139 588 l 379 588 q 521 624 462 588 q 592 744 592 667 q 531 859 592 819 q 393 899 471 899 m 419 124 q 566 169 504 124 q 635 303 635 219 q 559 436 635 389 q 402 477 494 477 l 139 477 l 139 124 l 419 124 " }, "": { x_min: 0, x_max: 614, ha: 708, o: "m 142 0 l 0 0 l 0 151 l 142 151 l 142 0 m 378 0 l 236 0 l 236 151 l 378 151 l 378 0 m 614 0 l 472 0 l 472 151 l 614 151 l 614 0 " }, "?": { x_min: 0, x_max: 607, ha: 704, o: "m 607 777 q 543 599 607 674 q 422 474 482 537 q 357 272 357 391 l 236 272 q 297 487 236 395 q 411 619 298 490 q 474 762 474 691 q 422 885 474 838 q 301 933 371 933 q 179 880 228 933 q 124 706 124 819 l 0 706 q 94 963 0 872 q 302 1044 177 1044 q 511 973 423 1044 q 607 777 607 895 m 370 0 l 230 0 l 230 151 l 370 151 l 370 0 " }, H: { x_min: 0, x_max: 803, ha: 915, o: "m 803 0 l 667 0 l 667 475 l 140 475 l 140 0 l 0 0 l 0 1013 l 140 1013 l 140 599 l 667 599 l 667 1013 l 803 1013 l 803 0 " }, "": { x_min: 0, x_max: 675, ha: 761, o: "m 675 738 l 404 0 l 272 0 l 0 738 l 133 738 l 340 147 l 541 738 l 675 738 " }, c: { x_min: 1, x_max: 701.390625, ha: 775, o: "m 701 264 q 584 53 681 133 q 353 -26 487 -26 q 91 91 188 -26 q 1 370 1 201 q 92 645 1 537 q 353 761 190 761 q 572 688 479 761 q 690 493 666 615 l 556 493 q 487 606 545 562 q 356 650 428 650 q 186 563 246 650 q 134 372 134 487 q 188 179 134 258 q 359 88 250 88 q 492 136 437 88 q 566 264 548 185 l 701 264 " }, "": { x_min: 0, x_max: 566.671875, ha: 678, o: "m 21 892 l 52 892 l 98 761 l 145 892 l 176 892 l 178 741 l 157 741 l 157 867 l 108 741 l 88 741 l 40 871 l 40 741 l 21 741 l 21 892 m 308 854 l 308 731 q 252 691 308 691 q 227 691 240 691 q 207 696 213 695 l 207 712 l 253 706 q 288 733 288 706 l 288 763 q 244 741 279 741 q 193 797 193 741 q 261 860 193 860 q 287 860 273 860 q 308 854 302 855 m 288 842 l 263 843 q 213 796 213 843 q 248 756 213 756 q 288 796 288 756 l 288 842 m 566 988 l 502 988 l 502 -1 l 439 -1 l 439 988 l 317 988 l 317 -1 l 252 -1 l 252 602 q 81 653 155 602 q 0 805 0 711 q 101 989 0 918 q 309 1053 194 1053 l 566 1053 l 566 988 " }, "": { x_min: 0, x_max: 660, ha: 745, o: "m 471 550 q 610 450 561 522 q 660 280 660 378 q 578 64 660 151 q 367 -22 497 -22 q 239 5 299 -22 q 126 82 178 32 l 126 -278 l 0 -278 l 0 593 q 54 903 0 801 q 318 1042 127 1042 q 519 964 436 1042 q 603 771 603 887 q 567 644 603 701 q 471 550 532 586 m 337 79 q 476 138 418 79 q 535 279 535 198 q 427 437 535 386 q 226 477 344 477 l 226 583 q 398 620 329 583 q 486 762 486 668 q 435 884 486 833 q 312 935 384 935 q 169 861 219 935 q 126 698 126 797 l 126 362 q 170 169 126 242 q 337 79 224 79 " }, "": { x_min: 0, x_max: 954, ha: 1068, o: "m 954 0 l 819 0 l 819 868 l 537 0 l 405 0 l 128 865 l 128 0 l 0 0 l 0 1013 l 199 1013 l 472 158 l 758 1013 l 954 1013 l 954 0 " }, "": { x_min: 0.109375, x_max: 1120, ha: 1217, o: "m 1120 505 q 994 132 1120 282 q 642 -29 861 -29 q 290 130 422 -29 q 167 505 167 280 q 294 883 167 730 q 650 1046 430 1046 q 999 882 868 1046 q 1120 505 1120 730 m 977 504 q 896 784 977 669 q 644 915 804 915 q 391 785 484 915 q 307 504 307 669 q 391 224 307 339 q 644 95 486 95 q 894 224 803 95 q 977 504 977 339 m 277 1040 l 83 799 l 0 799 l 140 1040 l 277 1040 " }, "": { x_min: 0, x_max: 1158, ha: 1275, o: "m 1158 0 l 1022 0 l 1022 475 l 496 475 l 496 0 l 356 0 l 356 1012 l 496 1012 l 496 599 l 1022 599 l 1022 1012 l 1158 1012 l 1158 0 m 277 1040 l 83 799 l 0 799 l 140 1040 l 277 1040 " }, "": { x_min: 0, x_max: 663.890625, ha: 775, o: "m 663 529 q 566 293 663 391 q 331 196 469 196 q 97 294 194 196 q 0 529 0 393 q 96 763 0 665 q 331 861 193 861 q 566 763 469 861 q 663 529 663 665 " }, "": { x_min: 0.1875, x_max: 819.546875, ha: 886, o: "m 563 561 l 697 561 l 696 487 l 520 487 l 482 416 l 482 380 l 697 380 l 695 308 l 482 308 l 482 0 l 342 0 l 342 308 l 125 308 l 125 380 l 342 380 l 342 417 l 303 487 l 125 487 l 125 561 l 258 561 l 0 1013 l 140 1013 l 411 533 l 679 1013 l 819 1013 l 563 561 " }, "(": { x_min: 0, x_max: 318.0625, ha: 415, o: "m 318 -290 l 230 -290 q 61 23 122 -142 q 0 365 0 190 q 62 712 0 540 q 230 1024 119 869 l 318 1024 q 175 705 219 853 q 125 360 125 542 q 176 22 125 187 q 318 -290 223 -127 " }, U: { x_min: 0, x_max: 796, ha: 904, o: "m 796 393 q 681 93 796 212 q 386 -25 566 -25 q 101 95 208 -25 q 0 393 0 211 l 0 1013 l 138 1013 l 138 391 q 204 191 138 270 q 394 107 276 107 q 586 191 512 107 q 656 391 656 270 l 656 1013 l 796 1013 l 796 393 " }, "": { x_min: 0.5, x_max: 744.953125, ha: 822, o: "m 744 737 l 463 54 l 463 -278 l 338 -278 l 338 54 l 154 495 q 104 597 124 569 q 13 651 67 651 l 0 651 l 0 751 l 39 753 q 168 711 121 753 q 242 594 207 676 l 403 208 l 617 737 l 744 737 " }, "": { x_min: 0, x_max: 765.5625, ha: 809, o: "m 765 -4 q 698 -14 726 -14 q 564 97 586 -14 q 466 7 525 40 q 337 -26 407 -26 q 88 98 186 -26 q 0 369 0 212 q 88 637 0 525 q 337 760 184 760 q 465 728 407 760 q 563 637 524 696 l 563 739 l 685 739 l 685 222 q 693 141 685 168 q 748 94 708 94 q 765 96 760 94 l 765 -4 m 584 371 q 531 562 584 485 q 360 653 470 653 q 192 566 254 653 q 135 379 135 489 q 186 181 135 261 q 358 84 247 84 q 528 176 465 84 q 584 371 584 260 " }, F: { x_min: 0, x_max: 683.328125, ha: 717, o: "m 683 888 l 140 888 l 140 583 l 613 583 l 613 458 l 140 458 l 140 0 l 0 0 l 0 1013 l 683 1013 l 683 888 " }, "": { x_min: 0, x_max: 705.5625, ha: 803, o: "m 705 334 l 0 334 l 0 410 l 705 410 l 705 334 " }, ":": { x_min: 0, x_max: 142, ha: 239, o: "m 142 585 l 0 585 l 0 738 l 142 738 l 142 585 m 142 0 l 0 0 l 0 151 l 142 151 l 142 0 " }, "": { x_min: 0, x_max: 854.171875, ha: 935, o: "m 854 0 l 683 0 l 423 409 l 166 0 l 0 0 l 347 519 l 18 1013 l 186 1013 l 427 637 l 675 1013 l 836 1013 l 504 521 l 854 0 " }, "*": { x_min: 116, x_max: 674, ha: 792, o: "m 674 768 l 475 713 l 610 544 l 517 477 l 394 652 l 272 478 l 178 544 l 314 713 l 116 766 l 153 876 l 341 812 l 342 1013 l 446 1013 l 446 811 l 635 874 l 674 768 " }, "": { x_min: 0, x_max: 777, ha: 835, o: "m 458 804 l 777 804 l 777 683 l 458 683 l 458 0 l 319 0 l 319 681 l 0 683 l 0 804 l 319 804 l 319 1015 l 458 1013 l 458 804 " }, "": { x_min: 0, x_max: 347, ha: 444, o: "m 173 802 q 43 856 91 802 q 0 977 0 905 q 45 1101 0 1049 q 173 1153 90 1153 q 303 1098 255 1153 q 347 977 347 1049 q 303 856 347 905 q 173 802 256 802 m 173 884 q 238 910 214 884 q 262 973 262 937 q 239 1038 262 1012 q 173 1064 217 1064 q 108 1037 132 1064 q 85 973 85 1010 q 108 910 85 937 q 173 884 132 884 " }, V: { x_min: 0, x_max: 862.71875, ha: 940, o: "m 862 1013 l 505 0 l 361 0 l 0 1013 l 143 1013 l 434 165 l 718 1012 l 862 1013 " }, "": { x_min: 0, x_max: 734.71875, ha: 763, o: "m 723 889 l 9 889 l 9 1013 l 723 1013 l 723 889 m 673 463 l 61 463 l 61 589 l 673 589 l 673 463 m 734 0 l 0 0 l 0 124 l 734 124 l 734 0 " }, "": { x_min: 0, x_max: 0, ha: 853 }, "": { x_min: 0.328125, x_max: 819.515625, ha: 889, o: "m 588 1046 l 460 1046 l 460 1189 l 588 1189 l 588 1046 m 360 1046 l 232 1046 l 232 1189 l 360 1189 l 360 1046 m 819 1012 l 482 416 l 482 0 l 342 0 l 342 416 l 0 1012 l 140 1012 l 411 533 l 679 1012 l 819 1012 " }, "": { x_min: 0, x_max: 347, ha: 454, o: "m 139 851 q 102 737 139 784 q 0 669 65 690 l 0 734 q 59 787 42 741 q 72 873 72 821 l 0 873 l 0 1013 l 139 1013 l 139 851 m 347 851 q 310 737 347 784 q 208 669 273 690 l 208 734 q 267 787 250 741 q 280 873 280 821 l 208 873 l 208 1013 l 347 1013 l 347 851 " }, "@": { x_min: 0, x_max: 1260, ha: 1357, o: "m 1098 -45 q 877 -160 1001 -117 q 633 -203 752 -203 q 155 -29 327 -203 q 0 360 0 127 q 176 802 0 616 q 687 1008 372 1008 q 1123 854 969 1008 q 1260 517 1260 718 q 1155 216 1260 341 q 868 82 1044 82 q 772 106 801 82 q 737 202 737 135 q 647 113 700 144 q 527 82 594 82 q 367 147 420 82 q 314 312 314 212 q 401 565 314 452 q 639 690 498 690 q 810 588 760 690 l 849 668 l 938 668 q 877 441 900 532 q 833 226 833 268 q 853 182 833 198 q 902 167 873 167 q 1088 272 1012 167 q 1159 512 1159 372 q 1051 793 1159 681 q 687 925 925 925 q 248 747 415 925 q 97 361 97 586 q 226 26 97 159 q 627 -122 370 -122 q 856 -87 737 -122 q 1061 8 976 -53 l 1098 -45 m 786 488 q 738 580 777 545 q 643 615 700 615 q 483 517 548 615 q 425 322 425 430 q 457 203 425 250 q 552 156 490 156 q 722 273 665 156 q 786 488 738 309 " }, "": { x_min: 0, x_max: 499, ha: 613, o: "m 277 1040 l 83 799 l 0 799 l 140 1040 l 277 1040 m 499 0 l 360 0 l 360 1012 l 499 1012 l 499 0 " }, i: { x_min: 14, x_max: 136, ha: 275, o: "m 136 873 l 14 873 l 14 1013 l 136 1013 l 136 873 m 136 0 l 14 0 l 14 737 l 136 737 l 136 0 " }, "": { x_min: 0, x_max: 778, ha: 877, o: "m 580 545 q 724 468 671 534 q 778 310 778 402 q 673 83 778 170 q 432 0 575 0 l 0 0 l 0 1013 l 411 1013 q 629 957 541 1013 q 732 768 732 891 q 691 632 732 692 q 580 545 650 571 m 393 899 l 139 899 l 139 587 l 379 587 q 521 623 462 587 q 592 744 592 666 q 531 859 592 819 q 393 899 471 899 m 419 124 q 566 169 504 124 q 635 302 635 219 q 559 435 635 388 q 402 476 494 476 l 139 476 l 139 124 l 419 124 " }, "": { x_min: 0, x_max: 617, ha: 725, o: "m 617 352 q 540 94 617 199 q 308 -24 455 -24 q 76 94 161 -24 q 0 352 0 199 l 0 739 l 126 739 l 126 355 q 169 185 126 257 q 312 98 220 98 q 451 185 402 98 q 492 355 492 257 l 492 739 l 617 739 l 617 352 " }, "]": { x_min: 0, x_max: 275, ha: 372, o: "m 275 -281 l 0 -281 l 0 -187 l 151 -187 l 151 920 l 0 920 l 0 1013 l 275 1013 l 275 -281 " }, m: { x_min: 0, x_max: 1019, ha: 1128, o: "m 1019 0 l 897 0 l 897 454 q 860 591 897 536 q 739 660 816 660 q 613 586 659 660 q 573 436 573 522 l 573 0 l 447 0 l 447 455 q 412 591 447 535 q 294 657 372 657 q 165 586 213 657 q 122 437 122 521 l 122 0 l 0 0 l 0 738 l 117 738 l 117 640 q 202 730 150 697 q 316 763 254 763 q 437 730 381 763 q 525 642 494 697 q 621 731 559 700 q 753 763 682 763 q 943 694 867 763 q 1019 512 1019 625 l 1019 0 " }, "": { x_min: 8.328125, x_max: 780.5625, ha: 815, o: "m 780 -278 q 715 -294 747 -294 q 616 -257 663 -294 q 548 -175 576 -227 l 379 133 l 143 -277 l 9 -277 l 313 254 l 163 522 q 127 586 131 580 q 36 640 91 640 q 8 637 27 640 l 8 752 l 52 757 q 162 719 113 757 q 236 627 200 690 l 383 372 l 594 737 l 726 737 l 448 250 l 625 -69 q 670 -153 647 -110 q 743 -188 695 -188 q 780 -184 759 -188 l 780 -278 " }, "": { x_min: 42, x_max: 326.71875, ha: 361, o: "m 284 3 q 233 -10 258 -5 q 182 -15 207 -15 q 85 26 119 -15 q 42 200 42 79 l 42 737 l 167 737 l 168 215 q 172 141 168 157 q 226 101 183 101 q 248 102 239 101 q 284 112 257 104 l 284 3 m 326 1040 l 137 819 l 54 819 l 189 1040 l 326 1040 " }, "": { x_min: 0, x_max: 779.171875, ha: 850, o: "m 779 0 l 0 0 l 0 113 l 620 896 l 40 896 l 40 1013 l 779 1013 l 779 887 l 170 124 l 779 124 l 779 0 " }, R: { x_min: 0, x_max: 781.953125, ha: 907, o: "m 781 0 l 623 0 q 587 242 590 52 q 407 433 585 433 l 138 433 l 138 0 l 0 0 l 0 1013 l 396 1013 q 636 946 539 1013 q 749 731 749 868 q 711 597 749 659 q 608 502 674 534 q 718 370 696 474 q 729 207 722 352 q 781 26 736 62 l 781 0 m 373 551 q 533 594 465 551 q 614 731 614 645 q 532 859 614 815 q 373 896 465 896 l 138 896 l 138 551 l 373 551 " }, o: { x_min: 0, x_max: 713, ha: 821, o: "m 357 -25 q 94 91 194 -25 q 0 368 0 202 q 93 642 0 533 q 357 761 193 761 q 618 644 518 761 q 713 368 713 533 q 619 91 713 201 q 357 -25 521 -25 m 357 85 q 528 175 465 85 q 584 369 584 255 q 529 562 584 484 q 357 651 467 651 q 189 560 250 651 q 135 369 135 481 q 187 177 135 257 q 357 85 250 85 " }, K: { x_min: 0, x_max: 819.46875, ha: 906, o: "m 819 0 l 649 0 l 294 509 l 139 355 l 139 0 l 0 0 l 0 1013 l 139 1013 l 139 526 l 626 1013 l 809 1013 l 395 600 l 819 0 " }, ",": { x_min: 0, x_max: 142, ha: 239, o: "m 142 -12 q 105 -132 142 -82 q 0 -205 68 -182 l 0 -138 q 57 -82 40 -124 q 70 0 70 -51 l 0 0 l 0 151 l 142 151 l 142 -12 " }, d: { x_min: 0, x_max: 683, ha: 796, o: "m 683 0 l 564 0 l 564 93 q 456 6 516 38 q 327 -25 395 -25 q 87 100 181 -25 q 0 365 0 215 q 90 639 0 525 q 343 763 187 763 q 564 647 486 763 l 564 1013 l 683 1013 l 683 0 m 582 373 q 529 562 582 484 q 361 653 468 653 q 190 561 253 653 q 135 365 135 479 q 189 175 135 254 q 358 85 251 85 q 529 178 468 85 q 582 373 582 258 " }, "": { x_min: -109, x_max: 247, ha: 232, o: "m 247 1046 l 119 1046 l 119 1189 l 247 1189 l 247 1046 m 19 1046 l -109 1046 l -109 1189 l 19 1189 l 19 1046 " }, E: { x_min: 0, x_max: 736.109375, ha: 789, o: "m 736 0 l 0 0 l 0 1013 l 725 1013 l 725 889 l 139 889 l 139 585 l 677 585 l 677 467 l 139 467 l 139 125 l 736 125 l 736 0 " }, Y: { x_min: 0, x_max: 820, ha: 886, o: "m 820 1013 l 482 416 l 482 0 l 342 0 l 342 416 l 0 1013 l 140 1013 l 411 534 l 679 1012 l 820 1013 " }, '"': { x_min: 0, x_max: 299, ha: 396, o: "m 299 606 l 203 606 l 203 988 l 299 988 l 299 606 m 96 606 l 0 606 l 0 988 l 96 988 l 96 606 " }, "": { x_min: 17.984375, x_max: 773.609375, ha: 792, o: "m 773 40 l 18 376 l 17 465 l 773 799 l 773 692 l 159 420 l 773 149 l 773 40 " }, "": { x_min: 0, x_max: 364, ha: 467, o: "m 141 -12 q 104 -132 141 -82 q 0 -205 67 -182 l 0 -138 q 56 -82 40 -124 q 69 0 69 -51 l 0 0 l 0 151 l 141 151 l 141 -12 m 364 -12 q 327 -132 364 -82 q 222 -205 290 -182 l 222 -138 q 279 -82 262 -124 q 292 0 292 -51 l 222 0 l 222 151 l 364 151 l 364 -12 " }, "": { x_min: 1, x_max: 710, ha: 810, o: "m 710 360 q 616 87 710 196 q 356 -28 518 -28 q 99 82 197 -28 q 1 356 1 192 q 100 606 1 509 q 355 703 199 703 q 180 829 288 754 q 70 903 124 866 l 70 1012 l 643 1012 l 643 901 l 258 901 q 462 763 422 794 q 636 592 577 677 q 710 360 710 485 m 584 365 q 552 501 584 447 q 451 602 521 555 q 372 611 411 611 q 197 541 258 611 q 136 355 136 472 q 190 171 136 245 q 358 85 252 85 q 528 173 465 85 q 584 365 584 252 " }, "": { x_min: 0, x_max: 634.71875, ha: 714, o: "m 634 234 q 527 38 634 110 q 300 -25 433 -25 q 98 29 183 -25 q 0 204 0 93 q 37 313 0 265 q 128 390 67 352 q 56 459 82 419 q 26 555 26 505 q 114 712 26 654 q 295 763 191 763 q 499 700 416 763 q 589 515 589 631 l 478 515 q 419 618 464 580 q 307 657 374 657 q 207 630 253 657 q 151 547 151 598 q 238 445 151 469 q 389 434 280 434 l 389 331 l 349 331 q 206 315 255 331 q 125 210 125 287 q 183 107 125 145 q 302 76 233 76 q 436 117 379 76 q 509 234 493 159 l 634 234 m 520 1040 l 331 819 l 248 819 l 383 1040 l 520 1040 " }, "": { x_min: 0, x_max: 922, ha: 1031, o: "m 922 339 q 856 97 922 203 q 650 -26 780 -26 q 538 9 587 -26 q 461 103 489 44 q 387 12 436 46 q 277 -22 339 -22 q 69 97 147 -22 q 0 339 0 203 q 45 551 0 444 q 161 738 84 643 l 302 738 q 175 553 219 647 q 124 336 124 446 q 155 179 124 249 q 275 88 197 88 q 375 163 341 88 q 400 294 400 219 l 400 572 l 524 572 l 524 294 q 561 135 524 192 q 643 88 591 88 q 762 182 719 88 q 797 342 797 257 q 745 556 797 450 q 619 738 705 638 l 760 738 q 874 551 835 640 q 922 339 922 444 " }, "": { x_min: 0, x_max: 96, ha: 251, o: "m 96 606 l 0 606 l 0 988 l 96 988 l 96 606 " }, "": { x_min: 11, x_max: 781, ha: 792, o: "m 781 490 l 446 490 l 446 255 l 349 255 l 349 490 l 11 490 l 11 586 l 349 586 l 349 819 l 446 819 l 446 586 l 781 586 l 781 490 m 781 21 l 11 21 l 11 115 l 781 115 l 781 21 " }, "|": { x_min: 343, x_max: 449, ha: 792, o: "m 449 462 l 343 462 l 343 986 l 449 986 l 449 462 m 449 -242 l 343 -242 l 343 280 l 449 280 l 449 -242 " }, "": { x_min: 0, x_max: 617, ha: 725, o: "m 482 800 l 372 800 l 372 925 l 482 925 l 482 800 m 239 800 l 129 800 l 129 925 l 239 925 l 239 800 m 617 352 q 540 93 617 199 q 308 -24 455 -24 q 76 93 161 -24 q 0 352 0 199 l 0 738 l 126 738 l 126 354 q 169 185 126 257 q 312 98 220 98 q 451 185 402 98 q 492 354 492 257 l 492 738 l 617 738 l 617 352 " }, "": { x_min: 0, x_max: 593, ha: 690, o: "m 593 425 q 554 312 593 369 q 467 233 516 254 q 537 83 537 172 q 459 -74 537 -12 q 288 -133 387 -133 q 115 -69 184 -133 q 47 96 47 -6 l 166 96 q 199 7 166 40 q 288 -26 232 -26 q 371 -5 332 -26 q 420 60 420 21 q 311 201 420 139 q 108 309 210 255 q 0 490 0 383 q 33 602 0 551 q 124 687 66 654 q 75 743 93 712 q 58 812 58 773 q 133 984 58 920 q 300 1043 201 1043 q 458 987 394 1043 q 529 814 529 925 l 411 814 q 370 908 404 877 q 289 939 336 939 q 213 911 246 939 q 180 841 180 883 q 286 720 180 779 q 484 612 480 615 q 593 425 593 534 m 467 409 q 355 544 467 473 q 196 630 228 612 q 146 587 162 609 q 124 525 124 558 q 239 387 124 462 q 398 298 369 315 q 448 345 429 316 q 467 409 467 375 " }, b: { x_min: 0, x_max: 685, ha: 783, o: "m 685 372 q 597 99 685 213 q 347 -25 501 -25 q 219 5 277 -25 q 121 93 161 36 l 121 0 l 0 0 l 0 1013 l 121 1013 l 121 634 q 214 723 157 692 q 341 754 272 754 q 591 637 493 754 q 685 372 685 526 m 554 356 q 499 550 554 470 q 328 644 437 644 q 162 556 223 644 q 108 369 108 478 q 160 176 108 256 q 330 83 221 83 q 498 169 435 83 q 554 356 554 245 " }, q: { x_min: 0, x_max: 683, ha: 876, o: "m 683 -278 l 564 -278 l 564 97 q 474 8 533 39 q 345 -23 415 -23 q 91 93 188 -23 q 0 364 0 203 q 87 635 0 522 q 337 760 184 760 q 466 727 408 760 q 564 637 523 695 l 564 737 l 683 737 l 683 -278 m 582 375 q 527 564 582 488 q 358 652 466 652 q 190 565 253 652 q 135 377 135 488 q 189 179 135 261 q 361 84 251 84 q 530 179 469 84 q 582 375 582 260 " }, "": { x_min: -0.171875, x_max: 969.5625, ha: 1068, o: "m 969 0 l 555 0 l 555 123 q 744 308 675 194 q 814 558 814 423 q 726 812 814 709 q 484 922 633 922 q 244 820 334 922 q 154 567 154 719 q 223 316 154 433 q 412 123 292 199 l 412 0 l 0 0 l 0 124 l 217 124 q 68 327 122 210 q 15 572 15 444 q 144 911 15 781 q 484 1041 274 1041 q 822 909 691 1041 q 953 569 953 777 q 899 326 953 443 q 750 124 846 210 l 969 124 l 969 0 " }, "": { x_min: 0, x_max: 617, ha: 725, o: "m 617 352 q 540 93 617 199 q 308 -24 455 -24 q 76 93 161 -24 q 0 352 0 199 l 0 738 l 126 738 l 126 354 q 169 185 126 257 q 312 98 220 98 q 451 185 402 98 q 492 354 492 257 l 492 738 l 617 738 l 617 352 m 535 1040 l 346 819 l 262 819 l 397 1040 l 535 1040 " }, z: { x_min: -0.015625, x_max: 613.890625, ha: 697, o: "m 613 0 l 0 0 l 0 100 l 433 630 l 20 630 l 20 738 l 594 738 l 593 636 l 163 110 l 613 110 l 613 0 " }, "": { x_min: 0, x_max: 894, ha: 1e3, o: "m 389 951 l 229 951 l 229 503 l 160 503 l 160 951 l 0 951 l 0 1011 l 389 1011 l 389 951 m 894 503 l 827 503 l 827 939 l 685 503 l 620 503 l 481 937 l 481 503 l 417 503 l 417 1011 l 517 1011 l 653 580 l 796 1010 l 894 1011 l 894 503 " }, "": { x_min: 0.78125, x_max: 697, ha: 810, o: "m 697 -278 l 572 -278 l 572 454 q 540 587 572 536 q 425 650 501 650 q 271 579 337 650 q 206 420 206 509 l 206 0 l 81 0 l 81 489 q 73 588 81 562 q 0 644 56 644 l 0 741 q 68 755 38 755 q 158 721 124 755 q 200 630 193 687 q 297 726 234 692 q 434 761 359 761 q 620 692 544 761 q 697 516 697 624 l 697 -278 m 479 1040 l 290 819 l 207 819 l 341 1040 l 479 1040 " }, "": { x_min: 0, x_max: 960, ha: 1056, o: "m 960 507 q 833 129 960 280 q 476 -32 698 -32 q 123 129 255 -32 q 0 507 0 280 q 123 883 0 732 q 476 1045 255 1045 q 832 883 696 1045 q 960 507 960 732 m 817 500 q 733 789 817 669 q 476 924 639 924 q 223 792 317 924 q 142 507 142 675 q 222 222 142 339 q 476 89 315 89 q 730 218 636 89 q 817 500 817 334 m 716 449 l 243 449 l 243 571 l 716 571 l 716 449 " }, "": { x_min: -3, x_max: 1008, ha: 1106, o: "m 503 532 q 614 562 566 532 q 672 658 672 598 q 614 747 672 716 q 503 772 569 772 l 338 772 l 338 532 l 503 532 m 502 -7 q 123 151 263 -7 q -3 501 -3 294 q 123 851 -3 706 q 502 1011 263 1011 q 881 851 739 1011 q 1008 501 1008 708 q 883 151 1008 292 q 502 -7 744 -7 m 502 60 q 830 197 709 60 q 940 501 940 322 q 831 805 940 681 q 502 944 709 944 q 174 805 296 944 q 65 501 65 680 q 173 197 65 320 q 502 60 294 60 m 788 146 l 678 146 q 653 316 655 183 q 527 449 652 449 l 338 449 l 338 146 l 241 146 l 241 854 l 518 854 q 688 808 621 854 q 766 658 766 755 q 739 563 766 607 q 668 497 713 519 q 751 331 747 472 q 788 164 756 190 l 788 146 " }, "~": { x_min: 0, x_max: 833, ha: 931, o: "m 833 958 q 778 753 833 831 q 594 665 716 665 q 402 761 502 665 q 240 857 302 857 q 131 795 166 857 q 104 665 104 745 l 0 665 q 54 867 0 789 q 237 958 116 958 q 429 861 331 958 q 594 765 527 765 q 704 827 670 765 q 729 958 729 874 l 833 958 " }, "": { x_min: 0, x_max: 736.21875, ha: 778, o: "m 736 0 l 0 0 l 0 1013 l 725 1013 l 725 889 l 139 889 l 139 585 l 677 585 l 677 467 l 139 467 l 139 125 l 736 125 l 736 0 " }, "": { x_min: 0, x_max: 450, ha: 547, o: "m 450 552 q 379 413 450 464 q 220 366 313 366 q 69 414 130 366 q 0 567 0 470 l 85 567 q 126 470 85 504 q 225 437 168 437 q 320 467 280 437 q 360 552 360 498 q 318 632 360 608 q 213 657 276 657 q 195 657 203 657 q 176 657 181 657 l 176 722 q 279 733 249 722 q 334 815 334 752 q 300 881 334 856 q 220 907 267 907 q 133 875 169 907 q 97 781 97 844 l 15 781 q 78 926 15 875 q 220 972 135 972 q 364 930 303 972 q 426 817 426 888 q 344 697 426 733 q 421 642 392 681 q 450 552 450 603 " }, "[": { x_min: 0, x_max: 273.609375, ha: 371, o: "m 273 -281 l 0 -281 l 0 1013 l 273 1013 l 273 920 l 124 920 l 124 -187 l 273 -187 l 273 -281 " }, L: { x_min: 0, x_max: 645.828125, ha: 696, o: "m 645 0 l 0 0 l 0 1013 l 140 1013 l 140 126 l 645 126 l 645 0 " }, "": { x_min: 0, x_max: 803.390625, ha: 894, o: "m 803 628 l 633 628 q 713 368 713 512 q 618 93 713 204 q 357 -25 518 -25 q 94 91 194 -25 q 0 368 0 201 q 94 644 0 533 q 356 761 194 761 q 481 750 398 761 q 608 739 564 739 l 803 739 l 803 628 m 360 85 q 529 180 467 85 q 584 374 584 262 q 527 566 584 490 q 352 651 463 651 q 187 559 247 651 q 135 368 135 478 q 189 175 135 254 q 360 85 251 85 " }, "": { x_min: 0, x_max: 573, ha: 642, o: "m 573 -40 q 553 -162 573 -97 q 510 -278 543 -193 l 400 -278 q 441 -187 428 -219 q 462 -90 462 -132 q 378 -14 462 -14 q 108 45 197 -14 q 0 290 0 117 q 108 631 0 462 q 353 901 194 767 l 55 901 l 55 1012 l 561 1012 l 561 924 q 261 669 382 831 q 128 301 128 489 q 243 117 128 149 q 458 98 350 108 q 573 -40 573 80 " }, "": { x_min: 0, x_max: 674, ha: 778, o: "m 674 496 q 601 160 674 304 q 336 -26 508 -26 q 73 153 165 -26 q 0 485 0 296 q 72 840 0 683 q 343 1045 166 1045 q 605 844 516 1045 q 674 496 674 692 m 546 579 q 498 798 546 691 q 336 935 437 935 q 178 798 237 935 q 126 579 137 701 l 546 579 m 546 475 l 126 475 q 170 233 126 348 q 338 80 230 80 q 504 233 447 80 q 546 475 546 346 " }, "": { x_min: 0, x_max: 958, ha: 1054, o: "m 485 1042 q 834 883 703 1042 q 958 511 958 735 q 834 136 958 287 q 481 -26 701 -26 q 126 130 261 -26 q 0 504 0 279 q 127 880 0 729 q 485 1042 263 1042 m 480 98 q 731 225 638 98 q 815 504 815 340 q 733 783 815 670 q 480 913 640 913 q 226 785 321 913 q 142 504 142 671 q 226 224 142 339 q 480 98 319 98 " }, "": { x_min: 0, x_max: 705.28125, ha: 749, o: "m 705 886 l 140 886 l 140 0 l 0 0 l 0 1012 l 705 1012 l 705 886 " }, " ": { x_min: 0, x_max: 0, ha: 375 }, "%": { x_min: -3, x_max: 1089, ha: 1186, o: "m 845 0 q 663 76 731 0 q 602 244 602 145 q 661 412 602 344 q 845 489 728 489 q 1027 412 959 489 q 1089 244 1089 343 q 1029 76 1089 144 q 845 0 962 0 m 844 103 q 945 143 909 103 q 981 243 981 184 q 947 340 981 301 q 844 385 909 385 q 744 342 781 385 q 708 243 708 300 q 741 147 708 186 q 844 103 780 103 m 888 986 l 284 -25 l 199 -25 l 803 986 l 888 986 m 241 468 q 58 545 126 468 q -3 715 -3 615 q 56 881 -3 813 q 238 958 124 958 q 421 881 353 958 q 483 712 483 813 q 423 544 483 612 q 241 468 356 468 m 241 855 q 137 811 175 855 q 100 710 100 768 q 136 612 100 653 q 240 572 172 572 q 344 614 306 572 q 382 713 382 656 q 347 810 382 771 q 241 855 308 855 " }, P: { x_min: 0, x_max: 726, ha: 806, o: "m 424 1013 q 640 931 555 1013 q 726 719 726 850 q 637 506 726 587 q 413 426 548 426 l 140 426 l 140 0 l 0 0 l 0 1013 l 424 1013 m 379 889 l 140 889 l 140 548 l 372 548 q 522 589 459 548 q 593 720 593 637 q 528 845 593 801 q 379 889 463 889 " }, "": { x_min: 0, x_max: 1078.21875, ha: 1118, o: "m 1078 0 l 342 0 l 342 1013 l 1067 1013 l 1067 889 l 481 889 l 481 585 l 1019 585 l 1019 467 l 481 467 l 481 125 l 1078 125 l 1078 0 m 277 1040 l 83 799 l 0 799 l 140 1040 l 277 1040 " }, "": { x_min: 0.125, x_max: 1136.546875, ha: 1235, o: "m 1136 0 l 722 0 l 722 123 q 911 309 842 194 q 981 558 981 423 q 893 813 981 710 q 651 923 800 923 q 411 821 501 923 q 321 568 321 720 q 390 316 321 433 q 579 123 459 200 l 579 0 l 166 0 l 166 124 l 384 124 q 235 327 289 210 q 182 572 182 444 q 311 912 182 782 q 651 1042 441 1042 q 989 910 858 1042 q 1120 569 1120 778 q 1066 326 1120 443 q 917 124 1013 210 l 1136 124 l 1136 0 m 277 1040 l 83 800 l 0 800 l 140 1041 l 277 1040 " }, _: { x_min: 0, x_max: 705.5625, ha: 803, o: "m 705 -334 l 0 -334 l 0 -234 l 705 -234 l 705 -334 " }, "": { x_min: -110, x_max: 246, ha: 275, o: "m 246 1046 l 118 1046 l 118 1189 l 246 1189 l 246 1046 m 18 1046 l -110 1046 l -110 1189 l 18 1189 l 18 1046 m 136 0 l 0 0 l 0 1012 l 136 1012 l 136 0 " }, "+": { x_min: 23, x_max: 768, ha: 792, o: "m 768 372 l 444 372 l 444 0 l 347 0 l 347 372 l 23 372 l 23 468 l 347 468 l 347 840 l 444 840 l 444 468 l 768 468 l 768 372 " }, "": { x_min: 0, x_max: 1050, ha: 1149, o: "m 1050 0 l 625 0 q 712 178 625 108 q 878 277 722 187 q 967 385 967 328 q 932 456 967 429 q 850 484 897 484 q 759 450 798 484 q 721 352 721 416 l 640 352 q 706 502 640 448 q 851 551 766 551 q 987 509 931 551 q 1050 385 1050 462 q 976 251 1050 301 q 829 179 902 215 q 717 68 740 133 l 1050 68 l 1050 0 m 834 985 l 215 -28 l 130 -28 l 750 984 l 834 985 m 224 422 l 142 422 l 142 811 l 0 811 l 0 867 q 104 889 62 867 q 164 973 157 916 l 224 973 l 224 422 " }, "": { x_min: 0, x_max: 720, ha: 783, o: "m 424 1013 q 637 933 554 1013 q 720 723 720 853 q 633 508 720 591 q 413 426 546 426 l 140 426 l 140 0 l 0 0 l 0 1013 l 424 1013 m 378 889 l 140 889 l 140 548 l 371 548 q 521 589 458 548 q 592 720 592 637 q 527 845 592 801 q 378 889 463 889 " }, "'": { x_min: 0, x_max: 139, ha: 236, o: "m 139 851 q 102 737 139 784 q 0 669 65 690 l 0 734 q 59 787 42 741 q 72 873 72 821 l 0 873 l 0 1013 l 139 1013 l 139 851 " }, "": { x_min: 0, x_max: 350, ha: 397, o: "m 350 625 q 307 616 328 616 q 266 631 281 616 q 247 673 251 645 q 190 628 225 644 q 116 613 156 613 q 32 641 64 613 q 0 722 0 669 q 72 826 0 800 q 247 866 159 846 l 247 887 q 220 934 247 916 q 162 953 194 953 q 104 934 129 953 q 76 882 80 915 l 16 882 q 60 976 16 941 q 166 1011 104 1011 q 266 979 224 1011 q 308 891 308 948 l 308 706 q 311 679 308 688 q 331 670 315 670 l 350 672 l 350 625 m 247 757 l 247 811 q 136 790 175 798 q 64 726 64 773 q 83 682 64 697 q 132 667 103 667 q 207 690 174 667 q 247 757 247 718 " }, "": { x_min: 0, x_max: 450, ha: 553, o: "m 450 800 l 340 800 l 340 925 l 450 925 l 450 800 m 406 1040 l 212 800 l 129 800 l 269 1040 l 406 1040 m 110 800 l 0 800 l 0 925 l 110 925 l 110 800 " }, T: { x_min: 0, x_max: 777, ha: 835, o: "m 777 894 l 458 894 l 458 0 l 319 0 l 319 894 l 0 894 l 0 1013 l 777 1013 l 777 894 " }, "": { x_min: 0, x_max: 915, ha: 997, o: "m 527 0 l 389 0 l 389 122 q 110 231 220 122 q 0 509 0 340 q 110 785 0 677 q 389 893 220 893 l 389 1013 l 527 1013 l 527 893 q 804 786 693 893 q 915 509 915 679 q 805 231 915 341 q 527 122 696 122 l 527 0 m 527 226 q 712 310 641 226 q 779 507 779 389 q 712 705 779 627 q 527 787 641 787 l 527 226 m 389 226 l 389 787 q 205 698 275 775 q 136 505 136 620 q 206 308 136 391 q 389 226 276 226 " }, "": { x_min: 0, x_max: 0, ha: 694 }, j: { x_min: -77.78125, x_max: 167, ha: 349, o: "m 167 871 l 42 871 l 42 1013 l 167 1013 l 167 871 m 167 -80 q 121 -231 167 -184 q -26 -278 76 -278 l -77 -278 l -77 -164 l -41 -164 q 26 -143 11 -164 q 42 -65 42 -122 l 42 737 l 167 737 l 167 -80 " }, "": { x_min: 0, x_max: 756.953125, ha: 819, o: "m 756 0 l 0 0 l 0 107 l 395 523 l 22 904 l 22 1013 l 745 1013 l 745 889 l 209 889 l 566 523 l 187 125 l 756 125 l 756 0 " }, "": { x_min: 18.0625, x_max: 774, ha: 792, o: "m 774 376 l 18 40 l 18 149 l 631 421 l 18 692 l 18 799 l 774 465 l 774 376 " }, "<": { x_min: 17.984375, x_max: 773.609375, ha: 792, o: "m 773 40 l 18 376 l 17 465 l 773 799 l 773 692 l 159 420 l 773 149 l 773 40 " }, "": { x_min: 0, x_max: 704.484375, ha: 801, o: "m 704 41 q 623 -10 664 5 q 543 -26 583 -26 q 359 15 501 -26 q 243 36 288 36 q 158 23 197 36 q 73 -21 119 10 l 6 76 q 125 195 90 150 q 175 331 175 262 q 147 443 175 383 l 0 443 l 0 512 l 108 512 q 43 734 43 623 q 120 929 43 854 q 358 1010 204 1010 q 579 936 487 1010 q 678 729 678 857 l 678 684 l 552 684 q 504 838 552 780 q 362 896 457 896 q 216 852 263 896 q 176 747 176 815 q 199 627 176 697 q 248 512 217 574 l 468 512 l 468 443 l 279 443 q 297 356 297 398 q 230 194 297 279 q 153 107 211 170 q 227 133 190 125 q 293 142 264 142 q 410 119 339 142 q 516 96 482 96 q 579 105 550 96 q 648 142 608 115 l 704 41 " }, t: { x_min: 0, x_max: 367, ha: 458, o: "m 367 0 q 312 -5 339 -2 q 262 -8 284 -8 q 145 28 183 -8 q 108 143 108 64 l 108 638 l 0 638 l 0 738 l 108 738 l 108 944 l 232 944 l 232 738 l 367 738 l 367 638 l 232 638 l 232 185 q 248 121 232 140 q 307 102 264 102 q 345 104 330 102 q 367 107 360 107 l 367 0 " }, "": { x_min: 0, x_max: 706, ha: 803, o: "m 706 411 l 706 158 l 630 158 l 630 335 l 0 335 l 0 411 l 706 411 " }, "": { x_min: 0, x_max: 750, ha: 803, o: "m 750 -7 q 679 -15 716 -15 q 538 59 591 -15 q 466 214 512 97 l 336 551 l 126 0 l 0 0 l 270 705 q 223 837 247 770 q 116 899 190 899 q 90 898 100 899 l 90 1004 q 152 1011 125 1011 q 298 938 244 1011 q 373 783 326 901 l 605 192 q 649 115 629 136 q 716 95 669 95 l 736 95 q 750 97 745 97 l 750 -7 " }, W: { x_min: 0, x_max: 1263.890625, ha: 1351, o: "m 1263 1013 l 995 0 l 859 0 l 627 837 l 405 0 l 265 0 l 0 1013 l 136 1013 l 342 202 l 556 1013 l 701 1013 l 921 207 l 1133 1012 l 1263 1013 " }, ">": { x_min: 18.0625, x_max: 774, ha: 792, o: "m 774 376 l 18 40 l 18 149 l 631 421 l 18 692 l 18 799 l 774 465 l 774 376 " }, v: { x_min: 0, x_max: 675.15625, ha: 761, o: "m 675 738 l 404 0 l 272 0 l 0 738 l 133 737 l 340 147 l 541 737 l 675 738 " }, "": { x_min: 0.28125, x_max: 644.5, ha: 703, o: "m 644 628 l 382 628 l 382 179 q 388 120 382 137 q 436 91 401 91 q 474 94 447 91 q 504 97 501 97 l 504 0 q 454 -9 482 -5 q 401 -14 426 -14 q 278 67 308 -14 q 260 233 260 118 l 260 628 l 0 628 l 0 739 l 644 739 l 644 628 " }, "": { x_min: 0, x_max: 624.9375, ha: 699, o: "m 624 -37 q 608 -153 624 -96 q 563 -278 593 -211 l 454 -278 q 491 -183 486 -200 q 511 -83 511 -126 q 484 -23 511 -44 q 370 1 452 1 q 323 0 354 1 q 283 -1 293 -1 q 84 76 169 -1 q 0 266 0 154 q 56 431 0 358 q 197 538 108 498 q 94 613 134 562 q 54 730 54 665 q 77 823 54 780 q 143 901 101 867 l 27 901 l 27 1012 l 576 1012 l 576 901 l 380 901 q 244 863 303 901 q 178 745 178 820 q 312 600 178 636 q 532 582 380 582 l 532 479 q 276 455 361 479 q 118 281 118 410 q 165 173 118 217 q 274 120 208 133 q 494 101 384 110 q 624 -37 624 76 " }, "&": { x_min: -3, x_max: 894.25, ha: 992, o: "m 894 0 l 725 0 l 624 123 q 471 0 553 40 q 306 -41 390 -41 q 168 -7 231 -41 q 62 92 105 26 q 14 187 31 139 q -3 276 -3 235 q 55 433 -3 358 q 248 581 114 508 q 170 689 196 640 q 137 817 137 751 q 214 985 137 922 q 384 1041 284 1041 q 548 988 483 1041 q 622 824 622 928 q 563 666 622 739 q 431 556 516 608 l 621 326 q 649 407 639 361 q 663 493 653 426 l 781 493 q 703 229 781 352 l 894 0 m 504 818 q 468 908 504 877 q 384 940 433 940 q 293 907 331 940 q 255 818 255 875 q 289 714 255 767 q 363 628 313 678 q 477 729 446 682 q 504 818 504 771 m 556 209 l 314 499 q 179 395 223 449 q 135 283 135 341 q 146 222 135 253 q 183 158 158 192 q 333 80 241 80 q 556 209 448 80 " }, "": { x_min: 0, x_max: 862.5, ha: 942, o: "m 862 0 l 719 0 l 426 847 l 143 0 l 0 0 l 356 1013 l 501 1013 l 862 0 " }, I: { x_min: 41, x_max: 180, ha: 293, o: "m 180 0 l 41 0 l 41 1013 l 180 1013 l 180 0 " }, G: { x_min: 0, x_max: 921, ha: 1011, o: "m 921 0 l 832 0 l 801 136 q 655 15 741 58 q 470 -28 568 -28 q 126 133 259 -28 q 0 499 0 284 q 125 881 0 731 q 486 1043 259 1043 q 763 957 647 1043 q 905 709 890 864 l 772 709 q 668 866 747 807 q 486 926 589 926 q 228 795 322 926 q 142 507 142 677 q 228 224 142 342 q 483 94 323 94 q 712 195 625 94 q 796 435 796 291 l 477 435 l 477 549 l 921 549 l 921 0 " }, "": { x_min: 0, x_max: 617, ha: 725, o: "m 524 800 l 414 800 l 414 925 l 524 925 l 524 800 m 183 800 l 73 800 l 73 925 l 183 925 l 183 800 m 617 352 q 540 93 617 199 q 308 -24 455 -24 q 76 93 161 -24 q 0 352 0 199 l 0 738 l 126 738 l 126 354 q 169 185 126 257 q 312 98 220 98 q 451 185 402 98 q 492 354 492 257 l 492 738 l 617 738 l 617 352 m 489 1040 l 300 819 l 216 819 l 351 1040 l 489 1040 " }, "`": { x_min: 0, x_max: 138.890625, ha: 236, o: "m 138 699 l 0 699 l 0 861 q 36 974 0 929 q 138 1041 72 1020 l 138 977 q 82 931 95 969 q 69 839 69 893 l 138 839 l 138 699 " }, "": { x_min: 0, x_max: 142, ha: 239, o: "m 142 585 l 0 585 l 0 738 l 142 738 l 142 585 " }, "": { x_min: 0.328125, x_max: 819.515625, ha: 889, o: "m 819 1013 l 482 416 l 482 0 l 342 0 l 342 416 l 0 1013 l 140 1013 l 411 533 l 679 1013 l 819 1013 " }, r: { x_min: 0, x_max: 355.5625, ha: 432, o: "m 355 621 l 343 621 q 179 569 236 621 q 122 411 122 518 l 122 0 l 0 0 l 0 737 l 117 737 l 117 604 q 204 719 146 686 q 355 753 262 753 l 355 621 " }, x: { x_min: 0, x_max: 675, ha: 764, o: "m 675 0 l 525 0 l 331 286 l 144 0 l 0 0 l 256 379 l 12 738 l 157 737 l 336 473 l 516 738 l 661 738 l 412 380 l 675 0 " }, "": { x_min: 0, x_max: 696.609375, ha: 747, o: "m 696 -4 q 628 -14 657 -14 q 498 97 513 -14 q 422 8 470 41 q 313 -24 374 -24 q 207 3 258 -24 q 120 80 157 31 l 120 -278 l 0 -278 l 0 738 l 124 738 l 124 343 q 165 172 124 246 q 308 82 216 82 q 451 177 402 82 q 492 358 492 254 l 492 738 l 616 738 l 616 214 q 623 136 616 160 q 673 92 636 92 q 696 95 684 92 l 696 -4 " }, h: { x_min: 0, x_max: 615, ha: 724, o: "m 615 472 l 615 0 l 490 0 l 490 454 q 456 590 490 535 q 338 654 416 654 q 186 588 251 654 q 122 436 122 522 l 122 0 l 0 0 l 0 1013 l 122 1013 l 122 633 q 218 727 149 694 q 362 760 287 760 q 552 676 484 760 q 615 472 615 600 " }, ".": { x_min: 0, x_max: 142, ha: 239, o: "m 142 0 l 0 0 l 0 151 l 142 151 l 142 0 " }, "": { x_min: -2, x_max: 878, ha: 974, o: "m 496 -279 l 378 -279 l 378 -17 q 101 88 204 -17 q -2 367 -2 194 q 68 626 -2 510 q 283 758 151 758 l 283 646 q 167 537 209 626 q 133 373 133 462 q 192 177 133 254 q 378 93 259 93 l 378 758 q 445 764 426 763 q 476 765 464 765 q 765 659 653 765 q 878 377 878 553 q 771 96 878 209 q 496 -17 665 -17 l 496 -279 m 496 93 l 514 93 q 687 183 623 93 q 746 380 746 265 q 691 569 746 491 q 522 658 629 658 l 496 656 l 496 93 " }, ";": { x_min: 0, x_max: 142, ha: 239, o: "m 142 585 l 0 585 l 0 738 l 142 738 l 142 585 m 142 -12 q 105 -132 142 -82 q 0 -206 68 -182 l 0 -138 q 58 -82 43 -123 q 68 0 68 -56 l 0 0 l 0 151 l 142 151 l 142 -12 " }, f: { x_min: 0, x_max: 378, ha: 472, o: "m 378 638 l 246 638 l 246 0 l 121 0 l 121 638 l 0 638 l 0 738 l 121 738 q 137 935 121 887 q 290 1028 171 1028 q 320 1027 305 1028 q 378 1021 334 1026 l 378 908 q 323 918 346 918 q 257 870 273 918 q 246 780 246 840 l 246 738 l 378 738 l 378 638 " }, "": { x_min: 1, x_max: 348.21875, ha: 454, o: "m 140 670 l 1 670 l 1 830 q 37 943 1 897 q 140 1011 74 990 l 140 947 q 82 900 97 940 q 68 810 68 861 l 140 810 l 140 670 m 348 670 l 209 670 l 209 830 q 245 943 209 897 q 348 1011 282 990 l 348 947 q 290 900 305 940 q 276 810 276 861 l 348 810 l 348 670 " }, A: { x_min: 0.03125, x_max: 906.953125, ha: 1008, o: "m 906 0 l 756 0 l 648 303 l 251 303 l 142 0 l 0 0 l 376 1013 l 529 1013 l 906 0 m 610 421 l 452 867 l 293 421 l 610 421 " }, "": { x_min: 1, x_max: 139.890625, ha: 236, o: "m 139 670 l 1 670 l 1 830 q 37 943 1 897 q 139 1011 74 990 l 139 947 q 82 900 97 940 q 68 810 68 861 l 139 810 l 139 670 " }, "": { x_min: -70, x_max: 283, ha: 361, o: "m 283 800 l 173 800 l 173 925 l 283 925 l 283 800 m 40 800 l -70 800 l -70 925 l 40 925 l 40 800 m 283 3 q 232 -10 257 -5 q 181 -15 206 -15 q 84 26 118 -15 q 41 200 41 79 l 41 737 l 166 737 l 167 215 q 171 141 167 157 q 225 101 182 101 q 247 103 238 101 q 283 112 256 104 l 283 3 " }, "": { x_min: -0.21875, x_max: 773.21875, ha: 857, o: "m 773 -7 l 707 -11 q 575 40 607 -11 q 552 174 552 77 l 552 226 l 552 626 l 222 626 l 222 0 l 97 0 l 97 626 l 0 626 l 0 737 l 773 737 l 773 626 l 676 626 l 676 171 q 695 103 676 117 q 773 90 714 90 l 773 -7 " }, "": { x_min: 0, x_max: 765.5625, ha: 809, o: "m 765 -4 q 698 -14 726 -14 q 564 97 586 -14 q 466 7 525 40 q 337 -26 407 -26 q 88 98 186 -26 q 0 369 0 212 q 88 637 0 525 q 337 760 184 760 q 465 727 407 760 q 563 637 524 695 l 563 738 l 685 738 l 685 222 q 693 141 685 168 q 748 94 708 94 q 765 95 760 94 l 765 -4 m 584 371 q 531 562 584 485 q 360 653 470 653 q 192 566 254 653 q 135 379 135 489 q 186 181 135 261 q 358 84 247 84 q 528 176 465 84 q 584 371 584 260 m 604 1040 l 415 819 l 332 819 l 466 1040 l 604 1040 " }, O: { x_min: 0, x_max: 958, ha: 1057, o: "m 485 1041 q 834 882 702 1041 q 958 512 958 734 q 834 136 958 287 q 481 -26 702 -26 q 126 130 261 -26 q 0 504 0 279 q 127 880 0 728 q 485 1041 263 1041 m 480 98 q 731 225 638 98 q 815 504 815 340 q 733 783 815 669 q 480 912 640 912 q 226 784 321 912 q 142 504 142 670 q 226 224 142 339 q 480 98 319 98 " }, n: { x_min: 0, x_max: 615, ha: 724, o: "m 615 463 l 615 0 l 490 0 l 490 454 q 453 592 490 537 q 331 656 410 656 q 178 585 240 656 q 117 421 117 514 l 117 0 l 0 0 l 0 738 l 117 738 l 117 630 q 218 728 150 693 q 359 764 286 764 q 552 675 484 764 q 615 463 615 593 " }, l: { x_min: 41, x_max: 166, ha: 279, o: "m 166 0 l 41 0 l 41 1013 l 166 1013 l 166 0 " }, "": { x_min: 40.09375, x_max: 728.796875, ha: 825, o: "m 728 304 l 649 224 l 512 363 q 383 331 458 331 q 256 363 310 331 l 119 224 l 40 304 l 177 441 q 150 553 150 493 q 184 673 150 621 l 40 818 l 119 898 l 267 749 q 321 766 291 759 q 384 773 351 773 q 447 766 417 773 q 501 749 477 759 l 649 898 l 728 818 l 585 675 q 612 618 604 648 q 621 553 621 587 q 591 441 621 491 l 728 304 m 384 682 q 280 643 318 682 q 243 551 243 604 q 279 461 243 499 q 383 423 316 423 q 487 461 449 423 q 525 553 525 500 q 490 641 525 605 q 384 682 451 682 " }, "": { x_min: 0, x_max: 632.328125, ha: 679, o: "m 632 0 l 482 0 l 225 384 l 124 288 l 124 0 l 0 0 l 0 738 l 124 738 l 124 446 l 433 738 l 596 738 l 312 466 l 632 0 " }, p: { x_min: 0, x_max: 685, ha: 786, o: "m 685 364 q 598 96 685 205 q 350 -23 504 -23 q 121 89 205 -23 l 121 -278 l 0 -278 l 0 738 l 121 738 l 121 633 q 220 726 159 691 q 351 761 280 761 q 598 636 504 761 q 685 364 685 522 m 557 371 q 501 560 557 481 q 330 651 437 651 q 162 559 223 651 q 108 366 108 479 q 162 177 108 254 q 333 87 224 87 q 502 178 441 87 q 557 371 557 258 " }, "": { x_min: 0, x_max: 777, ha: 835, o: "m 458 238 l 458 0 l 319 0 l 319 238 l 0 238 l 0 360 l 319 360 l 319 681 l 0 683 l 0 804 l 319 804 l 319 1015 l 458 1013 l 458 804 l 777 804 l 777 683 l 458 683 l 458 360 l 777 360 l 777 238 l 458 238 " }, "": { x_min: 0, x_max: 808, ha: 907, o: "m 465 -278 l 341 -278 l 341 -15 q 87 102 180 -15 q 0 378 0 210 l 0 739 l 133 739 l 133 379 q 182 195 133 275 q 341 98 242 98 l 341 922 l 465 922 l 465 98 q 623 195 563 98 q 675 382 675 278 l 675 742 l 808 742 l 808 381 q 720 104 808 213 q 466 -13 627 -13 l 465 -278 " }, "": { x_min: 0.78125, x_max: 697, ha: 810, o: "m 697 -278 l 572 -278 l 572 454 q 540 587 572 536 q 425 650 501 650 q 271 579 337 650 q 206 420 206 509 l 206 0 l 81 0 l 81 489 q 73 588 81 562 q 0 644 56 644 l 0 741 q 68 755 38 755 q 158 720 124 755 q 200 630 193 686 q 297 726 234 692 q 434 761 359 761 q 620 692 544 761 q 697 516 697 624 l 697 -278 " } };
var cssFontWeight = "normal";
var ascender = 1189;
var underlinePosition = -100;
var cssFontStyle = "normal";
var boundingBox = { yMin: -334, xMin: -111, yMax: 1189, xMax: 1672 };
var resolution = 1e3;
var original_font_information = { postscript_name: "Helvetiker-Regular", version_string: "Version 1.00 2004 initial release", vendor_url: "http://www.magenta.gr/", full_font_name: "Helvetiker", font_family_name: "Helvetiker", copyright: "Copyright (c) agenta ltd, 2004", description: "", trademark: "", designer: "", designer_url: "", unique_font_identifier: "agenta ltd:Helvetiker:22-10-104", license_url: "http://www.ellak.gr/fonts/MgOpen/license.html", license_description: 'Copyright (c) 2004 by MAGENTA Ltd. All Rights Reserved.\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy of the fonts accompanying this license ("Fonts") and associated documentation files (the "Font Software"), to reproduce and distribute the Font Software, including without limitation the rights to use, copy, merge, publish, distribute, and/or sell copies of the Font Software, and to permit persons to whom the Font Software is furnished to do so, subject to the following conditions: \r\n\r\nThe above copyright and this permission notice shall be included in all copies of one or more of the Font Software typefaces.\r\n\r\nThe Font Software may be modified, altered, or added to, and in particular the designs of glyphs or characters in the Fonts may be modified and additional glyphs or characters may be added to the Fonts, only if the fonts are renamed to names not containing the word "MgOpen", or if the modifications are accepted for inclusion in the Font Software itself by the each appointed Administrator.\r\n\r\nThis License becomes null and void to the extent applicable to Fonts or Font Software that has been modified and is distributed under the "MgOpen" name.\r\n\r\nThe Font Software may be sold as part of a larger software package but no copy of one or more of the Font Software typefaces may be sold by itself. \r\n\r\nTHE FONT SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF COPYRIGHT, PATENT, TRADEMARK, OR OTHER RIGHT. IN NO EVENT SHALL MAGENTA OR PERSONS OR BODIES IN CHARGE OF ADMINISTRATION AND MAINTENANCE OF THE FONT SOFTWARE BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, INCLUDING ANY GENERAL, SPECIAL, INDIRECT, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF THE USE OR INABILITY TO USE THE FONT SOFTWARE OR FROM OTHER DEALINGS IN THE FONT SOFTWARE.', manufacturer_name: "agenta ltd", font_sub_family_name: "Regular" };
var descender = -334;
var familyName = "Helvetiker";
var lineHeight = 1522;
var underlineThickness = 50;
var defaultTypeFace = { glyphs, cssFontWeight, ascender, underlinePosition, cssFontStyle, boundingBox, resolution, original_font_information, descender, familyName, lineHeight, underlineThickness };
var THREE$3 = _objectSpread2(_objectSpread2({}, window.THREE ? window.THREE : {
  BoxGeometry,
  CircleGeometry,
  DoubleSide,
  Group,
  Mesh,
  MeshLambertMaterial,
  TextGeometry,
  Vector3
}), {}, {
  Font,
  TextGeometry
});
var LabelsLayerKapsule = index({
  props: {
    labelsData: {
      "default": []
    },
    labelLat: {
      "default": "lat"
    },
    labelLng: {
      "default": "lng"
    },
    labelAltitude: {
      "default": 2e-3
    },
    // in units of globe radius
    labelText: {
      "default": "text"
    },
    labelSize: {
      "default": 0.5
    },
    // text height in deg
    labelTypeFace: {
      "default": defaultTypeFace,
      onChange: function onChange7(tf, state) {
        state.font = new THREE$3.Font(tf);
      }
    },
    labelColor: {
      "default": function _default22() {
        return "lightgrey";
      }
    },
    labelRotation: {
      "default": 0
    },
    // clockwise degrees, relative to the latitute parallel plane
    labelResolution: {
      "default": 3
    },
    // how many segments in the text's curves
    labelIncludeDot: {
      "default": true
    },
    labelDotRadius: {
      "default": 0.1
    },
    // in deg
    labelDotOrientation: {
      "default": function _default23() {
        return "bottom";
      }
    },
    // right, top, bottom
    labelsTransitionDuration: {
      "default": 1e3,
      triggerUpdate: false
    }
    // ms
  },
  init: function init12(threeObj, state, _ref) {
    var tweenGroup = _ref.tweenGroup;
    emptyObject3(threeObj);
    state.scene = threeObj;
    state.tweenGroup = tweenGroup;
    var circleGeometry = new THREE$3.CircleGeometry(1, 32);
    state.dataMapper = new ThreeDigest(threeObj, {
      objBindAttr: "__threeObjLabel"
    }).onCreateObj(function() {
      var material = new THREE$3.MeshLambertMaterial();
      material.side = DoubleSide;
      var obj = new THREE$3.Group();
      obj.add(new THREE$3.Mesh(circleGeometry, material));
      var textObj = new THREE$3.Mesh(void 0, material);
      obj.add(textObj);
      var bbObj = new THREE$3.Mesh();
      bbObj.visible = false;
      textObj.add(bbObj);
      obj.__globeObjType = "label";
      return obj;
    });
  },
  update: function update13(state) {
    var latAccessor = index3(state.labelLat);
    var lngAccessor = index3(state.labelLng);
    var altitudeAccessor = index3(state.labelAltitude);
    var textAccessor = index3(state.labelText);
    var sizeAccessor = index3(state.labelSize);
    var rotationAccessor = index3(state.labelRotation);
    var colorAccessor = index3(state.labelColor);
    var includeDotAccessor = index3(state.labelIncludeDot);
    var dotRadiusAccessor = index3(state.labelDotRadius);
    var dotOrientationAccessor = index3(state.labelDotOrientation);
    var orientations = /* @__PURE__ */ new Set(["right", "top", "bottom"]);
    var pxPerDeg = 2 * Math.PI * GLOBE_RADIUS / 360;
    state.dataMapper.onUpdateObj(function(obj, d) {
      var _obj$children = _slicedToArray7(obj.children, 2), dotObj = _obj$children[0], textObj = _obj$children[1];
      var _textObj$children = _slicedToArray7(textObj.children, 1), bbObj = _textObj$children[0];
      var color4 = colorAccessor(d);
      var opacity = colorAlpha(color4);
      textObj.material.color.set(colorStr2Hex(color4));
      textObj.material.transparent = opacity < 1;
      textObj.material.opacity = opacity;
      var includeDot = includeDotAccessor(d);
      var dotOrient = dotOrientationAccessor(d);
      !includeDot || !orientations.has(dotOrient) && (dotOrient = "bottom");
      var dotR = includeDot ? +dotRadiusAccessor(d) * pxPerDeg : 1e-12;
      dotObj.scale.x = dotObj.scale.y = dotR;
      var textHeight = +sizeAccessor(d) * pxPerDeg;
      textObj.geometry && textObj.geometry.dispose();
      textObj.geometry = new THREE$3.TextGeometry(textAccessor(d), {
        font: state.font,
        size: textHeight,
        depth: 0,
        bevelEnabled: true,
        bevelThickness: 0,
        bevelSize: 0,
        curveSegments: state.labelResolution
      });
      bbObj.geometry && bbObj.geometry.dispose();
      textObj.geometry.computeBoundingBox();
      bbObj.geometry = _construct(THREE$3.BoxGeometry, _toConsumableArray6(new THREE$3.Vector3().subVectors(textObj.geometry.boundingBox.max, textObj.geometry.boundingBox.min).clampScalar(0, Infinity).toArray()));
      dotOrient !== "right" && textObj.geometry.center();
      if (includeDot) {
        var padding = dotR + textHeight / 2;
        dotOrient === "right" && (textObj.position.x = padding);
        textObj.position.y = {
          right: -textHeight / 2,
          // center vertically
          top: padding + textHeight / 2,
          bottom: -padding - textHeight / 2
        }[dotOrient];
      }
      var applyPosition = function applyPosition2(td) {
        var _obj$__currentTargetD = obj.__currentTargetD = td, lat = _obj$__currentTargetD.lat, lng = _obj$__currentTargetD.lng, alt = _obj$__currentTargetD.alt, rot = _obj$__currentTargetD.rot, scale3 = _obj$__currentTargetD.scale;
        Object.assign(obj.position, polar2Cartesian4(lat, lng, alt));
        obj.lookAt(state.scene.localToWorld(new THREE$3.Vector3(0, 0, 0)));
        obj.rotateY(Math.PI);
        obj.rotateZ(-rot * Math.PI / 180);
        obj.scale.x = obj.scale.y = obj.scale.z = scale3;
      };
      var targetD = {
        lat: +latAccessor(d),
        lng: +lngAccessor(d),
        alt: +altitudeAccessor(d),
        rot: +rotationAccessor(d),
        scale: 1
      };
      var currentTargetD = obj.__currentTargetD || Object.assign({}, targetD, {
        scale: 1e-12
      });
      if (Object.keys(targetD).some(function(k) {
        return currentTargetD[k] !== targetD[k];
      })) {
        if (!state.labelsTransitionDuration || state.labelsTransitionDuration < 0) {
          applyPosition(targetD);
        } else {
          state.tweenGroup.add(new Tween(currentTargetD).to(targetD, state.labelsTransitionDuration).easing(Easing.Quadratic.InOut).onUpdate(applyPosition).start());
        }
      }
    }).digest(state.labelsData);
  }
});
var THREE$2 = _objectSpread2(_objectSpread2({}, window.THREE ? window.THREE : {}), {}, {
  CSS2DObject
});
var HtmlElementsLayerKapsule = index({
  props: {
    htmlElementsData: {
      "default": []
    },
    htmlLat: {
      "default": "lat"
    },
    htmlLng: {
      "default": "lng"
    },
    htmlAltitude: {
      "default": 0
    },
    // in units of globe radius
    htmlElement: {},
    htmlElementVisibilityModifier: {
      triggerUpdate: false
    },
    htmlTransitionDuration: {
      "default": 1e3,
      triggerUpdate: false
    },
    // ms
    isBehindGlobe: {
      onChange: function onChange8() {
        this.updateObjVisibility();
      },
      triggerUpdate: false
    }
  },
  methods: {
    updateObjVisibility: function updateObjVisibility(state, obj) {
      if (!state.dataMapper) return;
      var objs = obj ? [obj] : state.dataMapper.entries().map(function(_ref) {
        var _ref2 = _slicedToArray7(_ref, 2), o = _ref2[1];
        return o;
      }).filter(function(d) {
        return d;
      });
      objs.forEach(function(obj2) {
        var isVisible = !state.isBehindGlobe || !state.isBehindGlobe(obj2.position);
        if (state.htmlElementVisibilityModifier) {
          obj2.visible = true;
          state.htmlElementVisibilityModifier(obj2.element, isVisible);
        } else {
          obj2.visible = isVisible;
        }
      });
    }
  },
  init: function init13(threeObj, state, _ref3) {
    var tweenGroup = _ref3.tweenGroup;
    emptyObject3(threeObj);
    state.scene = threeObj;
    state.tweenGroup = tweenGroup;
    state.dataMapper = new ThreeDigest(threeObj, {
      objBindAttr: "__threeObjHtml"
    }).onCreateObj(function(d) {
      var elem = index3(state.htmlElement)(d);
      var obj = new THREE$2.CSS2DObject(elem);
      obj.__globeObjType = "html";
      return obj;
    });
  },
  update: function update14(state, changedProps) {
    var _this = this;
    var latAccessor = index3(state.htmlLat);
    var lngAccessor = index3(state.htmlLng);
    var altitudeAccessor = index3(state.htmlAltitude);
    changedProps.hasOwnProperty("htmlElement") && state.dataMapper.clear();
    state.dataMapper.onUpdateObj(function(obj, d) {
      var applyUpdate = function applyUpdate2(td) {
        var _obj$__currentTargetD = obj.__currentTargetD = td, alt = _obj$__currentTargetD.alt, lat = _obj$__currentTargetD.lat, lng = _obj$__currentTargetD.lng;
        Object.assign(obj.position, polar2Cartesian4(lat, lng, alt));
        _this.updateObjVisibility(obj);
      };
      var targetD = {
        lat: +latAccessor(d),
        lng: +lngAccessor(d),
        alt: +altitudeAccessor(d)
      };
      if (!state.htmlTransitionDuration || state.htmlTransitionDuration < 0 || !obj.__currentTargetD) {
        applyUpdate(targetD);
      } else {
        state.tweenGroup.add(new Tween(obj.__currentTargetD).to(targetD, state.htmlTransitionDuration).easing(Easing.Quadratic.InOut).onUpdate(applyUpdate).start());
      }
    }).digest(state.htmlElementsData);
  }
});
var THREE$1 = window.THREE ? window.THREE : {
  Group,
  Mesh,
  MeshLambertMaterial,
  SphereGeometry
};
var ObjectsLayerKapsule = index({
  props: {
    objectsData: {
      "default": []
    },
    objectLat: {
      "default": "lat"
    },
    objectLng: {
      "default": "lng"
    },
    objectAltitude: {
      "default": 0.01
    },
    // in units of globe radius
    objectFacesSurface: {
      "default": true
    },
    objectRotation: {},
    objectThreeObject: {
      "default": new THREE$1.Mesh(
        // default object: yellow sphere
        new THREE$1.SphereGeometry(1, 16, 8),
        new THREE$1.MeshLambertMaterial({
          color: "#ffffaa",
          transparent: true,
          opacity: 0.7
        })
      )
    }
  },
  init: function init14(threeObj, state) {
    emptyObject3(threeObj);
    state.scene = threeObj;
    state.dataMapper = new ThreeDigest(threeObj, {
      objBindAttr: "__threeObjObject"
    }).onCreateObj(function(d) {
      var obj = index3(state.objectThreeObject)(d);
      if (state.objectThreeObject === obj) {
        obj = obj.clone();
      }
      var g = new THREE$1.Group();
      g.add(obj);
      g.__globeObjType = "object";
      return g;
    });
  },
  update: function update15(state, changedProps) {
    var latAccessor = index3(state.objectLat);
    var lngAccessor = index3(state.objectLng);
    var altitudeAccessor = index3(state.objectAltitude);
    var parallelAccessor = index3(state.objectFacesSurface);
    var rotationAccessor = index3(state.objectRotation);
    changedProps.hasOwnProperty("objectThreeObject") && state.dataMapper.clear();
    state.dataMapper.onUpdateObj(function(objG, d) {
      var lat = +latAccessor(d);
      var lng = +lngAccessor(d);
      var alt = +altitudeAccessor(d);
      Object.assign(objG.position, polar2Cartesian4(lat, lng, alt));
      parallelAccessor(d) ? objG.setRotationFromEuler(new Euler(deg2Rad$1(-lat), deg2Rad$1(lng), 0, "YXZ")) : objG.rotation.set(0, 0, 0);
      var obj = objG.children[0];
      var rot = rotationAccessor(d);
      rot && obj.setRotationFromEuler(new Euler(deg2Rad$1(rot.x || 0), deg2Rad$1(rot.y || 0), deg2Rad$1(rot.z || 0)));
    }).digest(state.objectsData);
  }
});
var CustomLayerKapsule = index({
  props: {
    customLayerData: {
      "default": []
    },
    customThreeObject: {},
    customThreeObjectUpdate: {
      triggerUpdate: false
    }
  },
  init: function init15(threeObj, state) {
    emptyObject3(threeObj);
    state.scene = threeObj;
    state.dataMapper = new ThreeDigest(threeObj, {
      objBindAttr: "__threeObjCustom"
    }).onCreateObj(function(d) {
      var obj = index3(state.customThreeObject)(d, GLOBE_RADIUS);
      if (obj) {
        if (state.customThreeObject === obj) {
          obj = obj.clone();
        }
        obj.__globeObjType = "custom";
      }
      return obj;
    });
  },
  update: function update16(state, changedProps) {
    if (!state.customThreeObjectUpdate) {
      emptyObject3(state.scene);
    }
    var customObjectUpdateAccessor = index3(state.customThreeObjectUpdate);
    changedProps.hasOwnProperty("customThreeObject") && state.dataMapper.clear();
    state.dataMapper.onUpdateObj(function(obj, d) {
      return customObjectUpdateAccessor(obj, d, GLOBE_RADIUS);
    }).digest(state.customLayerData);
  }
});
var THREE3 = window.THREE ? window.THREE : {
  Camera,
  Group,
  Vector2,
  Vector3
};
var layers = ["globeLayer", "pointsLayer", "arcsLayer", "hexBinLayer", "heatmapsLayer", "polygonsLayer", "hexedPolygonsLayer", "pathsLayer", "tilesLayer", "particlesLayer", "ringsLayer", "labelsLayer", "htmlElementsLayer", "objectsLayer", "customLayer"];
var bindGlobeLayer = linkKapsule("globeLayer", GlobeLayerKapsule);
var linkedGlobeLayerProps = Object.assign.apply(Object, _toConsumableArray6(["globeImageUrl", "bumpImageUrl", "globeCurvatureResolution", "globeTileEngineUrl", "globeTileEngineMaxLevel", "showGlobe", "showGraticules", "showAtmosphere", "atmosphereColor", "atmosphereAltitude"].map(function(p) {
  return _defineProperty2({}, p, bindGlobeLayer.linkProp(p));
})));
var linkedGlobeLayerMethods = Object.assign.apply(Object, _toConsumableArray6(["globeMaterial", "globeTileEngineClearCache"].map(function(p) {
  return _defineProperty2({}, p, bindGlobeLayer.linkMethod(p));
})));
var bindPointsLayer = linkKapsule("pointsLayer", PointsLayerKapsule);
var linkedPointsLayerProps = Object.assign.apply(Object, _toConsumableArray6(["pointsData", "pointLat", "pointLng", "pointColor", "pointAltitude", "pointRadius", "pointResolution", "pointsMerge", "pointsTransitionDuration"].map(function(p) {
  return _defineProperty2({}, p, bindPointsLayer.linkProp(p));
})));
var bindArcsLayer = linkKapsule("arcsLayer", ArcsLayerKapsule);
var linkedArcsLayerProps = Object.assign.apply(Object, _toConsumableArray6(["arcsData", "arcStartLat", "arcStartLng", "arcStartAltitude", "arcEndLat", "arcEndLng", "arcEndAltitude", "arcColor", "arcAltitude", "arcAltitudeAutoScale", "arcStroke", "arcCurveResolution", "arcCircularResolution", "arcDashLength", "arcDashGap", "arcDashInitialGap", "arcDashAnimateTime", "arcsTransitionDuration"].map(function(p) {
  return _defineProperty2({}, p, bindArcsLayer.linkProp(p));
})));
var bindHexBinLayer = linkKapsule("hexBinLayer", HexBinLayerKapsule);
var linkedHexBinLayerProps = Object.assign.apply(Object, _toConsumableArray6(["hexBinPointsData", "hexBinPointLat", "hexBinPointLng", "hexBinPointWeight", "hexBinResolution", "hexMargin", "hexTopCurvatureResolution", "hexTopColor", "hexSideColor", "hexAltitude", "hexBinMerge", "hexTransitionDuration"].map(function(p) {
  return _defineProperty2({}, p, bindHexBinLayer.linkProp(p));
})));
var bindHeatmapsLayer = linkKapsule("heatmapsLayer", HeatmapsLayerKapsule);
var linkedHeatmapsLayerProps = Object.assign.apply(Object, _toConsumableArray6(["heatmapsData", "heatmapPoints", "heatmapPointLat", "heatmapPointLng", "heatmapPointWeight", "heatmapBandwidth", "heatmapColorFn", "heatmapColorSaturation", "heatmapBaseAltitude", "heatmapTopAltitude", "heatmapsTransitionDuration"].map(function(p) {
  return _defineProperty2({}, p, bindHeatmapsLayer.linkProp(p));
})));
var bindHexedPolygonsLayer = linkKapsule("hexedPolygonsLayer", HexedPolygonsLayerKapsule);
var linkedHexedPolygonsLayerProps = Object.assign.apply(Object, _toConsumableArray6(["hexPolygonsData", "hexPolygonGeoJsonGeometry", "hexPolygonColor", "hexPolygonAltitude", "hexPolygonResolution", "hexPolygonMargin", "hexPolygonUseDots", "hexPolygonCurvatureResolution", "hexPolygonDotResolution", "hexPolygonsTransitionDuration"].map(function(p) {
  return _defineProperty2({}, p, bindHexedPolygonsLayer.linkProp(p));
})));
var bindPolygonsLayer = linkKapsule("polygonsLayer", PolygonsLayerKapsule);
var linkedPolygonsLayerProps = Object.assign.apply(Object, _toConsumableArray6(["polygonsData", "polygonGeoJsonGeometry", "polygonCapColor", "polygonCapMaterial", "polygonSideColor", "polygonSideMaterial", "polygonStrokeColor", "polygonAltitude", "polygonCapCurvatureResolution", "polygonsTransitionDuration"].map(function(p) {
  return _defineProperty2({}, p, bindPolygonsLayer.linkProp(p));
})));
var bindPathsLayer = linkKapsule("pathsLayer", PathsLayerKapsule);
var linkedPathsLayerProps = Object.assign.apply(Object, _toConsumableArray6(["pathsData", "pathPoints", "pathPointLat", "pathPointLng", "pathPointAlt", "pathResolution", "pathColor", "pathStroke", "pathDashLength", "pathDashGap", "pathDashInitialGap", "pathDashAnimateTime", "pathTransitionDuration"].map(function(p) {
  return _defineProperty2({}, p, bindPathsLayer.linkProp(p));
})));
var bindTilesLayer = linkKapsule("tilesLayer", TilesLayerKapsule);
var linkedTilesLayerProps = Object.assign.apply(Object, _toConsumableArray6(["tilesData", "tileLat", "tileLng", "tileAltitude", "tileWidth", "tileHeight", "tileUseGlobeProjection", "tileMaterial", "tileCurvatureResolution", "tilesTransitionDuration"].map(function(p) {
  return _defineProperty2({}, p, bindTilesLayer.linkProp(p));
})));
var bindParticlesLayer = linkKapsule("particlesLayer", ParticlesLayerKapsule);
var linkedParticlesLayerProps = Object.assign.apply(Object, _toConsumableArray6(["particlesData", "particlesList", "particleLat", "particleLng", "particleAltitude", "particlesSize", "particlesSizeAttenuation", "particlesColor", "particlesTexture"].map(function(p) {
  return _defineProperty2({}, p, bindParticlesLayer.linkProp(p));
})));
var bindRingsLayer = linkKapsule("ringsLayer", RingsLayerKapsule);
var linkedRingsLayerProps = Object.assign.apply(Object, _toConsumableArray6(["ringsData", "ringLat", "ringLng", "ringAltitude", "ringColor", "ringResolution", "ringMaxRadius", "ringPropagationSpeed", "ringRepeatPeriod"].map(function(p) {
  return _defineProperty2({}, p, bindRingsLayer.linkProp(p));
})));
var bindLabelsLayer = linkKapsule("labelsLayer", LabelsLayerKapsule);
var linkedLabelsLayerProps = Object.assign.apply(Object, _toConsumableArray6(["labelsData", "labelLat", "labelLng", "labelAltitude", "labelRotation", "labelText", "labelSize", "labelTypeFace", "labelColor", "labelResolution", "labelIncludeDot", "labelDotRadius", "labelDotOrientation", "labelsTransitionDuration"].map(function(p) {
  return _defineProperty2({}, p, bindLabelsLayer.linkProp(p));
})));
var bindHtmlElementsLayer = linkKapsule("htmlElementsLayer", HtmlElementsLayerKapsule);
var linkedHtmlElementsLayerProps = Object.assign.apply(Object, _toConsumableArray6(["htmlElementsData", "htmlLat", "htmlLng", "htmlAltitude", "htmlElement", "htmlElementVisibilityModifier", "htmlTransitionDuration"].map(function(p) {
  return _defineProperty2({}, p, bindHtmlElementsLayer.linkProp(p));
})));
var bindObjectsLayer = linkKapsule("objectsLayer", ObjectsLayerKapsule);
var linkedObjectsLayerProps = Object.assign.apply(Object, _toConsumableArray6(["objectsData", "objectLat", "objectLng", "objectAltitude", "objectRotation", "objectFacesSurface", "objectThreeObject"].map(function(p) {
  return _defineProperty2({}, p, bindObjectsLayer.linkProp(p));
})));
var bindCustomLayer = linkKapsule("customLayer", CustomLayerKapsule);
var linkedCustomLayerProps = Object.assign.apply(Object, _toConsumableArray6(["customLayerData", "customThreeObject", "customThreeObjectUpdate"].map(function(p) {
  return _defineProperty2({}, p, bindCustomLayer.linkProp(p));
})));
var Globe = index({
  props: _objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2({
    onGlobeReady: {
      triggerUpdate: false
    },
    rendererSize: {
      "default": new THREE3.Vector2(window.innerWidth, window.innerHeight),
      onChange: function onChange9(rendererSize, state) {
        state.pathsLayer.rendererSize(rendererSize);
      },
      triggerUpdate: false
    }
  }, linkedGlobeLayerProps), linkedPointsLayerProps), linkedArcsLayerProps), linkedHexBinLayerProps), linkedHeatmapsLayerProps), linkedPolygonsLayerProps), linkedHexedPolygonsLayerProps), linkedPathsLayerProps), linkedTilesLayerProps), linkedParticlesLayerProps), linkedRingsLayerProps), linkedLabelsLayerProps), linkedHtmlElementsLayerProps), linkedObjectsLayerProps), linkedCustomLayerProps),
  methods: _objectSpread2({
    getGlobeRadius,
    getCoords: function getCoords(state) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      return polar2Cartesian4.apply(void 0, args);
    },
    toGeoCoords: function toGeoCoords(state) {
      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }
      return cartesian2Polar2.apply(void 0, args);
    },
    setPointOfView: function setPointOfView(state, camera) {
      var globalPov = camera instanceof THREE3.Camera ? camera.position : camera;
      var globeRadius = getGlobeRadius();
      var isBehindGlobe = void 0;
      if (state.scene && globalPov) {
        var pov, povDist, povEdgeDist, povEdgeAngle;
        isBehindGlobe = function isBehindGlobe2(pos) {
          pov === void 0 && (pov = globalPov.clone().applyMatrix4(state.scene.matrixWorld.clone().invert()));
          povDist === void 0 && (povDist = pov.length());
          povEdgeDist === void 0 && (povEdgeDist = Math.sqrt(Math.pow(povDist, 2) - Math.pow(globeRadius, 2)));
          povEdgeAngle === void 0 && (povEdgeAngle = Math.acos(povEdgeDist / povDist));
          var povPosDist = pov.distanceTo(pos);
          if (povPosDist < povEdgeDist) return false;
          var posDist = pos.length();
          var povPosAngle = Math.acos((Math.pow(povDist, 2) + Math.pow(povPosDist, 2) - Math.pow(posDist, 2)) / (2 * povDist * povPosDist));
          return povPosAngle < povEdgeAngle;
        };
      }
      state.layersThatNeedUpdatePov.forEach(function(l) {
        return l.updatePov(camera);
      });
      state.layersThatNeedBehindGlobeChecker.forEach(function(l) {
        return l.isBehindGlobe(isBehindGlobe);
      });
    },
    pauseAnimation: function pauseAnimation4(state) {
      if (state.animationFrameRequestId !== null) {
        cancelAnimationFrame(state.animationFrameRequestId);
        state.animationFrameRequestId = null;
      }
      state.pausableLayers.forEach(function(l) {
        var _l$pauseAnimation;
        return (_l$pauseAnimation = l.pauseAnimation) === null || _l$pauseAnimation === void 0 ? void 0 : _l$pauseAnimation.call(l);
      });
      return this;
    },
    resumeAnimation: function resumeAnimation4(state) {
      if (state.animationFrameRequestId === null) {
        this._animationCycle();
      }
      state.pausableLayers.forEach(function(l) {
        var _l$resumeAnimation;
        return (_l$resumeAnimation = l.resumeAnimation) === null || _l$resumeAnimation === void 0 ? void 0 : _l$resumeAnimation.call(l);
      });
      return this;
    },
    _animationCycle: function _animationCycle(state) {
      state.animationFrameRequestId = requestAnimationFrame(this._animationCycle);
      state.tweenGroup.update();
    },
    _destructor: function _destructor5(state) {
      this.pauseAnimation();
      state.destructableLayers.forEach(function(l) {
        return l._destructor();
      });
    }
  }, linkedGlobeLayerMethods),
  stateInit: function stateInit4() {
    var tweenGroup = new Group2();
    var initProps = {
      tweenGroup
    };
    var layers2 = {
      globeLayer: GlobeLayerKapsule(initProps),
      pointsLayer: PointsLayerKapsule(initProps),
      arcsLayer: ArcsLayerKapsule(initProps),
      hexBinLayer: HexBinLayerKapsule(initProps),
      heatmapsLayer: HeatmapsLayerKapsule(initProps),
      polygonsLayer: PolygonsLayerKapsule(initProps),
      hexedPolygonsLayer: HexedPolygonsLayerKapsule(initProps),
      pathsLayer: PathsLayerKapsule(initProps),
      tilesLayer: TilesLayerKapsule(initProps),
      particlesLayer: ParticlesLayerKapsule(initProps),
      ringsLayer: RingsLayerKapsule(initProps),
      labelsLayer: LabelsLayerKapsule(initProps),
      htmlElementsLayer: HtmlElementsLayerKapsule(initProps),
      objectsLayer: ObjectsLayerKapsule(initProps),
      customLayer: CustomLayerKapsule(initProps)
    };
    return _objectSpread2(_objectSpread2({
      tweenGroup
    }, layers2), {}, {
      layersThatNeedUpdatePov: Object.values(layers2).filter(function(l) {
        return l.hasOwnProperty("updatePov");
      }),
      layersThatNeedBehindGlobeChecker: Object.values(layers2).filter(function(l) {
        return l.hasOwnProperty("isBehindGlobe");
      }),
      destructableLayers: Object.values(layers2).filter(function(l) {
        return l.hasOwnProperty("_destructor");
      }),
      pausableLayers: Object.values(layers2).filter(function(l) {
        return l.hasOwnProperty("pauseAnimation");
      })
    });
  },
  init: function init16(threeObj, state, _ref15) {
    var _ref15$animateIn = _ref15.animateIn, animateIn = _ref15$animateIn === void 0 ? true : _ref15$animateIn, _ref15$waitForGlobeRe = _ref15.waitForGlobeReady, waitForGlobeReady = _ref15$waitForGlobeRe === void 0 ? true : _ref15$waitForGlobeRe;
    emptyObject3(threeObj);
    state.scene = threeObj;
    state.scene.visible = false;
    layers.forEach(function(layer) {
      var g = new THREE3.Group();
      state.scene.add(g);
      state[layer](g);
    });
    var initGlobe = function initGlobe2() {
      if (animateIn) {
        state.scene.scale.set(1e-6, 1e-6, 1e-6);
        state.tweenGroup.add(new Tween({
          k: 1e-6
        }).to({
          k: 1
        }, 600).easing(Easing.Quadratic.Out).onUpdate(function(_ref16) {
          var k = _ref16.k;
          return state.scene.scale.set(k, k, k);
        }).start());
        var rotAxis = new THREE3.Vector3(0, 1, 0);
        state.tweenGroup.add(new Tween({
          rot: Math.PI * 2
        }).to({
          rot: 0
        }, 1200).easing(Easing.Quintic.Out).onUpdate(function(_ref17) {
          var rot = _ref17.rot;
          return state.scene.setRotationFromAxisAngle(rotAxis, rot);
        }).start());
      }
      state.scene.visible = true;
      state.onGlobeReady && state.onGlobeReady();
    };
    waitForGlobeReady ? state.globeLayer.onReady(initGlobe) : initGlobe();
    this._animationCycle();
  },
  update: function update17(state) {
  }
});
function fromKapsule(kapsule) {
  var baseClass = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Object;
  var initKapsuleWithSelf = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  var Globe2 = function(_baseClass) {
    function Globe3() {
      var _this;
      _classCallCheck6(this, Globe3);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _callSuper4(this, Globe3, [].concat(args));
      _this.__kapsuleInstance = _construct(kapsule, [].concat(_toConsumableArray6(initKapsuleWithSelf ? [_this] : []), args));
      return _this;
    }
    _inherits4(Globe3, _baseClass);
    return _createClass6(Globe3);
  }(baseClass);
  Object.keys(kapsule()).forEach(function(m) {
    return Globe2.prototype[m] = function() {
      var _this$__kapsuleInstan;
      var returnVal = (_this$__kapsuleInstan = this.__kapsuleInstance)[m].apply(_this$__kapsuleInstan, arguments);
      return returnVal === this.__kapsuleInstance ? this : returnVal;
    };
  });
  return Globe2;
}
var three = window.THREE ? window.THREE : {
  Group
};
var threeGlobe = fromKapsule(Globe, three.Group, true);
export {
  threeGlobe as default
};
/*! Bundled license information:

three/build/three.webgpu.js:
  (**
   * @license
   * Copyright 2010-2025 Three.js Authors
   * SPDX-License-Identifier: MIT
   *)

three/build/three.tsl.js:
  (**
   * @license
   * Copyright 2010-2025 Three.js Authors
   * SPDX-License-Identifier: MIT
   *)

three-globe/dist/three-globe.mjs:
  (*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE *)
*/
//# sourceMappingURL=three-globe.js.map
